; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--thumb --list -c --asm --interleave -o.\output\lpc2478_ea\release_flash_j-link\obj\rtosinit.o --asm_dir=.\Output\LPC2478_EA\Release_FLASH_J-Link\LST\ --list_dir=.\Output\LPC2478_EA\Release_FLASH_J-Link\LST\ --depend=.\output\lpc2478_ea\release_flash_j-link\obj\rtosinit.d --apcs=interwork -O3 -IApplication\SEGGERDEMO -IApplication\SEGGERDEMO\Src -ISetup -IInc -IConfig -IFS -IIP -IIP\IP_FS\FS_RO\Generated -IGUI -IOS -IUSB -IUSBH -I"C:\Program Files (x86)\Keil\V473\ARM\RV31\INC" -I"C:\Program Files (x86)\Keil\V473\ARM\CMSIS\Include" -I"C:\Program Files (x86)\Keil\V473\ARM\Inc\Philips" Setup\RTOSInit.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OS_ARM_InstallISRHandler PROC
;;;970    */
;;;971    OS_ISR_HANDLER* OS_ARM_InstallISRHandler (int ISRIndex, OS_ISR_HANDLER* pISRHandler) {
000000  b570              PUSH     {r4-r6,lr}
000002  000c              MOVS     r4,r1
000004  0005              MOVS     r5,r0
;;;972      OS_ISR_HANDLER*  pOldHandler;
;;;973      OS_ISR_HANDLER** papISR;
;;;974    
;;;975    #if DEBUG
;;;976      if ((unsigned)ISRIndex >= _NUM_INT_VECTORS) {
;;;977        OS_Error(OS_ERR_ISR_INDEX);
;;;978        return NULL;
;;;979      }
;;;980    #endif
;;;981      OS_DI();
000006  f7fffffe          BL       __ARM_common_disable_irq
;;;982      papISR = (OS_ISR_HANDLER**) &_VIC_VECT_0;
00000a  4ab9              LDR      r2,|L1.752|
00000c  00a8              LSLS     r0,r5,#2
;;;983      pOldHandler          = *(papISR + ISRIndex);
00000e  5815              LDR      r5,[r2,r0]
;;;984      *(papISR + ISRIndex) = pISRHandler;
000010  5014              STR      r4,[r2,r0]
;;;985      OS_RestoreI();
000012  f7fffffe          BL       OS_RestoreI
;;;986      return pOldHandler;
000016  0028              MOVS     r0,r5
                  |L1.24|
;;;987    }
000018  bc70              POP      {r4-r6}
00001a  bc08              POP      {r3}
00001c  4718              BX       r3
;;;988    
                          ENDP

                  _OS_ISR_Tick PROC
;;;459    */
;;;460    static void _OS_ISR_Tick(void) {
00001e  49b5              LDR      r1,|L1.756|
000020  b510              PUSH     {r4,lr}
;;;461      _OS_TIM_IR = (1 << _OS_TIM_IR_BIT);  // Clear OS timer interrupt flag
000022  2001              MOVS     r0,#1
000024  6008              STR      r0,[r1,#0]
;;;462      OS_HandleTick();                     // Call OS tick handler
000026  f7fffffe          BL       OS_HandleTick
                  |L1.42|
;;;463    #if DEBUG
;;;464      DCC_Process();
;;;465    #endif
;;;466    }
00002a  bc10              POP      {r4}
00002c  bc08              POP      {r3}
00002e  4718              BX       r3
;;;467    
                          ENDP

                  _EMC_Init PROC
;;;474    */
;;;475    static void _EMC_Init(void) {
000030  b438              PUSH     {r3-r5}
;;;476      volatile unsigned long i;
;;;477      volatile unsigned long Dummy;
;;;478    
;;;479      _EMCCONTROL  = (1 << 0);    // EMC enable
000032  48b1              LDR      r0,|L1.760|
000034  2101              MOVS     r1,#1
000036  6001              STR      r1,[r0,#0]
;;;480      _PCONP      |= (1 << 11);   // Turn on EMC peripheral clock
000038  4ab0              LDR      r2,|L1.764|
00003a  6853              LDR      r3,[r2,#4]
00003c  02cc              LSLS     r4,r1,#11
00003e  4323              ORRS     r3,r3,r4
000040  6053              STR      r3,[r2,#4]
;;;481      _PINSEL4     = 0
000042  4aaf              LDR      r2,|L1.768|
000044  2305              MOVS     r3,#5
000046  071b              LSLS     r3,r3,#28
000048  6113              STR      r3,[r2,#0x10]
;;;482                     | (1 << 28)  // Reserved
;;;483                     | (1 << 30)  // Reserved
;;;484                     ;
;;;485    #if DATABUS_32BIT
;;;486      _PINSEL5     = 0
00004a  4bae              LDR      r3,|L1.772|
00004c  6153              STR      r3,[r2,#0x14]
;;;487                     | (1 <<  0)  // CAS
;;;488                     | (1 <<  2)  // RAS
;;;489                     | (1 <<  4)  // CLKOUT0
;;;490                     | (1 <<  8)  // DYCS0
;;;491                     | (1 << 16)  // CKEOUT0
;;;492                     | (1 << 24)  // DQMOUT0
;;;493                     | (1 << 26)  // DQMOUT1
;;;494                     | (1 << 28)  // DQMOUT2
;;;495                     | (1 << 30)  // DQMOUT3
;;;496                     ;
;;;497      _PINSEL7     = 0
00004e  4bae              LDR      r3,|L1.776|
000050  61d3              STR      r3,[r2,#0x1c]
;;;498                     | (1 <<  0)  // D16
;;;499                     | (1 <<  2)  // D17
;;;500                     | (1 <<  4)  // D18
;;;501                     | (1 <<  6)  // D19
;;;502                     | (1 <<  8)  // D20
;;;503                     | (1 << 10)  // D21
;;;504                     | (1 << 12)  // D22
;;;505                     | (1 << 14)  // D23
;;;506                     | (1 << 16)  // D24
;;;507                     | (1 << 18)  // D25
;;;508                     | (1 << 20)  // D26
;;;509                     | (1 << 22)  // D27
;;;510                     | (1 << 24)  // D28
;;;511                     | (1 << 26)  // D29
;;;512                     | (1 << 28)  // D30
;;;513                     | (1 << 30)  // D31
;;;514                     ;
;;;515    #else
;;;516      _PINSEL5     = 0
;;;517                     | (1 <<  0)  // CAS
;;;518                     | (1 <<  2)  // RAS
;;;519                     | (1 <<  4)  // CLKOUT0
;;;520                     | (1 <<  6)  // CLKOUT1
;;;521                     | (1 <<  8)  // DYCS0
;;;522                     | (1 << 10)  // DYCS1
;;;523                     | (1 << 16)  // CKEOUT0
;;;524                     | (1 << 18)  // CKEOUT1
;;;525                     | (1 << 24)  // DQMOUT0
;;;526                     | (1 << 26)  // DQMOUT1
;;;527                     ;
;;;528    #endif
;;;529      _PINSEL6     = 0
000052  6193              STR      r3,[r2,#0x18]
;;;530                     | (1 <<  0)  // D0
;;;531                     | (1 <<  2)  // D1
;;;532                     | (1 <<  4)  // D2
;;;533                     | (1 <<  6)  // D3
;;;534                     | (1 <<  8)  // D4
;;;535                     | (1 << 10)  // D5
;;;536                     | (1 << 12)  // D6
;;;537                     | (1 << 14)  // D7
;;;538                     | (1 << 16)  // D8
;;;539                     | (1 << 18)  // D9
;;;540                     | (1 << 20)  // D10
;;;541                     | (1 << 22)  // D11
;;;542                     | (1 << 24)  // D12
;;;543                     | (1 << 26)  // D13
;;;544                     | (1 << 28)  // D14
;;;545                     | (1 << 30)  // D15
;;;546                     ;
;;;547      _PINSEL8     = 0
000054  6213              STR      r3,[r2,#0x20]
;;;548                     | (1 <<  0)  // A0
;;;549                     | (1 <<  2)  // A1
;;;550                     | (1 <<  4)  // A2
;;;551                     | (1 <<  6)  // A3
;;;552                     | (1 <<  8)  // A4
;;;553                     | (1 << 10)  // A5
;;;554                     | (1 << 12)  // A6
;;;555                     | (1 << 14)  // A7
;;;556                     | (1 << 16)  // A8
;;;557                     | (1 << 18)  // A9
;;;558                     | (1 << 20)  // A10
;;;559                     | (1 << 22)  // A11
;;;560                     | (1 << 24)  // A12
;;;561                     | (1 << 26)  // A13
;;;562                     | (1 << 28)  // A14
;;;563                     | (1 << 30)  // A15
;;;564                     ;
;;;565      _PINSEL9     = 0
000056  4bad              LDR      r3,|L1.780|
000058  6253              STR      r3,[r2,#0x24]
;;;566                     | (1 <<  0)  // A16
;;;567                     | (1 <<  2)  // A17
;;;568                     | (1 <<  4)  // A18
;;;569                     | (1 <<  6)  // A19
;;;570                     | (1 <<  8)  // A20
;;;571                     | (1 << 10)  // A21
;;;572                     | (1 << 12)  // A22
;;;573                     | (1 << 14)  // A23
;;;574                     | (1 << 16)  // OE
;;;575                     | (1 << 18)  // WE
;;;576                     | (1 << 20)  // BLS0
;;;577                     | (1 << 22)  // BLS1
;;;578                     | (1 << 28)  // CS0
;;;579                     | (1 << 30)  // P4.31 (NAND CE)
;;;580                     ;
;;;581    #if DATABUS_32BIT
;;;582      //
;;;583      // Set memory cycles
;;;584      //
;;;585      _EMCDYNAMIC_RP         = 1;
00005a  6301              STR      r1,[r0,#0x30]
;;;586      _EMCDYNAMIC_RAS        = 3;
00005c  2203              MOVS     r2,#3
00005e  6342              STR      r2,[r0,#0x34]
;;;587      _EMCDYNAMIC_SREX       = 5;
000060  2305              MOVS     r3,#5
000062  6383              STR      r3,[r0,#0x38]
;;;588      _EMCDYNAMIC_APR        = 1;
000064  63c1              STR      r1,[r0,#0x3c]
;;;589      _EMCDYNAMIC_DAL        = 5;
000066  4aa4              LDR      r2,|L1.760|
000068  3240              ADDS     r2,r2,#0x40
00006a  6013              STR      r3,[r2,#0]
;;;590      _EMCDYNAMIC_WR         = 1;
00006c  6051              STR      r1,[r2,#4]
;;;591      _EMCDYNAMIC_RC         = 5;
00006e  6093              STR      r3,[r2,#8]
;;;592      _EMCDYNAMIC_RFC        = 5;
000070  60d3              STR      r3,[r2,#0xc]
;;;593      _EMCDYNAMIC_XSR        = 5;
000072  6113              STR      r3,[r2,#0x10]
;;;594      _EMCDYNAMIC_RRD        = 1;
000074  6151              STR      r1,[r2,#0x14]
;;;595      _EMCDYNAMIC_MRD        = 1;
000076  6191              STR      r1,[r2,#0x18]
;;;596      _EMCDYNAMIC_READCONFIG = 1;
000078  6281              STR      r1,[r0,#0x28]
;;;597    
;;;598      _EMCDYNAMIC_RASCAS0 = 0
00007a  49a5              LDR      r1,|L1.784|
00007c  4ba5              LDR      r3,|L1.788|
00007e  6059              STR      r1,[r3,#4]
;;;599                            | (0x2 << 0)  // RAS latency, two CCLK cycles
;;;600                            | (0x2 << 8)  // CAS latency, two CCLK cycles
;;;601                            ;
;;;602      _EMCDYNAMIC_CONFIG0 = 0x5488;       // 128MB (8Mx16), 4 banks, row length = 12, column length = 9
000080  49a5              LDR      r1,|L1.792|
000082  6019              STR      r1,[r3,#0]
;;;603    #else
;;;604      //
;;;605      // Set memory cycles
;;;606      //
;;;607      _EMCDYNAMIC_RP         = 2;
;;;608      _EMCDYNAMIC_RAS        = 3;
;;;609      _EMCDYNAMIC_SREX       = 7;
;;;610      _EMCDYNAMIC_APR        = 2;
;;;611      _EMCDYNAMIC_DAL        = 5;
;;;612      _EMCDYNAMIC_WR         = 1;
;;;613      _EMCDYNAMIC_RC         = 5;
;;;614      _EMCDYNAMIC_RFC        = 5;
;;;615      _EMCDYNAMIC_XSR        = 7;
;;;616      _EMCDYNAMIC_RRD        = 1;
;;;617      _EMCDYNAMIC_MRD        = 2;
;;;618      _EMCDYNAMIC_READCONFIG = 1;
;;;619    
;;;620      _EMCDYNAMIC_RASCAS0 = 0
;;;621                            | (0x3 << 0)  // RAS latency, three CCLK cycles
;;;622                            | (0x3 << 8)  // CAS latency, three CCLK cycles
;;;623                            ;
;;;624      _EMCDYNAMIC_CONFIG0 = 0x0680;       // 256MB (16Mx16), 4 banks, row length = 13, column length = 9
;;;625    #endif
;;;626      //
;;;627      // Delay at least 100 us
;;;628      //
;;;629      for (i = 0; i < 5000; i++) {        // Delay
000084  4aa5              LDR      r2,|L1.796|
000086  2100              MOVS     r1,#0
000088  9100              STR      r1,[sp,#0]
                  |L1.138|
00008a  9c00              LDR      r4,[sp,#0]
00008c  1c64              ADDS     r4,r4,#1
00008e  4294              CMP      r4,r2
000090  9400              STR      r4,[sp,#0]
000092  d3fa              BCC      |L1.138|
;;;630      }
;;;631      _EMCDYNAMIC_CONTROL = 0
000094  24ff              MOVS     r4,#0xff
000096  3484              ADDS     r4,r4,#0x84
000098  6204              STR      r4,[r0,#0x20]
;;;632                            | (1   << 0)  // Dynamic memory clock enable (CE), all clock enables are driven high continuously
;;;633                            | (1   << 1)  // Dynamic memory clock control (CS), CLKOUT runs continuously
;;;634                            | (0x3 << 7)  // Issue SDRAM NOP command
;;;635                            ;
;;;636      //
;;;637      // Delay at least 200 us
;;;638      //
;;;639      for (i = 0; i < 10000; i++) {       // Delay
00009a  4ca1              LDR      r4,|L1.800|
00009c  9100              STR      r1,[sp,#0]
                  |L1.158|
00009e  9d00              LDR      r5,[sp,#0]
0000a0  1c6d              ADDS     r5,r5,#1
0000a2  42a5              CMP      r5,r4
0000a4  9500              STR      r5,[sp,#0]
0000a6  d3fa              BCC      |L1.158|
;;;640      }
;;;641      _EMCDYNAMIC_CONTROL = 0
0000a8  24ff              MOVS     r4,#0xff
0000aa  3404              ADDS     r4,#4
0000ac  6204              STR      r4,[r0,#0x20]
;;;642                            | (1 << 0)    // Dynamic memory clock enable (CE), all clock enables are driven high continuously
;;;643                            | (1 << 1)    // Dynamic memory clock control (CS), CLKOUT runs continuously
;;;644                            | (1 << 8)    // Issue SDRAM PALL (precharge all) command
;;;645                            ;
;;;646      _EMCDYNAMIC_REFRESH = 0x02;         // n x 16 CCLKs between SDRAM refresh cycles
0000ae  2402              MOVS     r4,#2
0000b0  6244              STR      r4,[r0,#0x24]
;;;647      //
;;;648      // Delay at least 100 us
;;;649      //
;;;650      for (i = 0; i < 5000; i++) {        // Delay
0000b2  9100              STR      r1,[sp,#0]
                  |L1.180|
0000b4  9d00              LDR      r5,[sp,#0]
0000b6  1c6d              ADDS     r5,r5,#1
0000b8  4295              CMP      r5,r2
0000ba  9500              STR      r5,[sp,#0]
0000bc  d3fa              BCC      |L1.180|
;;;651      }
;;;652      _EMCDYNAMIC_REFRESH = 0x1C;         // Set correct refresh period, n x 16 CCLKs between SDRAM refresh cycles
0000be  251c              MOVS     r5,#0x1c
0000c0  6245              STR      r5,[r0,#0x24]
;;;653      _EMCDYNAMIC_CONTROL = 0
0000c2  2583              MOVS     r5,#0x83
0000c4  6205              STR      r5,[r0,#0x20]
;;;654                            | (1 << 0)    // Dynamic memory clock enable (CE), all clock enables are driven high continuously
;;;655                            | (1 << 1)    // Dynamic memory clock control (CS), CLKOUT runs continuously
;;;656                            | (1 << 7)    // Issue SDRAM MODE command
;;;657                            ;
;;;658    #if DATABUS_32BIT
;;;659      Dummy = *((volatile unsigned long*)(SDRAM_BASE_ADDR | (0x22 << 11)));  //Set mode register in SDRAM
0000c6  4d97              LDR      r5,|L1.804|
0000c8  682d              LDR      r5,[r5,#0]
;;;660    #else
;;;661      Dummy = *((volatile unsigned long*)(SDRAM_BASE_ADDR | (0x33 << 12)));  //Set mode register in SDRAM
;;;662    #endif
;;;663      _EMCDYNAMIC_CONTROL  = 0x00;        // Issue SDRAM NORMAL operation command
0000ca  9500              STR      r5,[sp,#0]
0000cc  6201              STR      r1,[r0,#0x20]
;;;664      _EMCDYNAMIC_CONFIG0 |= (1 << 19);   // Enable buffer
0000ce  6818              LDR      r0,[r3,#0]
0000d0  2501              MOVS     r5,#1
0000d2  04ed              LSLS     r5,r5,#19
0000d4  4328              ORRS     r0,r0,r5
0000d6  6018              STR      r0,[r3,#0]
;;;665      //
;;;666      // Initial system delay, at least 100 us
;;;667      //
;;;668      for (i = 0; i < (50 * 100); i++) { // Delay
0000d8  9100              STR      r1,[sp,#0]
                  |L1.218|
0000da  9800              LDR      r0,[sp,#0]
0000dc  1c40              ADDS     r0,r0,#1
0000de  4290              CMP      r0,r2
0000e0  9000              STR      r0,[sp,#0]
0000e2  d3fa              BCC      |L1.218|
;;;669      }
;;;670      _EMCSTATIC_WAITWEN0  = 0x02;       // n + 1 CCLK cycle delay between assertion of chip select and write enable
0000e4  4890              LDR      r0,|L1.808|
0000e6  6044              STR      r4,[r0,#4]
;;;671      _EMCSTATIC_WAITOEN0  = 0x02;       // n cycle delay.
0000e8  6084              STR      r4,[r0,#8]
;;;672      _EMCSTATIC_WAITRD0   = 0x1F;       // 32 CCLK cycles for read accesses
0000ea  221f              MOVS     r2,#0x1f
0000ec  60c2              STR      r2,[r0,#0xc]
;;;673      _EMCSTATIC_WAITPAGE0 = 0x1F;       // 32 CCLK cycle read access time
0000ee  6102              STR      r2,[r0,#0x10]
;;;674      _EMCSTATIC_WAITWR0   = 0x1F;       // 33 CCLK cycle write access time
0000f0  6142              STR      r2,[r0,#0x14]
;;;675      _EMCSTATIC_WAITTURN0 = 0x0F;       // 16 CCLK turnaround cycles
0000f2  230f              MOVS     r3,#0xf
0000f4  6183              STR      r3,[r0,#0x18]
;;;676      _EMCSTATIC_CONFIG0   = 0
0000f6  2581              MOVS     r5,#0x81
0000f8  6005              STR      r5,[r0,#0]
;;;677                             | (1 << 0)  // 16bit memory width
;;;678                             | (1 << 7)  // Bit lane state
;;;679                             ;
;;;680      _EMCSTATIC_WAITWEN1  = 0x02;       // n + 1 CCLK cycle delay between assertion of chip select and write enable
0000fa  6244              STR      r4,[r0,#0x24]
;;;681      _EMCSTATIC_WAITOEN1  = 0x02;       // n cycle delay.
0000fc  6284              STR      r4,[r0,#0x28]
;;;682      _EMCSTATIC_WAITRD1   = 0x08;       // n + 1 CCLK cycle delay
0000fe  2408              MOVS     r4,#8
000100  62c4              STR      r4,[r0,#0x2c]
;;;683      _EMCSTATIC_WAITPAGE1 = 0x1F;       // 32 CCLK cycle read access time
000102  6302              STR      r2,[r0,#0x30]
;;;684      _EMCSTATIC_WAITWR1   = 0x08;       // n + 2 CCLK cycle write access time
000104  6344              STR      r4,[r0,#0x34]
;;;685      _EMCSTATIC_WAITTURN1 = 0x0F;       // 16 CCLK turnaround cycles
000106  6383              STR      r3,[r0,#0x38]
;;;686      _EMCSTATIC_CONFIG1   = (1 << 7);   // Bit lane state
000108  2280              MOVS     r2,#0x80
00010a  6202              STR      r2,[r0,#0x20]
;;;687      //
;;;688      // Delay, at least 10 us
;;;689      //
;;;690      for (i = 0; i < (50 * 10); i++) {  // Delay
00010c  20ff              MOVS     r0,#0xff
00010e  30f5              ADDS     r0,r0,#0xf5
000110  9100              STR      r1,[sp,#0]
                  |L1.274|
000112  1c49              ADDS     r1,r1,#1
000114  4281              CMP      r1,r0
000116  9100              STR      r1,[sp,#0]
000118  d3fb              BCC      |L1.274|
;;;691      }
;;;692    }
00011a  bc38              POP      {r3-r5}
00011c  4770              BX       lr
;;;693    
                          ENDP

                  OS_COM_Init PROC
;;;905    
;;;906    void OS_COM_Init(void) {}
00011e  4770              BX       lr
;;;907    void OS_COM_Send1(OS_U8 c) {
                          ENDP

                  OS_ARM_ISRSetPrio PROC
;;;1024   */
;;;1025   int OS_ARM_ISRSetPrio(int ISRIndex, int Prio) {
000120  b570              PUSH     {r4-r6,lr}
000122  000d              MOVS     r5,r1
000124  0004              MOVS     r4,r0
;;;1026     OS_U32* pPrio;
;;;1027     int     OldPrio;
;;;1028   #if DEBUG
;;;1029     if ((unsigned)ISRIndex >= _NUM_INT_VECTORS) {
;;;1030       OS_Error(OS_ERR_ISR_INDEX);
;;;1031       return 0;
;;;1032     }
;;;1033   #endif
;;;1034     OS_DI();
000126  f7fffffe          BL       __ARM_common_disable_irq
;;;1035     pPrio = (OS_U32*) _VIC_PRIO_BASE_ADDR;
00012a  4a80              LDR      r2,|L1.812|
00012c  00a0              LSLS     r0,r4,#2
;;;1036     OldPrio = pPrio[ISRIndex];
00012e  5814              LDR      r4,[r2,r0]
;;;1037     pPrio[ISRIndex] = (OldPrio & ~_INT_PRIORITY_MASK) | (Prio & _INT_PRIORITY_MASK);
000130  072b              LSLS     r3,r5,#28
000132  0921              LSRS     r1,r4,#4
000134  0109              LSLS     r1,r1,#4
000136  0f1b              LSRS     r3,r3,#28
000138  4319              ORRS     r1,r1,r3
00013a  5011              STR      r1,[r2,r0]
;;;1038     OS_RestoreI();
00013c  f7fffffe          BL       OS_RestoreI
;;;1039     return OldPrio & _INT_PRIORITY_MASK;
000140  0720              LSLS     r0,r4,#28
000142  0f00              LSRS     r0,r0,#28
;;;1040   }
000144  e768              B        |L1.24|
;;;1041   
                          ENDP

                  OS_ARM_EnableISR PROC
;;;992    */
;;;993    void OS_ARM_EnableISR(int ISRIndex) {
000146  b510              PUSH     {r4,lr}
000148  0004              MOVS     r4,r0
;;;994    #if DEBUG
;;;995      if ((unsigned)ISRIndex >= _NUM_INT_VECTORS) {
;;;996        OS_Error(OS_ERR_ISR_INDEX);
;;;997        return;
;;;998      }
;;;999    #endif
;;;1000     OS_DI();
00014a  f7fffffe          BL       __ARM_common_disable_irq
;;;1001     _VIC_INTENABLE = (1UL << ISRIndex);
00014e  2001              MOVS     r0,#1
000150  4977              LDR      r1,|L1.816|
000152  40a0              LSLS     r0,r0,r4
000154  6108              STR      r0,[r1,#0x10]
;;;1002     OS_RestoreI();
000156  f7fffffe          BL       OS_RestoreI
;;;1003   }
00015a  e766              B        |L1.42|
;;;1004   
                          ENDP

                  OS_InitHW PROC
;;;708    */
;;;709    void OS_InitHW(void) {
00015c  b5f8              PUSH     {r3-r7,lr}
;;;710      OS_DI();
00015e  f7fffffe          BL       __ARM_common_disable_irq
000162  2700              MOVS     r7,#0
000164  43ff              MVNS     r7,r7
000166  033d              LSLS     r5,r7,#12
000168  616f              STR      r7,[r5,#0x14]
00016a  2600              MOVS     r6,#0
00016c  1128              ASRS     r0,r5,#4
00016e  6006              STR      r6,[r0,#0]
000170  0034              MOVS     r4,r6
                  |L1.370|
000172  2100              MOVS     r1,#0
000174  0020              MOVS     r0,r4
000176  f7fffffe          BL       OS_ARM_InstallISRHandler
00017a  1c64              ADDS     r4,r4,#1
00017c  2c20              CMP      r4,#0x20
00017e  dbf8              BLT      |L1.370|
000180  61ef              STR      r7,[r5,#0x1c]
000182  60ee              STR      r6,[r5,#0xc]
;;;711      _Init_VIC();                   // Initialize VIC, clear and disable all interrupts
;;;712      // Initialize timer for OS
;;;713      _PCONP      |=  (1 << _TIMER_PCONP_BIT);   // Enable Clock for OS timer
000184  485d              LDR      r0,|L1.764|
000186  6841              LDR      r1,[r0,#4]
000188  2202              MOVS     r2,#2
00018a  4311              ORRS     r1,r1,r2
00018c  6041              STR      r1,[r0,#4]
;;;714      _OS_TIM_TCR &= ~(1 << 0);                  // Disable timer
00018e  4859              LDR      r0,|L1.756|
000190  6841              LDR      r1,[r0,#4]
000192  0849              LSRS     r1,r1,#1
000194  0049              LSLS     r1,r1,#1
000196  6041              STR      r1,[r0,#4]
;;;715      _OS_TIM_IR   =  (1 << _OS_TIM_IR_BIT);     // Clear OS timer interrupt flag
000198  2101              MOVS     r1,#1
00019a  6001              STR      r1,[r0,#0]
;;;716      _OS_TIM_PR   = 0;                          // Count on every pclk
00019c  60c6              STR      r6,[r0,#0xc]
;;;717      _OS_TIM_MR0  = _OS_TIMER_INTERVAL - 1;     // Initialize match register 1
00019e  4a65              LDR      r2,|L1.820|
0001a0  6182              STR      r2,[r0,#0x18]
;;;718      _OS_TIM_MCR  =  (1 << 0)                   // Interrupt on match channel 0
0001a2  2203              MOVS     r2,#3
0001a4  6142              STR      r2,[r0,#0x14]
;;;719                    | (1 << 1);                  // Counter reset on match channel 0
;;;720      _OS_TIM_TC   =  0;                         // Clear counter
0001a6  6086              STR      r6,[r0,#8]
;;;721      _OS_TIM_TCR |=  (1 << 0);                  // Enable timer
0001a8  6842              LDR      r2,[r0,#4]
0001aa  430a              ORRS     r2,r2,r1
0001ac  6042              STR      r2,[r0,#4]
;;;722      // Setup interrupt controller
;;;723      OS_ARM_InstallISRHandler(_OS_TIMER_INT_INDEX, &_OS_ISR_Tick); // Timer/counter interrupt vector.
0001ae  4962              LDR      r1,|L1.824|
0001b0  2004              MOVS     r0,#4
0001b2  f7fffffe          BL       OS_ARM_InstallISRHandler
;;;724      OS_ARM_EnableISR(_OS_TIMER_INT_INDEX);                        // Enable timer/counter 0 interrupt.
0001b6  2004              MOVS     r0,#4
0001b8  f7fffffe          BL       OS_ARM_EnableISR
;;;725      OS_ARM_ISRSetPrio(_OS_TIMER_INT_INDEX, 15);                   // lowest priority
0001bc  210f              MOVS     r1,#0xf
0001be  2004              MOVS     r0,#4
0001c0  f7fffffe          BL       OS_ARM_ISRSetPrio
;;;726      // optionally initialize UART for OSView
;;;727      OS_COM_Init();
;;;728      OS_RestoreI();
0001c4  f7fffffe          BL       OS_RestoreI
                  |L1.456|
;;;729    }
0001c8  bcf8              POP      {r3-r7}
0001ca  bc08              POP      {r3}
0001cc  4718              BX       r3
;;;730    
                          ENDP

                  OS_Idle PROC
                  |L1.462|
;;;742    */
;;;743    void OS_Idle(void) {     // Idle loop: No task is ready to exec
0001ce  e7fe              B        |L1.462|
;;;744      while (1) {
;;;745      }
;;;746    }
;;;747    
                          ENDP

                  OS_GetTime_Cycles PROC
;;;755    */
;;;756    OS_U32 OS_GetTime_Cycles(void) {
0001d0  4a48              LDR      r2,|L1.756|
;;;757      OS_U32 time;
;;;758      OS_U32 count;
;;;759    
;;;760      count = _OS_TIM_TC;                               // Read current timer value
0001d2  6891              LDR      r1,[r2,#8]
;;;761      time  = OS_GetTime32();                           // Read current OS time
0001d4  4859              LDR      r0,|L1.828|
0001d6  6800              LDR      r0,[r0,#0]  ; OS_Time
;;;762      if ((_OS_TIM_IR & (1 << _OS_TIM_IR_BIT)) != 0) {  // Timer Interrupt pending ?
0001d8  6813              LDR      r3,[r2,#0]
0001da  07db              LSLS     r3,r3,#31
0001dc  d001              BEQ      |L1.482|
;;;763        time++;                                         // Adjust result, read timer again
;;;764        count = _OS_TIM_TC;                             // Read again
0001de  6891              LDR      r1,[r2,#8]
0001e0  1c40              ADDS     r0,r0,#1              ;763
                  |L1.482|
;;;765      }
;;;766      return (_OS_TIMER_INTERVAL) * time + count;
0001e2  22e1              MOVS     r2,#0xe1
0001e4  01d2              LSLS     r2,r2,#7
0001e6  4350              MULS     r0,r2,r0
0001e8  1840              ADDS     r0,r0,r1
;;;767    }
0001ea  4770              BX       lr
;;;768    
                          ENDP

                  OS_ConvertCycles2us PROC
;;;781    */
;;;782    OS_U32 OS_ConvertCycles2us(OS_U32 Cycles) {
0001ec  b510              PUSH     {r4,lr}
;;;783      return Cycles/(OS_PCLK_TIMER/1000000);
0001ee  211c              MOVS     r1,#0x1c
0001f0  f7fffffe          BL       __aeabi_uidivmod
;;;784    }
0001f4  e719              B        |L1.42|
;;;785    
                          ENDP

                  OS_COM_Send1 PROC
;;;906    void OS_COM_Init(void) {}
;;;907    void OS_COM_Send1(OS_U8 c) {
0001f6  b510              PUSH     {r4,lr}
;;;908      OS_USEPARA(c);           // avoid compiler warning
;;;909      OS_COM_ClearTxActive();  // let the OS know that Tx is not busy
0001f8  f7fffffe          BL       OS_COM_ClearTxActive
;;;910    }
0001fc  e715              B        |L1.42|
;;;911    
                          ENDP

                  OS_irq_handler PROC
;;;952    */
;;;953    OS_INTERWORK void OS_irq_handler(void) {
0001fe  b5f8              PUSH     {r3-r7,lr}
;;;954      OS_ISR_HANDLER* pISR;
;;;955      pISR = (OS_ISR_HANDLER*) _VIC_VECTORADDR;   // Get current interrupt handler
000200  26ff              MOVS     r6,#0xff
000202  43f6              MVNS     r6,r6
000204  6835              LDR      r5,[r6,#0]
;;;956      OS_EnterNestableInterrupt();                // Now interrupts may be reenabled. If nesting should be allowed
000206  4c4e              LDR      r4,|L1.832|
000208  7820              LDRB     r0,[r4,#0]  ; OS_Counters
00020a  1c40              ADDS     r0,r0,#1
00020c  7020              STRB     r0,[r4,#0]
00020e  f7fffffe          BL       __ARM_common_enable_irq
;;;957      if (pISR != NULL) {
000212  2d00              CMP      r5,#0
000214  d002              BEQ      |L1.540|
;;;958        pISR();                                   // Call installed interrupt service routine
000216  f7fffffe          BL       __ARM_common_call_via_r5
00021a  e003              B        |L1.548|
                  |L1.540|
00021c  2001              MOVS     r0,#1
00021e  9000              STR      r0,[sp,#0]
                  |L1.544|
000220  2800              CMP      r0,#0
000222  d1fd              BNE      |L1.544|
                  |L1.548|
;;;959      } else {
;;;960        _OS_ISR_Undefined();
;;;961      }
;;;962      OS_DI();                                    // Disable interrupts and unlock
000224  f7fffffe          BL       __ARM_common_disable_irq
;;;963      _VIC_VECTORADDR = 0;                        // Clear current interrupt pending condition, reset VIC
000228  2000              MOVS     r0,#0
00022a  6030              STR      r0,[r6,#0]
;;;964      OS_LeaveNestableInterrupt();                // Replace by OS_LeaveInterrupt(), when nesting was disabled
00022c  f7fffffe          BL       __ARM_common_disable_irq
000230  7820              LDRB     r0,[r4,#0]  ; OS_Counters
000232  2801              CMP      r0,#1
000234  d106              BNE      |L1.580|
000236  4943              LDR      r1,|L1.836|
000238  7809              LDRB     r1,[r1,#0]  ; OS_Pending
00023a  2900              CMP      r1,#0
00023c  d002              BEQ      |L1.580|
00023e  f7fffffe          BL       OS_SwitchFromInt
;;;965    }
000242  e7c1              B        |L1.456|
                  |L1.580|
000244  1e40              SUBS     r0,r0,#1              ;964
000246  7020              STRB     r0,[r4,#0]            ;964
000248  e7be              B        |L1.456|
;;;966    
                          ENDP

                  OS_ARM_DisableISR PROC
;;;1008   */
;;;1009   void OS_ARM_DisableISR(int ISRIndex) {
00024a  b510              PUSH     {r4,lr}
00024c  0004              MOVS     r4,r0
;;;1010   #if DEBUG
;;;1011     if ((unsigned)ISRIndex >= _NUM_INT_VECTORS) {
;;;1012       OS_Error(OS_ERR_ISR_INDEX);
;;;1013       return;
;;;1014     }
;;;1015   #endif
;;;1016     OS_DI();
00024e  f7fffffe          BL       __ARM_common_disable_irq
;;;1017     _VIC_INTENABLECLEAR = (1UL << ISRIndex);
000252  2001              MOVS     r0,#1
000254  4936              LDR      r1,|L1.816|
000256  40a0              LSLS     r0,r0,r4
000258  6148              STR      r0,[r1,#0x14]
;;;1018     OS_RestoreI();
00025a  f7fffffe          BL       OS_RestoreI
;;;1019   }
00025e  e6e4              B        |L1.42|
;;;1020   
                          ENDP

                  __low_level_init PROC
;;;1050   OS_INTERWORK int __low_level_init(void);       /* Avoid "No prototype" warning */
;;;1051   OS_INTERWORK int __low_level_init(void) {
000260  b510              PUSH     {r4,lr}
;;;1052     #if OS_INIT_PLL
;;;1053       _InitPLL();
000262  f7fffffe          BL       _InitPLL
;;;1054     #endif
;;;1055     #if OS_INIT_MAM                // Speedup CPU
;;;1056       _MAMCR  = 0x00;              // Disable Memory accelerator module
000266  4825              LDR      r0,|L1.764|
000268  2100              MOVS     r1,#0
00026a  38c0              SUBS     r0,r0,#0xc0
00026c  6001              STR      r1,[r0,#0]
;;;1057       _MAMTIM = _OS_MAMTIM_VALUE;  // Depends on OS_FSYS
00026e  2105              MOVS     r1,#5
000270  6041              STR      r1,[r0,#4]
;;;1058       _MAMCR  = 0x01;              // Enable Memory accelerator module partially , refer to [1], MAM.1 operation
000272  2101              MOVS     r1,#1
000274  6001              STR      r1,[r0,#0]
;;;1059     #endif
;;;1060     //
;;;1061     // Init SDRAM, NAND- and NOR-flash
;;;1062     //
;;;1063     _EMC_Init();
000276  f7fffffe          BL       _EMC_Init
;;;1064   
;;;1065     return 1;                      // Always initialize segments !
00027a  2001              MOVS     r0,#1
;;;1066   };
00027c  e6d5              B        |L1.42|
;;;1067   
                          ENDP

                  _InitPLL PROC
;;;401    */
;;;402    static void _InitPLL(void) {
00027e  481f              LDR      r0,|L1.764|
000280  b470              PUSH     {r4-r6}
;;;403      if (_PLLSTAT & (1 << 25)) {
000282  3840              SUBS     r0,r0,#0x40
000284  6881              LDR      r1,[r0,#8]
;;;404        _PLLCON  |= (1 << 1);
;;;405        _PLLFEED  = 0xAA;
000286  22aa              MOVS     r2,#0xaa
;;;406        _PLLFEED  = 0x55;
000288  2355              MOVS     r3,#0x55
00028a  0189              LSLS     r1,r1,#6              ;403
00028c  d505              BPL      |L1.666|
00028e  6801              LDR      r1,[r0,#0]            ;404
000290  2402              MOVS     r4,#2                 ;404
000292  4321              ORRS     r1,r1,r4              ;404
000294  6001              STR      r1,[r0,#0]            ;404
000296  60c2              STR      r2,[r0,#0xc]          ;405
000298  60c3              STR      r3,[r0,#0xc]
                  |L1.666|
;;;407      }
;;;408      _PLLCON     = 0;                         // Set PLL disabled and disconnected
00029a  2100              MOVS     r1,#0
00029c  6001              STR      r1,[r0,#0]
;;;409      _PLLFEED    = 0xAA;
00029e  60c2              STR      r2,[r0,#0xc]
;;;410      _PLLFEED    = 0x55;
0002a0  60c3              STR      r3,[r0,#0xc]
;;;411    #if (OS_USE_INTERNAL_RC)
;;;412      _CLKSRCSEL  = 0;                         // Select internal RC oscillator 4 MHz as clock source
;;;413    #else
;;;414      _SCS        &= ~(1 << 4);                // The frequency range of the main oscillator is 1 MHz to 20 MHz.
0002a2  4916              LDR      r1,|L1.764|
0002a4  31c0              ADDS     r1,r1,#0xc0
0002a6  6a0c              LDR      r4,[r1,#0x20]
0002a8  2510              MOVS     r5,#0x10
0002aa  43ac              BICS     r4,r4,r5
0002ac  620c              STR      r4,[r1,#0x20]
;;;415      _SCS        |=  (1 << 5);                // Main oscillator enable.
0002ae  6a0c              LDR      r4,[r1,#0x20]
0002b0  2520              MOVS     r5,#0x20
0002b2  432c              ORRS     r4,r4,r5
0002b4  620c              STR      r4,[r1,#0x20]
;;;416      _CLKSRCSEL  = 1;                         // Select main oscillator 12 MHz as clock source
0002b6  4c11              LDR      r4,|L1.764|
0002b8  2501              MOVS     r5,#1
0002ba  3440              ADDS     r4,r4,#0x40
0002bc  60e5              STR      r5,[r4,#0xc]
;;;417    #endif
;;;418      _PLLCFG     = (OS_PLL_MULTIPLIER - 1);   // MSEL: Multiplier - 1
0002be  260b              MOVS     r6,#0xb
0002c0  6046              STR      r6,[r0,#4]
;;;419      _PLLFEED    = 0xAA;
0002c2  60c2              STR      r2,[r0,#0xc]
;;;420      _PLLFEED    = 0x55;
0002c4  60c3              STR      r3,[r0,#0xc]
;;;421      _PLLCON     = 1;                         // Enable PLL, Disconnect
0002c6  6005              STR      r5,[r0,#0]
;;;422      _PLLFEED    = 0xAA;
0002c8  60c2              STR      r2,[r0,#0xc]
;;;423      _PLLFEED    = 0x55;
0002ca  60c3              STR      r3,[r0,#0xc]
                  |L1.716|
;;;424      do {
;;;425      } while ((_PLLSTAT & (1 << 26)) == 0);   // Check PLOCK bit	
0002cc  6885              LDR      r5,[r0,#8]
0002ce  016d              LSLS     r5,r5,#5
0002d0  d5fc              BPL      |L1.716|
;;;426      _CPUCLKCFG  = 4;                         // Set CPU clock divider, value = Division ratio - 1)
0002d2  2504              MOVS     r5,#4
0002d4  6065              STR      r5,[r4,#4]
;;;427      _USBCLKCFG  = 5;                         // Set USB clock divider, value = Division ratio - 1)
0002d6  2505              MOVS     r5,#5
0002d8  60a5              STR      r5,[r4,#8]
;;;428    
;;;429      _PCLKSEL0   = _PCLKSEL_VALUE;
0002da  4c0b              LDR      r4,|L1.776|
0002dc  43e4              MVNS     r4,r4
0002de  628c              STR      r4,[r1,#0x28]
;;;430      _PCLKSEL1   = _PCLKSEL_VALUE;
0002e0  62cc              STR      r4,[r1,#0x2c]
;;;431    
;;;432      _PLLCON     = (1 << 0) | (1 << 1);       // Enable PLL and select as clock source
0002e2  2103              MOVS     r1,#3
0002e4  6001              STR      r1,[r0,#0]
;;;433      _PLLFEED    =  0xAA;
0002e6  60c2              STR      r2,[r0,#0xc]
;;;434      _PLLFEED    =  0x55;
0002e8  60c3              STR      r3,[r0,#0xc]
;;;435    }
0002ea  bc70              POP      {r4-r6}
0002ec  4770              BX       lr
;;;436    
                          ENDP

0002ee  0000              DCW      0x0000
                  |L1.752|
                          DCD      0xfffff100
                  |L1.756|
                          DCD      0xe0004000
                  |L1.760|
                          DCD      0xffe08000
                  |L1.764|
                          DCD      0xe01fc0c0
                  |L1.768|
                          DCD      0xe002c000
                  |L1.772|
                          DCD      0x55010115
                  |L1.776|
                          DCD      0x55555555
                  |L1.780|
                          DCD      0x50555555
                  |L1.784|
                          DCD      0x00000202
                  |L1.788|
                          DCD      0xffe08100
                  |L1.792|
                          DCD      0x00005488
                  |L1.796|
                          DCD      0x00001388
                  |L1.800|
                          DCD      0x00002710
                  |L1.804|
                          DCD      0xa0011000
                  |L1.808|
                          DCD      0xffe08200
                  |L1.812|
                          DCD      0xfffff200
                  |L1.816|
                          DCD      0xfffff000
                  |L1.820|
                          DCD      0x0000707f
                  |L1.824|
                          DCD      _OS_ISR_Tick
                  |L1.828|
                          DCD      OS_Time
                  |L1.832|
                          DCD      OS_Counters
                  |L1.836|
                          DCD      OS_Pending

                          AREA ||i.__ARM_common_call_via_r5||, COMGROUP=__ARM_common_call_via_r5, CODE, READONLY, ALIGN=1

                  __ARM_common_call_via_r5 PROC
000000  4728              BX       r5
                          ENDP


                          AREA ||i.__ARM_common_enable_irq||, COMGROUP=__ARM_common_enable_irq, CODE, READONLY, ALIGN=2

                          ARM
                  __ARM_common_enable_irq PROC
000000  e10f0000          MRS      r0,APSR ; formerly CPSR
000004  e3c00080          BIC      r0,r0,#0x80
000008  e121f000          MSR      CPSR_c,r0
00000c  e12fff1e          BX       lr
                          ENDP


                          AREA ||i.__ARM_common_disable_irq||, COMGROUP=__ARM_common_disable_irq, CODE, READONLY, ALIGN=2

                  __ARM_common_disable_irq PROC
000000  e10f0000          MRS      r0,APSR ; formerly CPSR
000004  e3801080          ORR      r1,r0,#0x80
000008  e121f001          MSR      CPSR_c,r1
00000c  e2000080          AND      r0,r0,#0x80
000010  e12fff1e          BX       lr
                          ENDP

