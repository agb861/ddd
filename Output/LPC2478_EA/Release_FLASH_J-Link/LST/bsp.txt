; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--thumb --list -c --asm --interleave -o.\output\lpc2478_ea\release_flash_j-link\obj\bsp.o --asm_dir=.\Output\LPC2478_EA\Release_FLASH_J-Link\LST\ --list_dir=.\Output\LPC2478_EA\Release_FLASH_J-Link\LST\ --depend=.\output\lpc2478_ea\release_flash_j-link\obj\bsp.d --apcs=interwork -O3 -IApplication\SEGGERDEMO -IApplication\SEGGERDEMO\Src -ISetup -IInc -IConfig -IFS -IIP -IIP\IP_FS\FS_RO\Generated -IGUI -IOS -IUSB -IUSBH -I"C:\Program Files (x86)\Keil\V473\ARM\RV31\INC" -I"C:\Program Files (x86)\Keil\V473\ARM\CMSIS\Include" -I"C:\Program Files (x86)\Keil\V473\ARM\Inc\Philips" Setup\BSP.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _SetLEDState PROC
;;;317    */
;;;318    static void _SetLEDState(unsigned char LED, unsigned char State) {
000000  b57c              PUSH     {r2-r6,lr}
000002  0004              MOVS     r4,r0
;;;319      U8  acCommandString[2] = {0x08, 0x00};
000004  a0fe              ADR      r0,|L1.1024|
000006  6800              LDR      r0,[r0,#0]
000008  000e              MOVS     r6,r1                 ;318
;;;320      U8  Reg;
;;;321    
;;;322      if (LED > 7) {
00000a  2c07              CMP      r4,#7
00000c  9001              STR      r0,[sp,#4]
00000e  d83e              BHI      |L1.142|
;;;323        return;
;;;324      }
;;;325      //
;;;326      // Adjust address if LED >= 5
;;;327      //
;;;328      if (LED >= 4) {
000010  2c04              CMP      r4,#4
000012  d302              BCC      |L1.26|
;;;329        acCommandString[0] = 0x09;
000014  2009              MOVS     r0,#9
000016  4669              MOV      r1,sp
000018  7108              STRB     r0,[r1,#4]
                  |L1.26|
;;;330      }
;;;331      //
;;;332      // Read current register value
;;;333      //
;;;334      OS_IncDI();
00001a  f7fffffe          BL       __ARM_common_disable_irq
00001e  4df9              LDR      r5,|L1.1028|
;;;335      I2CPCA9532_WriteRead(acCommandString, 1, &Reg, 1);
000020  2301              MOVS     r3,#1
000022  7868              LDRB     r0,[r5,#1]            ;334  ; OS_Counters
000024  0019              MOVS     r1,r3
000026  466a              MOV      r2,sp
000028  1c40              ADDS     r0,r0,#1              ;334
00002a  7068              STRB     r0,[r5,#1]            ;334
00002c  a801              ADD      r0,sp,#4
00002e  f7fffffe          BL       I2CPCA9532_WriteRead
;;;336      OS_DecRI();
000032  7868              LDRB     r0,[r5,#1]  ; OS_Counters
000034  1e40              SUBS     r0,r0,#1
000036  0600              LSLS     r0,r0,#24
000038  0e00              LSRS     r0,r0,#24
00003a  7068              STRB     r0,[r5,#1]
00003c  d101              BNE      |L1.66|
00003e  f7fffffe          BL       __ARM_common_enable_irq
                  |L1.66|
;;;337      //
;;;338      // Set new LED state
;;;339      //
;;;340      if (LED >= 4) {
000042  2c04              CMP      r4,#4
000044  d302              BCC      |L1.76|
;;;341        LED -= 4;  // Address was already corrected above
000046  1f24              SUBS     r4,r4,#4
000048  0624              LSLS     r4,r4,#24
00004a  0e24              LSRS     r4,r4,#24
                  |L1.76|
00004c  2001              MOVS     r0,#1                 ;335
;;;342      }
;;;343      if (State == LED_SET) {
00004e  2e00              CMP      r6,#0
000050  d020              BEQ      |L1.148|
;;;344        Reg |= (1 << (LED * 2)); //0x01;
;;;345      } else if (State == LED_TOGGLE) {
000052  2e02              CMP      r6,#2
000054  d023              BEQ      |L1.158|
;;;346        if (Reg & (1 << (LED * 2))) {
;;;347          Reg &= ~(1 << (LED * 2));
;;;348        } else {
;;;349          Reg |= (1 << (LED * 2));
;;;350        }
;;;351      } else {
;;;352        Reg &= ~(1 << (LED * 2));
000056  0061              LSLS     r1,r4,#1
000058  4088              LSLS     r0,r0,r1
00005a  466a              MOV      r2,sp
00005c  7811              LDRB     r1,[r2,#0]
00005e  4381              BICS     r1,r1,r0
000060  7011              STRB     r1,[r2,#0]
                  |L1.98|
;;;353      }
;;;354      acCommandString[1] = Reg;
000062  4668              MOV      r0,sp
000064  7801              LDRB     r1,[r0,#0]
000066  7141              STRB     r1,[r0,#5]
;;;355      OS_IncDI();
000068  f7fffffe          BL       __ARM_common_disable_irq
00006c  7868              LDRB     r0,[r5,#1]  ; OS_Counters
;;;356      I2CPCA9532_WriteRead(acCommandString, sizeof(acCommandString), 0, 0);
00006e  2300              MOVS     r3,#0
000070  001a              MOVS     r2,r3
000072  1c40              ADDS     r0,r0,#1              ;355
000074  7068              STRB     r0,[r5,#1]            ;355
000076  2102              MOVS     r1,#2
000078  a801              ADD      r0,sp,#4
00007a  f7fffffe          BL       I2CPCA9532_WriteRead
;;;357      OS_DecRI();
00007e  7868              LDRB     r0,[r5,#1]  ; OS_Counters
000080  1e40              SUBS     r0,r0,#1
000082  0600              LSLS     r0,r0,#24
000084  0e00              LSRS     r0,r0,#24
000086  7068              STRB     r0,[r5,#1]
000088  d101              BNE      |L1.142|
00008a  f7fffffe          BL       __ARM_common_enable_irq
                  |L1.142|
;;;358    }
00008e  bc7c              POP      {r2-r6}
000090  bc08              POP      {r3}
000092  4718              BX       r3
                  |L1.148|
000094  0061              LSLS     r1,r4,#1              ;344
000096  4088              LSLS     r0,r0,r1              ;344
000098  4669              MOV      r1,sp                 ;344
00009a  7809              LDRB     r1,[r1,#0]            ;344
00009c  e00a              B        |L1.180|
                  |L1.158|
00009e  0061              LSLS     r1,r4,#1              ;346
0000a0  4088              LSLS     r0,r0,r1              ;346
0000a2  4669              MOV      r1,sp                 ;346
0000a4  7809              LDRB     r1,[r1,#0]            ;346
0000a6  0002              MOVS     r2,r0                 ;346
0000a8  420a              TST      r2,r1                 ;346
0000aa  d003              BEQ      |L1.180|
0000ac  4381              BICS     r1,r1,r0              ;347
0000ae  4668              MOV      r0,sp                 ;347
0000b0  7001              STRB     r1,[r0,#0]            ;347
0000b2  e7d6              B        |L1.98|
                  |L1.180|
0000b4  4308              ORRS     r0,r0,r1              ;349
0000b6  4669              MOV      r1,sp                 ;349
0000b8  7008              STRB     r0,[r1,#0]            ;349
0000ba  e7d2              B        |L1.98|
;;;359    /*********************************************************************
                          ENDP

                  _LCD_HW_Init PROC
;;;362    */
;;;363    static void _LCD_HW_Init(void) {
0000bc  48d2              LDR      r0,|L1.1032|
0000be  b410              PUSH     {r4}
;;;364      PCONP   |= (1 << 20);   // Enable peripheral clock for LCDC
0000c0  6841              LDR      r1,[r0,#4]
0000c2  2201              MOVS     r2,#1
0000c4  0512              LSLS     r2,r2,#20
0000c6  4311              ORRS     r1,r1,r2
0000c8  6041              STR      r1,[r0,#4]
;;;365      //
;;;366      // Turn on LCD power
;;;367      //
;;;368      FIO2DIR |= (1 << 0);
0000ca  48d0              LDR      r0,|L1.1036|
0000cc  6802              LDR      r2,[r0,#0]
0000ce  2101              MOVS     r1,#1
0000d0  430a              ORRS     r2,r2,r1
0000d2  6002              STR      r2,[r0,#0]
;;;369      FIO2SET  = (1 << 0);
0000d4  6181              STR      r1,[r0,#0x18]
;;;370    
;;;371      //
;;;372      // Set P1.18 as PWM output
;;;373      //
;;;374      PINSEL3 &= ~(0x3 << 4);  // Clear P1[18]
0000d6  48ce              LDR      r0,|L1.1040|
0000d8  68c1              LDR      r1,[r0,#0xc]
0000da  2230              MOVS     r2,#0x30
0000dc  4391              BICS     r1,r1,r2
0000de  60c1              STR      r1,[r0,#0xc]
;;;375      PINSEL3 |= (1 << 5);     // PWM1[1]
0000e0  68c1              LDR      r1,[r0,#0xc]
0000e2  2220              MOVS     r2,#0x20
0000e4  4311              ORRS     r1,r1,r2
0000e6  60c1              STR      r1,[r0,#0xc]
;;;376      PWM1PR  = 0x00;          // No prescaling
0000e8  49ca              LDR      r1,|L1.1044|
0000ea  2200              MOVS     r2,#0
0000ec  60ca              STR      r2,[r1,#0xc]
;;;377      PWM1MCR = (1 << 1);      // Reset counter if MR0 match
0000ee  2302              MOVS     r3,#2
0000f0  614b              STR      r3,[r1,#0x14]
;;;378      PWM1MR0 = 0x3000;        // Period time equal about 5 ms
0000f2  2303              MOVS     r3,#3
0000f4  031b              LSLS     r3,r3,#12
0000f6  618b              STR      r3,[r1,#0x18]
;;;379      PWM1MR1 = 0x00;
0000f8  61ca              STR      r2,[r1,#0x1c]
;;;380      PWM1LER = 0
0000fa  4bc6              LDR      r3,|L1.1044|
0000fc  2403              MOVS     r4,#3
0000fe  3340              ADDS     r3,r3,#0x40
000100  611c              STR      r4,[r3,#0x10]
;;;381                | (1 << 0)     // Latch MR0
;;;382                | (1 << 1)     // Latch MR1
;;;383                ;
;;;384      PWM1PCR = (1 << 9);      // Enable PWMENA1
000102  2401              MOVS     r4,#1
000104  0264              LSLS     r4,r4,#9
000106  60dc              STR      r4,[r3,#0xc]
;;;385      PWM1TCR = 0
000108  2309              MOVS     r3,#9
00010a  604b              STR      r3,[r1,#4]
;;;386                | (1 << 0)     // Enable counter
;;;387                | (1 << 3)     // Enable PWM
;;;388                ;
;;;389      //
;;;390      // Init SPI0
;;;391      //
;;;392      PINSEL0 |= (0x3uL << 30);   // SCK
00010c  6801              LDR      r1,[r0,#0]
00010e  0403              LSLS     r3,r0,#16
000110  4319              ORRS     r1,r1,r3
000112  6001              STR      r1,[r0,#0]
;;;393      PINSEL1 |= (0
000114  6841              LDR      r1,[r0,#4]
000116  233c              MOVS     r3,#0x3c
000118  4319              ORRS     r1,r1,r3
00011a  6041              STR      r1,[r0,#4]
;;;394                  | (0x3 << 2)  // SSEL
;;;395                  | (0x3 << 4)  // MOSI
;;;396                 );
;;;397      IO0DIR  |= (0
00011c  49be              LDR      r1,|L1.1048|
00011e  688c              LDR      r4,[r1,#8]
000120  2309              MOVS     r3,#9
000122  041b              LSLS     r3,r3,#16
000124  431c              ORRS     r4,r4,r3
000126  608c              STR      r4,[r1,#8]
;;;398                  | (1 << 16)
;;;399                  | (1 << 19)
;;;400                 );
;;;401      IO0SET   =  0
000128  604b              STR      r3,[r1,#4]
;;;402                  | (1 << 16)
;;;403                  | (1 << 19)
;;;404                  ;
;;;405      S0SPCCR  =  0xC;          // SPI0 clock counter setting
00012a  49bc              LDR      r1,|L1.1052|
00012c  230c              MOVS     r3,#0xc
00012e  60cb              STR      r3,[r1,#0xc]
;;;406      S0SPCR   =  0
000130  2338              MOVS     r3,#0x38
000132  600b              STR      r3,[r1,#0]
;;;407                  | (1 << 3)    // Clock phase control, data is sampled on second clock edge of SCK
;;;408                  | (1 << 4)    // CPOL, SCK is active low
;;;409                  | (1 << 5)    // MSTR, SPI operates in master mode
;;;410                  ;
;;;411      PINSEL10 = 0x00;
000134  6282              STR      r2,[r0,#0x28]
;;;412      PINSEL0  = (PINSEL0 & 0xFFF000FF)
000136  6801              LDR      r1,[r0,#0]
000138  4bb9              LDR      r3,|L1.1056|
00013a  4aba              LDR      r2,|L1.1060|
00013c  4019              ANDS     r1,r1,r3
00013e  31ff              ADDS     r1,r1,#0xff
000140  3101              ADDS     r1,#1
000142  4311              ORRS     r1,r1,r2
000144  6001              STR      r1,[r0,#0]
;;;413                 | (1 <<  8)    // I2SRX_CLK  / LCDVD[0]
;;;414                 | (1 << 10)    // I2SRX_WS   / LCDVD[1]
;;;415                 | (1 << 12)    // I2SRX_SDA  / LCDVD[8]
;;;416                 | (1 << 14)    // I2STX_CLK  / LCDVD[9]
;;;417                 | (1 << 16)    // I2STX_WS   / LCDVD[16]
;;;418                 | (1 << 18)    // I2STX_SDA  / LCDVD[17]
;;;419                 ;
;;;420      PINSEL3  = (PINSEL3 & 0xF00000FF)
000146  68c1              LDR      r1,[r0,#0xc]
000148  4bb7              LDR      r3,|L1.1064|
00014a  2201              MOVS     r2,#1
00014c  0292              LSLS     r2,r2,#10
00014e  4019              ANDS     r1,r1,r3
000150  1889              ADDS     r1,r1,r2
000152  4ab6              LDR      r2,|L1.1068|
000154  4311              ORRS     r1,r1,r2
000156  60c1              STR      r1,[r0,#0xc]
;;;421                 | (1 <<  8)    // USB_TX_DP1 / LCDVD[6]  / LCDVD[10]
;;;422                 | (1 << 10)    // USB_TX_DM1 / LCDVD[7]  / LCDVD[11]
;;;423                 | (1 << 12)    // USB_RCV1   / LCDVD[8]  / LCDVD[12]
;;;424                 | (1 << 14)    // USB_RX_DP1 / LCDVD[9]  / LCDVD[13]
;;;425                 | (1 << 16)    // USB_RX_DM1 / LCDVD[10] / LCDVD[14]
;;;426                 | (1 << 18)    // USB_LS1    / LCDVD[11] / LCDVD[15]
;;;427                 | (1 << 20)    // USB_SSPND1 / LCDVD[12] / LCDVD[20]
;;;428                 | (1 << 22)    // USB_INT1   / LCDVD[13] / LCDVD[21]
;;;429                 | (1 << 24)    // USB_SCL1   / LCDVD[14] / LCDVD[22]
;;;430                 | (1 << 26)    // USB_SDA1   / LCDVD[15] / LCDVD[23]
;;;431                 ;
;;;432      PINSEL4  = (PINSEL4 & 0xF0300000)
000158  6901              LDR      r1,[r0,#0x10]
00015a  4bb5              LDR      r3,|L1.1072|
00015c  4ab5              LDR      r2,|L1.1076|
00015e  4019              ANDS     r1,r1,r3
000160  310c              ADDS     r1,r1,#0xc
000162  4311              ORRS     r1,r1,r2
000164  6101              STR      r1,[r0,#0x10]
;;;433                 | (0x3 <<  0)  // TRACECLK   / LCDPWR
;;;434                 | (0x3 <<  2)  // PIPESTAT0  / LCDLE
;;;435                 | (0x3 <<  4)  // PIPESTAT1  / LCDDCLK
;;;436                 | (0x3 <<  6)  // PIPESTAT2  / LCDFP
;;;437                 | (0x3 <<  8)  // TRACESYNC  / LCDENAB   / LCDM
;;;438                 | (0x3 << 10)  // TRACEPKT0  / LCDLP
;;;439                 | (0x3 << 12)  // TRACEPKT1  / LCDVD[0]  / LCDVD[4]
;;;440                 | (0x3 << 14)  // TRACEPKT2  / LCDVD[1]  / LCDVD[5]
;;;441                 | (0x3 << 16)  // TRACEPKT3  / LCDVD[2]  / LCDVD[6]
;;;442                 | (0x3 << 18)  // EXTIN0     / LCDVD[3]  / LCDVD[7]
;;;443                 | (1   << 22)  // EINT1      / LCDCLKIN
;;;444                 | (1   << 24)  // EINT2      / LCDVD[4]  / LCDVD[3]  / LCDVD[8]  / LCDVD[18]
;;;445                 | (1   << 24)  // EINT3      / LCDVD[5]  / LCDVD[9]  / LCDVD[19]
;;;446                 ;
;;;447      PINSEL9  = (PINSEL9 & 0xF0FFFFFF)
000166  6a41              LDR      r1,[r0,#0x24]
000168  220f              MOVS     r2,#0xf
00016a  0612              LSLS     r2,r2,#24
00016c  2305              MOVS     r3,#5
00016e  065b              LSLS     r3,r3,#25
000170  4391              BICS     r1,r1,r2
000172  18c9              ADDS     r1,r1,r3
000174  6241              STR      r1,[r0,#0x24]
;;;448                 | (1 << 25)    // MAT2[0]    / LCDVD[6]  / LCDVD[10] / LCDVD[2]
;;;449                 | (1 << 27)    // MAT2[1]    / LCDVD[7]  / LCDVD[11] / LCDVD[3]
;;;450                 ;
;;;451      PINSEL11 = 0
000176  210d              MOVS     r1,#0xd
000178  62c1              STR      r1,[r0,#0x2c]
;;;452                 | (1   << 0)   // Enable LCD port
;;;453                 | (0x3 << 2)   // LCD Mode: TFT 16-bit (1:5:5:5 mode)
;;;454                 ;
;;;455    }
00017a  bc10              POP      {r4}
00017c  4770              BX       lr
;;;456    
                          ENDP

                  _SPI_Send PROC
;;;519    */
;;;520    static void _SPI_Send(unsigned char Data) {
00017e  49a7              LDR      r1,|L1.1052|
;;;521      unsigned long Failsafe = 0;
000180  2200              MOVS     r2,#0
;;;522    
;;;523      S0SPDR = Data;
000182  6088              STR      r0,[r1,#8]
;;;524      while (((S0SPSR & 0x80) == 0) && (Failsafe < 5000)) {  // while (SPI Transfer active)
000184  48ac              LDR      r0,|L1.1080|
000186  e000              B        |L1.394|
                  |L1.392|
;;;525        Failsafe++;
000188  1c52              ADDS     r2,r2,#1
                  |L1.394|
00018a  684b              LDR      r3,[r1,#4]            ;524
00018c  061b              LSLS     r3,r3,#24             ;524
00018e  d401              BMI      |L1.404|
000190  4282              CMP      r2,r0                 ;524
000192  d3f9              BCC      |L1.392|
                  |L1.404|
;;;526      }
;;;527      if (Failsafe >= 5000) {
000194  4282              CMP      r2,r0
000196  d303              BCC      |L1.416|
;;;528        S0SPCCR = 0x08;  // SPI0 clock counter setting
000198  2008              MOVS     r0,#8
00019a  60c8              STR      r0,[r1,#0xc]
;;;529        S0SPCR  = 0
00019c  2038              MOVS     r0,#0x38
00019e  6008              STR      r0,[r1,#0]
                  |L1.416|
;;;530                 | (1 << 3)  // Clock phase control, data is sampled on second clock edge of SCK
;;;531                 | (1 << 4)  // CPOL, SCK is active low
;;;532                 | (1 << 5)  // MSTR, SPI operates in master mode
;;;533                 ;
;;;534      }
;;;535    }
0001a0  4770              BX       lr
;;;536    
                          ENDP

                  _LCD_WriteToReg PROC
;;;540    */
;;;541    static void _LCD_WriteToReg(unsigned short Addr, unsigned short Data) {
0001a2  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;542      IO0CLR = (1 << 19);  // RESET_RS
0001a4  4c9c              LDR      r4,|L1.1048|
0001a6  000f              MOVS     r7,r1                 ;541
0001a8  2601              MOVS     r6,#1
0001aa  04f6              LSLS     r6,r6,#19
0001ac  b081              SUB      sp,sp,#4              ;541
0001ae  60e6              STR      r6,[r4,#0xc]
;;;543      IO0CLR = (1 << 16);  // ACTIVATE_CS
0001b0  10f5              ASRS     r5,r6,#3
0001b2  60e5              STR      r5,[r4,#0xc]
;;;544      _SPI_Send(0);
0001b4  2000              MOVS     r0,#0
0001b6  f7fffffe          BL       _SPI_Send
;;;545      _SPI_Send(Addr);
0001ba  9801              LDR      r0,[sp,#4]
0001bc  0600              LSLS     r0,r0,#24
0001be  0e00              LSRS     r0,r0,#24
0001c0  f7fffffe          BL       _SPI_Send
;;;546      IO0SET = (1 << 16);  // DEACTIVATE_CS
0001c4  6065              STR      r5,[r4,#4]
;;;547      IO0SET = (1 << 19);  // SET_RS
0001c6  6066              STR      r6,[r4,#4]
;;;548      IO0CLR = (1 << 16);  // ACTIVATE_CS
0001c8  60e5              STR      r5,[r4,#0xc]
;;;549      _SPI_Send(Data >> 8);
0001ca  0a38              LSRS     r0,r7,#8
0001cc  f7fffffe          BL       _SPI_Send
;;;550      _SPI_Send(Data & 0xFF);
0001d0  0638              LSLS     r0,r7,#24
0001d2  0e00              LSRS     r0,r0,#24
0001d4  f7fffffe          BL       _SPI_Send
;;;551      IO0SET = (1 << 16);  // DEACTIVATE_CS
0001d8  6065              STR      r5,[r4,#4]
;;;552      IO0CLR = (1 << 19);  // RESET_RS
0001da  60e6              STR      r6,[r4,#0xc]
;;;553      IO0CLR = (1 << 16);  // ACTIVATE_CS
0001dc  60e5              STR      r5,[r4,#0xc]
;;;554      _SPI_Send(0);
0001de  2000              MOVS     r0,#0
0001e0  f7fffffe          BL       _SPI_Send
;;;555      _SPI_Send(0x22);
0001e4  2022              MOVS     r0,#0x22
0001e6  f7fffffe          BL       _SPI_Send
;;;556      IO0SET = (1 << 16);  // DEACTIVATE_CS
0001ea  6065              STR      r5,[r4,#4]
;;;557    }
0001ec  bcfe              POP      {r1-r7}
0001ee  bc08              POP      {r3}
0001f0  4718              BX       r3
;;;558    
                          ENDP

                  _LCD_DisplayInit PROC
;;;562    */
;;;563    static void _LCD_DisplayInit(void) {
0001f2  b570              PUSH     {r4-r6,lr}
;;;564      _LCD_WriteToReg(0x00,0x0001);
0001f4  2101              MOVS     r1,#1
0001f6  2000              MOVS     r0,#0
0001f8  f7fffffe          BL       _LCD_WriteToReg
;;;565      _Delay(20);
0001fc  2014              MOVS     r0,#0x14
0001fe  f7fffffe          BL       _Delay
;;;566      _LCD_WriteToReg(0x03,0xA2A4);
000202  498e              LDR      r1,|L1.1084|
000204  2003              MOVS     r0,#3
000206  f7fffffe          BL       _LCD_WriteToReg
;;;567      _LCD_WriteToReg(0x0C,0x0004);
00020a  2104              MOVS     r1,#4
00020c  200c              MOVS     r0,#0xc
00020e  f7fffffe          BL       _LCD_WriteToReg
;;;568      _LCD_WriteToReg(0x0D,0x0308);
000212  2161              MOVS     r1,#0x61
000214  00c9              LSLS     r1,r1,#3
000216  200d              MOVS     r0,#0xd
000218  f7fffffe          BL       _LCD_WriteToReg
;;;569      _LCD_WriteToReg(0x0E,0x3000);
00021c  2103              MOVS     r1,#3
00021e  0309              LSLS     r1,r1,#12
000220  200e              MOVS     r0,#0xe
000222  f7fffffe          BL       _LCD_WriteToReg
;;;570      _Delay(50);
000226  2032              MOVS     r0,#0x32
000228  f7fffffe          BL       _Delay
;;;571      _LCD_WriteToReg(0x1E,0x00AF);
00022c  21af              MOVS     r1,#0xaf
00022e  201e              MOVS     r0,#0x1e
000230  f7fffffe          BL       _LCD_WriteToReg
;;;572      _LCD_WriteToReg(0x01,0x2B3F);
000234  4982              LDR      r1,|L1.1088|
000236  2001              MOVS     r0,#1
000238  f7fffffe          BL       _LCD_WriteToReg
;;;573      _LCD_WriteToReg(0x02,0x0600);
00023c  2103              MOVS     r1,#3
00023e  0249              LSLS     r1,r1,#9
000240  2002              MOVS     r0,#2
000242  f7fffffe          BL       _LCD_WriteToReg
;;;574      _LCD_WriteToReg(0x10,0x0000);
000246  2100              MOVS     r1,#0
000248  2010              MOVS     r0,#0x10
00024a  f7fffffe          BL       _LCD_WriteToReg
;;;575      _LCD_WriteToReg(0x07,0x0233);
00024e  497d              LDR      r1,|L1.1092|
000250  2007              MOVS     r0,#7
000252  f7fffffe          BL       _LCD_WriteToReg
;;;576      _LCD_WriteToReg(0x0B,0x0039);
000256  2139              MOVS     r1,#0x39
000258  200b              MOVS     r0,#0xb
00025a  f7fffffe          BL       _LCD_WriteToReg
;;;577      _LCD_WriteToReg(0x0F,0x0000);
00025e  2100              MOVS     r1,#0
000260  200f              MOVS     r0,#0xf
000262  f7fffffe          BL       _LCD_WriteToReg
;;;578      _Delay(50);
000266  2032              MOVS     r0,#0x32
000268  f7fffffe          BL       _Delay
;;;579      _LCD_WriteToReg(0x30,0x0707);
00026c  4976              LDR      r1,|L1.1096|
00026e  2030              MOVS     r0,#0x30
000270  f7fffffe          BL       _LCD_WriteToReg
;;;580      _LCD_WriteToReg(0x31,0x0204);
000274  2481              MOVS     r4,#0x81
000276  00a4              LSLS     r4,r4,#2
000278  0021              MOVS     r1,r4
00027a  2031              MOVS     r0,#0x31
00027c  f7fffffe          BL       _LCD_WriteToReg
;;;581      _LCD_WriteToReg(0x32,0x0204);
000280  0021              MOVS     r1,r4
000282  2032              MOVS     r0,#0x32
000284  f7fffffe          BL       _LCD_WriteToReg
;;;582      _LCD_WriteToReg(0x33,0x0502);
000288  4d70              LDR      r5,|L1.1100|
00028a  2033              MOVS     r0,#0x33
00028c  0029              MOVS     r1,r5
00028e  f7fffffe          BL       _LCD_WriteToReg
;;;583      _LCD_WriteToReg(0x34,0x0507);
000292  1d69              ADDS     r1,r5,#5
000294  2034              MOVS     r0,#0x34
000296  f7fffffe          BL       _LCD_WriteToReg
;;;584      _LCD_WriteToReg(0x35,0x0204);
00029a  0021              MOVS     r1,r4
00029c  2035              MOVS     r0,#0x35
00029e  f7fffffe          BL       _LCD_WriteToReg
;;;585      _LCD_WriteToReg(0x36,0x0204);
0002a2  0021              MOVS     r1,r4
0002a4  2036              MOVS     r0,#0x36
0002a6  f7fffffe          BL       _LCD_WriteToReg
;;;586      _LCD_WriteToReg(0x37,0x0502);
0002aa  0029              MOVS     r1,r5
0002ac  2037              MOVS     r0,#0x37
0002ae  f7fffffe          BL       _LCD_WriteToReg
;;;587      _LCD_WriteToReg(0x3A,0x0302);
0002b2  4c64              LDR      r4,|L1.1092|
0002b4  203a              MOVS     r0,#0x3a
0002b6  34cf              ADDS     r4,r4,#0xcf
0002b8  0021              MOVS     r1,r4
0002ba  f7fffffe          BL       _LCD_WriteToReg
;;;588      _LCD_WriteToReg(0x3B,0x0302);
0002be  0021              MOVS     r1,r4
0002c0  203b              MOVS     r0,#0x3b
0002c2  f7fffffe          BL       _LCD_WriteToReg
;;;589    
;;;590      _LCD_WriteToReg(0x23,0x0000);
0002c6  2100              MOVS     r1,#0
0002c8  2023              MOVS     r0,#0x23
0002ca  f7fffffe          BL       _LCD_WriteToReg
;;;591      _LCD_WriteToReg(0x24,0x0000);
0002ce  2100              MOVS     r1,#0
0002d0  2024              MOVS     r0,#0x24
0002d2  f7fffffe          BL       _LCD_WriteToReg
;;;592    
;;;593      _LCD_WriteToReg(0x48,0x0000);
0002d6  2100              MOVS     r1,#0
0002d8  2048              MOVS     r0,#0x48
0002da  f7fffffe          BL       _LCD_WriteToReg
;;;594      _LCD_WriteToReg(0x49,0x013F);
0002de  24ff              MOVS     r4,#0xff
0002e0  3440              ADDS     r4,r4,#0x40
0002e2  0021              MOVS     r1,r4
0002e4  2049              MOVS     r0,#0x49
0002e6  f7fffffe          BL       _LCD_WriteToReg
;;;595      _LCD_WriteToReg(0x4A,0x0000);
0002ea  2100              MOVS     r1,#0
0002ec  204a              MOVS     r0,#0x4a
0002ee  f7fffffe          BL       _LCD_WriteToReg
;;;596      _LCD_WriteToReg(0x4B,0x0000);
0002f2  2100              MOVS     r1,#0
0002f4  204b              MOVS     r0,#0x4b
0002f6  f7fffffe          BL       _LCD_WriteToReg
;;;597    
;;;598      _LCD_WriteToReg(0x41,0x0000);
0002fa  2100              MOVS     r1,#0
0002fc  2041              MOVS     r0,#0x41
0002fe  f7fffffe          BL       _LCD_WriteToReg
;;;599      _LCD_WriteToReg(0x42,0x0000);
000302  2100              MOVS     r1,#0
000304  2042              MOVS     r0,#0x42
000306  f7fffffe          BL       _LCD_WriteToReg
;;;600    
;;;601      _LCD_WriteToReg(0x44,0xEF00);
00030a  25ef              MOVS     r5,#0xef
00030c  022d              LSLS     r5,r5,#8
00030e  0029              MOVS     r1,r5
000310  2044              MOVS     r0,#0x44
000312  f7fffffe          BL       _LCD_WriteToReg
;;;602      _LCD_WriteToReg(0x45,0x0000);
000316  2100              MOVS     r1,#0
000318  2045              MOVS     r0,#0x45
00031a  f7fffffe          BL       _LCD_WriteToReg
;;;603      _LCD_WriteToReg(0x46,0x013F);
00031e  0021              MOVS     r1,r4
000320  2046              MOVS     r0,#0x46
000322  f7fffffe          BL       _LCD_WriteToReg
;;;604      _Delay(50);
000326  2032              MOVS     r0,#0x32
000328  f7fffffe          BL       _Delay
;;;605      _LCD_WriteToReg(0x44,0xEF00);
00032c  0029              MOVS     r1,r5
00032e  2044              MOVS     r0,#0x44
000330  f7fffffe          BL       _LCD_WriteToReg
;;;606      _LCD_WriteToReg(0x45,0x0000);
000334  2100              MOVS     r1,#0
000336  2045              MOVS     r0,#0x45
000338  f7fffffe          BL       _LCD_WriteToReg
;;;607      _LCD_WriteToReg(0x4E,0x0000);
00033c  2100              MOVS     r1,#0
00033e  204e              MOVS     r0,#0x4e
000340  f7fffffe          BL       _LCD_WriteToReg
;;;608      _LCD_WriteToReg(0x4F,0x0000);
000344  2100              MOVS     r1,#0
000346  204f              MOVS     r0,#0x4f
000348  f7fffffe          BL       _LCD_WriteToReg
;;;609      _LCD_WriteToReg(0x46,0x013F);
00034c  0021              MOVS     r1,r4
00034e  2046              MOVS     r0,#0x46
000350  f7fffffe          BL       _LCD_WriteToReg
;;;610    }
000354  bc70              POP      {r4-r6}
000356  bc08              POP      {r3}
000358  4718              BX       r3
;;;611    
                          ENDP

                  _ExecTouch PROC
;;;629    */
;;;630    static void _ExecTouch(void) {
00035a  b510              PUSH     {r4,lr}
;;;631        GUI_TOUCH_Exec();
00035c  f7fffffe          BL       GUI_TOUCH_Exec
;;;632        OS_RetriggerTimer(&_TouchTimer);
000360  483b              LDR      r0,|L1.1104|
000362  f7fffffe          BL       OS_RetriggerTimer
                  |L1.870|
;;;633    }
000366  bc10              POP      {r4}
000368  bc08              POP      {r3}
00036a  4718              BX       r3
;;;634    
                          ENDP

                  BSP_ETH_Init PROC
;;;682    */
;;;683    void BSP_ETH_Init(unsigned Unit) {
00036c  4839              LDR      r0,|L1.1108|
;;;684    
;;;685      /*------------------------------------------------------------------------------
;;;686      * write to PINSEL2/3 to select the PHY functions on P1[17:0]
;;;687      *-----------------------------------------------------------------------------*/
;;;688      /* P1.6, ENET-TX_CLK, has to be set for EMAC to address a BUG in
;;;689      the rev"xx-X" or "xx-Y" silicon(see errata). On the new rev.(xxAY, released
;;;690      on 06/22/2007), P1.6 should NOT be set. */
;;;691      if (MAC_MODULEID == 0x39022000) {  // Older chip ?
00036e  6bc1              LDR      r1,[r0,#0x3c]
000370  4a39              LDR      r2,|L1.1112|
;;;692        PINSEL2 = 0x50151105;            // selects P1[0,1,4,6,8,9,10,14,15]
000372  4827              LDR      r0,|L1.1040|
000374  4291              CMP      r1,r2                 ;691
000376  d101              BNE      |L1.892|
000378  4938              LDR      r1,|L1.1116|
00037a  e000              B        |L1.894|
                  |L1.892|
;;;693      } else {
;;;694        PINSEL2 = 0x50150105;            // selects P1[0,1,4,8,9,10,14,15]
00037c  4938              LDR      r1,|L1.1120|
                  |L1.894|
00037e  6081              STR      r1,[r0,#8]
;;;695      }
;;;696      PINSEL3 = (PINSEL3 & ~0x0000000f) | 0x5;
000380  68c1              LDR      r1,[r0,#0xc]
000382  0909              LSRS     r1,r1,#4
000384  0109              LSLS     r1,r1,#4
000386  1d49              ADDS     r1,r1,#5
000388  60c1              STR      r1,[r0,#0xc]
;;;697    }
00038a  4770              BX       lr
;;;698    
                          ENDP

                  BSP_ETH_InstallISR PROC
;;;702    */
;;;703    void BSP_ETH_InstallISR(void (*pfISR)(void)) {
00038c  0001              MOVS     r1,r0
00038e  b510              PUSH     {r4,lr}
;;;704      OS_ARM_InstallISRHandler(INT_INDEX_MAC, pfISR);     // Timer/counter interrupt vector.
000390  2015              MOVS     r0,#0x15
000392  f7fffffe          BL       OS_ARM_InstallISRHandler
;;;705      OS_ARM_EnableISR(INT_INDEX_MAC);                    // Enable timer/counter 0 interrupt.
000396  2015              MOVS     r0,#0x15
000398  f7fffffe          BL       OS_ARM_EnableISR
;;;706      OS_ARM_ISRSetPrio(INT_INDEX_MAC, 15);               // lowest priority
00039c  210f              MOVS     r1,#0xf
00039e  2015              MOVS     r0,#0x15
0003a0  f7fffffe          BL       OS_ARM_ISRSetPrio
;;;707    }
0003a4  e7df              B        |L1.870|
;;;708    
                          ENDP

                  BSP_Init PROC
;;;712    */
;;;713    void BSP_Init(void) {
0003a6  b510              PUSH     {r4,lr}
;;;714      //
;;;715      // Init I2C
;;;716      //
;;;717      I2CPCA9532_Init();
0003a8  f7fffffe          BL       I2CPCA9532_Init
;;;718    }
0003ac  e7db              B        |L1.870|
;;;719    
                          ENDP

                  BSP_SetLED PROC
;;;723    */
;;;724    void BSP_SetLED(int Index) {
0003ae  0600              LSLS     r0,r0,#24
;;;725      _SetLEDState(Index, LED_SET);
0003b0  0e00              LSRS     r0,r0,#24
0003b2  2100              MOVS     r1,#0
0003b4  e7fe              B        _SetLEDState
;;;726    }
;;;727    
                          ENDP

                  BSP_ClrLED PROC
;;;728    void BSP_ClrLED(int Index) {
0003b6  0600              LSLS     r0,r0,#24
;;;729      _SetLEDState(Index, LED_CLR);
0003b8  0e00              LSRS     r0,r0,#24
0003ba  2101              MOVS     r1,#1
0003bc  e7fe              B        _SetLEDState
;;;730    }
;;;731    
                          ENDP

                  BSP_ToggleLED PROC
;;;732    void BSP_ToggleLED(int Index) {
0003be  0600              LSLS     r0,r0,#24
;;;733      _SetLEDState(Index, LED_TOGGLE);
0003c0  0e00              LSRS     r0,r0,#24
0003c2  2102              MOVS     r1,#2
0003c4  e7fe              B        _SetLEDState
;;;734    }
;;;735    
                          ENDP

                  _InitLCDController PROC
;;;742    */
;;;743    static void _InitLCDController(unsigned LayerIndex) {
0003c6  b538              PUSH     {r3-r5,lr}
;;;744      U32 TouchOrientation;
;;;745    
;;;746      //
;;;747      // Calibrate touch
;;;748      //
;;;749      TouchOrientation = (GUI_MIRROR_X * LCD_GetMirrorXEx(0)) |
0003c8  2000              MOVS     r0,#0
0003ca  f7fffffe          BL       LCD_GetMirrorXEx
0003ce  0004              MOVS     r4,r0
0003d0  2000              MOVS     r0,#0
0003d2  f7fffffe          BL       LCD_GetMirrorYEx
0003d6  0040              LSLS     r0,r0,#1
0003d8  4304              ORRS     r4,r4,r0
0003da  2000              MOVS     r0,#0
0003dc  f7fffffe          BL       LCD_GetSwapXYEx
0003e0  0080              LSLS     r0,r0,#2
0003e2  4320              ORRS     r0,r0,r4
;;;750                         (GUI_MIRROR_Y * LCD_GetMirrorYEx(0)) |
;;;751                         (GUI_SWAP_XY  * LCD_GetSwapXYEx (0)) ;
;;;752      GUI_TOUCH_SetOrientation(TouchOrientation);
0003e4  f7fffffe          BL       GUI_TOUCH_SetOrientation
;;;753      GUI_TOUCH_Calibrate(GUI_COORD_X, 0, 240, TOUCH_AD_TOP , TOUCH_AD_BOTTOM);  // x axis
0003e8  481e              LDR      r0,|L1.1124|
0003ea  2100              MOVS     r1,#0
0003ec  9000              STR      r0,[sp,#0]
0003ee  23b8              MOVS     r3,#0xb8
0003f0  22f0              MOVS     r2,#0xf0
0003f2  0008              MOVS     r0,r1
0003f4  f7fffffe          BL       GUI_TOUCH_Calibrate
;;;754      GUI_TOUCH_Calibrate(GUI_COORD_Y, 0, 320, TOUCH_AD_LEFT, TOUCH_AD_RIGHT);   // y axis
0003f8  481a              LDR      r0,|L1.1124|
0003fa  383c              SUBS     r0,r0,#0x3c
0003fc  239a              MOVS     r3,#0x9a
0003fe  e033              B        |L1.1128|
                  |L1.1024|
000400  0800              DCB      "\b",0
000402  00                DCB      0
000403  00                DCB      0
                  |L1.1028|
                          DCD      OS_Counters
                  |L1.1032|
                          DCD      0xe01fc0c0
                  |L1.1036|
                          DCD      0x3fffc040
                  |L1.1040|
                          DCD      0xe002c000
                  |L1.1044|
                          DCD      0xe0018000
                  |L1.1048|
                          DCD      0xe0028000
                  |L1.1052|
                          DCD      0xe0020000
                  |L1.1056|
                          DCD      0xfff000ff
                  |L1.1060|
                          DCD      0x00055400
                  |L1.1064|
                          DCD      0xf00000ff
                  |L1.1068|
                          DCD      0x05555500
                  |L1.1072|
                          DCD      0xf0300000
                  |L1.1076|
                          DCD      0x014fffff
                  |L1.1080|
                          DCD      0x00001388
                  |L1.1084|
                          DCD      0x0000a2a4
                  |L1.1088|
                          DCD      0x00002b3f
                  |L1.1092|
                          DCD      0x00000233
                  |L1.1096|
                          DCD      0x00000707
                  |L1.1100|
                          DCD      0x00000502
                  |L1.1104|
                          DCD      ||.bss||+0x4b020
                  |L1.1108|
                          DCD      0xffe00fc0
                  |L1.1112|
                          DCD      0x39022000
                  |L1.1116|
                          DCD      0x50151105
                  |L1.1120|
                          DCD      0x50150105
                  |L1.1124|
                          DCD      0x00000f36
                  |L1.1128|
000468  22ff              MOVS     r2,#0xff
00046a  9000              STR      r0,[sp,#0]
00046c  3241              ADDS     r2,r2,#0x41
00046e  2100              MOVS     r1,#0
000470  2001              MOVS     r0,#1
000472  f7fffffe          BL       GUI_TOUCH_Calibrate
;;;755      //
;;;756      // LCD Init
;;;757      //
;;;758      _VRAMAddr = (U32)_Align((void *)VRAM_ADDR, 8);
000476  4874              LDR      r0,|L1.1608|
000478  2108              MOVS     r1,#8
00047a  f7fffffe          BL       _Align
00047e  4d73              LDR      r5,|L1.1612|
;;;759      _LCD_HW_Init();
000480  6028              STR      r0,[r5,#0]  ; _VRAMAddr
000482  f7fffffe          BL       _LCD_HW_Init
;;;760      _LCD_SetBacklight(0);
000486  2000              MOVS     r0,#0
000488  f7fffffe          BL       _LCD_SetBacklight
00048c  4c70              LDR      r4,|L1.1616|
00048e  69a0              LDR      r0,[r4,#0x18]
000490  0840              LSRS     r0,r0,#1
000492  0040              LSLS     r0,r0,#1
000494  61a0              STR      r0,[r4,#0x18]
000496  486f              LDR      r0,|L1.1620|
000498  6020              STR      r0,[r4,#0]
00049a  486f              LDR      r0,|L1.1624|
00049c  6060              STR      r0,[r4,#4]
00049e  486f              LDR      r0,|L1.1628|
0004a0  60a0              STR      r0,[r4,#8]
0004a2  2100              MOVS     r1,#0
0004a4  60e1              STR      r1,[r4,#0xc]
0004a6  61e1              STR      r1,[r4,#0x1c]
0004a8  202c              MOVS     r0,#0x2c
0004aa  61a0              STR      r0,[r4,#0x18]
0004ac  4a6c              LDR      r2,|L1.1632|
0004ae  0008              MOVS     r0,r1
                  |L1.1200|
0004b0  1c40              ADDS     r0,r0,#1
0004b2  0600              LSLS     r0,r0,#24
0004b4  0e00              LSRS     r0,r0,#24
0004b6  c202              STM      r2!,{r1}
0004b8  2880              CMP      r0,#0x80
0004ba  d3f9              BCC      |L1.1200|
0004bc  4869              LDR      r0,|L1.1636|
0004be  6381              STR      r1,[r0,#0x38]
0004c0  2014              MOVS     r0,#0x14
0004c2  f7fffffe          BL       _Delay
;;;761      _LCD_Ctrl_Init();
;;;762      LCD_UPBASE = _VRAMAddr;
0004c6  6828              LDR      r0,[r5,#0]  ; _VRAMAddr
0004c8  6120              STR      r0,[r4,#0x10]
0004ca  69a0              LDR      r0,[r4,#0x18]
0004cc  4966              LDR      r1,|L1.1640|
0004ce  4308              ORRS     r0,r0,r1
0004d0  61a0              STR      r0,[r4,#0x18]
0004d2  2032              MOVS     r0,#0x32
0004d4  f7fffffe          BL       _Delay
0004d8  f7fffffe          BL       _LCD_DisplayInit
0004dc  2064              MOVS     r0,#0x64
0004de  f7fffffe          BL       _LCD_SetBacklight
0004e2  4862              LDR      r0,|L1.1644|
0004e4  6801              LDR      r1,[r0,#0]
0004e6  0402              LSLS     r2,r0,#16
0004e8  4311              ORRS     r1,r1,r2
0004ea  6001              STR      r1,[r0,#0]
0004ec  6841              LDR      r1,[r0,#4]
0004ee  223c              MOVS     r2,#0x3c
0004f0  4311              ORRS     r1,r1,r2
0004f2  6041              STR      r1,[r0,#4]
0004f4  485e              LDR      r0,|L1.1648|
0004f6  6882              LDR      r2,[r0,#8]
0004f8  2101              MOVS     r1,#1
0004fa  0509              LSLS     r1,r1,#20
0004fc  430a              ORRS     r2,r2,r1
0004fe  6082              STR      r2,[r0,#8]
000500  6041              STR      r1,[r0,#4]
000502  485c              LDR      r0,|L1.1652|
000504  2139              MOVS     r1,#0x39
000506  60c1              STR      r1,[r0,#0xc]
000508  2138              MOVS     r1,#0x38
00050a  6001              STR      r1,[r0,#0]
;;;763      _LCD_TurnOn();
;;;764      //
;;;765      // Setup LCD touch
;;;766      //
;;;767      _TouchInit();
;;;768      OS_CREATETIMER(&_TouchTimer, _ExecTouch, TOUCHTIMERINTERVAL);
00050c  495a              LDR      r1,|L1.1656|
00050e  485b              LDR      r0,|L1.1660|
000510  220a              MOVS     r2,#0xa
000512  f7fffffe          BL       OS_CreateTimer
000516  4859              LDR      r0,|L1.1660|
000518  f7fffffe          BL       OS_StartTimer
;;;769    }
00051c  bc38              POP      {r3-r5}
00051e  bc08              POP      {r3}
000520  4718              BX       r3
;;;770    
                          ENDP

                  LCD_X_DisplayDriver PROC
;;;786    */
;;;787    int LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData) {
000522  b510              PUSH     {r4,lr}
;;;788      LCD_X_SETORG_INFO * pSetOrg;
;;;789    
;;;790      switch (Cmd) {
000524  2901              CMP      r1,#1
000526  d002              BEQ      |L1.1326|
000528  2903              CMP      r1,#3
00052a  d10c              BNE      |L1.1350|
00052c  e002              B        |L1.1332|
                  |L1.1326|
;;;791      //
;;;792      // Required
;;;793      //
;;;794      case LCD_X_INITCONTROLLER:
;;;795        //
;;;796        // Called during the initialization process in order to set up the
;;;797        // display controller and put it into operation. If the display
;;;798        // controller is not initialized by any external routine this needs
;;;799        // to be adapted by the customer...
;;;800        //
;;;801        _InitLCDController(LayerIndex);
00052e  f7fffffe          BL       _InitLCDController
;;;802        break;
000532  e008              B        |L1.1350|
                  |L1.1332|
000534  6850              LDR      r0,[r2,#4]
000536  2105              MOVS     r1,#5
000538  01c9              LSLS     r1,r1,#7
00053a  4348              MULS     r0,r1,r0
00053c  4943              LDR      r1,|L1.1612|
00053e  680a              LDR      r2,[r1,#0]  ; _VRAMAddr
000540  4943              LDR      r1,|L1.1616|
000542  1880              ADDS     r0,r0,r2
000544  6108              STR      r0,[r1,#0x10]
                  |L1.1350|
;;;803      case LCD_X_SETORG:
;;;804        //
;;;805        // Required for setting the display origin which is passed in the 'xPos' and 'yPos' element of p
;;;806        //
;;;807        pSetOrg = (LCD_X_SETORG_INFO *)pData;
;;;808        _SetDisplayOrigin(pSetOrg->xPos, pSetOrg->yPos);
;;;809      }
;;;810      return 0;
000546  2000              MOVS     r0,#0
;;;811    }
000548  e70d              B        |L1.870|
;;;812    
                          ENDP

                  LCD_X_Config PROC
;;;821    */
;;;822    void LCD_X_Config(void) {
00054a  b510              PUSH     {r4,lr}
;;;823      _VRAMAddr = (U32)_Align((void *)VRAM_ADDR, 8);
00054c  483e              LDR      r0,|L1.1608|
00054e  2108              MOVS     r1,#8
000550  f7fffffe          BL       _Align
000554  4c3d              LDR      r4,|L1.1612|
;;;824      //
;;;825      // Set display driver and color conversion for 1st layer
;;;826      //
;;;827      GUI_DEVICE_CreateAndLink(&DISPLAY_DRIVER, COLOR_CONVERSION, 0, 0);
000556  2300              MOVS     r3,#0
000558  6020              STR      r0,[r4,#0]  ; _VRAMAddr
00055a  4949              LDR      r1,|L1.1664|
00055c  4849              LDR      r0,|L1.1668|
00055e  001a              MOVS     r2,r3
000560  f7fffffe          BL       GUI_DEVICE_CreateAndLink
;;;828      //
;;;829      // Display driver configuration, required for Lin-driver
;;;830      //
;;;831      LCD_SetSizeEx    (0, XSIZE_PHYS,   YSIZE_PHYS);
000564  21ff              MOVS     r1,#0xff
000566  22f0              MOVS     r2,#0xf0
000568  3141              ADDS     r1,r1,#0x41
00056a  2000              MOVS     r0,#0
00056c  f7fffffe          BL       LCD_SetSizeEx
;;;832      LCD_SetVSizeEx   (0, VXSIZE_PHYS,  VYSIZE_PHYS);
000570  2105              MOVS     r1,#5
000572  22f0              MOVS     r2,#0xf0
000574  01c9              LSLS     r1,r1,#7
000576  2000              MOVS     r0,#0
000578  f7fffffe          BL       LCD_SetVSizeEx
;;;833      LCD_SetVRAMAddrEx(0, (void *)_VRAMAddr);
00057c  6821              LDR      r1,[r4,#0]  ; _VRAMAddr
00057e  2000              MOVS     r0,#0
000580  f7fffffe          BL       LCD_SetVRAMAddrEx
;;;834      //
;;;835      // Set user palette data (only required if no fixed palette is used)
;;;836      //
;;;837      #if defined(PALETTE)
;;;838        LCD_SetLUTEx(0, PALETTE);
;;;839      #endif
;;;840    }
000584  e6ef              B        |L1.870|
;;;841    
                          ENDP

                  BSP_USBH_InstallISR PROC
;;;845    */
;;;846    void BSP_USBH_InstallISR(void (*pfISR)(void)) {
000586  0001              MOVS     r1,r0
000588  b510              PUSH     {r4,lr}
;;;847      OS_ARM_InstallISRHandler(INT_INDEX_USB, pfISR);     // Timer/counter interrupt vector.
00058a  2016              MOVS     r0,#0x16
00058c  f7fffffe          BL       OS_ARM_InstallISRHandler
;;;848      OS_ARM_EnableISR(INT_INDEX_USB);                    // Enable timer/counter 0 interrupt.
000590  2016              MOVS     r0,#0x16
000592  f7fffffe          BL       OS_ARM_EnableISR
;;;849      OS_ARM_ISRSetPrio(INT_INDEX_USB, 2);               // lowest priority
000596  2102              MOVS     r1,#2
000598  2016              MOVS     r0,#0x16
00059a  f7fffffe          BL       OS_ARM_ISRSetPrio
;;;850    }
00059e  e6e2              B        |L1.870|
;;;851    
                          ENDP

                  BSP_USBH_Init PROC
;;;883    */
;;;884    void BSP_USBH_Init(void) {
0005a0  4830              LDR      r0,|L1.1636|
;;;885      //
;;;886      // power the USB block
;;;887      //
;;;888      PCONP |= PCUSB;
0005a2  38c0              SUBS     r0,r0,#0xc0
0005a4  6841              LDR      r1,[r0,#4]
0005a6  0642              LSLS     r2,r0,#25
0005a8  4311              ORRS     r1,r1,r2
0005aa  6041              STR      r1,[r0,#4]
;;;889      //
;;;890      // Enable USB host and USB OTG clock
;;;891      //
;;;892      OTG_CLK_CTRL  |= USB_HOST_CLK_EN | USB_OTG_CLK_EN | USB_AHB_CLK_EN;
0005ac  4836              LDR      r0,|L1.1672|
0005ae  6b42              LDR      r2,[r0,#0x34]
0005b0  2119              MOVS     r1,#0x19
0005b2  430a              ORRS     r2,r2,r1
0005b4  6342              STR      r2,[r0,#0x34]
                  |L1.1462|
;;;893      while( (OTG_CLK_STAT & (USB_HOST_CLK_EN | USB_OTG_CLK_EN | USB_AHB_CLK_EN)) != (USB_HOST_CLK_EN | USB_OTG_CLK_EN | USB_AHB_CLK_EN));
0005b6  6b83              LDR      r3,[r0,#0x38]
0005b8  000a              MOVS     r2,r1
0005ba  439a              BICS     r2,r2,r3
0005bc  d1fb              BNE      |L1.1462|
;;;894    	//
;;;895      // Configure the pins for port1 OTG
;;;896    	// The USB device is connected to port 1 	
;;;897    	// port2 Host port
;;;898    	// P0.12    = USB-2:PORT_PWRn
;;;899    	// P0.13    = USB-2:LEDn
;;;900    	// P0.13    = USB-2:HostEN2 enable the 15k pull downs, static +5V
;;;901    	// P0.15 = GPIO
;;;902      //
;;;903    	PINSEL0 |= PS0_P012_USB_PPWR2 | PS0_P013_USB_UP_LED2;
0005be  482b              LDR      r0,|L1.1644|
0005c0  6801              LDR      r1,[r0,#0]
0005c2  2205              MOVS     r2,#5
0005c4  0612              LSLS     r2,r2,#24
0005c6  4311              ORRS     r1,r1,r2
0005c8  6001              STR      r1,[r0,#0]
;;;904    	//
;;;905      // if P0.14 does not correct switch disable P0.14 function
;;;906      //  configure P014 as GPIO Output */
;;;907    	IO0DIR |= (1 << 14); /* P0.14 is an output */
0005ca  4929              LDR      r1,|L1.1648|
0005cc  688b              LDR      r3,[r1,#8]
0005ce  2201              MOVS     r2,#1
0005d0  0392              LSLS     r2,r2,#14
0005d2  4313              ORRS     r3,r3,r2
0005d4  608b              STR      r3,[r1,#8]
;;;908    	IO0CLR  = (1 << 14); /* P0.14 is 0, enabling the pull-downs */
0005d6  60ca              STR      r2,[r1,#0xc]
;;;909    	//		
;;;910    	// P0.29 = USB1:D+
;;;911      // P0.30 = USB1:D-
;;;912      // P0.31 = USB2:D+
;;;913      //
;;;914    	PINSEL1 |= PS1_P029_USB_DP1 | PS1_P030_USB_DM1 | PS1_P031_USB_DP2;
0005d8  6841              LDR      r1,[r0,#4]
0005da  2215              MOVS     r2,#0x15
0005dc  0692              LSLS     r2,r2,#26
0005de  4311              ORRS     r1,r1,r2
0005e0  6041              STR      r1,[r0,#4]
;;;915    	PINSEL3 |= PS3_P118_USB_UP_LED1 // P1.18 = USBOTG:LEDn
0005e2  68c1              LDR      r1,[r0,#0xc]
0005e4  4a29              LDR      r2,|L1.1676|
0005e6  4311              ORRS     r1,r1,r2
0005e8  60c1              STR      r1,[r0,#0xc]
;;;916              |  PS3_P130_USB_PWRD2		// P1.30 = USB2:POWEREDn
;;;917              |  PS3_P131_USB_OVECR2;	// P1.31 = USB2:OVR_CRNTn
;;;918    
;;;919      /* In all configurations,
;;;920         disable the pull ups on P1.27 (OTG interrupt input)
;;;921         and P1.30 (Host Port 2 Power status)
;;;922      */
;;;923      PINMODE3 &=~ (PINMODE_GET_16_TO_31(27,PIN_MODE_MASK)
0005ea  4820              LDR      r0,|L1.1644|
0005ec  3040              ADDS     r0,r0,#0x40
0005ee  68c1              LDR      r1,[r0,#0xc]
0005f0  221b              MOVS     r2,#0x1b
0005f2  02d2              LSLS     r2,r2,#11
0005f4  4391              BICS     r1,r1,r2
0005f6  60c1              STR      r1,[r0,#0xc]
;;;924    						   | PINMODE_GET_16_TO_31(30,PIN_MODE_MASK) );
;;;925      PINMODE3 |= PINMODE_GET_16_TO_31(27,PIN_MODE_NO_PULLS)
0005f8  68c1              LDR      r1,[r0,#0xc]
0005fa  2209              MOVS     r2,#9
0005fc  0312              LSLS     r2,r2,#12
0005fe  4311              ORRS     r1,r1,r2
000600  60c1              STR      r1,[r0,#0xc]
;;;926      					  | PINMODE_GET_16_TO_31(30,PIN_MODE_NO_PULLS);
;;;927    }
000602  4770              BX       lr
;;;928    
                          ENDP

                  _Delay PROC
;;;307    */
;;;308    static void _Delay(int ms) {
000604  2100              MOVS     r1,#0
000606  b081              SUB      sp,sp,#4
;;;309      volatile int i;
;;;310    
;;;311      for (i = 0; i < (50 * ms); i++) {}  // Delay of x * 1ms
000608  9100              STR      r1,[sp,#0]
00060a  2132              MOVS     r1,#0x32
00060c  4348              MULS     r0,r1,r0
00060e  9900              LDR      r1,[sp,#0]            ;308
000610  e001              B        |L1.1558|
                  |L1.1554|
000612  1c49              ADDS     r1,r1,#1
000614  9100              STR      r1,[sp,#0]
                  |L1.1558|
000616  4288              CMP      r0,r1
000618  dcfb              BGT      |L1.1554|
;;;312    }
00061a  b001              ADD      sp,sp,#4
00061c  4770              BX       lr
;;;313    
                          ENDP

                  _LCD_SetBacklight PROC
;;;460    */
;;;461    static void _LCD_SetBacklight(unsigned char Percent) {
00061e  2164              MOVS     r1,#0x64
;;;462      PWM1MR1 = ((unsigned long)0x3000 * (unsigned long)(100 - Percent)) / (unsigned long)100;
000620  1a08              SUBS     r0,r1,r0
000622  2103              MOVS     r1,#3
000624  0309              LSLS     r1,r1,#12
000626  4348              MULS     r0,r1,r0
000628  b510              PUSH     {r4,lr}               ;461
00062a  2164              MOVS     r1,#0x64
00062c  f7fffffe          BL       __aeabi_uidivmod
000630  4917              LDR      r1,|L1.1680|
000632  61c8              STR      r0,[r1,#0x1c]
;;;463      PWM1LER = (1 << 1);
000634  4916              LDR      r1,|L1.1680|
000636  2002              MOVS     r0,#2
000638  3140              ADDS     r1,r1,#0x40
00063a  6108              STR      r0,[r1,#0x10]
;;;464    }
00063c  e693              B        |L1.870|
;;;465    
                          ENDP

                  _Align PROC
;;;651    */
;;;652    static void * _Align(void * pMem, U32 NumBytes) {
00063e  1e49              SUBS     r1,r1,#1
;;;653     U32 Addr;
;;;654     Addr = (U32)pMem;
;;;655     NumBytes -= 1;
;;;656     Addr += NumBytes;
000640  1840              ADDS     r0,r0,r1
;;;657     Addr &= ~NumBytes;
000642  4388              BICS     r0,r0,r1
;;;658     return (void*)Addr;
;;;659    }
000644  4770              BX       lr
;;;660    
                          ENDP

000646  0000              DCW      0x0000
                  |L1.1608|
                          DCD      ||.bss||
                  |L1.1612|
                          DCD      ||.data||
                  |L1.1616|
                          DCD      0xffe10000
                  |L1.1620|
                          DCD      0x1b090138
                  |L1.1624|
                          DCD      0x0201053f
                  |L1.1628|
                          DCD      0x00ef380b
                  |L1.1632|
                          DCD      0xffe10200
                  |L1.1636|
                          DCD      0xe01fc180
                  |L1.1640|
                          DCD      0x00000801
                  |L1.1644|
                          DCD      0xe002c000
                  |L1.1648|
                          DCD      0xe0028000
                  |L1.1652|
                          DCD      0xe0020000
                  |L1.1656|
                          DCD      _ExecTouch
                  |L1.1660|
                          DCD      ||.bss||+0x4b020
                  |L1.1664|
                          DCD      LCD_API_ColorConv_565
                  |L1.1668|
                          DCD      GUIDRV_Lin_OSX_16_API
                  |L1.1672|
                          DCD      0xffe0cfc0
                  |L1.1676|
                          DCD      0x50000010
                  |L1.1680|
                          DCD      0xe0018000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _aVRAM
                          %        307232
                  _TouchTimer
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  _VRAMAddr
                          DCD      0x00000000

                          AREA ||i.__ARM_common_enable_irq||, COMGROUP=__ARM_common_enable_irq, CODE, READONLY, ALIGN=2

                          ARM
                  __ARM_common_enable_irq PROC
000000  e10f0000          MRS      r0,APSR ; formerly CPSR
000004  e3c00080          BIC      r0,r0,#0x80
000008  e121f000          MSR      CPSR_c,r0
00000c  e12fff1e          BX       lr
                          ENDP


                          AREA ||i.__ARM_common_disable_irq||, COMGROUP=__ARM_common_disable_irq, CODE, READONLY, ALIGN=2

                  __ARM_common_disable_irq PROC
000000  e10f0000          MRS      r0,APSR ; formerly CPSR
000004  e3801080          ORR      r1,r0,#0x80
000008  e121f001          MSR      CPSR_c,r1
00000c  e2000080          AND      r0,r0,#0x80
000010  e12fff1e          BX       lr
                          ENDP

