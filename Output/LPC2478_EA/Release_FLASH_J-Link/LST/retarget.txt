; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--thumb --list -c --asm --interleave -o.\output\lpc2478_ea\release_flash_j-link\obj\retarget.o --asm_dir=.\Output\LPC2478_EA\Release_FLASH_J-Link\LST\ --list_dir=.\Output\LPC2478_EA\Release_FLASH_J-Link\LST\ --depend=.\output\lpc2478_ea\release_flash_j-link\obj\retarget.d --apcs=interwork -O3 -IApplication\SEGGERDEMO -IApplication\SEGGERDEMO\Src -ISetup -IInc -IConfig -IFS -IIP -IIP\IP_FS\FS_RO\Generated -IGUI -IOS -IUSB -IUSBH -I"C:\Program Files (x86)\Keil\V473\ARM\RV31\INC" -I"C:\Program Files (x86)\Keil\V473\ARM\CMSIS\Include" -I"C:\Program Files (x86)\Keil\V473\ARM\Inc\Philips" Setup\Retarget.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                  fputc PROC
;;;60     
;;;61     int fputc(int ch, FILE *f)
000000  4770              BX       lr
;;;62     {
;;;63         /* Place your implementation of fputc here     */
;;;64         /* e.g. write a character to a UART, or to the */
;;;65         /* debugger console with SWI WriteC            */
;;;66     
;;;67     #if 0  // Implement your output routine here
;;;68         char tempch = ch;
;;;69     #ifdef USE_SERIAL_PORT
;;;70         sendchar( &tempch);
;;;71     #else
;;;72         WriteC( &tempch );
;;;73     #endif
;;;74     #endif
;;;75         return ch;
;;;76     }
;;;77     
                          ENDP

                  ferror PROC
;;;78     int ferror(FILE *f)
000002  2000              MOVS     r0,#0
;;;79     {   /* Your implementation of ferror */
;;;80         return EOF;
000004  43c0              MVNS     r0,r0
;;;81     }
000006  4770              BX       lr
;;;82     
                          ENDP

                  _sys_exit PROC
                  |L1.8|
;;;83     
;;;84     void _sys_exit(int return_code)
000008  e7fe              B        |L1.8|
;;;85     {
;;;86     /*    Exit();         for debugging */
;;;87     
;;;88     label:  goto label; /* endless loop */
;;;89     }
;;;90     
                          ENDP

                  _ttywrch PROC
;;;91     
;;;92     void _ttywrch(int ch)
00000a  b508              PUSH     {r3,lr}
;;;93     {
;;;94         char tempch = ch;
00000c  4669              MOV      r1,sp
00000e  7008              STRB     r0,[r1,#0]
;;;95     #ifdef USE_SERIAL_PORT
;;;96         sendchar( &tempch );
;;;97     #else
;;;98         WriteC( &tempch );
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __2printf
;;;99     #endif
;;;100    }
000016  b001              ADD      sp,sp,#4
000018  bc08              POP      {r3}
00001a  4718              BX       r3
;;;101    
                          ENDP

                  __user_initial_stackheap PROC
;;;103    
;;;104    __value_in_regs struct __initial_stackheap __user_initial_stackheap(
00001c  b410              PUSH     {r4}
;;;105            unsigned R0, unsigned SP, unsigned R2, unsigned SL) {
;;;106        struct __initial_stackheap config;
;;;107       
;;;108        config.heap_base   = (unsigned int)&Image$$HEAP$$ZI$$Base; // placed by scatterfile   
;;;109        config.heap_limit  = (unsigned int)&Image$$HEAP$$ZI$$Limit;
;;;110        config.stack_base  = (unsigned int)&Image$$CSTACK$$ZI$$Limit;   // inherit SP from the execution environment
;;;111        config.stack_limit = (unsigned int)&Image$$CSTACK$$ZI$$Base;
;;;112    
;;;113        return config;
;;;114    }
00001e  bc10              POP      {r4}
000020  4802              LDR      r0,|L1.44|
000022  4a03              LDR      r2,|L1.48|
000024  4903              LDR      r1,|L1.52|
000026  4b04              LDR      r3,|L1.56|
000028  4770              BX       lr
;;;115    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      ||Image$$HEAP$$ZI$$Base||
                  |L1.48|
                          DCD      ||Image$$HEAP$$ZI$$Limit||
                  |L1.52|
                          DCD      ||Image$$CSTACK$$ZI$$Limit||
                  |L1.56|
                          DCD      ||Image$$CSTACK$$ZI$$Base||

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
