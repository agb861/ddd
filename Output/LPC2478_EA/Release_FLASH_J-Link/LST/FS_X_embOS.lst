L 1 "FS\FS_X_embOS.c"
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
N----------------------------------------------------------------------
NFile        : FS_X_embOS.c
NPurpose     : embOS OS Layer for the file system
N---------------------------END-OF-HEADER------------------------------
N*/
N
N/*********************************************************************
N*
N*             #include Section
N*
N**********************************************************************
N*/
N
N#include <stdio.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030076
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 27 "FS\FS_X_embOS.c" 2
N#include "FS_Int.h"
L 1 "FS\FS_Int.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : FS_Int.h
NPurpose     : Internals used accross different layers of the file system
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef _FS_INT_H_              // Avoid multiple/recursive inclusion
N#define _FS_INT_H_
N
N#include <string.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 22 "FS\FS_Int.h" 2
N#include <stdlib.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 23 "FS\FS_Int.h" 2
N#include <ctype.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\ctype.h" 1
N/* ctype.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.3 */
N/* Copyright (C) Codemist Ltd. 1988-1993.                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N/*
N * ctype.h declares several functions useful for testing and mapping
N * characters. In all cases the argument is an int, the value of which shall
N * be representable as an unsigned char or shall equal the value of the
N * macro EOF. If the argument has any other value, the behaviour is undefined.
N */
N
N#ifndef __ctype_h
N#define __ctype_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE_DEF inline
S#elif defined(__GNUC__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif 0L || (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N  #ifndef __CTYPE_DECLS
N  #define __CTYPE_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* AEABI portable ctype flag bits */
N#define _ABI_A    1       /* alphabetic        */
N#define _ABI_X    2       /* A-F, a-f and 0-9  */
N#define _ABI_P    4       /* punctuation       */
N#define _ABI_B    8       /* blank             */
N#define _ABI_S   16       /* white space       */
N#define _ABI_L   32       /* lower case letter */
N#define _ABI_U   64       /* upper case letter */
N#define _ABI_C  128       /* control chars     */
N
N/* ARM internal ctype flag bits */
N/* N.B. - keep in step with <ctype.c> */
N
N/*
N * __ARM_CT_A (alphabetic) is required because characters in some locales
N * (e.g. Japanese) can be alphabetic but neither uppercase nor
N * lowercase. Unfortunately there wasn't a bit free for this, so
N * instead we've defined __ARM_CT_A as __ARM_CT_N+__ARM_CT_X (on the grounds that this
N * was a previously unused combination). Hence some of the ctype
N * predicates below are slightly less than obvious in
N * implementation.
N */
N#define __ARM_CT_S 1            /* whitespace           */
N#define __ARM_CT_P 2            /* punctuation          */
N#define __ARM_CT_B 4            /* blank                */
N#define __ARM_CT_L 8            /* lower case letter    */
N#define __ARM_CT_U 16           /* upper case letter    */
N#define __ARM_CT_N 32           /* (decimal) digit      */
N#define __ARM_CT_C 64           /* control chars        */
N#define __ARM_CT_X 128          /* A-F and a-f          */
N#define __ARM_CT_A (__ARM_CT_N+__ARM_CT_X)    /* alphabetic           */
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S
Sextern int (isalnum)(int /*c*/);
Sextern int (isalpha)(int /*c*/);
Sextern int (isblank)(int /*c*/);
Sextern int (iscntrl)(int /*c*/);
Sextern int (isdigit)(int /*c*/);
Sextern int (isgraph)(int /*c*/);
Sextern int (islower)(int /*c*/);
Sextern int (isprint)(int /*c*/);
Sextern int (ispunct)(int /*c*/);
Sextern int (isspace)(int /*c*/);
Sextern int (isupper)(int /*c*/);
Sextern int (isxdigit)(int /*c*/);
S
S/* Mandatory character attribute arrays indexed from 0 to 256 */
Sextern unsigned char const __aeabi_ctype_table_C[257];  /* "C" locale */
Sextern unsigned char const __aeabi_ctype_table_[257];   /* default locale */
S         /* The default locale might be the C locale */
S/* Optional character attribute arrays indexed from 0 to 256.        */
S/* These do not have to be provided by every execution environment   */
S/* but, if provided, shall be provided with these names and meaning. */
Sextern unsigned char const __aeabi_ctype_table_ISO8859_1[257];
Sextern unsigned char const __aeabi_ctype_table_SJIS[257];
Sextern unsigned char const __aeabi_ctype_table_BIG5[257];
Sextern unsigned char const __aeabi_ctype_table_UTF8[257];
S#ifdef _AEABI_LC_CTYPE
S# define _AEABI_CTYPE_TABLE(_X) __aeabi_ctype_table_ ## _X
S# define _AEABI_CTYPE(_X) _AEABI_CTYPE_TABLE(_X)
S# define __aeabi_ctype_table _AEABI_CTYPE(_AEABI_LC_CTYPE)
S#else
S# define __aeabi_ctype_table __aeabi_ctype_table_
S#endif
S
S#define isspace(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_S)
S#define isalpha(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_A)
S#define isalnum(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 30) /* test for _ABI_A and _ABI_X */
S#define isprint(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 28) /* test for _ABI_A, _ABI_X, _ABI_P and _ABI_B */
S#define isupper(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_U)
S#define islower(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_L)
S#define isxdigit(x) ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_X)
S#define isgraph(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 29) /* test for _ABI_A, _ABI_X and _ABI_P */
S#define iscntrl(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_C)
S#define ispunct(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_P)
S#define isdigit(c)  (((unsigned)(c) - '0') < 10)
S
N#else /* __AEABI_PORTABILITY_LEVEL */
N
Nextern _ARMABI_PURE unsigned char **__rt_ctype_table(void);
Xextern __declspec(__nothrow) __pure unsigned char **__rt_ctype_table(void);
N
N#define __arm_ctype (*__CLIBNS __rt_ctype_table())
N
N#ifdef __cplusplus
S    inline int isalnum(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N)); }
N#else
N    #define isalnum(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N))
N    extern int (isalnum)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic or numeric */
N
N#ifdef __cplusplus
S    inline int isalpha(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X)); }
N#else
N    #define isalpha(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X))
N    extern int (isalpha)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic */
N
N#ifdef __cplusplus
S    inline int iscntrl(int __c) { return (__arm_ctype[__c] & __ARM_CT_C); }
N#else
N    #define iscntrl(c) (__arm_ctype[c] & __ARM_CT_C)
N    extern int (iscntrl)(int /*c*/);
N#endif
N    /* non-0 iff c is a control character - in the "C" locale */
N    /*       this means (c < ' ') || (c > '~')                */
N
N/* isdigit must test for the presence of _only_ __ARM_CT_N, not just __ARM_CT_N at all. */
N#ifdef __cplusplus
S    inline int isdigit(int __c) { return (__arm_ctype[__c] == __ARM_CT_N); }
N#else
N    #define isdigit(c) (__arm_ctype[c] == __ARM_CT_N)
N    extern int (isdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a decimal digit */
N
N    extern int (isblank)(int /*c*/);
N    /* non-0 iff c is ' ', '\t' or some other locale-specific, */
N    /* word-separating character (there are no others in "C"   */
N    /* locale) */
N
N#ifdef __cplusplus
S    inline int isgraph(int __c) {return(__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P));}
N#else
N    #define isgraph(c) (__arm_ctype[c]&(__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P))
N    extern int (isgraph)(int /*c*/);
N#endif
N    /* non-0 iff c is any printing character other than ' ' */
N
N#ifdef __cplusplus
S    inline int islower(int __c) { return (__arm_ctype[__c] & __ARM_CT_L); }
N#else
N    #define islower(c) (__arm_ctype[c] & __ARM_CT_L)
N    extern int (islower)(int /*c*/);
N#endif
N    /* non-0 iff c is a lower-case letter */
N
N#ifdef __cplusplus
S    inline int isprint(int __c) { return (__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B)); }
N#else
N    #define isprint(c) (__arm_ctype[c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B))
N    extern int (isprint)(int /*c*/);
N#endif
N    /* non-0 iff c is a printing character - in the "C" locale */
N    /*       this means 0x20 (space) -> 0x7E (tilde)           */
N
N#ifdef __cplusplus
S    inline int ispunct(int __c) { return (__arm_ctype[__c] & __ARM_CT_P); }
N#else
N    #define ispunct(c) (__arm_ctype[c] & __ARM_CT_P)
N    extern int (ispunct)(int /*c*/);
N#endif
N    /* non-0 iff c is a non-space, non-alpha-numeric, printing character */
N
N#ifdef __cplusplus
S    inline int isspace(int __c) { return (__arm_ctype[__c] & __ARM_CT_S); }
N#else
N    #define isspace(c) (__arm_ctype[c] & __ARM_CT_S)
N    extern int (isspace)(int /*c*/);
N#endif
N    /* non-0 iff c is a white-space char: ' ', '\f', '\n', '\r', '\t', '\v'. */
N
N#ifdef __cplusplus
S    inline int isupper(int __c) { return (__arm_ctype[__c] & __ARM_CT_U); }
N#else
N    #define isupper(c) (__arm_ctype[c] & __ARM_CT_U)
N    extern int (isupper)(int /*c*/);
N#endif
N    /* non-0 iff c is an upper-case letter */
N
N/* isxdigit must test for the presence of __ARM_CT_N or __ARM_CT_X but not both. */
N/* This helper function avoids needing to evaluate c twice. */
N
N_ARMABI_INLINE_DEF int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
X__inline int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
N#ifdef __cplusplus
S    inline int isxdigit(int __c){return __isxdigit_helper(__arm_ctype[__c]) & __ARM_CT_X;}
N#else
N    #define isxdigit(c) (__isxdigit_helper(__arm_ctype[c]) & __ARM_CT_X)
N    extern int (isxdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a digit, in 'a'..'f', or in 'A'..'F' */
N
N#endif /* __AEABI_PORTABILITY_LEVEL */
N
Nextern int tolower(int /*c*/);
N    /* if c is an upper-case letter then return the corresponding */
N    /* lower-case letter, otherwise return c.                     */
N
Nextern int toupper(int /*c*/);
N    /* if c is an lower-case letter then return the corresponding */
N    /* upper-case letter, otherwise return c.                     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __CTYPE_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __CTYPE_NO_EXPORTS
S      using ::std::isalnum;
S      using ::std::isalpha;
S      using ::std::iscntrl;
S      using ::std::isdigit;
S      using ::std::isblank;
S      using ::std::isgraph;
S      using ::std::islower;
S      using ::std::isprint;
S      using ::std::ispunct;
S      using ::std::isspace;
S      using ::std::isupper;
S      using ::std::isxdigit;
S      using ::std::tolower;
S      using ::std::toupper;
S    #endif /* __CTYPE_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of ctype.h */
N
L 24 "FS\FS_Int.h" 2
N
N#include "FS_Types.h"
L 1 "FS\FS_Types.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : FS_Int.h
NPurpose     : Internals used accross different layers of the file system
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef _FS_TYPES_H_
N#define _FS_TYPES_H_
N
N
N#include "Global.h"
L 1 "GUI\Global.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : GLOBAL.h
NPurpose : Global types etc.
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GLOBAL_H            // Guard against multiple inclusion
N#define GLOBAL_H
N
N/*********************************************************************
N*
N*       Macros
N*
N**********************************************************************
N*/
N#define U8    unsigned char
N#define U16   unsigned short
N#define U32   unsigned long
N#define I8    signed char
N#define I16   signed short
N#define I32   signed long
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 23 "FS\FS_Types.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N
N
N/*********************************************************************
N*
N*       Defines non configurable
N*
N**********************************************************************
N*/
N#define FS_FILE_ACCESS_FLAG_A (1 << 0)
N#define FS_FILE_ACCESS_FLAG_B (1 << 1)
N#define FS_FILE_ACCESS_FLAG_C (1 << 2)
N#define FS_FILE_ACCESS_FLAG_R (1 << 3)
N#define FS_FILE_ACCESS_FLAG_W (1 << 4)
N//
N// Combined access modes which are frequently used
N//
N#define FS_FILE_ACCESS_FLAGS_AW     (FS_FILE_ACCESS_FLAG_A | FS_FILE_ACCESS_FLAG_W)
N#define FS_FILE_ACCESS_FLAGS_BR     (FS_FILE_ACCESS_FLAG_B | FS_FILE_ACCESS_FLAG_R)
N#define FS_FILE_ACCESS_FLAGS_CW     (FS_FILE_ACCESS_FLAG_C | FS_FILE_ACCESS_FLAG_W)
N#define FS_FILE_ACCESS_FLAGS_RW     (FS_FILE_ACCESS_FLAG_R | FS_FILE_ACCESS_FLAG_W)
N
N#define FS_FILE_ACCESS_FLAGS_ACW    (FS_FILE_ACCESS_FLAG_C | FS_FILE_ACCESS_FLAGS_AW)
N#define FS_FILE_ACCESS_FLAGS_ARW    (FS_FILE_ACCESS_FLAG_A | FS_FILE_ACCESS_FLAGS_RW)
N#define FS_FILE_ACCESS_FLAGS_BCW    (FS_FILE_ACCESS_FLAG_B | FS_FILE_ACCESS_FLAGS_CW)
N#define FS_FILE_ACCESS_FLAGS_BRW    (FS_FILE_ACCESS_FLAG_W | FS_FILE_ACCESS_FLAGS_BR)
N#define FS_FILE_ACCESS_FLAGS_CRW    (FS_FILE_ACCESS_FLAG_C | FS_FILE_ACCESS_FLAG_R | FS_FILE_ACCESS_FLAG_W)
N
N#define FS_FILE_ACCESS_FLAGS_ABCW   (FS_FILE_ACCESS_FLAG_B | FS_FILE_ACCESS_FLAGS_ACW)
N#define FS_FILE_ACCESS_FLAGS_ACRW   (FS_FILE_ACCESS_FLAG_A | FS_FILE_ACCESS_FLAGS_CRW)
N#define FS_FILE_ACCESS_FLAGS_BCRW   (FS_FILE_ACCESS_FLAG_B | FS_FILE_ACCESS_FLAGS_CRW)
N
N#define FS_FILE_ACCESS_FLAGS_ABCRW  (FS_FILE_ACCESS_FLAGS_ACRW | FS_FILE_ACCESS_FLAG_A)
N
N//
N// Partition table definitions
N//
N#define FS__DEV_PART_0_TABLE       0x01BE /* start of first entry */
N
N//
N// Directory entry get/set macros 
N//
N#define FS_DIRENTRY_GET_ATTRIBUTES             (1 << 0)
N#define FS_DIRENTRY_GET_TIMESTAMP_CREATE       (1 << 1)
N#define FS_DIRENTRY_GET_TIMESTAMP_MODIFY       (1 << 2)
N#define FS_DIRENTRY_GET_TIMESTAMP_ACCESS       (1 << 3)
N#define FS_DIRENTRY_SET_ATTRIBUTES             (1 << 0)
N#define FS_DIRENTRY_SET_TIMESTAMP_CREATE       (1 << 1)
N#define FS_DIRENTRY_SET_TIMESTAMP_MODIFY       (1 << 2)
N#define FS_DIRENTRY_SET_TIMESTAMP_ACCESS       (1 << 3)
N//
N//  Smart buffer (SB) type defines
N//
N#define FS_SB_TYPE_DATA               FS_SECTOR_TYPE_DATA
N#define FS_SB_TYPE_MANAGEMENT         FS_SECTOR_TYPE_MAN
N#define FS_SB_TYPE_DIRECTORY          FS_SECTOR_TYPE_DIR
N
N/*********************************************************************
N*
N*       Sector type defines
N*/
N#define FS_SECTOR_TYPE_DATA    0
N#define FS_SECTOR_TYPE_DIR     1
N#define FS_SECTOR_TYPE_MAN     2
N#define FS_SECTOR_TYPE_COUNT   3   /* Number of sector types */
N
N/*********************************************************************
N*
N*       Sector type defines
N*/
N#define FS_SECTOR_TYPE_MASK_DATA    (1 << FS_SECTOR_TYPE_DATA)
N#define FS_SECTOR_TYPE_MASK_DIR     (1 << FS_SECTOR_TYPE_DIR)
N#define FS_SECTOR_TYPE_MASK_MAN     (1 << FS_SECTOR_TYPE_MAN)
N#define FS_SECTOR_TYPE_MASK_ALL     (FS_SECTOR_TYPE_MASK_DATA | FS_SECTOR_TYPE_MASK_DIR | FS_SECTOR_TYPE_MASK_MAN)
N
N/*********************************************************************
N*
N*       Data types, opaque
N*
N**********************************************************************
N*/
Ntypedef struct FS_FAT_INFO    FS_FAT_INFO;
Ntypedef struct FS_EFS_INFO    FS_EFS_INFO;
Ntypedef struct FS_SB          FS_SB;
N
N/*********************************************************************
N*
N*       Internal data types, used as opaque types for pointers
N*
N**********************************************************************
N*/
Ntypedef struct FS_CACHE_API     FS_CACHE_API;
Ntypedef struct FS_DEVICE        FS_DEVICE;
Ntypedef struct FS_DIR           FS_DIR;
Ntypedef struct FS_FILE          FS_FILE;
Ntypedef struct FS_PARTITION     FS_PARTITION;
Ntypedef struct FS_VOLUME        FS_VOLUME;
Ntypedef struct FS_DEVICE_TYPE   FS_DEVICE_TYPE;
Ntypedef struct FS_DIRENT        FS_DIRENT;
Ntypedef struct FS_DEV_INFO      FS_DEV_INFO;
N
N#if defined(__cplusplus)
X#if 0L
S}                /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#endif  /* _FS_INT_H_ */
N
N/*************************** End of file ****************************/
L 26 "FS\FS_Int.h" 2
N#include "FS.h"
L 1 "FS\FS.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : FS.h
NPurpose     : Define global functions and types to be used by an
N              application using the file system.
N
N              This file needs to be included by any module using the
N              file system.
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef _FS_H_               // Avoid recursive and multiple inclusion
N#define _FS_H_
N
N
N/*********************************************************************
N*
N*             #include Section
N*
N**********************************************************************
N*/
N
N#include "FS_ConfDefaults.h"        /* FS Configuration */
L 1 "FS\FS_ConfDefaults.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : FS_ConfDefaults.h
NPurpose : File system configuration defaults
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef _FS_CONFDEFAULT_H_
N#define _FS_CONFDEFAULT_H_
N
N#include "FS_Conf.h"
L 1 "Config\FS_Conf.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : FS_Conf.h
NPurpose     : File system configuration
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef _FS_CONF_H_
N#define _FS_CONF_H_
N
N#ifdef DEBUG
S #if (DEBUG)
S   #define FS_DEBUG_LEVEL                     5
S #endif
N#endif
N
N#define FS_OS_LOCKING                         1
N#define FS_USE_FILE_BUFFER                    1
N
N#define FS_SUPPORT_EFS                        0
N#define FS_SUPPORT_FAT                        1
N#define FS_SUPPORT_JOURNAL                    0
N#define FS_MULTI_HANDLE_SAFE                  0
N
N#ifdef __ICCARM__
S  #if __ICCARM__
S    #if ((__TID__ >> 4) & 0x0F) < 6   // For any ARM CPU core < v7, we will use optimized routines
S      #include "SEGGER.h"
S      #define FS_MEMCPY(pDest, pSrc, NumBytes) SEGGER_ARM_memcpy(pDest, pSrc, NumBytes)    // Speed optimization: Our memcpy is much faster!
S    #endif
S  #endif
N#endif
N
N#endif  /* Avoid multiple inclusion */
N
N
L 22 "FS\FS_ConfDefaults.h" 2
N#include "Global.h"
N
N
N/*********************************************************************
N*
N*       Defaults for optimizations
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       File system defaults
N*
N**********************************************************************
N*/
N#ifndef   FS_LOG_MASK_DEFAULT     
N  #define FS_LOG_MASK_DEFAULT    (1 << 0)   /* FS_MTYPE_INIT */
N#endif
N
N#ifndef   FS_MAX_PATH
N  #define FS_MAX_PATH                 260
N#endif
N
N#ifndef   FS_SUPPORT_FAT
S  #define FS_SUPPORT_FAT                1   /* Support the FAT file system if enabled */
N#endif
N
N#ifndef   FS_SUPPORT_EFS
S  #define FS_SUPPORT_EFS                0   /* Support the EFS file system if enabled */
N#endif
N
N#ifndef   FS_SUPPORT_MULTIPLE_FS
N  #define FS_SUPPORT_MULTIPLE_FS      ((FS_SUPPORT_EFS) && (FS_SUPPORT_FAT))
N#endif
N
N#ifndef   FS_SUPPORT_BURST             /* Burst support, allows read/write of multiple sectors at a time (speed opt.) */
N  #define FS_SUPPORT_BURST              1
N#endif
N
N#ifndef   FS_SUPPORT_FREE_SECTOR
N  #define FS_SUPPORT_FREE_SECTOR        1     /* Informs lower layer of unused sectors ... Makes sense only for drivers which use it */
N#endif
N
N#ifndef   FS_SUPPORT_CACHE
N  #define FS_SUPPORT_CACHE              1
N#endif
N
N#ifndef   FS_MULTI_HANDLE_SAFE
S  #define FS_MULTI_HANDLE_SAFE          0
N#endif
N
N#ifndef   FS_MAX_LEN_FULL_FILE_NAME
N  #define FS_MAX_LEN_FULL_FILE_NAME   256
N#endif
N
N#ifndef   FS_DRIVER_ALIGNMENT
N  //
N  // Added for compatibility reasons.
N  //
N  #ifdef    FS_DRIVER_ALIGMENT  
S    #define FS_DRIVER_ALIGNMENT           FS_DRIVER_ALIGMENT
N  #else
N    #define FS_DRIVER_ALIGNMENT           4
N  #endif
N#endif
N
N#ifndef   FS_DIRECTORY_DELIMITER
N  #define FS_DIRECTORY_DELIMITER     '\\'
N#endif
N
N#ifndef   FS_VERIFY_WRITE
N  #define FS_VERIFY_WRITE              0    /* Verify every write sector operation (tests the driver and hardware) */
N#endif
N
N#ifndef   FS_SUPPORT_BUSY_LED
N  #define FS_SUPPORT_BUSY_LED          1
N#endif
N
N#ifndef   FS_SUPPORT_CHECK_MEMORY
N  #define FS_SUPPORT_CHECK_MEMORY      0
N#endif
N
N#ifndef   FS_SUPPORT_JOURNAL
S  #define FS_SUPPORT_JOURNAL           0
N#endif
N
N#ifndef   FS_OPTIMIZE
N  #define FS_OPTIMIZE                  // Allow optimizations such as "__arm __ramfunc" or similar. What works best depends on target.
N#endif
N
N#ifndef   FS_SUPPORT_DEINIT
N  #define FS_SUPPORT_DEINIT            0  // Allows to have a deinitialization of the file system
N#endif
N
N#ifndef   FS_SUPPORT_EXT_MEM_MANAGER
N  #define FS_SUPPORT_EXT_MEM_MANAGER        0                // Set to 1 will use external alloc/free memory functions, these must be set with FS_SetMemFunc()
N#endif 
N
N#ifndef FS_JOURNAL_FILE_NAME
N  #define FS_JOURNAL_FILE_NAME "Journal.dat"
N#endif
N
N#ifndef   FS_USE_FILE_BUFFER
S  #define FS_USE_FILE_BUFFER                 0
N#endif
N
N/*********************************************************************
N*
N*       FAT File System Layer defines
N*
N*  For each media in your system using FAT, the file system reserves
N*  memory to keep required information of the boot sector of that media.
N*  FS_MAXDEV is the number of device drivers in your system used
N*  with FAT, FS_FAT_MAXUNIT is the maximum number of logical units
N*  supported by one of the activated drivers.
N*/
N
N#ifndef   FS_FAT_SUPPORT_FAT32                         // 0  disables FAT32 support
N  #define FS_FAT_SUPPORT_FAT32      1
N#endif
N
N#ifndef   FS_FAT_SUPPORT_UTF8
N  #define FS_FAT_SUPPORT_UTF8       0                  // Use UTF-8 encoding to support unicode characters
N#endif
N
N#ifndef   FS_UNICODE_UPPERCASE_EXT
N  #define FS_UNICODE_UPPERCASE_EXT  {0x0000, 0x0000}   // allow to extend the static unicode lower to upper case table
N#endif
N
N#ifndef   FS_MAINTAIN_FAT_COPY
N  #define FS_MAINTAIN_FAT_COPY      0                  // Shall the 2nd FAT (copy) be maintained
N#endif
N
N#ifndef   FS_FAT_USE_FSINFO_SECTOR                     // Use and update FSInfo sector on FAT32 media. For FAT12/FAT116 there is no FSInfo sector
N  #define FS_FAT_USE_FSINFO_SECTOR  1
N#endif
N
N#ifndef   FS_FAT_OPTIMIZE_DELETE                       // Accelerate delete of large files
N  #define FS_FAT_OPTIMIZE_DELETE    1
N#endif
N
N#ifndef   FS_FAT_FWRITE_UPDATE_DIR                     // On size change, shall the directory entry of the file be updated
N  #define FS_FAT_FWRITE_UPDATE_DIR  1
N#endif
N
N
N/*********************************************************************
N*
N*       EFS File System Layer defines
N*
N*/
N#ifndef   FS_EFS_OPTIMIZE_DELETE                       // Accelerate delete of large files
N  #define FS_EFS_OPTIMIZE_DELETE    1
N#endif
N
N#ifndef   FS_EFS_CASE_SENSITIVE
N  #define FS_EFS_CASE_SENSITIVE     0                  // Should the file/directory names be case sensitively compared
N#endif
N
N#ifndef   FS_EFS_FWRITE_UPDATE_DIR
N  #define FS_EFS_FWRITE_UPDATE_DIR  1                  // On size change, shall the directory entry of the file be updated
N#endif
N
N/*********************************************************************
N*
N*       CLib
N*/
N#ifndef   FS_NO_CLIB
N  #define FS_NO_CLIB  0
N#endif
N
N/*********************************************************************
N*
N*       OS Layer
N*
N**********************************************************************
N*/
N#ifdef FS_OS_LOCKING
N  #if   FS_OS_LOCKING == 0
X  #if   1 == 0
S    #define FS_OS               0
S    #define FS_OS_LOCK_PER_DRIVER 0
N  #elif FS_OS_LOCKING == 1
X  #elif 1 == 1
N    #define FS_OS               1
N    #define FS_OS_LOCK_PER_DRIVER 0
N  #elif FS_OS_LOCKING == 2
S    #define FS_OS               1
S    #define FS_OS_LOCK_PER_DRIVER 1
S  #else
S  #error FS_OS_LOCKING has illegal value
N  #endif
N#endif
N
N#ifndef   FS_OS
S  #define FS_OS                 0
N#endif
N
N#ifndef   FS_OS_LOCK_PER_DRIVER
S  #define FS_OS_LOCK_PER_DRIVER 0        /* 0 = means a single lock for all files, 1 means one lock per file */
N#endif
N
N/*********************************************************************
N*
N*       Device driver defaults
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       RAMDISK defines
N*
N*/
N#ifndef   FS_RAMDISK_SECTOR_SIZE
N  #define FS_RAMDISK_SECTOR_SIZE   512
N#endif
N
N/*********************************************************************
N*
N*       NOR flash driver defines
N*/
N#ifndef FS_NOR_WEARLEVELING
N  #define FS_NOR_WEARLEVELING         1
N#endif
N
N#ifndef   FS_NOR_SECTOR_SIZE
N  #define FS_NOR_SECTOR_SIZE         512
N#endif
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef FS_USE_PARA
N  #if defined(NC30) || defined(NC308)
X  #if 0L || 0L
S    #define FS_USE_PARA(para)
N  #else
N    #define FS_USE_PARA(para) para=para;
N  #endif
N#endif
N
N/*********************************************************************
N*
N*       Number of
N*/
N#ifndef   FS_NUM_VOLUMES
N  #define FS_NUM_VOLUMES 4
N#endif
N
N#ifndef   FS_NUM_FILE_HANDLES
N  #define FS_NUM_FILE_HANDLES    4 + (FS_SUPPORT_EFS * 2)
N#endif
N
N#ifndef   FS_NUM_FILE_OBJECTS
N  #define FS_NUM_FILE_OBJECTS    FS_NUM_FILE_HANDLES
N#endif
N
N#ifndef   FS_NUM_DIR_HANDLES
N  #define FS_NUM_DIR_HANDLES     1
N#endif
N
N#ifndef   FS_NUM_MEMBLOCKS_PER_OPERATION
N  //
N  // FAT file system needs at least 2 sector buffers for a FS operation
N  //
N  #if (FS_SUPPORT_EFS == 0)
X  #if (0 == 0)
N    #define FS_NUM_FS_MEMBLOCKS_PER_OPERATION  2
N  //
N  // EFS needs at least 2 sector buffers for a FS operation
N  //
N  #elif (FS_SUPPORT_EFS == 1)
S    #define FS_NUM_FS_MEMBLOCKS_PER_OPERATION  3
N  #endif
N
N  //
N  // Check for journal support
N  //
N  #if FS_SUPPORT_JOURNAL 
X  #if 0 
S    #define FS_NUM_MEMBLOCKS_PER_OPERATION      FS_NUM_FS_MEMBLOCKS_PER_OPERATION + 1
N  #else
N    #define FS_NUM_MEMBLOCKS_PER_OPERATION      FS_NUM_FS_MEMBLOCKS_PER_OPERATION
N  #endif
N
N#endif
N
N
N/********************************************************************/
N
N#endif  /* Avoid multiple inclusion */
N
N/****** End of file *************************************************/
L 34 "FS\FS.h" 2
N#include "FS_Types.h"
N#include "FS_Storage.h"
L 1 "FS\FS_Storage.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : FS_Storage.h
NPurpose     : Define global functions and types to be used by an
N              application using the storage API.
N
N              This file needs to be included by any module using the
N              storage API.
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef _FS_STORAGE_H_               // Avoid recursive and multiple inclusion
N#define _FS_STORAGE_H_
N
N/*********************************************************************
N*
N*             #include Section
N*
N**********************************************************************
N*/
N
N#include "FS_ConfDefaults.h"        /* FS Configuration */
N#include "FS_Types.h"
N#include "FS_Dev.h"
L 1 "FS\FS_Dev.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : FS_Dev.h
NPurpose     : Define structures for Device Drivers
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef _FS_DEV_H_              // Avoid recursive and multiple inclusion
N#define _FS_DEV_H_
N
N// File is obsolete. Do not use any more, Use "FS_Int.h" instead.
N
N#endif                           // Avoid recursive and multiple inclusion
N
N/*************************** End of file ****************************/
L 35 "FS\FS_Storage.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N
N#ifdef FS_STORAGE_C
S  #define EXTERN
N#else
N  #define EXTERN extern
N#endif
N
N
N/*********************************************************************
N*
N*             #define constants
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       Media states
N*/
N#define FS_MEDIA_NOT_PRESENT        0
N#define FS_MEDIA_IS_PRESENT         1
N#define FS_MEDIA_STATE_UNKNOWN      2
N
N
N#define FS_OPERATION_READ           0
N#define FS_OPERATION_WRITE          1
N
N/*********************************************************************
N*
N*       Data structures
N*/
Nstruct FS_DEV_INFO {
N  U16 NumHeads;          /* Relevant only for mechanical drives   */
X  unsigned short NumHeads;           
N  U16 SectorsPerTrack;   /* Relevant only for mechanical drives   */
X  unsigned short SectorsPerTrack;    
N  U32 NumSectors;        /* Total number of sectors on the medium */
X  unsigned long NumSectors;         
N  U16 BytesPerSector;    /* Number of bytes per sector            */
X  unsigned short BytesPerSector;     
N};
N
N
Ntypedef void (FS_ONDEVICEACTIVITYHOOK)(FS_DEVICE * pDevice, unsigned Operation, U32 StartSector, U32 NumSectors, int Sectortype);
Xtypedef void (FS_ONDEVICEACTIVITYHOOK)(FS_DEVICE * pDevice, unsigned Operation, unsigned long StartSector, unsigned long NumSectors, int Sectortype);
N
N
N
N
N/*********************************************************************
N*
N*       Global function prototypes
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       Volume related functions
N*/
Nint              FS_IsLLFormatted     (const char * sVolume);
Nint              FS_FormatLLIfRequired(const char * sVolume);
Nvoid             FS_UnmountForced     (const char * sVolume);
Nint              FS_GetVolumeStatus   (const char * sVolume);
NFS_VOLUME *      FS_FindVolume        (const char * sVolume);
N
N/*********************************************************************
N*
N*       File system control functions
N*/
N#define FS_InitStorage()                                    FS_STORAGE_Init()
N#define FS_ReadSector(sVolume, pData, SectorIndex)          FS_STORAGE_ReadSector(sVolume,  pData, SectorIndex)
N#define FS_WriteSector(sVolume, pData, SectorIndex)         FS_STORAGE_WriteSector(sVolume, pData, SectorIndex)
N#define FS_UnmountLL(sVolume)                               FS_STORAGE_Unmount(sVolume)
N#define FS_CleanVolume(sVolume)                             FS_STORAGE_Sync(sVolume)
N#define FS_GetDeviceInfo(sVolume, pDevInfo)                 FS_STORAGE_GetDeviceInfo(sVolume, pDevInfo)
N
Nint      FS_STORAGE_GetDeviceInfo(const char * sVolume, FS_DEV_INFO * pDevInfo);
Nunsigned FS_STORAGE_Init         (void);
Nint      FS_STORAGE_ReadSector   (const char * sVolume,       void * pData, U32 SectorIndex);
Xint      FS_STORAGE_ReadSector   (const char * sVolume,       void * pData, unsigned long SectorIndex);
Nint      FS_STORAGE_WriteSector  (const char * sVolume, const void * pData, U32 SectorIndex);
Xint      FS_STORAGE_WriteSector  (const char * sVolume, const void * pData, unsigned long SectorIndex);
Nint      FS_STORAGE_ReadSectors  (const char * sVolume,       void * pData, U32 FirstSector, U32 NumSectors);
Xint      FS_STORAGE_ReadSectors  (const char * sVolume,       void * pData, unsigned long FirstSector, unsigned long NumSectors);
Nvoid     FS_STORAGE_Sync         (const char * sVolume);
Nvoid     FS_STORAGE_Unmount      (const char * sVolume);
Nvoid     FS_STORAGE_UnmountForced(const char * sVolume);
Nint      FS_STORAGE_WriteSectors (const char * sVolume, const void * pData, U32 FirstSector, U32 NumSectors);
Xint      FS_STORAGE_WriteSectors (const char * sVolume, const void * pData, unsigned long FirstSector, unsigned long NumSectors);
Nvoid     FS_SetOnDeviceActivityHook(const char * sVolume, FS_ONDEVICEACTIVITYHOOK * pfOnDeviceActivityHook);
N
N
N/*********************************************************************
N*
N*       Storage statistics
N*/
Ntypedef struct {
N  U32 ReadOperationCnt;       // Number of "Read sector operation" calls
X  unsigned long ReadOperationCnt;       
N  U32 ReadSectorCnt;          // Number of sectors read (before cache). Note that this can be (and typically is) higher than the number of "Read sector operation" counts, since one operation can request multiple sectors (in a burst)
X  unsigned long ReadSectorCnt;          
N  U32 ReadSectorCachedCnt;    // Number of sectors read from cache.
X  unsigned long ReadSectorCachedCnt;    
N  U32 WriteOperationCnt;      // Number of "Write sector operation" calls
X  unsigned long WriteOperationCnt;      
N  U32 WriteSectorCnt;         // Number of sectors written (before cache). Note that this can be (and typically is) higher than the number of "Write sector operation" counts, since one operation can write multiple sectors (in a burst)
X  unsigned long WriteSectorCnt;         
N} FS_STORAGE_COUNTERS;
N
Nvoid FS_STORAGE_GetCounters  (FS_STORAGE_COUNTERS * pStat);
Nvoid FS_STORAGE_ResetCounters(void);
N
N#if FS_SUPPORT_DEINIT
X#if 0
Svoid     FS_STORAGE_DeInit(void);
N#endif
N
NEXTERN FS_STORAGE_COUNTERS FS_STORAGE_Counters;
Xextern FS_STORAGE_COUNTERS FS_STORAGE_Counters;
N
N
N
N#if defined(__cplusplus)
X#if 0L
S  }              /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#endif                        // Avoid recursive and multiple inclusion
N
N/*************************** End of file ****************************/
L 36 "FS\FS.h" 2
N#include "FS_Dev.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*             #define constants
N*
N**********************************************************************
N*/
N
N/* File system version */
N#define FS_VERSION                32001UL
N
N
N#define FS_ERROR_ALLOC                  (1)
N#define FS_ERROR_NOMEMORY               (2)
N#define FS_ERROR_ILLEGAL_FORMAT_STRING  (3)
N#define FS_ERROR_UNKNOWN_DEVICE         (4)
N
N/* Global error codes */
N#define FS_ERR_OK                 0
N#define FS_ERR_EOF                -1
N#define FS_ERR_DISKFULL           -2
N#define FS_ERR_INVALIDPAR         -3
N#define FS_ERR_CMDNOTSUPPORTED    -4
N#define FS_ERR_WRITEONLY          -5
N#define FS_ERR_READONLY           -6
N#define FS_ERR_READERROR          -7
N#define FS_ERR_WRITEERROR         -8
N
N/* Global constants*/
N/* File Positions */
N#define FS_SEEK_CUR               1
N#define FS_SEEK_END               2
N#define FS_SEEK_SET               0
N
N#define FS_FILE_CURRENT           FS_SEEK_CUR
N#define FS_FILE_END               FS_SEEK_END
N#define FS_FILE_BEGIN             FS_SEEK_SET
N
N/*********************************************************************
N*
N*       I/O commands for driver
N*/
N#define FS_CMD_REQUIRES_FORMAT        1003
N#define FS_CMD_GET_DEVINFO            1004
N#define FS_CMD_FORMAT_LOW_LEVEL       1005            /* Used internally by FS_FormatLow() to command the driver to perform low-level format */
N#define FS_CMD_FREE_SECTORS           1006            /* Used internally: Allows the FS layer to inform driver about free sectors */
N#define FS_CMD_SET_DELAY              1007            /* Used in the simulation to simulate a slow device with RAM driver */
N
N#define FS_CMD_UNMOUNT                1008            /* Used internally by FS_STORAGE_Unmount() to inform the driver. Driver invalidates caches and all other information about medium. */
N#define FS_CMD_UNMOUNT_FORCED         1009            /* Used internally by FS_STORAGE_UnmountForced() to inform the driver about an unforced remove of the device. */
N                                                      /* Driver invalidates caches and all other information about medium. */
N#define FS_CMD_SYNC                   1010            /* Tells the driver to clean caches. Typically, all dirty sectors are written */
N#define FS_CMD_UNMOUNT_VOLUME         FS_CMD_UNMOUNT  // Obsolete: FS_CMD_UNMOUNT shall be used instead of FS_CMD_UNMOUNT_VOLUME.
N
N#define FS_CMD_DEINIT                 1011
N
N/*********************************************************************
N*
N*       CACHE Commands (internal)
N*/
N#define FS_CMD_CACHE_SET_MODE     6000L
N#define FS_CMD_CACHE_CLEAN        6001L   /* Write out all dirty sectors */
N#define FS_CMD_CACHE_SET_QUOTA    6002L
N#define FS_CMD_CACHE_FREE_SECTORS 6003L
N#define FS_CMD_CACHE_INVALIDATE   6004L   /* Invalidate all sectors in cache */
N
N/*********************************************************************
N*
N*       Directory entry attribute definitions
N*/
N#define FS_ATTR_READ_ONLY    0x01
N#define FS_ATTR_HIDDEN       0x02
N#define FS_ATTR_SYSTEM       0x04
N#define FS_ATTR_ARCHIVE      0x20
N#define FS_ATTR_DIRECTORY    0x10
N
N
N/*********************************************************************
N*
N*       Directory entry attribute definitions
N*/
N#define FS_FILETIME_CREATE     0
N#define FS_FILETIME_ACCESS     1
N#define FS_FILETIME_MODIFY     2
N
N/*********************************************************************
N*
N*       Volume mount flags
N*/
N#define FS_MOUNT_R                  1
N#define FS_MOUNT_RW                 3
N
N/*********************************************************************
N*
N*       File system selection
N*/
N#define FS_FAT                  0
N#define FS_EFS                  1
N
N/*********************************************************************
N*
N*       CheckDisk error codes
N*/
Nenum {
N  FS_ERRCODE_0FILE = 0x10,
N  FS_ERRCODE_SHORTEN_CLUSTER,
N  FS_ERRCODE_CROSSLINKED_CLUSTER,
N  FS_ERRCODE_FEW_CLUSTER,
N  FS_ERRCODE_CLUSTER_UNUSED,
N  FS_ERRCODE_CLUSTER_NOT_EOC,
N  FS_ERRCODE_INVALID_CLUSTER,
N  FS_ERRCODE_INVALID_DIRECTORY_ENTRY
N};
N
N/*********************************************************************
N*
N*       FS_MTYPE
N*
N*  Ids to distinguish different message types
N*/
N#define FS_MTYPE_INIT       (1 << 0)
N#define FS_MTYPE_API        (1 << 1)
N#define FS_MTYPE_FS         (1 << 2)
N#define FS_MTYPE_STORAGE    (1 << 3)
N#define FS_MTYPE_JOURNAL    (1 << 4)
N#define FS_MTYPE_CACHE      (1 << 5)
N#define FS_MTYPE_DRIVER     (1 << 6)
N#define FS_MTYPE_OS         (1 << 7)
N#define FS_MTYPE_MEM        (1 << 8)
N
N/*********************************************************************
N*
N*       Global data types
N*
N**********************************************************************
N*/
N
Ntypedef int  FS_QUERY_F_TYPE(int ErrCode, ...);
Ntypedef void FS_BUSY_LED_CALLBACK(U8 OnOff);
Xtypedef void FS_BUSY_LED_CALLBACK(unsigned char OnOff);
Ntypedef int  FS_MEMORY_IS_ACCESSIBLE_CALLBACK(void * p, U32 NumBytes);
Xtypedef int  FS_MEMORY_IS_ACCESSIBLE_CALLBACK(void * p, unsigned long NumBytes);
N
Nstruct FS_DIRENT {
N  char  DirName[FS_MAX_PATH];
X  char  DirName[260];
N  U8    Attributes;
X  unsigned char    Attributes;
N  U32   Size;
X  unsigned long   Size;
N  U32   TimeStamp;
X  unsigned long   TimeStamp;
N};
N
Ntypedef struct {
N  U32 Cluster;                    /* Cluster of current sector */
X  unsigned long Cluster;                     
N  U32 FirstCluster;
X  unsigned long FirstCluster;
N  U32 DirEntryIndex;              /* Directory entry index (first directory entry has index 0 */
X  unsigned long DirEntryIndex;               
N  U32 ClusterIndex;
X  unsigned long ClusterIndex;
N} FS_DIR_POS;
N
Ntypedef struct {
N  FS_DIR_POS  DirPos;             /* current position in file     */
N  U16         DirEntryIndex;
X  unsigned short         DirEntryIndex;
N  U32         FirstCluster;
X  unsigned long         FirstCluster;
N  FS_VOLUME * pVolume;
N  I16         error;              /* error code                   */
X  signed short         error;               
N  U8          InUse;              /* handle in use mark           */
X  unsigned char          InUse;               
N} FS__DIR;
N
Ntypedef struct {
N  U8     Attributes;
X  unsigned char     Attributes;
N  U32    CreationTime;
X  unsigned long    CreationTime;
N  U32    LastAccessTime;
X  unsigned long    LastAccessTime;
N  U32    LastWriteTime;
X  unsigned long    LastWriteTime;
N  U32    FileSize;
X  unsigned long    FileSize;
N  char * sFileName;
N  int    SizeofFileName;
N} FS_DIRENTRY_INFO;
N
Ntypedef struct {
N  U8     Attributes;
X  unsigned char     Attributes;
N  U32    CreationTime;
X  unsigned long    CreationTime;
N  U32    LastAccessTime;
X  unsigned long    LastAccessTime;
N  U32    LastWriteTime;
X  unsigned long    LastWriteTime;
N  U32    FileSize;
X  unsigned long    FileSize;
N  char * sFileName;
N  // Private elements. Not be used by the application
N  int SizeofFileName;
N  FS__DIR Dir;
N} FS_FIND_DATA;
N
Ntypedef struct {
N  U32 NumTotalClusters;
X  unsigned long NumTotalClusters;
N  U32 NumFreeClusters;
X  unsigned long NumFreeClusters;
N  U16 SectorsPerCluster;
X  unsigned short SectorsPerCluster;
N  U16 BytesPerSector;
X  unsigned short BytesPerSector;
N} FS_DISK_INFO;
N
N typedef struct {
N  U16        SectorsPerCluster;
X  unsigned short        SectorsPerCluster;
N  U16        NumRootDirEntries;    /* Proposed, actual value depends on FATType */
X  unsigned short        NumRootDirEntries;     
N  FS_DEV_INFO * pDevInfo;
N} FS_FORMAT_INFO;
N
Ntypedef struct {
N  U16           SectorsPerCluster;
X  unsigned short           SectorsPerCluster;
N  U16           NumRootDirEntries;    /* Proposed, actual value depends on FATType */
X  unsigned short           NumRootDirEntries;     
N  U16           NumReservedSectors;
X  unsigned short           NumReservedSectors;
N  U8            UpdatePartition;
X  unsigned char            UpdatePartition;
N  FS_DEV_INFO * pDevInfo;
N} FS_FORMAT_INFO_EX;
N
Ntypedef struct {
N  U16 Year;
X  unsigned short Year;
N  U16 Month;
X  unsigned short Month;
N  U16 Day;
X  unsigned short Day;
N  U16 Hour;
X  unsigned short Hour;
N  U16 Minute;
X  unsigned short Minute;
N  U16 Second;
X  unsigned short Second;
N} FS_FILETIME;
N
N/*********************************************************************
N*
N*             Non blocking (backgrounded) file I/O functions
N*/
N/* Information for background data */
Ntypedef struct FS_BG_DATA {
N  struct FS_BG_DATA * pNext;
N  U32                 NumBytes;
X  unsigned long                 NumBytes;
N  U32                 NumBytesRem;         /* Remaining bytes to transfer */
X  unsigned long                 NumBytesRem;          
N  void              * pData;
N  FS_FILE           * pFile;
N  U8                  Operation;
X  unsigned char                  Operation;
N  void (*pfOnCompletion) (void * p);   /* Optional completion routine */
N  void              * pCompletionData;     /* Optional data for completion routine */
N  char                IsCompleted;
N} FS_BG_DATA;
N
Nvoid FS_Daemon(void);
Nvoid FS_FReadNonBlock (void       * pData,
N                       U32          NumBytes,
X                       unsigned long          NumBytes,
N                       FS_FILE    * pFile,
N                       FS_BG_DATA * pBGData,                    /* User supplied management block */
N                       void (*pfOnCompletion) (void * p),   /* Optional completion routine */
N                       void * pCompletionData                   /* Optional data for completion routine */
N                      );
Nvoid FS_FWriteNonBlock(const void * pData,
N                       U32          NumBytes,
X                       unsigned long          NumBytes,
N                       FS_FILE    * pFile,
N                       FS_BG_DATA * pBGData,                    /* User supplied management block */
N                       void (*pfOnCompletion) (void * p),   /* Optional completion routine */
N                       void * pCompletionData                   /* Optional data for completion routine */
N                       );
Nchar FS_IsCompleted(FS_BG_DATA * pBGData);
N
N/*********************************************************************
N*
N*       Global function prototypes
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       "Standard" file I/O functions
N*/
NFS_FILE *        FS_FOpen (const char * pFileName, const char * pMode);
Nint              FS_FClose(FS_FILE    * pFile);
NU32              FS_FRead (      void * pData, U32 Size, U32 N, FS_FILE * pFile);
Xunsigned long              FS_FRead (      void * pData, unsigned long Size, unsigned long N, FS_FILE * pFile);
NU32              FS_FWrite(const void * pData, U32 Size, U32 N, FS_FILE * pFile);
Xunsigned long              FS_FWrite(const void * pData, unsigned long Size, unsigned long N, FS_FILE * pFile);
N
N/*********************************************************************
N*
N*       Non-standard file I/O functions
N*/
NU32           FS_Read (FS_FILE * pFile,       void * pData, U32 NumBytes);
Xunsigned long           FS_Read (FS_FILE * pFile,       void * pData, unsigned long NumBytes);
NU32           FS_Write(FS_FILE * pFile, const void * pData, U32 NumBytes);
Xunsigned long           FS_Write(FS_FILE * pFile, const void * pData, unsigned long NumBytes);
N
N/*********************************************************************
N*
N*       File pointer handling
N*/
Nint              FS_FSeek       (FS_FILE * pFile, I32 Offset,         int Origin);
Xint              FS_FSeek       (FS_FILE * pFile, signed long Offset,         int Origin);
Nint              FS_SetEndOfFile(FS_FILE * pFile);
NI32              FS_FTell       (FS_FILE * pFile);
Xsigned long              FS_FTell       (FS_FILE * pFile);
N
N#define FS_GetFilePos(pFile)                                FS_FTell(pFile)
N#define FS_SetFilePos(pFile, DistanceToMove, MoveMethod)    FS_FSeek(pFile, DistanceToMove, MoveMethod)
N
N/*********************************************************************
N*
N*       I/O error handling
N*/
Nint              FS_FEof        (FS_FILE * pFile);
NI16              FS_FError      (FS_FILE * pFile);
Xsigned short              FS_FError      (FS_FILE * pFile);
Nvoid             FS_ClearErr    (FS_FILE * pFile);
Nconst char *     FS_ErrorNo2Text(int       ErrCode);
N
N/*********************************************************************
N*
N*       File functions
N*/
Nint              FS_CopyFile   (const char * sSource,       const char * sDest);
NU32              FS_GetFileSize(FS_FILE    * pFile);
Xunsigned long              FS_GetFileSize(FS_FILE    * pFile);
Nint              FS_Move       (const char * sExistingName, const char * sNewName);
Nint              FS_Remove     (const char * pFileName);
Nint              FS_Rename     (const char * sOldName,      const char * sNewName);
Nint              FS_Truncate   (FS_FILE    * pFile,         U32          NewSize);
Xint              FS_Truncate   (FS_FILE    * pFile,         unsigned long          NewSize);
Nint              FS_Verify     (FS_FILE    * pFile,         const void * pData, U32 NumBytes);
Xint              FS_Verify     (FS_FILE    * pFile,         const void * pData, unsigned long NumBytes);
N
N/*********************************************************************
N*
N*       IOCTL
N*/
Nint              FS_IoCtl(const char *pDevName, I32 Cmd, I32 Aux, void *pBuffer);
Xint              FS_IoCtl(const char *pDevName, signed long Cmd, signed long Aux, void *pBuffer);
N
N/*********************************************************************
N*
N*       Volume related functions
N*/
Nint              FS_GetVolumeName       (int Index, char * pBuffer, int MaxSize);
NU32              FS_GetVolumeSize       (const char * sVolume);
Xunsigned long              FS_GetVolumeSize       (const char * sVolume);
NU32              FS_GetVolumeSizeKB     (const char * sVolume);
Xunsigned long              FS_GetVolumeSizeKB     (const char * sVolume);
NU32              FS_GetVolumeFreeSpace  (const char * sVolume);
Xunsigned long              FS_GetVolumeFreeSpace  (const char * sVolume);
NU32              FS_GetVolumeFreeSpaceKB(const char * sVolume);
Xunsigned long              FS_GetVolumeFreeSpaceKB(const char * sVolume);
Nint              FS_GetNumVolumes       (void);
NFS_VOLUME *      FS_AddDevice           (const FS_DEVICE_TYPE * pDevType);
Nvoid             FS_Unmount             (const char * sVolume);
Nint              FS_Mount               (const char * sVolName);
Nint              FS_MountEx             (const char * sVolume, U8 MountType);
Xint              FS_MountEx             (const char * sVolume, unsigned char MountType);
Nint              FS_GetVolumeInfo       (const char * sVolume, FS_DISK_INFO * pInfo);
Nint              FS_IsVolumeMounted     (const char * sVolumeName);
Nint              FS_GetVolumeLabel      (const char * sVolume, char * pVolumeLabel, unsigned VolumeLabelSize);
Nint              FS_SetVolumeLabel      (const char * sVolume, const char * pVolumeLabel);
Nvoid             FS_CleanVolume         (const char * sVolume);
Xvoid             FS_STORAGE_Sync(const char * sVolume);
Nint              FS_IsLLFormatted       (const char * sVolume);
Nint              FS_IsHLFormatted       (const char * sVolume);
Nint              FS_FormatLLIfRequired  (const char * sVolume);
Nvoid             FS_UnmountForced       (const char * sVolume);
Nvoid             FS_SetAutoMount        (const char * sVolume, U8 MountType);
Xvoid             FS_SetAutoMount        (const char * sVolume, unsigned char MountType);
Nvoid             FS_UnmountLL           (const char * sVolume);
Xvoid             FS_STORAGE_Unmount(const char * sVolume);
Nint              FS_GetVolumeStatus     (const char * sVolume);
NFS_VOLUME *      FS_FindVolume          (const char * sVolume);
Nvoid             FS_RemoveDevice        (const char * sVolume);
Nint              FS_Sync                (const char * sVolume);
N
N
N/*********************************************************************
N*
N*       Journaling / transaction safety
N*/
Nvoid FS_JOURNAL_Begin  (const char *sVolume);
Nvoid FS_JOURNAL_End    (const char *sVolume);
Nint  FS_JOURNAL_Create (const char * sVolume, U32 NumBytes);
Xint  FS_JOURNAL_Create (const char * sVolume, unsigned long NumBytes);
N
N
N#define FS_CreateJournal(sVolume, NumBytes)    FS_JOURNAL_Create(sVolume, NumBytes)
N#define FS_BeginTransaction(sVolume)           FS_JOURNAL_Begin(sVolume)
N#define FS_EndTransaction(sVolume)             FS_JOURNAL_End(sVolume)
N
N/*********************************************************************
N*
N*       FS_Attrib
N*/
Nint              FS_SetFileAttributes(const char * pName, U8 Attributes);
Xint              FS_SetFileAttributes(const char * pName, unsigned char Attributes);
NU8               FS_GetFileAttributes(const char * pName);
Xunsigned char               FS_GetFileAttributes(const char * pName);
N
N/*********************************************************************
N*
N*       FS_Time
N*/
Nvoid             FS_FileTimeToTimeStamp(const FS_FILETIME * pFileTime, U32 *         pTimeStamp);
Xvoid             FS_FileTimeToTimeStamp(const FS_FILETIME * pFileTime, unsigned long *         pTimeStamp);
Nint              FS_GetFileTime        (const char *        pName,     U32 *         pTimeStamp);
Xint              FS_GetFileTime        (const char *        pName,     unsigned long *         pTimeStamp);
Nint              FS_GetFileTimeEx      (const char *        pName,     U32 *         pTimeStamp, int Index);
Xint              FS_GetFileTimeEx      (const char *        pName,     unsigned long *         pTimeStamp, int Index);
Nint              FS_SetFileTime        (const char *        pName,     U32            TimeStamp);
Xint              FS_SetFileTime        (const char *        pName,     unsigned long            TimeStamp);
Nint              FS_SetFileTimeEx      (const char *        pName,     U32            TimeStamp, int Index);
Xint              FS_SetFileTimeEx      (const char *        pName,     unsigned long            TimeStamp, int Index);
Nvoid             FS_TimeStampToFileTime(U32                 TimeStamp, FS_FILETIME * pFileTime);
Xvoid             FS_TimeStampToFileTime(unsigned long                 TimeStamp, FS_FILETIME * pFileTime);
N
N
N/*********************************************************************
N*
N*       FS_GetNumFilesOpen
N*/
Nint      FS_GetNumFilesOpen(void);
N
N
N/*********************************************************************
N*
N*       File system directory functions
N*/
Nint  FS_CreateDir      (const char * sDirPath);
Nint  FS_MkDir          (const char * pDirName);
Nint  FS_RmDir          (const char * pDirName);
Nchar FS_FindFirstFile  (FS_FIND_DATA * pfd, const char * sPath, char * sFilename, int sizeofFilename);
Nchar FS_FindNextFile   (FS_FIND_DATA * pfd);
Nvoid FS_FindClose      (FS_FIND_DATA * pfd);
NU32  FS_FAT_GrowRootDir(const char * sVolume, U32 NumAddEntries);
Xunsigned long  FS_FAT_GrowRootDir(const char * sVolume, unsigned long NumAddEntries);
N
N
N
N/*********************************************************************
N*
N*       Olsolete directory functions
N*/
N
Nvoid     FS_DirEnt2Attr   (FS_DIRENT  * pDirEnt, U8   * pAttr);
Xvoid     FS_DirEnt2Attr   (FS_DIRENT  * pDirEnt, unsigned char   * pAttr);
Nvoid     FS_DirEnt2Name   (FS_DIRENT  * pDirEnt, char * pBuffer);
NU32      FS_DirEnt2Size   (FS_DIRENT  * pDirEnt);
Xunsigned long      FS_DirEnt2Size   (FS_DIRENT  * pDirEnt);
NU32      FS_DirEnt2Time   (FS_DIRENT  * pDirEnt);
Xunsigned long      FS_DirEnt2Time   (FS_DIRENT  * pDirEnt);
NU32      FS_GetNumFiles   (FS_DIR     * pDir);
Xunsigned long      FS_GetNumFiles   (FS_DIR     * pDir);
N
NFS_DIR    * FS_OpenDir    (const char * pDirName);
Nint         FS_CloseDir   (FS_DIR     * pDir);
NFS_DIRENT * FS_ReadDir    (FS_DIR     * pDir);
Nvoid        FS_RewindDir  (FS_DIR     * pDir);
N
N/*********************************************************************
N*
N*       File system standard application
N*/
Nvoid FSTask(void);
N
N/*********************************************************************
N*
N*       File system control functions
N*/
Nvoid     FS_Init          (void);
N#if FS_SUPPORT_DEINIT
X#if 0
Svoid     FS_DeInit        (void);
N#endif
N
N/*********************************************************************
N*
N*       Formatting
N*/
Nint              FS_FormatLLIfRequired(const char * sVolumeName);
Nint              FS_FormatLow         (const char * sVolumeName);
Nint              FS_Format            (const char * sVolumeName, FS_FORMAT_INFO * pFormatInfo);
Nint              FS_FormatSD          (const char * sVolumeName);
N
N/*********************************************************************
N*
N*       CheckDisk functionality
N*/
Nconst char * FS_CheckDisk_ErrCode2Text(int ErrCode);
Nint          FS_CheckDisk(const char * sVolumeName, void * pBuffer, U32 BufferSize, int MaxRecursionLevel, FS_QUERY_F_TYPE * pfOnError);
Xint          FS_CheckDisk(const char * sVolumeName, void * pBuffer, unsigned long BufferSize, int MaxRecursionLevel, FS_QUERY_F_TYPE * pfOnError);
Nvoid         FS_FAT_AbortCheckDisk(void);
N
N/*********************************************************************
N*
N*       CheckDisk macro replacement for
N*/
N#define FS_EFS_CheckDisk(sVolumeName, pBuffer, BufferSize, MaxRecursionLevel, pfOnError)  FS_CheckDisk(sVolumeName, pBuffer, BufferSize, MaxRecursionLevel, pfOnError)
N#define FS_FAT_CheckDisk(sVolumeName, pBuffer, BufferSize, MaxRecursionLevel, pfOnError)  FS_CheckDisk(sVolumeName, pBuffer, BufferSize, MaxRecursionLevel, pfOnError)
N#define FS_EFS_CheckDisk_ErrCode2Text(ErrCode)                                            FS_CheckDisk_ErrCode2Text(ErrCode)
N#define FS_FAT_CheckDisk_ErrCode2Text(ErrCode)                                            FS_CheckDisk_ErrCode2Text(ErrCode)
N
N/*********************************************************************
N*
N*       Configuration functions.
N*/
Nvoid FS_FAT_SupportLFN(void);
Nvoid FS_SetMaxSectorSize(unsigned MaxSectorSize);
Nvoid FS_WriteUpdateDir(char OnOff);
N
N
N/*********************************************************************
N*
N*       Space information functions
N*/
N#define FS_GetFreeSpace(sVolume)  FS_GetVolumeFreeSpace(sVolume)
N#define FS_GetTotalSpace(sVolume) FS_GetVolumeSize(sVolume)
N
N
N/*********************************************************************
N*
N*       BusyLED support
N*/
Nvoid FS_SetBusyLEDCallback(const char * sVolumeName, FS_BUSY_LED_CALLBACK * pfBusyLEDCallback);
N
N
N/*********************************************************************
N*
N*       Memory accessible support
N*/
Nvoid FS_SetMemAccessCallback(const char * sVolumeName, FS_MEMORY_IS_ACCESSIBLE_CALLBACK * pfIsAccessibleCallback);
N
N/*********************************************************************
N*
N*       Device Drivers
N*
N*/
Nstruct FS_DEVICE_TYPE {      // Note: This definition is really intern and should be in "FS_Int.h". In order to avoid problems with old compilers, keep it here.
N  const char *      (*pfGetName)      (U8 Unit);
X  const char *      (*pfGetName)      (unsigned char Unit);
N  int               (*pfAddDevice)    (void);                                                       // Called from AddDevice. Usually the first call to the driver
N  int               (*pfRead)         (U8 Unit, U32 SectorNo,       void *pBuffer, U32 NumSectors);
X  int               (*pfRead)         (unsigned char Unit, unsigned long SectorNo,       void *pBuffer, unsigned long NumSectors);
N  int               (*pfWrite)        (U8 Unit, U32 SectorNo, const void *pBuffer, U32 NumSectors, U8 RepeatSame);
X  int               (*pfWrite)        (unsigned char Unit, unsigned long SectorNo, const void *pBuffer, unsigned long NumSectors, unsigned char RepeatSame);
N  int               (*pfIoCtl)        (U8 Unit, I32 Cmd, I32 Aux, void *pBuffer);
X  int               (*pfIoCtl)        (unsigned char Unit, signed long Cmd, signed long Aux, void *pBuffer);
N  int               (*pfInitMedium)   (U8 Unit);                                                       // Called when formatting or mounting a device
X  int               (*pfInitMedium)   (unsigned char Unit);                                                       
N  int               (*pfGetStatus)    (U8 Unit);
X  int               (*pfGetStatus)    (unsigned char Unit);
N  int               (*pfGetNumUnits)  (void);
N};
N
Nextern const FS_DEVICE_TYPE    FS_RAMDISK_Driver;       /* RAMDISK_DRIVER function table */
Nextern const FS_DEVICE_TYPE    FS_WINDRIVE_Driver;      /* WINDRIVE_DRIVER function table */
Nextern const FS_DEVICE_TYPE    FS_MMC_CardMode_Driver;  /* MMC_DRIVER SPI function table */
Nextern const FS_DEVICE_TYPE    FS_MMC_SPI_Driver;       /* MMC_DRIVER CardMode function table */
Nextern const FS_DEVICE_TYPE    FS_IDE_Driver;           /* IDE_CF_DRIVER function table */
Nextern const FS_DEVICE_TYPE    FS_NOR_Driver;           /* NOR flash driver function table */
Nextern const FS_DEVICE_TYPE    FS_GENERIC_Driver;       /* GENERIC_DRIVER function table */
Nextern const FS_DEVICE_TYPE    FS_NAND_Driver;          /* Nand driver function table */
N
N/*********************************************************************
N*
N*       NOR driver
N*/
Ntypedef struct {
N  U32 Off;
X  unsigned long Off;
N  U32 Size;
X  unsigned long Size;
N  U32 EraseCnt;
X  unsigned long EraseCnt;
N  U16 NumUsedSectors;
X  unsigned short NumUsedSectors;
N  U16 NumFreeSectors;
X  unsigned short NumFreeSectors;
N  U16 NumEraseableSectors;
X  unsigned short NumEraseableSectors;
N} FS_NOR_SECTOR_INFO;
N
Ntypedef struct {
N  U32 NumPhysSectors;
X  unsigned long NumPhysSectors;
N  U32 NumLogSectors;
X  unsigned long NumLogSectors;
N  U32 NumUsedSectors;   /* Number of used logical sectors */
X  unsigned long NumUsedSectors;    
N} FS_NOR_DISK_INFO;
N
Ntypedef struct FS_NOR_PHY_TYPE {
N  int  (*pfWriteOff)         (U8 Unit, U32 Off, const void * pSrc, U32 Len);
X  int  (*pfWriteOff)         (unsigned char Unit, unsigned long Off, const void * pSrc, unsigned long Len);
N  int  (*pfReadOff)          (U8 Unit, void * pDest, U32 Off, U32 Len);
X  int  (*pfReadOff)          (unsigned char Unit, void * pDest, unsigned long Off, unsigned long Len);
N  int  (*pfEraseSector)      (U8 Unit, unsigned int SectorIndex);
X  int  (*pfEraseSector)      (unsigned char Unit, unsigned int SectorIndex);
N  void (*pfGetSectorInfo)    (U8 Unit, unsigned int SectorIndex, U32 * pOff, U32 * pLen);
X  void (*pfGetSectorInfo)    (unsigned char Unit, unsigned int SectorIndex, unsigned long * pOff, unsigned long * pLen);
N  int  (*pfGetNumSectors)    (U8 Unit);
X  int  (*pfGetNumSectors)    (unsigned char Unit);
N  void (*pfConfigure)        (U8 Unit, U32 BaseAddr, U32 StartAddr, U32 NumBytes);
X  void (*pfConfigure)        (unsigned char Unit, unsigned long BaseAddr, unsigned long StartAddr, unsigned long NumBytes);
N  void (*pfOnSelectPhy)      (U8 Unit);
X  void (*pfOnSelectPhy)      (unsigned char Unit);
N  void (*pfDeInit)           (U8 Unit);
X  void (*pfDeInit)           (unsigned char Unit);
N} FS_NOR_PHY_TYPE;
N
Nextern const FS_NOR_PHY_TYPE FS_NOR_PHY_CFI_1x16;            // 1 x 16-bit CFI compliant NOR flash
Nextern const FS_NOR_PHY_TYPE FS_NOR_PHY_CFI_2x16;            // 2 x 16-bit CFI compliant NOR flash
Nextern const FS_NOR_PHY_TYPE FS_NOR_PHY_ST_M25;              // ST M25P compliant Serial NOR flash
N
Nvoid         FS_NOR_GetDiskInfo            (U8 Unit, FS_NOR_DISK_INFO * pDiskInfo);
Xvoid         FS_NOR_GetDiskInfo            (unsigned char Unit, FS_NOR_DISK_INFO * pDiskInfo);
Nvoid         FS_NOR_GetSectorInfo          (U8 Unit, U32 PhysSectorIndex, FS_NOR_SECTOR_INFO * pSectorInfo);
Xvoid         FS_NOR_GetSectorInfo          (unsigned char Unit, unsigned long PhysSectorIndex, FS_NOR_SECTOR_INFO * pSectorInfo);
Nvoid         FS_NOR_Configure              (U8 Unit, U32 BaseAddr, U32 StartAddr, U32 NumBytes);
Xvoid         FS_NOR_Configure              (unsigned char Unit, unsigned long BaseAddr, unsigned long StartAddr, unsigned long NumBytes);
Nvoid         FS_NOR_ConfigureReserve       (U8 Unit, U8 Percentage2Reserve);
Xvoid         FS_NOR_ConfigureReserve       (unsigned char Unit, unsigned char Percentage2Reserve);
Nvoid         FS_NOR_SetPhyType             (U8 Unit, const FS_NOR_PHY_TYPE * pPhyType);
Xvoid         FS_NOR_SetPhyType             (unsigned char Unit, const FS_NOR_PHY_TYPE * pPhyType);
Nconst void * FS_NOR_LogSector2PhySectorAddr(U8 Unit, U32 LogSectorNo);
Xconst void * FS_NOR_LogSector2PhySectorAddr(unsigned char Unit, unsigned long LogSectorNo);
Nvoid         FS_NOR_SetSectorSize          (U8 Unit, U16 SectorSize);
Xvoid         FS_NOR_SetSectorSize          (unsigned char Unit, unsigned short SectorSize);
Nint          FS_NOR_FormatLow              (U8 Unit);
Xint          FS_NOR_FormatLow              (unsigned char Unit);
Nint          FS_NOR_IsLLFormatted          (U8 Unit);
Xint          FS_NOR_IsLLFormatted          (unsigned char Unit);
Nvoid         FS_NOR_SPI_Configure          (U8 Unit, U32  SectorSize, U16  NumSectors);
Xvoid         FS_NOR_SPI_Configure          (unsigned char Unit, unsigned long  SectorSize, unsigned short  NumSectors);
N
N/*********************************************************************
N*
N*       RAMDISK driver
N*/
Nvoid FS_RAMDISK_Configure(U8 Unit, void * pData, U16 BytesPerSector, U32 NumSectors);
Xvoid FS_RAMDISK_Configure(unsigned char Unit, void * pData, unsigned short BytesPerSector, unsigned long NumSectors);
N
N/*********************************************************************
N*
N*       MMC/SD driver
N*/
Ntypedef struct {
N  U8 aData[16];
X  unsigned char aData[16];
N} MMC_CARD_ID;
N
Nvoid FS_MMC_ActivateCRC        (void);
Nvoid FS_MMC_DeactivateCRC      (void);
Nint  FS_MMC_GetCardId          (U8 Unit, MMC_CARD_ID * pCardId);
Xint  FS_MMC_GetCardId          (unsigned char Unit, MMC_CARD_ID * pCardId);
Nvoid FS_MMC_CM_Allow4bitMode   (U8 Unit, U8 OnOff);
Xvoid FS_MMC_CM_Allow4bitMode   (unsigned char Unit, unsigned char OnOff);
N
N
N/*********************************************************************
N*
N*       IDE/CF driver
N*/
Nvoid FS_IDE_Configure(U8 Unit, U8 IsSlave);
Xvoid FS_IDE_Configure(unsigned char Unit, unsigned char IsSlave);
N
N/*********************************************************************
N*
N*       NAND driver
N*/
N
Ntypedef struct {
N  U16          brsi;              // Block relative sector index.
X  unsigned short          brsi;              
N  U32          ECC;               // Ecc stored for this sector.
X  unsigned long          ECC;               
N  U8           IsValid;           // Sector contains valid data.
X  unsigned char           IsValid;           
N} FS_NAND_SECTOR_INFO;
N
Ntypedef struct {
N  U32          EraseCnt;
X  unsigned long          EraseCnt;
N  U32          lbi;
X  unsigned long          lbi;
N  U16          NumSectorsBlank;               // Sectors are not used yet.
X  unsigned short          NumSectorsBlank;               
N  U16          NumSectorsValid;               // Sectors contain correct data.
X  unsigned short          NumSectorsValid;               
N  U16          NumSectorsInvalid;             // Sectors have been invalidated.
X  unsigned short          NumSectorsInvalid;             
N  U16          NumSectorsECCError;            // Sectors have incorrect ECC.
X  unsigned short          NumSectorsECCError;            
N  U16          NumSectorsECCCorrectable;      // Sectors have correctable ECC error.
X  unsigned short          NumSectorsECCCorrectable;      
N  const char * sType;
N} FS_NAND_BLOCK_INFO;
N
Ntypedef struct {
N  U32 NumPhyBlocks;
X  unsigned long NumPhyBlocks;
N  U32 NumLogBlocks;
X  unsigned long NumLogBlocks;
N  U32 NumUsedPhyBlocks;
X  unsigned long NumUsedPhyBlocks;
N  U32 NumBadPhyBlocks;
X  unsigned long NumBadPhyBlocks;
N  U32 NumPagesPerBlock;
X  unsigned long NumPagesPerBlock;
N  U32 NumSectorsPerBlock;
X  unsigned long NumSectorsPerBlock;
N  U32 BytesPerPage;
X  unsigned long BytesPerPage;
N  U32 BytesPerSector;
X  unsigned long BytesPerSector;
N} FS_NAND_DISK_INFO;
N
Ntypedef struct FS_NAND_DEVICE_INFO {
N  U8  BPP_Shift;              // Bytes per Page shift: 9 for 512 bytes/page or 11 for 2048 bytes/page
X  unsigned char  BPP_Shift;              
N  U8  PPB_Shift;              // Pages per block shift: 32 -> 5, 64 -> 6
X  unsigned char  PPB_Shift;              
N  U16 NumBlocks;              // Number of Blocks in device
X  unsigned short NumBlocks;              
N} FS_NAND_DEVICE_INFO;
N
Ntypedef struct FS_NAND_PHY_TYPE {
N  int    (*pfEraseBlock)    (U8 Unit, U32 Block);
X  int    (*pfEraseBlock)    (unsigned char Unit, unsigned long Block);
N  int    (*pfInitGetDeviceInfo) (U8 Unit, FS_NAND_DEVICE_INFO * pDevInfo);
X  int    (*pfInitGetDeviceInfo) (unsigned char Unit, FS_NAND_DEVICE_INFO * pDevInfo);
N  int    (*pfIsWP)          (U8 Unit);
X  int    (*pfIsWP)          (unsigned char Unit);
N  int    (*pfRead)          (U8 Unit, U32 PageNo,       void * pData, unsigned Off, unsigned NumBytes);
X  int    (*pfRead)          (unsigned char Unit, unsigned long PageNo,       void * pData, unsigned Off, unsigned NumBytes);
N  int    (*pfReadEx)        (U8 Unit, U32 PageNo,       void * pData, unsigned Off, unsigned NumBytes, void * pSpare, unsigned OffSpare, unsigned NumBytesSpare);
X  int    (*pfReadEx)        (unsigned char Unit, unsigned long PageNo,       void * pData, unsigned Off, unsigned NumBytes, void * pSpare, unsigned OffSpare, unsigned NumBytesSpare);
N  int    (*pfWrite)         (U8 Unit, U32 PageNo, const void * pData, unsigned Off, unsigned NumBytes);
X  int    (*pfWrite)         (unsigned char Unit, unsigned long PageNo, const void * pData, unsigned Off, unsigned NumBytes);
N  int    (*pfWriteEx)       (U8 Unit, U32 PageNo, const void * pData, unsigned Off, unsigned NumBytes, const void* pSpare, unsigned OffSpare, unsigned NumBytesSpare);
X  int    (*pfWriteEx)       (unsigned char Unit, unsigned long PageNo, const void * pData, unsigned Off, unsigned NumBytes, const void* pSpare, unsigned OffSpare, unsigned NumBytesSpare);
N} FS_NAND_PHY_TYPE;
N
N
Nextern const FS_NAND_PHY_TYPE FS_NAND_PHY_x;                        // 512 or 2048 byte pages,  8-bit or 16-bit interface
Nextern const FS_NAND_PHY_TYPE FS_NAND_PHY_x8;                       // 512 or 2048 byte pages,  8-bit interface
Nextern const FS_NAND_PHY_TYPE FS_NAND_PHY_x16;                      // 512 or 2048 byte pages, 16-bit interface
Nextern const FS_NAND_PHY_TYPE FS_NAND_PHY_512x8;                    // 512 byte pages,  8-bit interface
Nextern const FS_NAND_PHY_TYPE FS_NAND_PHY_512x16;                   // 512 byte pages, 16-bit interface
Nextern const FS_NAND_PHY_TYPE FS_NAND_PHY_2048x8;                   // 2048 byte pages,  8-bit interface
Nextern const FS_NAND_PHY_TYPE FS_NAND_PHY_2048x16;                  // 2048 byte pages,  16-bit interface
Nextern const FS_NAND_PHY_TYPE FS_NAND_PHY_4096x8;                   // 4096 byte pages,  8-bit interface
Nextern const FS_NAND_PHY_TYPE FS_NAND_PHY_DataFlash;                // Physical layer for Atmel serial DATAFLASH
N
Nvoid FS_NAND_ResetStatCounters(U8 Unit);
Xvoid FS_NAND_ResetStatCounters(unsigned char Unit);
Nvoid FS_NAND_SetPhyType       (U8 Unit, const FS_NAND_PHY_TYPE * pPhyType);
Xvoid FS_NAND_SetPhyType       (unsigned char Unit, const FS_NAND_PHY_TYPE * pPhyType);
Nvoid FS_NAND_SetBlockRange    (U8 Unit, U16 FirstBlock, U16 MaxNumBlocks);
Xvoid FS_NAND_SetBlockRange    (unsigned char Unit, unsigned short FirstBlock, unsigned short MaxNumBlocks);
Nvoid FS_NAND_GetDiskInfo      (U8 Unit, FS_NAND_DISK_INFO * pDiskInfo);
Xvoid FS_NAND_GetDiskInfo      (unsigned char Unit, FS_NAND_DISK_INFO * pDiskInfo);
Nvoid FS_NAND_GetBlockInfo     (U8 Unit, U32 PhysBlockIndex, FS_NAND_BLOCK_INFO * pBlockInfo);
Xvoid FS_NAND_GetBlockInfo     (unsigned char Unit, unsigned long PhysBlockIndex, FS_NAND_BLOCK_INFO * pBlockInfo);
Nvoid FS_NAND_GetSectorInfo    (U8 Unit, U32 PhysSectorIndex, FS_NAND_SECTOR_INFO * pBlockInfo);
Xvoid FS_NAND_GetSectorInfo    (unsigned char Unit, unsigned long PhysSectorIndex, FS_NAND_SECTOR_INFO * pBlockInfo);
Nint  FS_NAND_FormatLow        (U8 Unit);
Xint  FS_NAND_FormatLow        (unsigned char Unit);
Nint  FS_NAND_IsLLFormatted    (U8 Unit);
Xint  FS_NAND_IsLLFormatted    (unsigned char Unit);
N
N/*********************************************************************
N*
N*       WinDrive driver
N*/
Nvoid WINDRIVE_Configure(U8 Unit, const char * sWindowsDriveName);
Xvoid WINDRIVE_Configure(unsigned char Unit, const char * sWindowsDriveName);
N
N
N/*********************************************************************
N*
N*       Data Flash PHY layer
N*/
Nvoid FS_DF_ChipErase(U8 Unit);
Xvoid FS_DF_ChipErase(unsigned char Unit);
N
N/*********************************************************************
N*
N*       Cache handling
N*/
N#if FS_SUPPORT_CACHE
X#if 1
N
N/*********************************************************************
N*
N*       General Cache mode defines, do not use in application
N*/
N#define FS_CACHE_MODE_R         0x01
N#define FS_CACHE_MODE_W         0x02
N#define FS_CACHE_MODE_D         0x04
N// Obsolete Cache mode define, do not use
N#define FS_CACHE_MODE_FULL      (FS_CACHE_MODE_R | FS_CACHE_MODE_W | FS_CACHE_MODE_D)
N
N/*********************************************************************
N*
N*       Cache mode defines that can be used in application
N*/
N#define FS_CACHE_MODE_WT        (FS_CACHE_MODE_R | FS_CACHE_MODE_W)
N#define FS_CACHE_MODE_WB        (FS_CACHE_MODE_R | FS_CACHE_MODE_W | FS_CACHE_MODE_D)
N
N/*********************************************************************
N*
N*       Cache specific defines
N*/
N#define FS_CACHE_NONE      NULL
N#define FS_CACHE_MAN       FS_CacheMan_Init
N#define FS_CACHE_RW        FS_CacheRW_Init
N#define FS_CACHE_RW_QUOTA  FS_CacheRWQuota_Init
N#define FS_CACHE_ALL       FS_CacheAll_Init
N#define FS_CACHEALL_API    FS_CacheAll_Init    /* For compatibility with older version */
N#define FS_CACHEMAN_API    FS_CacheMan_Init    /* For compatibility with older version */
N/*********************************************************************
N*
N*       Cache specific types
N*/
Ntypedef U32 FS_INIT_CACHE (FS_DEVICE * pDevice, void * pData,   I32 NumBytes);
Xtypedef unsigned long FS_INIT_CACHE (FS_DEVICE * pDevice, void * pData,   signed long NumBytes);
N
N/*********************************************************************
N*
N*       Cache specific prototypes
N*/
NU32    FS_AssignCache     (const char * pName, void * pData, I32 NumBytes, FS_INIT_CACHE * pfInit);
Xunsigned long    FS_AssignCache     (const char * pName, void * pData, signed long NumBytes, FS_INIT_CACHE * pfInit);
Nvoid   FS_CACHE_Clean     (const char * pName);
Nint    FS_CACHE_Command   (const char * pName, int Cmd,      void * pData);
Nint    FS_CACHE_SetMode   (const char * pName, int TypeMask, int    ModeMask);
Nint    FS_CACHE_SetQuota  (const char * pName, int TypeMask, U32    NumSectors);
Xint    FS_CACHE_SetQuota  (const char * pName, int TypeMask, unsigned long    NumSectors);
Nint    FS_CACHE_Invalidate(const char * sVolumeName);
N
N/*********************************************************************
N*
N*       Cache initialization prototypes
N*/
NU32 FS_CacheAll_Init    (FS_DEVICE * pDev, void * pData, I32 NumBytes);
Xunsigned long FS_CacheAll_Init    (FS_DEVICE * pDev, void * pData, signed long NumBytes);
NU32 FS_CacheMan_Init    (FS_DEVICE * pDev, void * pData, I32 NumBytes);
Xunsigned long FS_CacheMan_Init    (FS_DEVICE * pDev, void * pData, signed long NumBytes);
NU32 FS_CacheRW_Init     (FS_DEVICE * pDev, void * pData, I32 NumBytes);
Xunsigned long FS_CacheRW_Init     (FS_DEVICE * pDev, void * pData, signed long NumBytes);
NU32 FS_CacheRWQuota_Init(FS_DEVICE * pDev, void * pData, I32 NumBytes);
Xunsigned long FS_CacheRWQuota_Init(FS_DEVICE * pDev, void * pData, signed long NumBytes);
N
N#endif
N
N/*********************************************************************
N*
N*       File system selection prototype
N*/
N#if FS_SUPPORT_MULTIPLE_FS
X#if ((0) && (1))
Sint FS_SetFSType(const char * sVolume, int FSType);
N#endif
N
Ntypedef void   (FS_PF_FREE) (void * p);
Ntypedef void * (FS_PF_ALLOC)(U32 NumBytes);
Xtypedef void * (FS_PF_ALLOC)(unsigned long NumBytes);
N/*********************************************************************
N*
N*       Memory allocation functions
N*/
Nvoid * FS_Alloc         (I32     NumBytes);
Xvoid * FS_Alloc         (signed long     NumBytes);
Nvoid * FS_AllocZeroed   (I32     NumBytes);
Xvoid * FS_AllocZeroed   (signed long     NumBytes);
Nvoid   FS_Free          (void *  p);
Nvoid   FS_AllocZeroedPtr(void ** pp, I32 NumBytes);
Xvoid   FS_AllocZeroedPtr(void ** pp, signed long NumBytes);
Nvoid * FS_TryAlloc      (I32     NumBytesReq);
Xvoid * FS_TryAlloc      (signed long     NumBytesReq);
N
N/*********************************************************************
N*
N*       Logical driver config
N*/
Nint FS_AddPhysDevice   (const FS_DEVICE_TYPE * pDevType);
Nint FS_LOGVOL_Create   (const char * sVolName);
Nint FS_LOGVOL_AddDevice(const char * sLogVolName, const FS_DEVICE_TYPE * pDevice, U8 Unit, U32 StartOff, U32 NumSectors);
Xint FS_LOGVOL_AddDevice(const char * sLogVolName, const FS_DEVICE_TYPE * pDevice, unsigned char Unit, unsigned long StartOff, unsigned long NumSectors);
N
N
N/*********************************************************************
N*
N*       Debug support
N*/
Nvoid   FS_X_Log     (const char *s);
Nvoid   FS_X_Warn    (const char *s);
Nvoid   FS_X_ErrorOut(const char *s);
N
N
N/*********************************************************************
N*
N*       Application supplied functions FS_X_...
N*/
Nvoid   FS_X_Free(void * p);
Nvoid   FS_X_Panic(int ErrorCode);
Nvoid   FS_X_AddDevices(void);
NU32    FS_X_GetTimeDate(void);
Xunsigned long    FS_X_GetTimeDate(void);
N
NU32  FS_GetMaxSectorSize(void);
Xunsigned long  FS_GetMaxSectorSize(void);
Nvoid FS_AssignMemory    (U32 *pMem, U32 NumBytes);
Xvoid FS_AssignMemory    (unsigned long *pMem, unsigned long NumBytes);
Nvoid FS_SetMemHandler   (FS_PF_ALLOC * pfAlloc, FS_PF_FREE * pfFree);
N
Nvoid     FS_SetDefFileBufferSize(U32 BufferSize);
Xvoid     FS_SetDefFileBufferSize(unsigned long BufferSize);
Nunsigned FS_GetDefFileBufferSize(void);
Nvoid     FS_SetFileBufferSize(FS_FILE * pFile, U32 BufferSize);
Xvoid     FS_SetFileBufferSize(FS_FILE * pFile, unsigned long BufferSize);
N
N#if defined(__cplusplus)
X#if 0L
S  }              /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#endif                        // Avoid recursive and multiple inclusion
N
N/*************************** End of file ****************************/
L 27 "FS\FS_Int.h" 2
N#include "FS_Debug.h"
L 1 "FS\FS_Debug.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : FS_Debug.h
NPurpose     : Debug macros
N----------------------------------------------------------------------
N   Debug macros for logging
N
N In the FS Simulation, all output is transferred into the log window.
N*/
N
N#ifndef FS_DEBUG_H
N#define FS_DEBUG_H
N
N#include <stdarg.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N  typedef struct __va_list { void *__ap; } va_list;
N
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stdarg.h */
N
L 25 "FS\FS_Debug.h" 2
N#include "Global.h"
N#include "FS_ConfDefaults.h"
N
N
N#define FS_DEBUG_LEVEL_NOCHECK       0  /* No run time checks are performed */
N#define FS_DEBUG_LEVEL_CHECK_PARA    1  /* Parameter checks are performed to avoid crashes */
N#define FS_DEBUG_LEVEL_CHECK_ALL     2  /* Parameter checks and consistency checks are performed */
N#define FS_DEBUG_LEVEL_LOG_ERRORS    3  /* Errors are recorded */
N#define FS_DEBUG_LEVEL_LOG_WARNINGS  4  /* Errors & Warnings are recorded */
N#define FS_DEBUG_LEVEL_LOG_ALL       5  /* Errors, Warnings and Messages are recorded. */
N
N#ifndef FS_DEBUG_LEVEL
N  #ifdef WIN32
S    #define FS_DEBUG_LEVEL FS_DEBUG_LEVEL_LOG_WARNINGS  /* Simulation should log all warnings */
N  #else
N    #define FS_DEBUG_LEVEL FS_DEBUG_LEVEL_CHECK_PARA  /* For most targets, min. size is important */
N  #endif
N#endif
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Logging (for debugging primarily)
N*
N**********************************************************************
N*/
N
Nvoid FS_AddWarnFilter (U32 FilterMask);
Xvoid FS_AddWarnFilter (unsigned long FilterMask);
Nvoid FS_SetWarnFilter (U32 FilterMask);
Xvoid FS_SetWarnFilter (unsigned long FilterMask);
Nvoid FS_AddLogFilter  (U32 FilterMask);
Xvoid FS_AddLogFilter  (unsigned long FilterMask);
Nvoid FS_SetLogFilter  (U32 FilterMask);
Xvoid FS_SetLogFilter  (unsigned long FilterMask);
Nvoid FS_AddErrorFilter(U32 FilterMask);
Xvoid FS_AddErrorFilter(unsigned long FilterMask);
Nvoid FS_SetErrorFilter(U32 FilterMask);
Xvoid FS_SetErrorFilter(unsigned long FilterMask);
N
Nvoid FS_PrintfSafe(char * pBuffer, const char * sFormat, int BufferSize, va_list * pParamList);
Nvoid FS_ErrorOutf(U32 Type, const char * sFormat, ...);
Xvoid FS_ErrorOutf(unsigned long Type, const char * sFormat, ...);
Nvoid FS_Logf     (U32 Type, const char * sFormat, ...);
Xvoid FS_Logf     (unsigned long Type, const char * sFormat, ...);
Nvoid FS_Warnf    (U32 Type, const char * sFormat, ...);
Xvoid FS_Warnf    (unsigned long Type, const char * sFormat, ...);
N
N/*******************************************************************
N*
N*       Commandline
N*
N********************************************************************
N*/
N
N/*******************************************************************
N*
N*       Error macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if FS_DEBUG_LEVEL >= FS_DEBUG_LEVEL_LOG_ERRORS
X#if 1 >= 3
S  #define FS_DEBUG_ERROROUT(s)              FS_ErrorOutf s
S  #define FS_DEBUG_ERROROUT_IF(MType, exp,s)              { if (exp) FS_DEBUG_ERROROUT((MType, s)); }
N#else
N  #define FS_DEBUG_ERROROUT(s)
N#endif
N
N/*******************************************************************
N*
N*       Warning macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if FS_DEBUG_LEVEL >= FS_DEBUG_LEVEL_LOG_WARNINGS
X#if 1 >= 4
S  #define FS_DEBUG_WARN(s)              FS_Warnf s
S  #define FS_DEBUG_WARN_IF(MType,exp,s)                  { if (exp) FS_DEBUG_WARN((MType, s)); }
N#else
N  #define FS_DEBUG_WARN(s)
N  #define FS_DEBUG_WARN_IF(MType,exp,s)
N#endif
N
N/*******************************************************************
N*
N*       Logging macros
N*
N********************************************************************
N*/
N/* Make sure the macros are actually defined */
N
N#if FS_DEBUG_LEVEL >= FS_DEBUG_LEVEL_LOG_ALL
X#if 1 >= 5
S  #define FS_DEBUG_LOG(s)              FS_Logf s
S  #define FS_DEBUG_LOG_IF(MType,exp,s)                   { if (exp) FS_DEBUG_LOG((MType, s)); }
N#else
N  #define FS_DEBUG_LOG(s)
N  #define FS_DEBUG_LOG_IF(MType,exp,s)
N#endif
N
N
N
N/*******************************************************************
N*
N*       Asserts
N*
N********************************************************************
N*/
N#if FS_DEBUG_LEVEL >= FS_DEBUG_LEVEL_LOG_ERRORS
X#if 1 >= 3
S  #define FS_DEBUG_ASSERT(MType,exp)                     { FS_DEBUG_ERROROUT_IF((MType),!(exp),(#exp)); }
N#else
N  #define FS_DEBUG_ASSERT(MType,exp)
N#endif
N
N#if defined(__cplusplus)
X#if 0L
S  }              /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#endif /* FS_DEBUG_H */
N
N
N
N
N/*************************** End of file ****************************/
L 28 "FS\FS_Int.h" 2
N#include "FS_ConfDefaults.h"        /* FS Configuration */
N#include "FS_OS.h"
L 1 "FS\FS_OS.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : FS_OS.h
NPurpose     : File system's OS Layer header file
N----------------------------------------------------------------------
NKnown problems or limitations with current version
N----------------------------------------------------------------------
NNone.
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef _FS_OS_H_
N
N#define _FS_OS_H_
N
N#include "FS_ConfDefaults.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
Nvoid FS_X_OS_Lock   (unsigned LockIndex);
Nvoid FS_X_OS_Unlock (unsigned LockIndex);
N
Nvoid FS_X_OS_Init   (unsigned MaxNumLocks);
Nvoid FS_X_OS_DeInit (void);
N
NU32  FS_X_OS_GetTime(void);
Xunsigned long  FS_X_OS_GetTime(void);
N
Nint  FS_X_OS_Wait   (int Timeout);
Nvoid FS_X_OS_Signal (void);
N
N#if defined(__cplusplus)
X#if 0L
S}                /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#endif    /*  _FS_OS_H_  */
N
N/*************************** End of file ****************************/
L 30 "FS\FS_Int.h" 2
N
N#if FS_SUPPORT_FAT
X#if 1
N  #include "FAT.h"
L 1 "FS\FAT.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : FAT.h
NPurpose     : FAT File System Layer header
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef _FS_FAT_H_
N#define _FS_FAT_H_
N
N#include "FS_Int.h"
L 1 "FS\FS_Int.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : FS_Int.h
NPurpose     : Internals used accross different layers of the file system
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef _FS_INT_H_              // Avoid multiple/recursive inclusion
S#define _FS_INT_H_
S
S#include <string.h>
S#include <stdlib.h>
S#include <ctype.h>
S
S#include "FS_Types.h"
S#include "FS.h"
S#include "FS_Debug.h"
S#include "FS_ConfDefaults.h"        /* FS Configuration */
S#include "FS_OS.h"
S
S#if FS_SUPPORT_FAT
S  #include "FAT.h"
S#endif
S#if FS_SUPPORT_EFS
S  #include "EFS.h"
S#endif
S
S#if defined(__cplusplus)
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
S#endif
S
S
S
S/*********************************************************************
S*
S*       Global defines
S*
S**********************************************************************
S*/
S#define COUNTOF(a)          (sizeof(a)/sizeof(a[0]))
S#define MIN(a,b)            (((a) < (b)) ? (a) : (b))
S#define MAX(a,b)            (((a) > (b)) ? (a) : (b))
S#define ZEROFILL(p, Size)   (memset(p, 0, Size))
S
S
S#define FS_DISKINFO_FLAG_USE_FREE_SPACE          (1 << 0)
S
S
S/*********************************************************************
S*
S*       Data types
S*
S**********************************************************************
S*/
S
Stypedef struct {
S  int TypeMask;    /* Combination of FS_SECTOR_TYPE_DATA, FS_SECTOR_TYPE_MAN, FS_SECTOR_TYPE_DIR */
S  int ModeMask;    /* Combination of FS_CACHE_MODE_R, FS_CACHE_MODE_W, FS_CACHE_MODE_D */
S} CACHE_MODE;
S
Stypedef struct {
S  int TypeMask;    /* Combination of FS_SECTOR_TYPE_DATA, FS_SECTOR_TYPE_MAN, FS_SECTOR_TYPE_DIR */
S  int NumSectors;  /* Number of sectors to use for the type(s) specified */
S} CACHE_QUOTA;
S
Stypedef struct {
S  U32 FirstSector;
S  U32 NumSectors;
S} CACHE_FREE;
S
S
S/*********************************************************************
S*
S*       FS_INFO
S*
S*  The following structures are related:
S*  The first 3 entries of the structures in the union need to be identical.
S*/
Sstruct FS_FAT_INFO {
S  U32          NumSectors;       // RSVD + FAT + ROOT + FATA
S  U16          BytesPerSec;      // 512,1024,2048,4096
S  U16          ldBytesPerSector; // 9, 10, 11, 12
S  U32          FirstDataSector;
S  U32          BytesPerCluster;
S  U32          FATSize;          // Number of FAT sectors
S  U32          RootDirPos;       /* Position of root directory. FAT32: Cluster, FAT12/16: Sector */
S  U16          RootEntCnt;       /* number of root dir entries     */
S  U16          RsvdSecCnt;       /* 1 for FAT12 & FAT16            */
S  U8           SecPerClus;       /* sec in allocation unit         */
S  U8           NumFATs;          /* Typical value is 2             */
S  U8           FATType;          /* FS_FAT_TYPE_FAT12/16/32        */
S  U32          NumClusters;
S  U32          NumFreeClusters;  /* Once known, we keep track of the number of free clusters */
S  U32          NextFreeCluster;  /* Once known, we keep track of the next free cluster */
S#if FS_FAT_USE_FSINFO_SECTOR
S  U16          FSInfoSector;
S  U16          FSInfoSectorIsInvalidated;
S#endif
S};
S
Sstruct FS_EFS_INFO {
S  U32          NumSectors;         // RSVD + EFS alloc table + DATA
S  U16          BytesPerSector;     // 512,1024,2048,4096
S  U16          ldBytesPerSector;   // 9, 10, 11, 12
S  U32          FirstDataSector;    // First data cluster -> First Sector after InfoSector, EFSAllocTable.
S  U32          BytesPerCluster;    // Bytes for each cluster: 512 - 32768
S  U32          EFSTableSize;       // EFS Alloc table size in no. of sectors
S  U32          RootDirPos;         // Cluster that is used for the root directory
S  U8           SectorsPerCluster;  // Number of sectors for a cluster
S  U32          NumClusters;        // Number of available clusters
S  U32          NumFreeClusters;    // Once known, we keep track of the number of free clusters
S  U32          NextFreeCluster;    // Once known, we keep track of the next free cluster
S};
S
S
Stypedef union {
S  FS_FAT_INFO  FATInfo;
S  FS_EFS_INFO  EFSInfo;
S  struct {
S    U32          NumSectors;         // RSVD + EFS alloc table + DATA
S    U16          BytesPerSector;     // 512,1024,2048,4096
S    U16          ldBytesPerSector;   // 9, 10, 11, 12
S  } Info;
S} FS_INFO;
S
Stypedef struct {
S  U8 Unit;
S  U8 IsInited;
S  U8 JournalIsActive;
S  U8 JournalUnit;
S#if FS_SUPPORT_CACHE
S  const FS_CACHE_API * pCacheAPI;
S  void               * pCacheData;
S#endif
S#if FS_SUPPORT_BUSY_LED
S  FS_BUSY_LED_CALLBACK * pfSetBusyLED;
S#endif
S#if FS_SUPPORT_CHECK_MEMORY
S  FS_MEMORY_IS_ACCESSIBLE_CALLBACK * pfMemoryIsAccessible;
S#endif
S  FS_ONDEVICEACTIVITYHOOK * pfOnDeviceActivityHook;
S} FS_DEVICE_DATA;
S
Sstruct FS_DEVICE {
S  const FS_DEVICE_TYPE * pType;
S  FS_DEVICE_DATA         Data;
S};
S
Sstruct FS_PARTITION {
S  FS_DEVICE Device;
S  U32       StartSector;
S  U32       NumSectors;
S};
S
Stypedef struct {
S  int   InUse;
S  U32 * pBuffer;
S} SECTOR_BUFFER;
S
S
Stypedef void        FS_CB_CLOSE               (FS_FILE    * pFile);
Stypedef int         FS_CB_CHECKFS_API         (FS_VOLUME  * pVolume);
Stypedef U32         FS_CB_READ                (FS_FILE    * pFile,           void  * pData, U32 NumBytes);
Stypedef U32         FS_CB_WRITE               (FS_FILE    * pFile,     const void  * pData, U32 NumBytes);
Stypedef char        FS_CB_OPEN                (const char * pFileName, FS_FILE * pFile, char DoDel, char DoOpen, char DoCreate);
Stypedef int         FS_CB_FORMAT              (FS_VOLUME  * pVolume,   FS_FORMAT_INFO * pFormatInfo);
Stypedef int         FS_CB_OPENDIR             (const char * pDirName,  FS__DIR *pDir);
Stypedef int         FS_CB_CLOSEDIR            (FS__DIR    * pDir);
Stypedef int         FS_CB_READDIR             (FS__DIR    * pDir,      FS_DIRENTRY_INFO * pDirEntryInfo);
Stypedef int         FS_CB_REMOVEDIR           (FS_VOLUME  * pVolume,   const char * pDirName);
Stypedef int         FS_CB_CREATEDIR           (FS_VOLUME  * pVolume,   const char * pDirName);
Stypedef int         FS_CB_RENAME              (const char * sOldName,  const char * sNewName, FS_VOLUME * pVolume);
Stypedef int         FS_CB_MOVE                (const char * sOldName,  const char * sNewName, FS_VOLUME * pVolume);
Stypedef char        FS_CB_SETDIRENTRYINFO     (FS_VOLUME  * pVolume,   const char * sName, const void * p, int Mask);
Stypedef char        FS_CB_GETDIRENTRYINFO     (FS_VOLUME  * pVolume,   const char * sName,       void * p, int Mask);
Stypedef int         FS_CB_SETENDOFFILE        (FS_FILE    * pFile);
Stypedef void        FS_CB_UNMOUNT             (FS_VOLUME  * pVolume);
S
Stypedef int         FS_CB_GETDISKINFO         (FS_VOLUME  * pVolume,   FS_DISK_INFO * pDiskData, int Flags);
Stypedef int         FS_CB_GETVOLUMELABEL      (FS_VOLUME  * pVolume,   char * pVolumeLabel, unsigned VolumeLabelSize);
Stypedef int         FS_CB_SETVOLUMELABEL      (FS_VOLUME  * pVolume,   const char * pVolumeLabel);
Stypedef int         FS_CB_CREATEJOURNALFILE   (FS_VOLUME  * pVolume,   U32 NumBytes, U32 * pFirstSector, U32 * pNumSectors);
Stypedef int         FS_CB_OPENJOURNALFILE     (FS_VOLUME  * pVolume);
Stypedef U32         FS_CB_GETINDEXOFLASTSECTOR(FS_VOLUME  * pVolume);
Stypedef int         FS_CB_CHECKDISK           (FS_VOLUME  * pVolume,   FS_DISK_INFO * pDiskInfo, void * pBuffer, U32 BufferSize, int MaxRecursionLevel, FS_QUERY_F_TYPE * pfOnError);
Stypedef void        FS_CB_UPDATE_FILE         (FS_FILE    * pFile);
S
Stypedef struct {
S  FS_CB_CHECKFS_API          * pfCheckBootSector;
S  FS_CB_OPEN                 * pfOpen;
S  FS_CB_CLOSE                * pfClose;
S  FS_CB_READ                 * pfRead;
S  FS_CB_WRITE                * pfWrite;
S  FS_CB_FORMAT               * pfFormat;
S  FS_CB_OPENDIR              * pfOpenDir;
S  FS_CB_CLOSEDIR             * pfCloseDir;
S  FS_CB_READDIR              * pfReadDir;
S  FS_CB_REMOVEDIR            * pfRemoveDir;
S  FS_CB_CREATEDIR            * pfCreateDir;
S  FS_CB_RENAME               * pfRename;
S  FS_CB_MOVE                 * pfMove;
S  FS_CB_SETDIRENTRYINFO      * pfSetDirEntryInfo;
S  FS_CB_GETDIRENTRYINFO      * pfGetDirEntryInfo;
S  FS_CB_SETENDOFFILE         * pfSetEndOfFile;
S  FS_CB_UNMOUNT              * pfUnmount;
S  FS_CB_GETDISKINFO          * pfGetDiskInfo;
S  FS_CB_GETVOLUMELABEL       * pfGetVolumeLabel;
S  FS_CB_SETVOLUMELABEL       * pfSetVolumeLabel;
S  FS_CB_CREATEJOURNALFILE    * pfCreateJournalFile;
S  FS_CB_OPENJOURNALFILE      * pfOpenJournalFile;
S  FS_CB_GETINDEXOFLASTSECTOR * pfGetIndexOfLastSector;
S  FS_CB_CHECKDISK            * pfCheckDisk;
S  FS_CB_UPDATE_FILE          * pfUpdateFile;
S} FS_FS_API;
S
Sstruct FS_VOLUME {
S  FS_PARTITION Partition;
S  FS_INFO      FSInfo;
S  U8           PartitionIndex;
S  U8           IsMounted;
S  U8           AllowAutoMount;
S  U8           InUse;
S#if FS_SUPPORT_MULTIPLE_FS
S  const FS_FS_API * pFS_API;
S#endif
S  FS_VOLUME *  pNext;
S};
S
S/*********************************************************************
S*
S*       Directory types
S*/
Sstruct FS_DIR {
S  FS__DIR     Dir;
S  FS_DIRENT   DirEntry;
S  I16         error;              /* error code                   */
S  U8          InUse;              /* handle in use mark           */
S};
S
S/*********************************************************************
S*
S*       File types
S*/
Stypedef union {
S    struct {
S      U32      CurClusterFile; /* Current cluster within the file. First cluster is 0, next cluster is 1 ... */
S      U32      CurClusterAbs;  /* Current cluster on the medium. This needs to be computed from file cluster, consulting the FAT */
S      U32      DirEntrySector; /* Sector of directory */
S      U16      DirEntryIndex;  /* Index of directory entry */
S      U16      NumAdjClusters; /* Number of cluster that are sequentially in chain behind current one */
S    } Fat;
S    struct {
S      U32      DirCluster;     /* Start cluster of directory file */
S      U32      DirEntryPos;    /* Offset of directory entry in directory file */
S      U32      CurClusterFile; /* Current cluster within the file. First cluster is 0, next cluster is 1 ... */
S      U32      CurClusterAbs;  /* Current cluster on the medium. This needs to be computed from file cluster, consulting the FAT */
S      U16      NumAdjClusters; /* Number of cluster that are sequentially in chain behind current one */
S    } Efs;
S} FS_INT_DATA;
S
S
Stypedef struct FS_FILE_OBJ FS_FILE_OBJ;
Stypedef struct {
S  U8       * pData;
S  U32        SectorIndex;
S  unsigned   Off;
S  unsigned   Size;
S} FS_FILE_BUFFER;
S
S
Sstruct FS_FILE_OBJ {      /* Describes the file object structure below the handle */
S  U32           FirstCluster;   /* First cluster used for file  */
S  U32           Size;           /* size of file                 */
S  FS_VOLUME   * pVolume;
S  U8            UseCnt;         /* handle in use mark           */
S  FS_INT_DATA   Data;
S#if FS_MULTI_HANDLE_SAFE
S  char          acFullFileName[FS_MAX_LEN_FULL_FILE_NAME];
S#endif
S#if FS_USE_FILE_BUFFER
S  FS_FILE_BUFFER * pBuffer;
S#endif
S  FS_FILE_OBJ * pNext;
S};
S
Sstruct FS_FILE { /* Describes the file handle structure */
S  FS_FILE_OBJ * pFileObj;
S  U32           FilePos;        /* current position in file     */
S  I16           Error;          /* error code                   */
S  U8            InUse;          /* handle in use mark           */
S  U8            AccessFlags;
S  FS_FILE     * pNext;
S};
S
S/*********************************************************************
S*
S*       Smart buffer (SB) type, internal
S*
S*/
Sstruct FS_SB {
S  U32 SectorNo;
S#if FS_MAINTAIN_FAT_COPY
S  U32 WriteCopyOff;  /* Duplicate on write if value is != 0 */
S#endif
S  FS_PARTITION * pPart;
S  U8 *           pBuffer;
S  char           IsDirty;
S  char           HasError;
S  U8             Type;
S  U8             Read;          /* 1 if data is valid, usually because the sector has been read */
S};
S
S/*********************************************************************
S*
S*       Partition related
S*/
SU32           FS__GetMediaStartSecEx(FS_VOLUME * pVolume, U32 * pNumSectors, U8* pBuffer);
SU32           FS__GetMediaStartSec(U8 PartIndex, U8 *pBuffer);
Ssigned char   FS__LocatePartition(FS_VOLUME * pVolume);
S
S/*********************************************************************
S*
S*       little endian translation functions, internal
S*/
SU16           FS_LoadU16LE (const U8 *pBuffer);
SU32           FS_LoadU32LE (const U8 *pBuffer);
Svoid          FS_StoreU16LE(      U8 *pBuffer, unsigned Data);
Svoid          FS_StoreU24LE(      U8 *pBuffer, U32 Data);
Svoid          FS_StoreU32LE(      U8 *pBuffer, U32 Data);
S
S/*********************************************************************
S*
S*       big endian translation functions, internal
S*/
SU32           FS_LoadU32BE (const U8 *pBuffer);
SU16           FS_LoadU16BE (const U8 *pBuffer);
Svoid          FS_StoreU32BE(      U8 *pBuffer, U32 Data);
Svoid          FS_StoreU16BE(      U8 *pBuffer, unsigned Data);
S
S
S/*********************************************************************
S*
S*       CACHE API type, internal
S*
S*/
Sstruct FS_CACHE_API {
S  char   (*pfReadFromCache)   (FS_DEVICE * pDevice,      U32 SectorNo,       void * pData, U8  Type);
S  char   (*pfUpdateCache)     (FS_DEVICE * pDevice,      U32 SectorNo, const void * pData, U8  Type);    /* Returns 0 if write cached, which means no further write is required */
S  void   (*pfInvalidateCache) (void      * pCacheData);
S  int    (*pfCommand)         (FS_DEVICE * pDevice   ,   int Cmd, void *p);
S  char   (*pfWriteIntoCache)  (FS_DEVICE * pDevice   ,   U32 SectorNo, const void * pData, U8  Type);    /* Returns 0 if write cached, which means no further write is required */
S
S};
S
S/*********************************************************************
S*
S*       Smart buffer (SB) API-functions, internal
S*
S*/
Svoid FS__SB_Clean          (FS_SB * pSB);
Schar FS__SB_Create         (FS_SB * pSB, FS_PARTITION *pPart);
Svoid FS__SB_Delete         (FS_SB * pSB);
Svoid FS__SB_Flush          (FS_SB * pSB);
Svoid FS__SB_MarkDirty      (FS_SB * pSB);
Svoid FS__SB_MarkValid      (FS_SB * pSB, U32 SectorNo, U8 Type);
Svoid FS__SB_MarkNotDirty   (FS_SB * pSB);
Schar FS__SB_Read           (FS_SB * pSB);
Svoid FS__SB_SetSector      (FS_SB * pSB, U32 SectorNo, U8 Type);
Schar FS__SB_Write          (FS_SB * pSB);
S
S#if FS_MAINTAIN_FAT_COPY
S  void FS__SB_SetWriteCopyOff(FS_SB * pSB, U32 Off);
S#endif
S
S/*********************************************************************
S*
S*       SB-functions, locking and unlocking SB operations
S*
S*/
Svoid    FS_Lock_SB  (FS_PARTITION * pPart, U32 SectorIndex);
Svoid    FS_Unlock_SB(FS_PARTITION * pPart, U32 SectorIndex);
S
S
S/*********************************************************************
S*
S*       Cache related fucntions, internal
S*
S*/
Sint   FS__CACHE_CommandVolume  (FS_VOLUME * pVolume, int Cmd, void * pData);
Sint   FS__CACHE_CommandDevice  (FS_DEVICE * pDevice, int Cmd, void * pData);
Svoid  FS__CACHE_CleanNL        (FS_DEVICE * pDevice);
Svoid  FS__CACHE_Clean          (FS_VOLUME * pVolume);
S
S
S/*********************************************************************
S*
S*       Sector allocation API-functions, internal
S*
S*/
SU8 *  FS__AllocSectorBuffer (void);
Svoid  FS__FreeSectorBuffer  (void * p);
S
S/*********************************************************************
S*
S*       String operation API-functions, internal
S*
S*/
Svoid           FS_memcpy(void * pDest, const void * pSrc, int NumBytes);
Sconst char *   FS__strchr     (const char *s, int c);
Svoid           FS__AddSpaceHex(U32 v, U8 Len, char** ps);
S
S/*********************************************************************
S*
S*       Volume API-functions, internal
S*
S*/
SFS_VOLUME * FS__FindVolume     (const char *pFullName, const char ** pFileName);
Sint         FS__Mount          (FS_VOLUME * pVolume, U8 MountType);
Sint         FS__AutoMount      (FS_VOLUME * pVolume);
Svoid        FS__Unmount        (FS_VOLUME * pVolume);
Svoid        FS__UnmountLL      (FS_VOLUME * pVolume);
Svoid        FS__UnmountForcedLL(FS_VOLUME * pVolume);
Svoid        FS__Sync           (FS_VOLUME * pVolume);
Svoid        FS__STORAGE_Sync   (FS_VOLUME * pVolume);
S
S/*********************************************************************
S*
S*       API-functions, internal (without Global locking)
S*
S*/
Sint         FS__FClose           (FS_FILE * pFile);
SU32         FS__GetFileSize      (FS_FILE * pFile);
SU32         FS__Read             (FS_FILE * pFile,       void * pData, U32 NumBytes);
SU32         FS__Write            (FS_FILE * pFile, const void * pData, U32 NumBytes);
Sint         FS__Verify           (FS_FILE * pFile, const void * pData, U32 NumBytes);
Sint         FS__Remove           (const char * pFileName);
SFS_FILE *   FS__FOpen            (const char * pFileName, const char * pMode);
SFS_FILE *   FS__FOpenEx          (const char * pFileName, U8 AccessFlags, char DoCreate, char DoDel, char DoOpen);
SFS_FILE *   FS__OpenEx           (FS_VOLUME  * pVolume,   const char * sFilePath, U8 AccessFlags, char DoCreate, char DoDel, char DoOpen);
S
SU32         FS__CalcSizeInBytes  (U32 NumClusters,   U32 SectorsPerCluster, U32 BytesPerSector);
SU32         FS__CalcSizeInKB     (U32 NumClusters, U32 SectorsPerCluster, U32 BytesPerSector);
S
SFS_VOLUME * FS__AddDevice        (const FS_DEVICE_TYPE * pDevType);
Sint         FS__AddPhysDevice    (const FS_DEVICE_TYPE * pDevType);
S
Sint         FS__IoCtl            (FS_VOLUME * pVolume, I32 Cmd, I32 Aux, void *pBuffer);
Sint         FS__Format           (FS_VOLUME * pVolume, FS_FORMAT_INFO * pFormatInfo);
Sint         FS__SD_Format        (FS_VOLUME  * pVolume);
Sint         FS__GetNumVolumes    (void);
Sint         FS__CopyFile         (const char * sSource, const char   * sDest);
Sint         FS__GetVolumeInfo    (const char * sVolume, FS_DISK_INFO * pInfo);
Sint         FS__GetVolumeInfoEx  (const char * sVolume, FS_DISK_INFO * pInfo, int Flags);
Sint         FS__CreateDir        (const char * sDir);
Sint         FS__MkDir            (const char * pDirName);
Sint         FS__RmDir            (const char * pDirName);
Sint         FS__FSeek            (FS_FILE *pFile, I32 Offset, int Origin);
SI32         FS__FTell            (FS_FILE *pFile);
Sint         FS__GetFileTimeEx    (const char * pName, U32 * pTimeStamp, int Index);
Sint         FS__SetFileTimeEx    (const char * pName, U32   TimeStamp,  int Index);
Sint         FS__SetFileAttributes(const char * pName, U8    Attributes);
SU8          FS__GetFileAttributes(const char * pName);
Sint         FS__SetEndOfFile     (FS_FILE    * pFile);
Svoid        FS__RemoveDevices    (void);
Svoid        FS__RemoveDevice     (FS_VOLUME * pVolume);
S
SFS_DIR    * FS__OpenDir      (const char *pDirName);
SFS_DIRENT * FS__ReadDir      (FS_DIR *pDir);
Sint         FS__CloseDir     (FS_DIR *pDir);
Svoid        FS__RewindDir    (FS_DIR *pDir);
Svoid        FS__DirEnt2Attr  (FS_DIRENT *pDirEnt, U8* pAttr);
SU32         FS__GetNumFiles  (FS_DIR *pDir);
Sint         FS__FindFirstFile(FS_FIND_DATA * pfd, const char * sPath, char * sFilename, int sizeofFilename);
Sint         FS__FindFirstFileEx(FS_FIND_DATA * pfd, FS_VOLUME * pVolume, const char * sPath, char * sFilename, int sizeofFilename);
Sint         FS__FindNextFile (FS_FIND_DATA * pfd);
Svoid        FS__FindClose    (FS_FIND_DATA * pfd);
S
Sint         FS__FormatLow      (FS_VOLUME * pVolume);
Svoid        FS__UnmountForced  (FS_VOLUME * pVolume);
Sint         FS__GetVolumeStatus(FS_VOLUME * pVolume);
S
Sint         FS__ReadSector   (FS_VOLUME * pVolume,       void * pData, U32 SectorIndex);
Sint         FS__ReadSectors  (FS_VOLUME * pVolume,       void * pData, U32 SectorIndex, U32 NumSectors);
Sint         FS__WriteSector  (FS_VOLUME * pVolume, const void * pData, U32 SectorIndex);
Sint         FS__WriteSectors (FS_VOLUME * pVolume, const void * pData, U32 SectorIndex, U32 NumSectors);
Sint         FS__GetDeviceInfo(FS_VOLUME * pVolume, FS_DEV_INFO * pDevInfo);
Sint         FS__IsLLFormatted(FS_VOLUME * pVolume);
S
S/*********************************************************************
S*
S*       API-functions, internal (without driver locking)
S*
S*/
Sint         FS__FCloseNL             (FS_FILE   * pFile);
Sint         FS__CACHE_CommandDeviceNL(FS_DEVICE * pDevice, int Cmd, void * pData);
Sint         FS__IoCtlNL              (FS_VOLUME * pVolume, I32 Cmd, I32 Aux, void * Buffer);
Svoid        FS__UnmountForcedNL      (FS_VOLUME * pVolume);
Svoid        FS__UnmountNL            (FS_VOLUME * pVolume);
Sint         FS__MountNL              (FS_VOLUME * pVolume, U8 MountType);
Sint         FS__AutoMountNL          (FS_VOLUME * pVolume);
S
S/*********************************************************************
S*
S*       API-functions, file handle operations
S*
S*/
SFS_FILE * FS__AllocFileHandle(void);
Svoid      FS__FreeFileHandle(FS_FILE * pFile);
S
S/*********************************************************************
S*
S*       API-functions, file object operations
S*
S*/
SFS_FILE_OBJ * FS__AllocFileObj(const char  * sFullFileName);
SFS_FILE_OBJ * FS__GetFileObj  (const char  * sFullFileName);
Svoid          FS__FreeFileObj (FS_FILE_OBJ * pFileObj);
S
S/*********************************************************************
S*
S*       ECC256
S*
S*/
Sint  FS__ECC256_Apply(U32 * pData, U32 eccRead);
SU32  FS__ECC256_Calc (const U32 * pData);
Sint  FS__ECC256_IsValid(U32 ecc);
SU32  FS__ECC256_Load (const U8 * p);
Svoid FS__ECC256_Store(U8 * p, U32 ecc);
S
S/*********************************************************************
S*
S*       Helper functions
S*
S*/
SU32      FS__DivideU32Up            (U32 Nom, U32 Div);
SU32      FS_CRC32_Calc              (const U8* pData, unsigned NumBytes, U32 crc);
Sunsigned FS_BITFIELD_CalcSize       (unsigned NumItems, unsigned BitsPerItem);
Sunsigned FS_BITFIELD_CalcNumBitsUsed(unsigned v);
SU32      FS_BITFIELD_Read           (const void * pBase, unsigned BitOff, unsigned NumBits);
Svoid     FS_BITFIELD_Write          (U8 * pBase, unsigned BitOff, unsigned NumBits, U32 v);
S
S
S/*********************************************************************
S*
S*       Public data
S*
S*/
Sextern FS_FILE       * FS__pFirstFilehandle;
Sextern FS_FILE_OBJ   * FS__pFirstFileObj;
Sextern FS_VOLUME       FS__FirstVolume;
Sextern FS_DIR          FS__aDirHandle  [FS_NUM_DIR_HANDLES];
Sextern U16             FS__MaxSectorSize;
Sextern U8              FS__IsInited;
Sextern int             FS__NumVolumes;
Sextern SECTOR_BUFFER * FS__paSectorBuffer;
Sextern unsigned        FS__NumSectorBuffers;
Sextern char            FS__UpdateDirAfterWrite;
S/*********************************************************************
S*
S*       OS mapping macros (multi tasking locks)
S*
S*
S* Notes
S*   These macros map to locking routines or are empty,
S*   depending on the configuration
S*   There are 3 different lock-levels:
S*   FS_OS == 0                     -> No locking
S*   FS_OS == 1
S*     FS_OS_LOCK_PER_DRIVER == 0     -> Single, global lock in every API function
S*     FS_OS_LOCK_PER_DRIVER == 1     -> Multiple locks
S*
S**********************************************************************
S*/
S
S#if (FS_OS == 0)                               /* No locking */
S  #define FS_LOCK()
S  #define FS_UNLOCK()
S
S  #define FS_LOCK_SYS()
S  #define FS_UNLOCK_SYS()
S
S  #define FS_OS_INIT(MaxNumLocks)
S  #define FS_OS_DEINIT()
S
S
S  #define FS_LOCK_DRIVER(pDriver)
S  #define FS_UNLOCK_DRIVER(pDriver)
S
S  #define FS_OS_ADD_DRIVER(pDevice)
S  #define FS_OS_REMOVE_DRIVER(pDevice)
S
S  #define  FS_OS_GETNUM_DRIVERLOCKS()               0
S  #define  FS_OS_GETNUM_SYSLOCKS()                  0
S
S  #define FS_OS_WAIT(Timeout)                       
S  #define FS_OS_SIGNAL()                            
S
S
S#elif (FS_OS) && (FS_OS_LOCK_PER_DRIVER == 0)    
S  //
S  // Coarse lock granularity: 
S  //   One global lock for all FS API functions
S  //
S
S  #define FS_LOCK_ID_SYSTEM                  0
S
S  #define FS_LOCK()           FS_OS_Lock(FS_LOCK_ID_SYSTEM)
S  #define FS_UNLOCK()         FS_OS_Unlock(FS_LOCK_ID_SYSTEM)
S
S  #define FS_LOCK_SYS()
S  #define FS_UNLOCK_SYS()
S
S  #define FS_LOCK_DRIVER(pDriver)
S  #define FS_UNLOCK_DRIVER(pDriver)
S
S  #define FS_OS_ADD_DRIVER(pDevice)
S  #define FS_OS_REMOVE_DRIVER(pDevice)
S
S  #define  FS_OS_GETNUM_DRIVERLOCKS()               0
S  #define  FS_OS_GETNUM_SYSLOCKS()                  1
S
S  #define FS_OS_INIT(MaxNumLocks)                       FS_OS_Init(MaxNumLocks)
S  #define FS_OS_DEINIT()                                FS_OS_DeInit()
S
S  #define FS_OS_WAIT(Timeout)                           FS_X_OS_Wait(Timeout)
S  #define FS_OS_SIGNAL()                                FS_X_OS_Signal()
S#else
S  //
S  // Fine lock granularity: 
S  //   Lock for different FS functions
S  //
S  #define FS_LOCK_ID_SYSTEM                  0
S  #define FS_LOCK_ID_DEVICE                  1
S
S  #define FS_LOCK()
S  #define FS_UNLOCK()
S
S
S  #define FS_LOCK_SYS()                      FS_OS_Lock  (FS_LOCK_ID_SYSTEM)
S  #define FS_UNLOCK_SYS()                    FS_OS_Unlock(FS_LOCK_ID_SYSTEM)
S
S  #define FS_LOCK_DRIVER(pDevice)            FS_OS_LockDriver(pDevice)
S  #define FS_UNLOCK_DRIVER(pDevice)          FS_OS_UnlockDriver(pDevice)
S  void FS_OS_LockDriver  (const FS_DEVICE * pDevice);
S  void FS_OS_UnlockDriver(const FS_DEVICE * pDevice);
S
S
S  #define  FS_OS_GETNUM_DRIVERLOCKS()               FS_OS_GetNumDriverLocks()
S  #define  FS_OS_GETNUM_SYSLOCKS()                  1
S  unsigned FS_OS_GetNumDriverLocks(void);
S
S  #define FS_OS_ADD_DRIVER(pDevice)         FS_OS_AddDriver(pDevice)
S  void FS_OS_AddDriver(const FS_DEVICE_TYPE * pDriver);
S
S  #define FS_OS_REMOVE_DRIVER(pDevice)              FS_OS_RemoveDriver(pDevice)
S  void FS_OS_RemoveDriver(const FS_DEVICE_TYPE * pDriver);
S
S  #define FS_OS_INIT(MaxNumLocks)                       FS_OS_Init(MaxNumLocks)
S  #define FS_OS_DEINIT()                                FS_OS_DeInit()
S
S  #define FS_OS_WAIT(Timeout)                           FS_X_OS_Wait(Timeout)
S  #define FS_OS_SIGNAL()                                FS_X_OS_Signal()
S#endif
S
Svoid FS_OS_Lock  (unsigned LockIndex);
Svoid FS_OS_Unlock(unsigned LockIndex);
Svoid FS_OS_Init  (unsigned NumLocks);
Svoid FS_OS_DeInit(void);
S
S/*********************************************************************
S*
S*       FS_JOURNAL
S*
S*/
Sint  FS__JOURNAL_Begin     (FS_VOLUME * pVolume);
Sint  FS__JOURNAL_End       (FS_VOLUME * pVolume);
Svoid FS__JOURNAL_Delete    (FS_VOLUME * pVolume, U32 LastSectorInFS);
Svoid FS__JOURNAL_Invalidate(FS_VOLUME * pVolume);
Sint  FS__JOURNAL_Clean     (FS_VOLUME * pVolume);
S
S#if FS_SUPPORT_JOURNAL
S  #define  FS_JOURNAL_BEGIN(pVolume)                  FS__JOURNAL_Begin(pVolume)
S  #define  FS_JOURNAL_END(pVolume)                    FS__JOURNAL_End  (pVolume)
S  #define  FS_JOURNAL_MOUNT(pVolume)                  FS__JOURNAL_Mount(pVolume)
S  #define  FS_JOURNAL_DELETE(pVolume, LastSector)     FS__JOURNAL_Delete(pVolume, LastSector)
S  #define  FS_JOURNAL_INVALIDATE(pVolume)             FS__JOURNAL_Invalidate(pVolume)
S  #define  FS_JOURNAL_CLEAN(pVolume)                  FS__JOURNAL_Clean(pVolume)
S#else
S  #define  FS_JOURNAL_BEGIN(pVolume)                  FS_USE_PARA(pVolume)
S  #define  FS_JOURNAL_END(pVolume)                    FS_USE_PARA(pVolume)
S  #define  FS_JOURNAL_MOUNT(pVolume)
S  #define  FS_JOURNAL_DELETE(pVolume, LastSector)
S  #define  FS_JOURNAL_INVALIDATE(pVolume)
S  #define  FS_JOURNAL_CLEAN(pVolume)
S#endif
S
S#if FS_SUPPORT_DEINIT
S  #define  FS_JOURNAL_DEINIT(pVolume)                 FS__JOURNAL_DeInit(pVolume)
S  void FS_JOURNAL_DeInit(FS_VOLUME * pVolume);
S#else
S  #define  FS_JOURNAL_DEINIT(pVolume)
S#endif
S
S
S/*********************************************************************
S*
S*       MEMORY API
S*
S*       This macro map to the memory free functions of the file system
S*       when deinitialization is enabled.
S*
S**********************************************************************
S*/
S#if FS_SUPPORT_DEINIT
S  #define  FS_FREE(pMem)                 FS_Free(pMem)
S#else
S  #define  FS_FREE(pMem)
S#endif
S
S/*********************************************************************
S*
S*       API mapping macros
S*
S*       These macros map to the functions of the file system (Currently FAT or EFS)
S*       or - in case of multiple file systems - to a mapping layer, which calls the
S*       appropriate function depending on the filesystem of the volume
S*
S**********************************************************************
S*/
S
S#define FS_IOCTL(    pDevice, Cmd, Aux, pBuffer)                FS_LB_Ioctl(pDevice, Cmd, Aux, pBuffer)
S
S#if   (FS_SUPPORT_FAT) && (! FS_SUPPORT_EFS)
S  #define FS_CHECK_INFOSECTOR(pVolume)                                FS_FAT_CheckBPB(pVolume)
S  #define FS_CLOSEDIR(pDir)                                           FS_FAT_CloseDir(pDir);
S  #define FS_CREATEDIR(pVolume, s)                                    FS_FAT_CreateDir(pVolume, s)
S  #define FS_CLOSE_FILE(   hFile)                                     FS_FAT_Close(hFile)
S  #define FS_OPEN_FILE(    s,       pFile, DoDel, DoOpen, DoCreate)   FS_FAT_Open(s, pFile, DoDel, DoOpen, DoCreate)
S  #define FS_FORMAT( pVolume,  pFormatInfo)                           FS_FAT_Format(pVolume, pFormatInfo)
S  #define FS_FREAD(    pFile,   pData, NumBytes)                      FS_FAT_Read(pFile, pData, NumBytes)
S  #define FS_FWRITE(   pFile,   pData, NumBytes)                      FS_FAT_Write(pFile, pData, NumBytes)
S  #define FS_GETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_FAT_GetDirEntryInfo(pVolume, sName, p, Mask)
S  #define FS_GET_DISKINFO(  pVolume, pInfo, Flags)                    FS_FAT_GetDiskInfo(pVolume, pInfo, Flags)
S  #define FS_MOVE(     sSrc,    sDest, pVolume)                       FS_FAT_Move(sSrc, sDest, pVolume)
S  #define FS_OPENDIR(  s,       pDirHandle)                           FS_FAT_OpenDir(s, pDirHandle)
S  #define FS_READDIR(  pDir, pDirEntryInfo)                           FS_FAT_ReadDir(pDir, pDirEntryInfo)
S  #define FS_REMOVEDIR(pVolume, s)                                    FS_FAT_RemoveDir(pVolume, s)
S  #define FS_RENAME(   s,       sNewName, pVolume)                    FS_FAT_Rename(s, sNewName, pVolume)
S  #define FS_SETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_FAT_SetDirEntryInfo(pVolume, sName, p, Mask)
S  #define FS_SET_END_OF_FILE(pFile)                                   FS_FAT_SetEndOfFile(pFile)
S  #define FS_CLEAN_FS(         pVolume)                               FS_FAT_Clean(pVolume)
S  #define FS_GET_VOLUME_LABEL(pVolume, pVolLabel, VolLabelSize)       FS_FAT_GetVolumeLabel(pVolume, pVolLabel, VolLabelSize)
S  #define FS_SET_VOLUME_LABEL(pVolume, pVolLabel)                     FS_FAT_SetVolumeLabel(pVolume, pVolLabel)
S  #define FS_CREATE_JOURNAL_FILE(pVolume, NumBytes, pFirstS, pNumS)   FS_FAT_CreateJournalFile(pVolume, NumBytes, pFirstS, pNumS)
S  #define FS_OPEN_JOURNAL_FILE(pVolume)                               FS_FAT_OpenJournalFile(pVolume)
S  #define FS_GET_INDEX_OF_LAST_SECTOR(pVolume)                        FS_FAT_GetIndexOfLastSector(pVolume)
S  #define FS_CHECKDISK(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError) FS_FAT__CheckDisk(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError)
S  #define FS_UPDATE_FILE(   hFile)                                    FS_FAT_Close(hFile)
S#elif (! FS_SUPPORT_FAT) && (FS_SUPPORT_EFS)
S  #define FS_CHECK_INFOSECTOR(pVolume)                                FS_EFS_CheckInfoSector(pVolume)
S  #define FS_CLOSEDIR( pDir)                                          FS_EFS_CloseDir(pDir)
S  #define FS_CREATEDIR(pVolume, s)                                    FS_EFS_CreateDir(pVolume, s)
S  #define FS_CLOSE_FILE(   hFile)                                     FS_EFS_Close(hFile)
S  #define FS_OPEN_FILE(    s,       pFile, DoDel, DoOpen, DoCreate)   FS_EFS_Open(s, pFile, DoDel, DoOpen, DoCreate)
S  #define FS_FORMAT( pVolume,  pFormatInfo)                           FS_EFS_Format(pVolume, pFormatInfo)
S  #define FS_FREAD(    pFile,   pData, NumBytes)                      FS_EFS_Read(pFile, pData, NumBytes)
S  #define FS_FWRITE(   pFile,   pData, NumBytes)                      FS_EFS_Write(pFile, pData, NumBytes)
S  #define FS_GETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_EFS_GetDirEntryInfo(pVolume, sName, p, Mask)
S  #define FS_GET_DISKINFO(  pVolume, pInfo, Flags)                    FS_EFS_GetDiskInfo(pVolume, pInfo, Flags)
S  #define FS_MOVE(     sSrc,    sDest, pVolume)                       FS_EFS_Move(sSrc, sDest, pVolume)
S  #define FS_OPENDIR(  s,       pDirHandle)                           FS_EFS_OpenDir(s, pDirHandle)
S  #define FS_READDIR(  pDir, pDirEntryInfo)                           FS_EFS_ReadDir(pDir, pDirEntryInfo)
S  #define FS_REMOVEDIR(pVolume, s)                                    FS_EFS_RemoveDir(pVolume, s)
S  #define FS_RENAME(   s,       sNewName, pVolume)                    FS_EFS_Rename(s, sNewName, pVolume)
S  #define FS_SETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_EFS_SetDirEntryInfo(pVolume, sName, p, Mask)
S  #define FS_SET_END_OF_FILE(pFile)                                   FS_EFS_SetEndOfFile(pFile)
S  #define FS_CLEAN_FS(pVolume)                                        FS_EFS_Clean(pVolume)
S  #define FS_GET_VOLUME_LABEL(pVolume, pVolLabel, VolLabelSize)       FS_EFS_GetVolumeLabel(pVolume, pVolLabel, VolLabelSize)
S  #define FS_SET_VOLUME_LABEL(pVolume, pVolLabel)                     FS_EFS_SetVolumeLabel(pVolume, pVolLabel)
S  #define FS_CREATE_JOURNAL_FILE(pVolume, NumBytes, pFirstS, pNumS)   FS_EFS_CreateJournalFile(pVolume, NumBytes, pFirstS, pNumS)
S  #define FS_OPEN_JOURNAL_FILE(pVolume)                               FS_EFS_OpenJournalFile(pVolume)
S  #define FS_GET_INDEX_OF_LAST_SECTOR(pVolume)                        FS_EFS_GetIndexOfLastSector(pVolume)
S  #define FS_CHECKDISK(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError) FS_EFS__CheckDisk(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError)
S  #define FS_UPDATE_FILE(   hFile)                                    FS_EFS_Close(hFile)
S#else
S//#error FS_SUPPORT_MULTIPLE_FS: Multiple simultaneous file systems not yet supported
S  #define FS_CHECK_INFOSECTOR(pVolume)                                FS_MAP_CheckFS_API(pVolume)
S  #define FS_CLOSEDIR( pDir)                                          FS_MAP_CloseDir(pDir)
S  #define FS_CREATEDIR(pVolume, s)                                    FS_MAP_CreateDir(pVolume, s)
S  #define FS_CLOSE_FILE(   hFile)                                     FS_MAP_Close(hFile)
S  #define FS_OPEN_FILE(    s,       pFile, DoDel, DoOpen, DoCreate)   FS_MAP_Open(s, pFile, DoDel, DoOpen, DoCreate)
S  #define FS_FORMAT( pVolume,  pFormatInfo)                           FS_MAP_Format(pVolume, pFormatInfo)
S  #define FS_FREAD(    pFile,   pData, NumBytes)                      FS_MAP_Read(pFile, pData, NumBytes)
S  #define FS_FWRITE(   pFile,   pData, NumBytes)                      FS_MAP_Write(pFile, pData, NumBytes)
S  #define FS_GETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_MAP_GetDirEntryInfo(pVolume, sName, p, Mask)
S  #define FS_GET_DISKINFO(  pVolume, pInfo, Flags)                    FS_MAP_GetDiskInfo(pVolume, pInfo, Flags)
S  #define FS_MOVE(     sSrc,    sDest, pVolume)                       FS_MAP_Move(sSrc, sDest, pVolume)
S  #define FS_OPENDIR(  s,       pDirHandle)                           FS_MAP_OpenDir(s, pDirHandle)
S  #define FS_READDIR(  pDir, pDirEntryInfo)                           FS_MAP_ReadDir(pDir, pDirEntryInfo)
S  #define FS_REMOVEDIR(pVolume, s)                                    FS_MAP_RemoveDir(pVolume, s)
S  #define FS_RENAME(   s,       sNewName, pVolume)                    FS_MAP_Rename(s, sNewName, pVolume)
S  #define FS_SETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_MAP_SetDirEntryInfo(pVolume, sName, p, Mask)
S  #define FS_SET_END_OF_FILE(pFile)                                   FS_MAP_SetEndOfFile(pFile)
S  #define FS_CLEAN_FS(pVolume)                                        FS_MAP_Clean(pVolume)
S  #define FS_GET_VOLUME_LABEL(pVolume, pVolLabel, VolLabelSize)       FS_MAP_GetVolumeLabel(pVolume, pVolLabel, VolLabelSize)
S  #define FS_SET_VOLUME_LABEL(pVolume, pVolLabel)                     FS_MAP_SetVolumeLabel(pVolume, pVolLabel)
S  #define FS_CREATE_JOURNAL_FILE(pVolume, NumBytes, pFirstS, pNumS)   FS_MAP_CreateJournalFile(pVolume, NumBytes, pFirstS, pNumS)
S  #define FS_OPEN_JOURNAL_FILE(pVolume)                               FS_MAP_OpenJournalFile(pVolume)
S  #define FS_GET_INDEX_OF_LAST_SECTOR(pVolume)                        FS_MAP_GetIndexOfLastSector(pVolume)
S  #define FS_CHECKDISK(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError) FS_MAP_CheckDisk(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError)
S  #define FS_UPDATE_FILE(   hFile)                                    FS_MAP_UpdateFile(hFile)
S#endif
S
Svoid        FS_MAP_Close               (FS_FILE    * pFile);
Sint         FS_MAP_CheckFS_API         (FS_VOLUME  * pVolume);
SU32         FS_MAP_Read                (FS_FILE    * pFile,           void  * pData, U32 NumBytes);
SU32         FS_MAP_Write               (FS_FILE    * pFile,     const void  * pData, U32 NumBytes);
Schar        FS_MAP_Open                (const char * pFileName, FS_FILE * pFile, char DoDel, char DoOpen, char DoCreate);
Sint         FS_MAP_Format              (FS_VOLUME  * pVolume,   FS_FORMAT_INFO * pFormatInfo);
Sint         FS_MAP_OpenDir             (const char * pDirName,  FS__DIR *pDir);
Sint         FS_MAP_CloseDir            (FS__DIR    * pDir);
Sint         FS_MAP_ReadDir             (FS__DIR    * pDir,      FS_DIRENTRY_INFO * pDirEntryInfo);
Sint         FS_MAP_RemoveDir           (FS_VOLUME  * pVolume,   const char * pDirName);
Sint         FS_MAP_CreateDir           (FS_VOLUME  * pVolume,   const char * pDirName);
Sint         FS_MAP_Rename              (const char * sOldName,  const char * sNewName, FS_VOLUME * pVolume);
Sint         FS_MAP_Move                (const char * sOldName,  const char * sNewName, FS_VOLUME * pVolume);
Schar        FS_MAP_SetDirEntryInfo     (FS_VOLUME  * pVolume,   const char * sName, const void * p, int Mask);
Schar        FS_MAP_GetDirEntryInfo     (FS_VOLUME  * pVolume,   const char * sName,       void * p, int Mask);
Sint         FS_MAP_SetEndOfFile        (FS_FILE    * pFile);
Svoid        FS_MAP_Clean               (FS_VOLUME  * pVolume);
Sint         FS_MAP_GetDiskInfo         (FS_VOLUME  * pVolume,   FS_DISK_INFO * pDiskData, int Flags);
Sint         FS_MAP_GetVolumeLabel      (FS_VOLUME  * pVolume,   char * pVolumeLabel, unsigned VolumeLabelSize);
Sint         FS_MAP_SetVolumeLabel      (FS_VOLUME  * pVolume,   const char * pVolumeLabel);
Sint         FS_MAP_CreateJournalFile   (FS_VOLUME  * pVolume,   U32 NumBytes, U32 * pFirstSector, U32 * pNumSectors);
Sint         FS_MAP_OpenJournalFile     (FS_VOLUME  * pVolume);
SU32         FS_MAP_GetIndexOfLastSector(FS_VOLUME  * pVolume);
Sint         FS_MAP_CheckDisk           (FS_VOLUME  * pVolume,   FS_DISK_INFO * pDiskInfo, void * pBuffer, U32 BufferSize, int MaxRecursionLevel, FS_QUERY_F_TYPE * pfOnError);
Svoid        FS_MAP_UpdateFile          (FS_FILE    * pFile);
S
S
S
S/*********************************************************************
S*
S*       CLIB
S*
S*   Optional replacements for standard "C" library routines.
S*
S**********************************************************************
S*/
S
Sint            FS__CLIB_atoi    (const char *s);
Sint            FS__CLIB_memcmp  (const void *s1, const void *s2, unsigned n);
Svoid *         FS__CLIB_memset  (void *s, int c, U32 n);
Sint            FS__CLIB_strcmp  (const char *s1, const char *s2);
Schar *         FS__CLIB_strcpy  (char *s1, const char *s2);
Sunsigned       FS__CLIB_strlen  (const char *s);
Sint            FS__CLIB_strncmp (const char *s1, const char *s2, int n);
Schar *         FS__CLIB_strncpy (char *s1, const char *s2, U32 n);
Sint            FS__CLIB_toupper (int c);
Schar *         FS__CLIB_strcat  (char *s1, const char *s2);
Schar *         FS__CLIB_strncat (char *s1, const char *s2, U32 n);
S
S
S#if FS_NO_CLIB
S  #define FS_ATOI(s)             FS__CLIB_atoi(s)
S  #define FS_MEMCMP(s1,s2,n)     FS__CLIB_memcmp(s1,s2,n)
S#ifndef FS_MEMCPY
S  #define FS_MEMCPY(s1,s2,n)     FS_memcpy(s1,s2,n)
S#endif
S  #define FS_MEMSET(s,c,n)       FS__CLIB_memset(s,c,n)
S  #define FS_STRCAT(s1,s2)       FS__CLIB_strcat(s1, s2)
S  #define FS_STRCMP(s1,s2)       FS__CLIB_strcmp(s1,s2)
S  #define FS_STRCPY(s1,s2)       FS__CLIB_strcpy(s1,s2)
S  #define FS_STRLEN(s)           FS__CLIB_strlen(s)
S  #define FS_STRNCAT(s1,s2,n)    FS__CLIB_strncat(s1, s2, n)
S  #define FS_STRNCMP(s1,s2,n)    FS__CLIB_strncmp(s1,s2,n)
S  #define FS_STRNCPY(s1,s2,n)    FS__CLIB_strncpy(s1,s2,n)
S  #define FS_TOUPPER(c)          FS__CLIB_toupper(c)
S#else
S  #define FS_ATOI(s)             atoi(s)
S  #define FS_MEMCMP(s1,s2,n)     memcmp(s1,s2,n)
S#ifndef FS_MEMCPY
S  #ifdef __ICCARM__
S    #define FS_MEMCPY(s1,s2,n)     FS_memcpy(s1,s2,n)
S  #else
S    #define FS_MEMCPY(s1,s2,n)     memcpy(s1,s2,n)
S  #endif
S#endif
S  #define FS_MEMSET(s,c,n)       memset(s,c,n)
S  #define FS_STRCAT(s1,s2)       strcat(s1,s2)
S  #define FS_STRCMP(s1,s2)       strcmp(s1,s2)
S  #define FS_STRCPY(s1,s2)       strcpy(s1,s2)
S  #define FS_STRLEN(s)           strlen(s)
S  #define FS_STRNCAT(s1,s2,n)    strncat(s1, s2, n)
S  #define FS_STRNCMP(s1,s2,n)    strncmp(s1,s2,n)
S  #define FS_STRNCPY(s1,s2,n)    strncpy(s1,s2,n)
S  #define FS_TOUPPER(c)          toupper(c)
S#endif
S
S
S
S/*********************************************************************
S*
S*       FS_LB
S*
S*       Logical block layer
S*
S**********************************************************************
S*/
S
Sint    FS_LB_GetStatus           (FS_DEVICE    * pDevice);
SU16    FS_GetSectorSize          (FS_DEVICE    * pDevice);
Sint    FS_LB_GetDeviceInfo       (FS_DEVICE    * pDevice, FS_DEV_INFO * pDevInfo);
Sint    FS_LB_InitMedium          (FS_DEVICE    * pDevice);
Sint    FS_LB_InitMediumIfRequired(FS_DEVICE    * pDevice);
Sint    FS_LB_Ioctl               (FS_DEVICE    * pDevice, I32 Cmd,         I32 Aux,              void * pBuffer);
Svoid   FS_LB_FreePartSectors     (FS_PARTITION * pPart,   U32 SectorIndex, U32 NumSectors);
Sint    FS_LB_ReadBurst           (FS_PARTITION * pPart,   U32 SectorNo,    U32 NumSectors,       void * pBuffer, U8 Type);
Sint    FS_LB_ReadDevice          (FS_DEVICE    * pDevice, U32 Sector,                            void * pBuffer, U8 Type);
Sint    FS_LB_ReadPart            (FS_PARTITION * pPart,   U32 Sector,                            void * pBuffer, U8 Type);
Sint    FS_LB_WriteBurst          (FS_PARTITION * pPart,   U32 SectorNo,    U32 NumSectors, const void * pBuffer, U8 Type);
Sint    FS_LB_WriteDevice         (FS_DEVICE    * pDevice, U32 Sector,                      const void * pBuffer, U8 Type);
Sint    FS_LB_WritePart           (FS_PARTITION * pPart,   U32 Sector,                      const void * pBuffer, U8 Type);
Sint    FS_LB_WriteMultiple       (FS_PARTITION * pPart,   U32 Sector,      U32 NumSectors, const void * pBuffer, U8 Type);
S
S
S/*********************************************************************
S*
S*       FS_JOURNAL
S*
S*       Journal to make file system layer transaction and fail safe
S*
S**********************************************************************
S*/
S
Sint FS__JOURNAL_Create           (FS_VOLUME * pVolume, U32 FirstSector, U32 NumSectors);
Sint FS__JOURNAL_GetNumFreeSectors(FS_VOLUME * pVolume);
Sint FS__JOURNAL_IsPresent        (FS_VOLUME * pVolume);
Sint FS__JOURNAL_Mount            (FS_VOLUME * pVolume);
Sint FS__JOURNAL_Read             (const FS_DEVICE * pDevice, U32 SectorNo, void * pBuffer, U32 NumSectors);
Sint FS__JOURNAL_Write            (const FS_DEVICE * pDevice, U32 SectorNo, const void * pBuffer, U32 NumSectors, U8 RepeatSame);
Svoid FS__JOURNAL_DeInit          (FS_VOLUME * pVolume);
S
S/*********************************************************************
S*
S*       Public const
S*
S**********************************************************************
S*/
S#if FS_SUPPORT_MULTIPLE_FS
S  extern const FS_FS_API FS_FAT_API;
S  extern const FS_FS_API FS_EFS_API;
S#endif
S
S#if defined(__cplusplus)
S}                /* Make sure we have C-declarations in C++ programs */
S#endif
S
N#endif                // Avoid multiple/recursive inclusion
N
N/*************************** End of file ****************************/
L 22 "FS\FAT.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       FAT_DiskInfo
N*/
Nint  FS_FAT_GetDiskInfo   (FS_VOLUME * pVolume, FS_DISK_INFO * pDiskData, int Flags);
NU32  FS_FAT_GetDiskSpace  (FS_VOLUME * pVolume);
Xunsigned long  FS_FAT_GetDiskSpace  (FS_VOLUME * pVolume);
Nint  FS_FAT_GetVolumeLabel(FS_VOLUME * pVolume, char * pVolumeLabel, unsigned VolumeLabelSize);
Nint  FS_FAT_SetVolumeLabel(FS_VOLUME * pVolume, const char * pVolumeLabel);
N
N/*********************************************************************
N*
N*       FAT_Read
N*/
N
NU32  FS_FAT_Read(FS_FILE *pFile, void *pData, U32 NumBytes);
Xunsigned long  FS_FAT_Read(FS_FILE *pFile, void *pData, unsigned long NumBytes);
N
N
N/*********************************************************************
N*
N*       FAT_Write
N*/
NU32  FS_FAT_Write  (FS_FILE   * pFile, const void *pData, U32 NumBytes);
Xunsigned long  FS_FAT_Write  (FS_FILE   * pFile, const void *pData, unsigned long NumBytes);
Nvoid FS_FAT_Close  (FS_FILE   * pFile);
Nvoid FS_FAT_Clean  (FS_VOLUME * pVolume);
N
N
N/*********************************************************************
N*
N*       FAT_Open
N*/
Nchar FS_FAT_Open   (const char * pFileName, FS_FILE * pFile, char DoDel, char DoOpen, char DoCreate);
N
N/*********************************************************************
N*
N*       FAT_Misc
N*/
Nint  FS_FAT_CheckBPB(FS_VOLUME * pVolume);
Nint  FS_FAT_CreateJournalFile(FS_VOLUME * pVolume, U32 NumClusters, U32 * pFirstSector, U32 * pNumSectors);
Xint  FS_FAT_CreateJournalFile(FS_VOLUME * pVolume, unsigned long NumClusters, unsigned long * pFirstSector, unsigned long * pNumSectors);
Nint  FS_FAT_OpenJournalFile(FS_VOLUME * pVolume);
NU32  FS_FAT_GetIndexOfLastSector(FS_VOLUME * pVolume);
Xunsigned long  FS_FAT_GetIndexOfLastSector(FS_VOLUME * pVolume);
N
N/*********************************************************************
N*
N*       FAT_Format
N*/
Nint  FS_FAT_Format  (FS_VOLUME * pVolume, FS_FORMAT_INFO    * pFormatInfo);
Nint  FS_FAT_FormatEx(FS_VOLUME * pVolume, FS_FORMAT_INFO_EX * pFormatInfoEx);
N
N
N/*********************************************************************
N*
N*       FAT_Move
N*/
Nint   FS_FAT_Move(const char * sOldName, const char * sNewName, FS_VOLUME * pVolume);
N
N
N/*********************************************************************
N*
N*       FS_FAT_DirEntry
N*
N*/
Nchar  FS_FAT_SetDirEntryInfo(FS_VOLUME * pVolume, const char * sName, const void * p, int Mask);
Nchar  FS_FAT_GetDirEntryInfo(FS_VOLUME * pVolume, const char * sName,       void * p, int Mask);
N
N/*********************************************************************
N*
N*       FAT_Rename
N*/
Nint   FS_FAT_Rename(const char * sOldName, const char * sNewName, FS_VOLUME * pVolume);
N
N/*********************************************************************
N*
N*       FAT_Dir
N*/
Nint   FS_FAT_OpenDir  (const char *pDirName, FS__DIR *pDir);
Nint   FS_FAT_CloseDir (FS__DIR *pDir);
Nint   FS_FAT_ReadDir  (FS__DIR *pDir, FS_DIRENTRY_INFO * pDirEntryInfo);
Nint   FS_FAT_RemoveDir(FS_VOLUME * pVolume, const char *pDirName);
Nint   FS_FAT_CreateDir(FS_VOLUME * pVolume, const char *pDirName);
N
N
N/*********************************************************************
N*
N*       FAT_SetEndOfFile
N*
N*/
Nint FS_FAT_SetEndOfFile(FS_FILE * pFile);
N
N/*********************************************************************
N*
N*       FS_FAT_CheckDisk
N*
N*/
Nint FS_FAT__CheckDisk(FS_VOLUME * pVolume, FS_DISK_INFO * pDiskInfo, void * pBuffer, U32 BufferSize, int MaxRecursionLevel, FS_QUERY_F_TYPE * pfOnError);
Xint FS_FAT__CheckDisk(FS_VOLUME * pVolume, FS_DISK_INFO * pDiskInfo, void * pBuffer, unsigned long BufferSize, int MaxRecursionLevel, FS_QUERY_F_TYPE * pfOnError);
N
N#if defined(__cplusplus)
X#if 0L
S}                /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#endif  /* _FS_FAT_H_ */
N
N/*************************** End of file ****************************/
L 33 "FS\FS_Int.h" 2
N#endif
N#if FS_SUPPORT_EFS
X#if 0
S  #include "EFS.h"
N#endif
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N
N
N/*********************************************************************
N*
N*       Global defines
N*
N**********************************************************************
N*/
N#define COUNTOF(a)          (sizeof(a)/sizeof(a[0]))
N#define MIN(a,b)            (((a) < (b)) ? (a) : (b))
N#define MAX(a,b)            (((a) > (b)) ? (a) : (b))
N#define ZEROFILL(p, Size)   (memset(p, 0, Size))
N
N
N#define FS_DISKINFO_FLAG_USE_FREE_SPACE          (1 << 0)
N
N
N/*********************************************************************
N*
N*       Data types
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  int TypeMask;    /* Combination of FS_SECTOR_TYPE_DATA, FS_SECTOR_TYPE_MAN, FS_SECTOR_TYPE_DIR */
N  int ModeMask;    /* Combination of FS_CACHE_MODE_R, FS_CACHE_MODE_W, FS_CACHE_MODE_D */
N} CACHE_MODE;
N
Ntypedef struct {
N  int TypeMask;    /* Combination of FS_SECTOR_TYPE_DATA, FS_SECTOR_TYPE_MAN, FS_SECTOR_TYPE_DIR */
N  int NumSectors;  /* Number of sectors to use for the type(s) specified */
N} CACHE_QUOTA;
N
Ntypedef struct {
N  U32 FirstSector;
X  unsigned long FirstSector;
N  U32 NumSectors;
X  unsigned long NumSectors;
N} CACHE_FREE;
N
N
N/*********************************************************************
N*
N*       FS_INFO
N*
N*  The following structures are related:
N*  The first 3 entries of the structures in the union need to be identical.
N*/
Nstruct FS_FAT_INFO {
N  U32          NumSectors;       // RSVD + FAT + ROOT + FATA
X  unsigned long          NumSectors;       
N  U16          BytesPerSec;      // 512,1024,2048,4096
X  unsigned short          BytesPerSec;      
N  U16          ldBytesPerSector; // 9, 10, 11, 12
X  unsigned short          ldBytesPerSector; 
N  U32          FirstDataSector;
X  unsigned long          FirstDataSector;
N  U32          BytesPerCluster;
X  unsigned long          BytesPerCluster;
N  U32          FATSize;          // Number of FAT sectors
X  unsigned long          FATSize;          
N  U32          RootDirPos;       /* Position of root directory. FAT32: Cluster, FAT12/16: Sector */
X  unsigned long          RootDirPos;        
N  U16          RootEntCnt;       /* number of root dir entries     */
X  unsigned short          RootEntCnt;        
N  U16          RsvdSecCnt;       /* 1 for FAT12 & FAT16            */
X  unsigned short          RsvdSecCnt;        
N  U8           SecPerClus;       /* sec in allocation unit         */
X  unsigned char           SecPerClus;        
N  U8           NumFATs;          /* Typical value is 2             */
X  unsigned char           NumFATs;           
N  U8           FATType;          /* FS_FAT_TYPE_FAT12/16/32        */
X  unsigned char           FATType;           
N  U32          NumClusters;
X  unsigned long          NumClusters;
N  U32          NumFreeClusters;  /* Once known, we keep track of the number of free clusters */
X  unsigned long          NumFreeClusters;   
N  U32          NextFreeCluster;  /* Once known, we keep track of the next free cluster */
X  unsigned long          NextFreeCluster;   
N#if FS_FAT_USE_FSINFO_SECTOR
X#if 1
N  U16          FSInfoSector;
X  unsigned short          FSInfoSector;
N  U16          FSInfoSectorIsInvalidated;
X  unsigned short          FSInfoSectorIsInvalidated;
N#endif
N};
N
Nstruct FS_EFS_INFO {
N  U32          NumSectors;         // RSVD + EFS alloc table + DATA
X  unsigned long          NumSectors;         
N  U16          BytesPerSector;     // 512,1024,2048,4096
X  unsigned short          BytesPerSector;     
N  U16          ldBytesPerSector;   // 9, 10, 11, 12
X  unsigned short          ldBytesPerSector;   
N  U32          FirstDataSector;    // First data cluster -> First Sector after InfoSector, EFSAllocTable.
X  unsigned long          FirstDataSector;    
N  U32          BytesPerCluster;    // Bytes for each cluster: 512 - 32768
X  unsigned long          BytesPerCluster;    
N  U32          EFSTableSize;       // EFS Alloc table size in no. of sectors
X  unsigned long          EFSTableSize;       
N  U32          RootDirPos;         // Cluster that is used for the root directory
X  unsigned long          RootDirPos;         
N  U8           SectorsPerCluster;  // Number of sectors for a cluster
X  unsigned char           SectorsPerCluster;  
N  U32          NumClusters;        // Number of available clusters
X  unsigned long          NumClusters;        
N  U32          NumFreeClusters;    // Once known, we keep track of the number of free clusters
X  unsigned long          NumFreeClusters;    
N  U32          NextFreeCluster;    // Once known, we keep track of the next free cluster
X  unsigned long          NextFreeCluster;    
N};
N
N
Ntypedef union {
N  FS_FAT_INFO  FATInfo;
N  FS_EFS_INFO  EFSInfo;
N  struct {
N    U32          NumSectors;         // RSVD + EFS alloc table + DATA
X    unsigned long          NumSectors;         
N    U16          BytesPerSector;     // 512,1024,2048,4096
X    unsigned short          BytesPerSector;     
N    U16          ldBytesPerSector;   // 9, 10, 11, 12
X    unsigned short          ldBytesPerSector;   
N  } Info;
N} FS_INFO;
N
Ntypedef struct {
N  U8 Unit;
X  unsigned char Unit;
N  U8 IsInited;
X  unsigned char IsInited;
N  U8 JournalIsActive;
X  unsigned char JournalIsActive;
N  U8 JournalUnit;
X  unsigned char JournalUnit;
N#if FS_SUPPORT_CACHE
X#if 1
N  const FS_CACHE_API * pCacheAPI;
N  void               * pCacheData;
N#endif
N#if FS_SUPPORT_BUSY_LED
X#if 1
N  FS_BUSY_LED_CALLBACK * pfSetBusyLED;
N#endif
N#if FS_SUPPORT_CHECK_MEMORY
X#if 0
S  FS_MEMORY_IS_ACCESSIBLE_CALLBACK * pfMemoryIsAccessible;
N#endif
N  FS_ONDEVICEACTIVITYHOOK * pfOnDeviceActivityHook;
N} FS_DEVICE_DATA;
N
Nstruct FS_DEVICE {
N  const FS_DEVICE_TYPE * pType;
N  FS_DEVICE_DATA         Data;
N};
N
Nstruct FS_PARTITION {
N  FS_DEVICE Device;
N  U32       StartSector;
X  unsigned long       StartSector;
N  U32       NumSectors;
X  unsigned long       NumSectors;
N};
N
Ntypedef struct {
N  int   InUse;
N  U32 * pBuffer;
X  unsigned long * pBuffer;
N} SECTOR_BUFFER;
N
N
Ntypedef void        FS_CB_CLOSE               (FS_FILE    * pFile);
Ntypedef int         FS_CB_CHECKFS_API         (FS_VOLUME  * pVolume);
Ntypedef U32         FS_CB_READ                (FS_FILE    * pFile,           void  * pData, U32 NumBytes);
Xtypedef unsigned long         FS_CB_READ                (FS_FILE    * pFile,           void  * pData, unsigned long NumBytes);
Ntypedef U32         FS_CB_WRITE               (FS_FILE    * pFile,     const void  * pData, U32 NumBytes);
Xtypedef unsigned long         FS_CB_WRITE               (FS_FILE    * pFile,     const void  * pData, unsigned long NumBytes);
Ntypedef char        FS_CB_OPEN                (const char * pFileName, FS_FILE * pFile, char DoDel, char DoOpen, char DoCreate);
Ntypedef int         FS_CB_FORMAT              (FS_VOLUME  * pVolume,   FS_FORMAT_INFO * pFormatInfo);
Ntypedef int         FS_CB_OPENDIR             (const char * pDirName,  FS__DIR *pDir);
Ntypedef int         FS_CB_CLOSEDIR            (FS__DIR    * pDir);
Ntypedef int         FS_CB_READDIR             (FS__DIR    * pDir,      FS_DIRENTRY_INFO * pDirEntryInfo);
Ntypedef int         FS_CB_REMOVEDIR           (FS_VOLUME  * pVolume,   const char * pDirName);
Ntypedef int         FS_CB_CREATEDIR           (FS_VOLUME  * pVolume,   const char * pDirName);
Ntypedef int         FS_CB_RENAME              (const char * sOldName,  const char * sNewName, FS_VOLUME * pVolume);
Ntypedef int         FS_CB_MOVE                (const char * sOldName,  const char * sNewName, FS_VOLUME * pVolume);
Ntypedef char        FS_CB_SETDIRENTRYINFO     (FS_VOLUME  * pVolume,   const char * sName, const void * p, int Mask);
Ntypedef char        FS_CB_GETDIRENTRYINFO     (FS_VOLUME  * pVolume,   const char * sName,       void * p, int Mask);
Ntypedef int         FS_CB_SETENDOFFILE        (FS_FILE    * pFile);
Ntypedef void        FS_CB_UNMOUNT             (FS_VOLUME  * pVolume);
N
Ntypedef int         FS_CB_GETDISKINFO         (FS_VOLUME  * pVolume,   FS_DISK_INFO * pDiskData, int Flags);
Ntypedef int         FS_CB_GETVOLUMELABEL      (FS_VOLUME  * pVolume,   char * pVolumeLabel, unsigned VolumeLabelSize);
Ntypedef int         FS_CB_SETVOLUMELABEL      (FS_VOLUME  * pVolume,   const char * pVolumeLabel);
Ntypedef int         FS_CB_CREATEJOURNALFILE   (FS_VOLUME  * pVolume,   U32 NumBytes, U32 * pFirstSector, U32 * pNumSectors);
Xtypedef int         FS_CB_CREATEJOURNALFILE   (FS_VOLUME  * pVolume,   unsigned long NumBytes, unsigned long * pFirstSector, unsigned long * pNumSectors);
Ntypedef int         FS_CB_OPENJOURNALFILE     (FS_VOLUME  * pVolume);
Ntypedef U32         FS_CB_GETINDEXOFLASTSECTOR(FS_VOLUME  * pVolume);
Xtypedef unsigned long         FS_CB_GETINDEXOFLASTSECTOR(FS_VOLUME  * pVolume);
Ntypedef int         FS_CB_CHECKDISK           (FS_VOLUME  * pVolume,   FS_DISK_INFO * pDiskInfo, void * pBuffer, U32 BufferSize, int MaxRecursionLevel, FS_QUERY_F_TYPE * pfOnError);
Xtypedef int         FS_CB_CHECKDISK           (FS_VOLUME  * pVolume,   FS_DISK_INFO * pDiskInfo, void * pBuffer, unsigned long BufferSize, int MaxRecursionLevel, FS_QUERY_F_TYPE * pfOnError);
Ntypedef void        FS_CB_UPDATE_FILE         (FS_FILE    * pFile);
N
Ntypedef struct {
N  FS_CB_CHECKFS_API          * pfCheckBootSector;
N  FS_CB_OPEN                 * pfOpen;
N  FS_CB_CLOSE                * pfClose;
N  FS_CB_READ                 * pfRead;
N  FS_CB_WRITE                * pfWrite;
N  FS_CB_FORMAT               * pfFormat;
N  FS_CB_OPENDIR              * pfOpenDir;
N  FS_CB_CLOSEDIR             * pfCloseDir;
N  FS_CB_READDIR              * pfReadDir;
N  FS_CB_REMOVEDIR            * pfRemoveDir;
N  FS_CB_CREATEDIR            * pfCreateDir;
N  FS_CB_RENAME               * pfRename;
N  FS_CB_MOVE                 * pfMove;
N  FS_CB_SETDIRENTRYINFO      * pfSetDirEntryInfo;
N  FS_CB_GETDIRENTRYINFO      * pfGetDirEntryInfo;
N  FS_CB_SETENDOFFILE         * pfSetEndOfFile;
N  FS_CB_UNMOUNT              * pfUnmount;
N  FS_CB_GETDISKINFO          * pfGetDiskInfo;
N  FS_CB_GETVOLUMELABEL       * pfGetVolumeLabel;
N  FS_CB_SETVOLUMELABEL       * pfSetVolumeLabel;
N  FS_CB_CREATEJOURNALFILE    * pfCreateJournalFile;
N  FS_CB_OPENJOURNALFILE      * pfOpenJournalFile;
N  FS_CB_GETINDEXOFLASTSECTOR * pfGetIndexOfLastSector;
N  FS_CB_CHECKDISK            * pfCheckDisk;
N  FS_CB_UPDATE_FILE          * pfUpdateFile;
N} FS_FS_API;
N
Nstruct FS_VOLUME {
N  FS_PARTITION Partition;
N  FS_INFO      FSInfo;
N  U8           PartitionIndex;
X  unsigned char           PartitionIndex;
N  U8           IsMounted;
X  unsigned char           IsMounted;
N  U8           AllowAutoMount;
X  unsigned char           AllowAutoMount;
N  U8           InUse;
X  unsigned char           InUse;
N#if FS_SUPPORT_MULTIPLE_FS
X#if ((0) && (1))
S  const FS_FS_API * pFS_API;
N#endif
N  FS_VOLUME *  pNext;
N};
N
N/*********************************************************************
N*
N*       Directory types
N*/
Nstruct FS_DIR {
N  FS__DIR     Dir;
N  FS_DIRENT   DirEntry;
N  I16         error;              /* error code                   */
X  signed short         error;               
N  U8          InUse;              /* handle in use mark           */
X  unsigned char          InUse;               
N};
N
N/*********************************************************************
N*
N*       File types
N*/
Ntypedef union {
N    struct {
N      U32      CurClusterFile; /* Current cluster within the file. First cluster is 0, next cluster is 1 ... */
X      unsigned long      CurClusterFile;  
N      U32      CurClusterAbs;  /* Current cluster on the medium. This needs to be computed from file cluster, consulting the FAT */
X      unsigned long      CurClusterAbs;   
N      U32      DirEntrySector; /* Sector of directory */
X      unsigned long      DirEntrySector;  
N      U16      DirEntryIndex;  /* Index of directory entry */
X      unsigned short      DirEntryIndex;   
N      U16      NumAdjClusters; /* Number of cluster that are sequentially in chain behind current one */
X      unsigned short      NumAdjClusters;  
N    } Fat;
N    struct {
N      U32      DirCluster;     /* Start cluster of directory file */
X      unsigned long      DirCluster;      
N      U32      DirEntryPos;    /* Offset of directory entry in directory file */
X      unsigned long      DirEntryPos;     
N      U32      CurClusterFile; /* Current cluster within the file. First cluster is 0, next cluster is 1 ... */
X      unsigned long      CurClusterFile;  
N      U32      CurClusterAbs;  /* Current cluster on the medium. This needs to be computed from file cluster, consulting the FAT */
X      unsigned long      CurClusterAbs;   
N      U16      NumAdjClusters; /* Number of cluster that are sequentially in chain behind current one */
X      unsigned short      NumAdjClusters;  
N    } Efs;
N} FS_INT_DATA;
N
N
Ntypedef struct FS_FILE_OBJ FS_FILE_OBJ;
Ntypedef struct {
N  U8       * pData;
X  unsigned char       * pData;
N  U32        SectorIndex;
X  unsigned long        SectorIndex;
N  unsigned   Off;
N  unsigned   Size;
N} FS_FILE_BUFFER;
N
N
Nstruct FS_FILE_OBJ {      /* Describes the file object structure below the handle */
N  U32           FirstCluster;   /* First cluster used for file  */
X  unsigned long           FirstCluster;    
N  U32           Size;           /* size of file                 */
X  unsigned long           Size;            
N  FS_VOLUME   * pVolume;
N  U8            UseCnt;         /* handle in use mark           */
X  unsigned char            UseCnt;          
N  FS_INT_DATA   Data;
N#if FS_MULTI_HANDLE_SAFE
X#if 0
S  char          acFullFileName[FS_MAX_LEN_FULL_FILE_NAME];
N#endif
N#if FS_USE_FILE_BUFFER
X#if 1
N  FS_FILE_BUFFER * pBuffer;
N#endif
N  FS_FILE_OBJ * pNext;
N};
N
Nstruct FS_FILE { /* Describes the file handle structure */
N  FS_FILE_OBJ * pFileObj;
N  U32           FilePos;        /* current position in file     */
X  unsigned long           FilePos;         
N  I16           Error;          /* error code                   */
X  signed short           Error;           
N  U8            InUse;          /* handle in use mark           */
X  unsigned char            InUse;           
N  U8            AccessFlags;
X  unsigned char            AccessFlags;
N  FS_FILE     * pNext;
N};
N
N/*********************************************************************
N*
N*       Smart buffer (SB) type, internal
N*
N*/
Nstruct FS_SB {
N  U32 SectorNo;
X  unsigned long SectorNo;
N#if FS_MAINTAIN_FAT_COPY
X#if 0
S  U32 WriteCopyOff;  /* Duplicate on write if value is != 0 */
N#endif
N  FS_PARTITION * pPart;
N  U8 *           pBuffer;
X  unsigned char *           pBuffer;
N  char           IsDirty;
N  char           HasError;
N  U8             Type;
X  unsigned char             Type;
N  U8             Read;          /* 1 if data is valid, usually because the sector has been read */
X  unsigned char             Read;           
N};
N
N/*********************************************************************
N*
N*       Partition related
N*/
NU32           FS__GetMediaStartSecEx(FS_VOLUME * pVolume, U32 * pNumSectors, U8* pBuffer);
Xunsigned long           FS__GetMediaStartSecEx(FS_VOLUME * pVolume, unsigned long * pNumSectors, unsigned char* pBuffer);
NU32           FS__GetMediaStartSec(U8 PartIndex, U8 *pBuffer);
Xunsigned long           FS__GetMediaStartSec(unsigned char PartIndex, unsigned char *pBuffer);
Nsigned char   FS__LocatePartition(FS_VOLUME * pVolume);
N
N/*********************************************************************
N*
N*       little endian translation functions, internal
N*/
NU16           FS_LoadU16LE (const U8 *pBuffer);
Xunsigned short           FS_LoadU16LE (const unsigned char *pBuffer);
NU32           FS_LoadU32LE (const U8 *pBuffer);
Xunsigned long           FS_LoadU32LE (const unsigned char *pBuffer);
Nvoid          FS_StoreU16LE(      U8 *pBuffer, unsigned Data);
Xvoid          FS_StoreU16LE(      unsigned char *pBuffer, unsigned Data);
Nvoid          FS_StoreU24LE(      U8 *pBuffer, U32 Data);
Xvoid          FS_StoreU24LE(      unsigned char *pBuffer, unsigned long Data);
Nvoid          FS_StoreU32LE(      U8 *pBuffer, U32 Data);
Xvoid          FS_StoreU32LE(      unsigned char *pBuffer, unsigned long Data);
N
N/*********************************************************************
N*
N*       big endian translation functions, internal
N*/
NU32           FS_LoadU32BE (const U8 *pBuffer);
Xunsigned long           FS_LoadU32BE (const unsigned char *pBuffer);
NU16           FS_LoadU16BE (const U8 *pBuffer);
Xunsigned short           FS_LoadU16BE (const unsigned char *pBuffer);
Nvoid          FS_StoreU32BE(      U8 *pBuffer, U32 Data);
Xvoid          FS_StoreU32BE(      unsigned char *pBuffer, unsigned long Data);
Nvoid          FS_StoreU16BE(      U8 *pBuffer, unsigned Data);
Xvoid          FS_StoreU16BE(      unsigned char *pBuffer, unsigned Data);
N
N
N/*********************************************************************
N*
N*       CACHE API type, internal
N*
N*/
Nstruct FS_CACHE_API {
N  char   (*pfReadFromCache)   (FS_DEVICE * pDevice,      U32 SectorNo,       void * pData, U8  Type);
X  char   (*pfReadFromCache)   (FS_DEVICE * pDevice,      unsigned long SectorNo,       void * pData, unsigned char  Type);
N  char   (*pfUpdateCache)     (FS_DEVICE * pDevice,      U32 SectorNo, const void * pData, U8  Type);    /* Returns 0 if write cached, which means no further write is required */
X  char   (*pfUpdateCache)     (FS_DEVICE * pDevice,      unsigned long SectorNo, const void * pData, unsigned char  Type);     
N  void   (*pfInvalidateCache) (void      * pCacheData);
N  int    (*pfCommand)         (FS_DEVICE * pDevice   ,   int Cmd, void *p);
N  char   (*pfWriteIntoCache)  (FS_DEVICE * pDevice   ,   U32 SectorNo, const void * pData, U8  Type);    /* Returns 0 if write cached, which means no further write is required */
X  char   (*pfWriteIntoCache)  (FS_DEVICE * pDevice   ,   unsigned long SectorNo, const void * pData, unsigned char  Type);     
N
N};
N
N/*********************************************************************
N*
N*       Smart buffer (SB) API-functions, internal
N*
N*/
Nvoid FS__SB_Clean          (FS_SB * pSB);
Nchar FS__SB_Create         (FS_SB * pSB, FS_PARTITION *pPart);
Nvoid FS__SB_Delete         (FS_SB * pSB);
Nvoid FS__SB_Flush          (FS_SB * pSB);
Nvoid FS__SB_MarkDirty      (FS_SB * pSB);
Nvoid FS__SB_MarkValid      (FS_SB * pSB, U32 SectorNo, U8 Type);
Xvoid FS__SB_MarkValid      (FS_SB * pSB, unsigned long SectorNo, unsigned char Type);
Nvoid FS__SB_MarkNotDirty   (FS_SB * pSB);
Nchar FS__SB_Read           (FS_SB * pSB);
Nvoid FS__SB_SetSector      (FS_SB * pSB, U32 SectorNo, U8 Type);
Xvoid FS__SB_SetSector      (FS_SB * pSB, unsigned long SectorNo, unsigned char Type);
Nchar FS__SB_Write          (FS_SB * pSB);
N
N#if FS_MAINTAIN_FAT_COPY
X#if 0
S  void FS__SB_SetWriteCopyOff(FS_SB * pSB, U32 Off);
N#endif
N
N/*********************************************************************
N*
N*       SB-functions, locking and unlocking SB operations
N*
N*/
Nvoid    FS_Lock_SB  (FS_PARTITION * pPart, U32 SectorIndex);
Xvoid    FS_Lock_SB  (FS_PARTITION * pPart, unsigned long SectorIndex);
Nvoid    FS_Unlock_SB(FS_PARTITION * pPart, U32 SectorIndex);
Xvoid    FS_Unlock_SB(FS_PARTITION * pPart, unsigned long SectorIndex);
N
N
N/*********************************************************************
N*
N*       Cache related fucntions, internal
N*
N*/
Nint   FS__CACHE_CommandVolume  (FS_VOLUME * pVolume, int Cmd, void * pData);
Nint   FS__CACHE_CommandDevice  (FS_DEVICE * pDevice, int Cmd, void * pData);
Nvoid  FS__CACHE_CleanNL        (FS_DEVICE * pDevice);
Nvoid  FS__CACHE_Clean          (FS_VOLUME * pVolume);
N
N
N/*********************************************************************
N*
N*       Sector allocation API-functions, internal
N*
N*/
NU8 *  FS__AllocSectorBuffer (void);
Xunsigned char *  FS__AllocSectorBuffer (void);
Nvoid  FS__FreeSectorBuffer  (void * p);
N
N/*********************************************************************
N*
N*       String operation API-functions, internal
N*
N*/
Nvoid           FS_memcpy(void * pDest, const void * pSrc, int NumBytes);
Nconst char *   FS__strchr     (const char *s, int c);
Nvoid           FS__AddSpaceHex(U32 v, U8 Len, char** ps);
Xvoid           FS__AddSpaceHex(unsigned long v, unsigned char Len, char** ps);
N
N/*********************************************************************
N*
N*       Volume API-functions, internal
N*
N*/
NFS_VOLUME * FS__FindVolume     (const char *pFullName, const char ** pFileName);
Nint         FS__Mount          (FS_VOLUME * pVolume, U8 MountType);
Xint         FS__Mount          (FS_VOLUME * pVolume, unsigned char MountType);
Nint         FS__AutoMount      (FS_VOLUME * pVolume);
Nvoid        FS__Unmount        (FS_VOLUME * pVolume);
Nvoid        FS__UnmountLL      (FS_VOLUME * pVolume);
Nvoid        FS__UnmountForcedLL(FS_VOLUME * pVolume);
Nvoid        FS__Sync           (FS_VOLUME * pVolume);
Nvoid        FS__STORAGE_Sync   (FS_VOLUME * pVolume);
N
N/*********************************************************************
N*
N*       API-functions, internal (without Global locking)
N*
N*/
Nint         FS__FClose           (FS_FILE * pFile);
NU32         FS__GetFileSize      (FS_FILE * pFile);
Xunsigned long         FS__GetFileSize      (FS_FILE * pFile);
NU32         FS__Read             (FS_FILE * pFile,       void * pData, U32 NumBytes);
Xunsigned long         FS__Read             (FS_FILE * pFile,       void * pData, unsigned long NumBytes);
NU32         FS__Write            (FS_FILE * pFile, const void * pData, U32 NumBytes);
Xunsigned long         FS__Write            (FS_FILE * pFile, const void * pData, unsigned long NumBytes);
Nint         FS__Verify           (FS_FILE * pFile, const void * pData, U32 NumBytes);
Xint         FS__Verify           (FS_FILE * pFile, const void * pData, unsigned long NumBytes);
Nint         FS__Remove           (const char * pFileName);
NFS_FILE *   FS__FOpen            (const char * pFileName, const char * pMode);
NFS_FILE *   FS__FOpenEx          (const char * pFileName, U8 AccessFlags, char DoCreate, char DoDel, char DoOpen);
XFS_FILE *   FS__FOpenEx          (const char * pFileName, unsigned char AccessFlags, char DoCreate, char DoDel, char DoOpen);
NFS_FILE *   FS__OpenEx           (FS_VOLUME  * pVolume,   const char * sFilePath, U8 AccessFlags, char DoCreate, char DoDel, char DoOpen);
XFS_FILE *   FS__OpenEx           (FS_VOLUME  * pVolume,   const char * sFilePath, unsigned char AccessFlags, char DoCreate, char DoDel, char DoOpen);
N
NU32         FS__CalcSizeInBytes  (U32 NumClusters,   U32 SectorsPerCluster, U32 BytesPerSector);
Xunsigned long         FS__CalcSizeInBytes  (unsigned long NumClusters,   unsigned long SectorsPerCluster, unsigned long BytesPerSector);
NU32         FS__CalcSizeInKB     (U32 NumClusters, U32 SectorsPerCluster, U32 BytesPerSector);
Xunsigned long         FS__CalcSizeInKB     (unsigned long NumClusters, unsigned long SectorsPerCluster, unsigned long BytesPerSector);
N
NFS_VOLUME * FS__AddDevice        (const FS_DEVICE_TYPE * pDevType);
Nint         FS__AddPhysDevice    (const FS_DEVICE_TYPE * pDevType);
N
Nint         FS__IoCtl            (FS_VOLUME * pVolume, I32 Cmd, I32 Aux, void *pBuffer);
Xint         FS__IoCtl            (FS_VOLUME * pVolume, signed long Cmd, signed long Aux, void *pBuffer);
Nint         FS__Format           (FS_VOLUME * pVolume, FS_FORMAT_INFO * pFormatInfo);
Nint         FS__SD_Format        (FS_VOLUME  * pVolume);
Nint         FS__GetNumVolumes    (void);
Nint         FS__CopyFile         (const char * sSource, const char   * sDest);
Nint         FS__GetVolumeInfo    (const char * sVolume, FS_DISK_INFO * pInfo);
Nint         FS__GetVolumeInfoEx  (const char * sVolume, FS_DISK_INFO * pInfo, int Flags);
Nint         FS__CreateDir        (const char * sDir);
Nint         FS__MkDir            (const char * pDirName);
Nint         FS__RmDir            (const char * pDirName);
Nint         FS__FSeek            (FS_FILE *pFile, I32 Offset, int Origin);
Xint         FS__FSeek            (FS_FILE *pFile, signed long Offset, int Origin);
NI32         FS__FTell            (FS_FILE *pFile);
Xsigned long         FS__FTell            (FS_FILE *pFile);
Nint         FS__GetFileTimeEx    (const char * pName, U32 * pTimeStamp, int Index);
Xint         FS__GetFileTimeEx    (const char * pName, unsigned long * pTimeStamp, int Index);
Nint         FS__SetFileTimeEx    (const char * pName, U32   TimeStamp,  int Index);
Xint         FS__SetFileTimeEx    (const char * pName, unsigned long   TimeStamp,  int Index);
Nint         FS__SetFileAttributes(const char * pName, U8    Attributes);
Xint         FS__SetFileAttributes(const char * pName, unsigned char    Attributes);
NU8          FS__GetFileAttributes(const char * pName);
Xunsigned char          FS__GetFileAttributes(const char * pName);
Nint         FS__SetEndOfFile     (FS_FILE    * pFile);
Nvoid        FS__RemoveDevices    (void);
Nvoid        FS__RemoveDevice     (FS_VOLUME * pVolume);
N
NFS_DIR    * FS__OpenDir      (const char *pDirName);
NFS_DIRENT * FS__ReadDir      (FS_DIR *pDir);
Nint         FS__CloseDir     (FS_DIR *pDir);
Nvoid        FS__RewindDir    (FS_DIR *pDir);
Nvoid        FS__DirEnt2Attr  (FS_DIRENT *pDirEnt, U8* pAttr);
Xvoid        FS__DirEnt2Attr  (FS_DIRENT *pDirEnt, unsigned char* pAttr);
NU32         FS__GetNumFiles  (FS_DIR *pDir);
Xunsigned long         FS__GetNumFiles  (FS_DIR *pDir);
Nint         FS__FindFirstFile(FS_FIND_DATA * pfd, const char * sPath, char * sFilename, int sizeofFilename);
Nint         FS__FindFirstFileEx(FS_FIND_DATA * pfd, FS_VOLUME * pVolume, const char * sPath, char * sFilename, int sizeofFilename);
Nint         FS__FindNextFile (FS_FIND_DATA * pfd);
Nvoid        FS__FindClose    (FS_FIND_DATA * pfd);
N
Nint         FS__FormatLow      (FS_VOLUME * pVolume);
Nvoid        FS__UnmountForced  (FS_VOLUME * pVolume);
Nint         FS__GetVolumeStatus(FS_VOLUME * pVolume);
N
Nint         FS__ReadSector   (FS_VOLUME * pVolume,       void * pData, U32 SectorIndex);
Xint         FS__ReadSector   (FS_VOLUME * pVolume,       void * pData, unsigned long SectorIndex);
Nint         FS__ReadSectors  (FS_VOLUME * pVolume,       void * pData, U32 SectorIndex, U32 NumSectors);
Xint         FS__ReadSectors  (FS_VOLUME * pVolume,       void * pData, unsigned long SectorIndex, unsigned long NumSectors);
Nint         FS__WriteSector  (FS_VOLUME * pVolume, const void * pData, U32 SectorIndex);
Xint         FS__WriteSector  (FS_VOLUME * pVolume, const void * pData, unsigned long SectorIndex);
Nint         FS__WriteSectors (FS_VOLUME * pVolume, const void * pData, U32 SectorIndex, U32 NumSectors);
Xint         FS__WriteSectors (FS_VOLUME * pVolume, const void * pData, unsigned long SectorIndex, unsigned long NumSectors);
Nint         FS__GetDeviceInfo(FS_VOLUME * pVolume, FS_DEV_INFO * pDevInfo);
Nint         FS__IsLLFormatted(FS_VOLUME * pVolume);
N
N/*********************************************************************
N*
N*       API-functions, internal (without driver locking)
N*
N*/
Nint         FS__FCloseNL             (FS_FILE   * pFile);
Nint         FS__CACHE_CommandDeviceNL(FS_DEVICE * pDevice, int Cmd, void * pData);
Nint         FS__IoCtlNL              (FS_VOLUME * pVolume, I32 Cmd, I32 Aux, void * Buffer);
Xint         FS__IoCtlNL              (FS_VOLUME * pVolume, signed long Cmd, signed long Aux, void * Buffer);
Nvoid        FS__UnmountForcedNL      (FS_VOLUME * pVolume);
Nvoid        FS__UnmountNL            (FS_VOLUME * pVolume);
Nint         FS__MountNL              (FS_VOLUME * pVolume, U8 MountType);
Xint         FS__MountNL              (FS_VOLUME * pVolume, unsigned char MountType);
Nint         FS__AutoMountNL          (FS_VOLUME * pVolume);
N
N/*********************************************************************
N*
N*       API-functions, file handle operations
N*
N*/
NFS_FILE * FS__AllocFileHandle(void);
Nvoid      FS__FreeFileHandle(FS_FILE * pFile);
N
N/*********************************************************************
N*
N*       API-functions, file object operations
N*
N*/
NFS_FILE_OBJ * FS__AllocFileObj(const char  * sFullFileName);
NFS_FILE_OBJ * FS__GetFileObj  (const char  * sFullFileName);
Nvoid          FS__FreeFileObj (FS_FILE_OBJ * pFileObj);
N
N/*********************************************************************
N*
N*       ECC256
N*
N*/
Nint  FS__ECC256_Apply(U32 * pData, U32 eccRead);
Xint  FS__ECC256_Apply(unsigned long * pData, unsigned long eccRead);
NU32  FS__ECC256_Calc (const U32 * pData);
Xunsigned long  FS__ECC256_Calc (const unsigned long * pData);
Nint  FS__ECC256_IsValid(U32 ecc);
Xint  FS__ECC256_IsValid(unsigned long ecc);
NU32  FS__ECC256_Load (const U8 * p);
Xunsigned long  FS__ECC256_Load (const unsigned char * p);
Nvoid FS__ECC256_Store(U8 * p, U32 ecc);
Xvoid FS__ECC256_Store(unsigned char * p, unsigned long ecc);
N
N/*********************************************************************
N*
N*       Helper functions
N*
N*/
NU32      FS__DivideU32Up            (U32 Nom, U32 Div);
Xunsigned long      FS__DivideU32Up            (unsigned long Nom, unsigned long Div);
NU32      FS_CRC32_Calc              (const U8* pData, unsigned NumBytes, U32 crc);
Xunsigned long      FS_CRC32_Calc              (const unsigned char* pData, unsigned NumBytes, unsigned long crc);
Nunsigned FS_BITFIELD_CalcSize       (unsigned NumItems, unsigned BitsPerItem);
Nunsigned FS_BITFIELD_CalcNumBitsUsed(unsigned v);
NU32      FS_BITFIELD_Read           (const void * pBase, unsigned BitOff, unsigned NumBits);
Xunsigned long      FS_BITFIELD_Read           (const void * pBase, unsigned BitOff, unsigned NumBits);
Nvoid     FS_BITFIELD_Write          (U8 * pBase, unsigned BitOff, unsigned NumBits, U32 v);
Xvoid     FS_BITFIELD_Write          (unsigned char * pBase, unsigned BitOff, unsigned NumBits, unsigned long v);
N
N
N/*********************************************************************
N*
N*       Public data
N*
N*/
Nextern FS_FILE       * FS__pFirstFilehandle;
Nextern FS_FILE_OBJ   * FS__pFirstFileObj;
Nextern FS_VOLUME       FS__FirstVolume;
Nextern FS_DIR          FS__aDirHandle  [FS_NUM_DIR_HANDLES];
Xextern FS_DIR          FS__aDirHandle  [1];
Nextern U16             FS__MaxSectorSize;
Xextern unsigned short             FS__MaxSectorSize;
Nextern U8              FS__IsInited;
Xextern unsigned char              FS__IsInited;
Nextern int             FS__NumVolumes;
Nextern SECTOR_BUFFER * FS__paSectorBuffer;
Nextern unsigned        FS__NumSectorBuffers;
Nextern char            FS__UpdateDirAfterWrite;
N/*********************************************************************
N*
N*       OS mapping macros (multi tasking locks)
N*
N*
N* Notes
N*   These macros map to locking routines or are empty,
N*   depending on the configuration
N*   There are 3 different lock-levels:
N*   FS_OS == 0                     -> No locking
N*   FS_OS == 1
N*     FS_OS_LOCK_PER_DRIVER == 0     -> Single, global lock in every API function
N*     FS_OS_LOCK_PER_DRIVER == 1     -> Multiple locks
N*
N**********************************************************************
N*/
N
N#if (FS_OS == 0)                               /* No locking */
X#if (1 == 0)                                
S  #define FS_LOCK()
S  #define FS_UNLOCK()
S
S  #define FS_LOCK_SYS()
S  #define FS_UNLOCK_SYS()
S
S  #define FS_OS_INIT(MaxNumLocks)
S  #define FS_OS_DEINIT()
S
S
S  #define FS_LOCK_DRIVER(pDriver)
S  #define FS_UNLOCK_DRIVER(pDriver)
S
S  #define FS_OS_ADD_DRIVER(pDevice)
S  #define FS_OS_REMOVE_DRIVER(pDevice)
S
S  #define  FS_OS_GETNUM_DRIVERLOCKS()               0
S  #define  FS_OS_GETNUM_SYSLOCKS()                  0
S
S  #define FS_OS_WAIT(Timeout)                       
S  #define FS_OS_SIGNAL()                            
S
S
N#elif (FS_OS) && (FS_OS_LOCK_PER_DRIVER == 0)    
X#elif (1) && (0 == 0)    
N  //
N  // Coarse lock granularity: 
N  //   One global lock for all FS API functions
N  //
N
N  #define FS_LOCK_ID_SYSTEM                  0
N
N  #define FS_LOCK()           FS_OS_Lock(FS_LOCK_ID_SYSTEM)
N  #define FS_UNLOCK()         FS_OS_Unlock(FS_LOCK_ID_SYSTEM)
N
N  #define FS_LOCK_SYS()
N  #define FS_UNLOCK_SYS()
N
N  #define FS_LOCK_DRIVER(pDriver)
N  #define FS_UNLOCK_DRIVER(pDriver)
N
N  #define FS_OS_ADD_DRIVER(pDevice)
N  #define FS_OS_REMOVE_DRIVER(pDevice)
N
N  #define  FS_OS_GETNUM_DRIVERLOCKS()               0
N  #define  FS_OS_GETNUM_SYSLOCKS()                  1
N
N  #define FS_OS_INIT(MaxNumLocks)                       FS_OS_Init(MaxNumLocks)
N  #define FS_OS_DEINIT()                                FS_OS_DeInit()
N
N  #define FS_OS_WAIT(Timeout)                           FS_X_OS_Wait(Timeout)
N  #define FS_OS_SIGNAL()                                FS_X_OS_Signal()
N#else
S  //
S  // Fine lock granularity: 
S  //   Lock for different FS functions
S  //
S  #define FS_LOCK_ID_SYSTEM                  0
S  #define FS_LOCK_ID_DEVICE                  1
S
S  #define FS_LOCK()
S  #define FS_UNLOCK()
S
S
S  #define FS_LOCK_SYS()                      FS_OS_Lock  (FS_LOCK_ID_SYSTEM)
S  #define FS_UNLOCK_SYS()                    FS_OS_Unlock(FS_LOCK_ID_SYSTEM)
S
S  #define FS_LOCK_DRIVER(pDevice)            FS_OS_LockDriver(pDevice)
S  #define FS_UNLOCK_DRIVER(pDevice)          FS_OS_UnlockDriver(pDevice)
S  void FS_OS_LockDriver  (const FS_DEVICE * pDevice);
S  void FS_OS_UnlockDriver(const FS_DEVICE * pDevice);
S
S
S  #define  FS_OS_GETNUM_DRIVERLOCKS()               FS_OS_GetNumDriverLocks()
S  #define  FS_OS_GETNUM_SYSLOCKS()                  1
S  unsigned FS_OS_GetNumDriverLocks(void);
S
S  #define FS_OS_ADD_DRIVER(pDevice)         FS_OS_AddDriver(pDevice)
S  void FS_OS_AddDriver(const FS_DEVICE_TYPE * pDriver);
S
S  #define FS_OS_REMOVE_DRIVER(pDevice)              FS_OS_RemoveDriver(pDevice)
S  void FS_OS_RemoveDriver(const FS_DEVICE_TYPE * pDriver);
S
S  #define FS_OS_INIT(MaxNumLocks)                       FS_OS_Init(MaxNumLocks)
S  #define FS_OS_DEINIT()                                FS_OS_DeInit()
S
S  #define FS_OS_WAIT(Timeout)                           FS_X_OS_Wait(Timeout)
S  #define FS_OS_SIGNAL()                                FS_X_OS_Signal()
N#endif
N
Nvoid FS_OS_Lock  (unsigned LockIndex);
Nvoid FS_OS_Unlock(unsigned LockIndex);
Nvoid FS_OS_Init  (unsigned NumLocks);
Nvoid FS_OS_DeInit(void);
N
N/*********************************************************************
N*
N*       FS_JOURNAL
N*
N*/
Nint  FS__JOURNAL_Begin     (FS_VOLUME * pVolume);
Nint  FS__JOURNAL_End       (FS_VOLUME * pVolume);
Nvoid FS__JOURNAL_Delete    (FS_VOLUME * pVolume, U32 LastSectorInFS);
Xvoid FS__JOURNAL_Delete    (FS_VOLUME * pVolume, unsigned long LastSectorInFS);
Nvoid FS__JOURNAL_Invalidate(FS_VOLUME * pVolume);
Nint  FS__JOURNAL_Clean     (FS_VOLUME * pVolume);
N
N#if FS_SUPPORT_JOURNAL
X#if 0
S  #define  FS_JOURNAL_BEGIN(pVolume)                  FS__JOURNAL_Begin(pVolume)
S  #define  FS_JOURNAL_END(pVolume)                    FS__JOURNAL_End  (pVolume)
S  #define  FS_JOURNAL_MOUNT(pVolume)                  FS__JOURNAL_Mount(pVolume)
S  #define  FS_JOURNAL_DELETE(pVolume, LastSector)     FS__JOURNAL_Delete(pVolume, LastSector)
S  #define  FS_JOURNAL_INVALIDATE(pVolume)             FS__JOURNAL_Invalidate(pVolume)
S  #define  FS_JOURNAL_CLEAN(pVolume)                  FS__JOURNAL_Clean(pVolume)
N#else
N  #define  FS_JOURNAL_BEGIN(pVolume)                  FS_USE_PARA(pVolume)
N  #define  FS_JOURNAL_END(pVolume)                    FS_USE_PARA(pVolume)
N  #define  FS_JOURNAL_MOUNT(pVolume)
N  #define  FS_JOURNAL_DELETE(pVolume, LastSector)
N  #define  FS_JOURNAL_INVALIDATE(pVolume)
N  #define  FS_JOURNAL_CLEAN(pVolume)
N#endif
N
N#if FS_SUPPORT_DEINIT
X#if 0
S  #define  FS_JOURNAL_DEINIT(pVolume)                 FS__JOURNAL_DeInit(pVolume)
S  void FS_JOURNAL_DeInit(FS_VOLUME * pVolume);
N#else
N  #define  FS_JOURNAL_DEINIT(pVolume)
N#endif
N
N
N/*********************************************************************
N*
N*       MEMORY API
N*
N*       This macro map to the memory free functions of the file system
N*       when deinitialization is enabled.
N*
N**********************************************************************
N*/
N#if FS_SUPPORT_DEINIT
X#if 0
S  #define  FS_FREE(pMem)                 FS_Free(pMem)
N#else
N  #define  FS_FREE(pMem)
N#endif
N
N/*********************************************************************
N*
N*       API mapping macros
N*
N*       These macros map to the functions of the file system (Currently FAT or EFS)
N*       or - in case of multiple file systems - to a mapping layer, which calls the
N*       appropriate function depending on the filesystem of the volume
N*
N**********************************************************************
N*/
N
N#define FS_IOCTL(    pDevice, Cmd, Aux, pBuffer)                FS_LB_Ioctl(pDevice, Cmd, Aux, pBuffer)
N
N#if   (FS_SUPPORT_FAT) && (! FS_SUPPORT_EFS)
X#if   (1) && (! 0)
N  #define FS_CHECK_INFOSECTOR(pVolume)                                FS_FAT_CheckBPB(pVolume)
N  #define FS_CLOSEDIR(pDir)                                           FS_FAT_CloseDir(pDir);
N  #define FS_CREATEDIR(pVolume, s)                                    FS_FAT_CreateDir(pVolume, s)
N  #define FS_CLOSE_FILE(   hFile)                                     FS_FAT_Close(hFile)
N  #define FS_OPEN_FILE(    s,       pFile, DoDel, DoOpen, DoCreate)   FS_FAT_Open(s, pFile, DoDel, DoOpen, DoCreate)
N  #define FS_FORMAT( pVolume,  pFormatInfo)                           FS_FAT_Format(pVolume, pFormatInfo)
N  #define FS_FREAD(    pFile,   pData, NumBytes)                      FS_FAT_Read(pFile, pData, NumBytes)
N  #define FS_FWRITE(   pFile,   pData, NumBytes)                      FS_FAT_Write(pFile, pData, NumBytes)
N  #define FS_GETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_FAT_GetDirEntryInfo(pVolume, sName, p, Mask)
N  #define FS_GET_DISKINFO(  pVolume, pInfo, Flags)                    FS_FAT_GetDiskInfo(pVolume, pInfo, Flags)
N  #define FS_MOVE(     sSrc,    sDest, pVolume)                       FS_FAT_Move(sSrc, sDest, pVolume)
N  #define FS_OPENDIR(  s,       pDirHandle)                           FS_FAT_OpenDir(s, pDirHandle)
N  #define FS_READDIR(  pDir, pDirEntryInfo)                           FS_FAT_ReadDir(pDir, pDirEntryInfo)
N  #define FS_REMOVEDIR(pVolume, s)                                    FS_FAT_RemoveDir(pVolume, s)
N  #define FS_RENAME(   s,       sNewName, pVolume)                    FS_FAT_Rename(s, sNewName, pVolume)
N  #define FS_SETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_FAT_SetDirEntryInfo(pVolume, sName, p, Mask)
N  #define FS_SET_END_OF_FILE(pFile)                                   FS_FAT_SetEndOfFile(pFile)
N  #define FS_CLEAN_FS(         pVolume)                               FS_FAT_Clean(pVolume)
N  #define FS_GET_VOLUME_LABEL(pVolume, pVolLabel, VolLabelSize)       FS_FAT_GetVolumeLabel(pVolume, pVolLabel, VolLabelSize)
N  #define FS_SET_VOLUME_LABEL(pVolume, pVolLabel)                     FS_FAT_SetVolumeLabel(pVolume, pVolLabel)
N  #define FS_CREATE_JOURNAL_FILE(pVolume, NumBytes, pFirstS, pNumS)   FS_FAT_CreateJournalFile(pVolume, NumBytes, pFirstS, pNumS)
N  #define FS_OPEN_JOURNAL_FILE(pVolume)                               FS_FAT_OpenJournalFile(pVolume)
N  #define FS_GET_INDEX_OF_LAST_SECTOR(pVolume)                        FS_FAT_GetIndexOfLastSector(pVolume)
N  #define FS_CHECKDISK(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError) FS_FAT__CheckDisk(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError)
N  #define FS_UPDATE_FILE(   hFile)                                    FS_FAT_Close(hFile)
N#elif (! FS_SUPPORT_FAT) && (FS_SUPPORT_EFS)
S  #define FS_CHECK_INFOSECTOR(pVolume)                                FS_EFS_CheckInfoSector(pVolume)
S  #define FS_CLOSEDIR( pDir)                                          FS_EFS_CloseDir(pDir)
S  #define FS_CREATEDIR(pVolume, s)                                    FS_EFS_CreateDir(pVolume, s)
S  #define FS_CLOSE_FILE(   hFile)                                     FS_EFS_Close(hFile)
S  #define FS_OPEN_FILE(    s,       pFile, DoDel, DoOpen, DoCreate)   FS_EFS_Open(s, pFile, DoDel, DoOpen, DoCreate)
S  #define FS_FORMAT( pVolume,  pFormatInfo)                           FS_EFS_Format(pVolume, pFormatInfo)
S  #define FS_FREAD(    pFile,   pData, NumBytes)                      FS_EFS_Read(pFile, pData, NumBytes)
S  #define FS_FWRITE(   pFile,   pData, NumBytes)                      FS_EFS_Write(pFile, pData, NumBytes)
S  #define FS_GETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_EFS_GetDirEntryInfo(pVolume, sName, p, Mask)
S  #define FS_GET_DISKINFO(  pVolume, pInfo, Flags)                    FS_EFS_GetDiskInfo(pVolume, pInfo, Flags)
S  #define FS_MOVE(     sSrc,    sDest, pVolume)                       FS_EFS_Move(sSrc, sDest, pVolume)
S  #define FS_OPENDIR(  s,       pDirHandle)                           FS_EFS_OpenDir(s, pDirHandle)
S  #define FS_READDIR(  pDir, pDirEntryInfo)                           FS_EFS_ReadDir(pDir, pDirEntryInfo)
S  #define FS_REMOVEDIR(pVolume, s)                                    FS_EFS_RemoveDir(pVolume, s)
S  #define FS_RENAME(   s,       sNewName, pVolume)                    FS_EFS_Rename(s, sNewName, pVolume)
S  #define FS_SETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_EFS_SetDirEntryInfo(pVolume, sName, p, Mask)
S  #define FS_SET_END_OF_FILE(pFile)                                   FS_EFS_SetEndOfFile(pFile)
S  #define FS_CLEAN_FS(pVolume)                                        FS_EFS_Clean(pVolume)
S  #define FS_GET_VOLUME_LABEL(pVolume, pVolLabel, VolLabelSize)       FS_EFS_GetVolumeLabel(pVolume, pVolLabel, VolLabelSize)
S  #define FS_SET_VOLUME_LABEL(pVolume, pVolLabel)                     FS_EFS_SetVolumeLabel(pVolume, pVolLabel)
S  #define FS_CREATE_JOURNAL_FILE(pVolume, NumBytes, pFirstS, pNumS)   FS_EFS_CreateJournalFile(pVolume, NumBytes, pFirstS, pNumS)
S  #define FS_OPEN_JOURNAL_FILE(pVolume)                               FS_EFS_OpenJournalFile(pVolume)
S  #define FS_GET_INDEX_OF_LAST_SECTOR(pVolume)                        FS_EFS_GetIndexOfLastSector(pVolume)
S  #define FS_CHECKDISK(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError) FS_EFS__CheckDisk(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError)
S  #define FS_UPDATE_FILE(   hFile)                                    FS_EFS_Close(hFile)
S#else
S//#error FS_SUPPORT_MULTIPLE_FS: Multiple simultaneous file systems not yet supported
S  #define FS_CHECK_INFOSECTOR(pVolume)                                FS_MAP_CheckFS_API(pVolume)
S  #define FS_CLOSEDIR( pDir)                                          FS_MAP_CloseDir(pDir)
S  #define FS_CREATEDIR(pVolume, s)                                    FS_MAP_CreateDir(pVolume, s)
S  #define FS_CLOSE_FILE(   hFile)                                     FS_MAP_Close(hFile)
S  #define FS_OPEN_FILE(    s,       pFile, DoDel, DoOpen, DoCreate)   FS_MAP_Open(s, pFile, DoDel, DoOpen, DoCreate)
S  #define FS_FORMAT( pVolume,  pFormatInfo)                           FS_MAP_Format(pVolume, pFormatInfo)
S  #define FS_FREAD(    pFile,   pData, NumBytes)                      FS_MAP_Read(pFile, pData, NumBytes)
S  #define FS_FWRITE(   pFile,   pData, NumBytes)                      FS_MAP_Write(pFile, pData, NumBytes)
S  #define FS_GETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_MAP_GetDirEntryInfo(pVolume, sName, p, Mask)
S  #define FS_GET_DISKINFO(  pVolume, pInfo, Flags)                    FS_MAP_GetDiskInfo(pVolume, pInfo, Flags)
S  #define FS_MOVE(     sSrc,    sDest, pVolume)                       FS_MAP_Move(sSrc, sDest, pVolume)
S  #define FS_OPENDIR(  s,       pDirHandle)                           FS_MAP_OpenDir(s, pDirHandle)
S  #define FS_READDIR(  pDir, pDirEntryInfo)                           FS_MAP_ReadDir(pDir, pDirEntryInfo)
S  #define FS_REMOVEDIR(pVolume, s)                                    FS_MAP_RemoveDir(pVolume, s)
S  #define FS_RENAME(   s,       sNewName, pVolume)                    FS_MAP_Rename(s, sNewName, pVolume)
S  #define FS_SETDIRENTRYINFO(pVolume, sName, p, Mask)                 FS_MAP_SetDirEntryInfo(pVolume, sName, p, Mask)
S  #define FS_SET_END_OF_FILE(pFile)                                   FS_MAP_SetEndOfFile(pFile)
S  #define FS_CLEAN_FS(pVolume)                                        FS_MAP_Clean(pVolume)
S  #define FS_GET_VOLUME_LABEL(pVolume, pVolLabel, VolLabelSize)       FS_MAP_GetVolumeLabel(pVolume, pVolLabel, VolLabelSize)
S  #define FS_SET_VOLUME_LABEL(pVolume, pVolLabel)                     FS_MAP_SetVolumeLabel(pVolume, pVolLabel)
S  #define FS_CREATE_JOURNAL_FILE(pVolume, NumBytes, pFirstS, pNumS)   FS_MAP_CreateJournalFile(pVolume, NumBytes, pFirstS, pNumS)
S  #define FS_OPEN_JOURNAL_FILE(pVolume)                               FS_MAP_OpenJournalFile(pVolume)
S  #define FS_GET_INDEX_OF_LAST_SECTOR(pVolume)                        FS_MAP_GetIndexOfLastSector(pVolume)
S  #define FS_CHECKDISK(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError) FS_MAP_CheckDisk(pVolume, pDiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError)
S  #define FS_UPDATE_FILE(   hFile)                                    FS_MAP_UpdateFile(hFile)
N#endif
N
Nvoid        FS_MAP_Close               (FS_FILE    * pFile);
Nint         FS_MAP_CheckFS_API         (FS_VOLUME  * pVolume);
NU32         FS_MAP_Read                (FS_FILE    * pFile,           void  * pData, U32 NumBytes);
Xunsigned long         FS_MAP_Read                (FS_FILE    * pFile,           void  * pData, unsigned long NumBytes);
NU32         FS_MAP_Write               (FS_FILE    * pFile,     const void  * pData, U32 NumBytes);
Xunsigned long         FS_MAP_Write               (FS_FILE    * pFile,     const void  * pData, unsigned long NumBytes);
Nchar        FS_MAP_Open                (const char * pFileName, FS_FILE * pFile, char DoDel, char DoOpen, char DoCreate);
Nint         FS_MAP_Format              (FS_VOLUME  * pVolume,   FS_FORMAT_INFO * pFormatInfo);
Nint         FS_MAP_OpenDir             (const char * pDirName,  FS__DIR *pDir);
Nint         FS_MAP_CloseDir            (FS__DIR    * pDir);
Nint         FS_MAP_ReadDir             (FS__DIR    * pDir,      FS_DIRENTRY_INFO * pDirEntryInfo);
Nint         FS_MAP_RemoveDir           (FS_VOLUME  * pVolume,   const char * pDirName);
Nint         FS_MAP_CreateDir           (FS_VOLUME  * pVolume,   const char * pDirName);
Nint         FS_MAP_Rename              (const char * sOldName,  const char * sNewName, FS_VOLUME * pVolume);
Nint         FS_MAP_Move                (const char * sOldName,  const char * sNewName, FS_VOLUME * pVolume);
Nchar        FS_MAP_SetDirEntryInfo     (FS_VOLUME  * pVolume,   const char * sName, const void * p, int Mask);
Nchar        FS_MAP_GetDirEntryInfo     (FS_VOLUME  * pVolume,   const char * sName,       void * p, int Mask);
Nint         FS_MAP_SetEndOfFile        (FS_FILE    * pFile);
Nvoid        FS_MAP_Clean               (FS_VOLUME  * pVolume);
Nint         FS_MAP_GetDiskInfo         (FS_VOLUME  * pVolume,   FS_DISK_INFO * pDiskData, int Flags);
Nint         FS_MAP_GetVolumeLabel      (FS_VOLUME  * pVolume,   char * pVolumeLabel, unsigned VolumeLabelSize);
Nint         FS_MAP_SetVolumeLabel      (FS_VOLUME  * pVolume,   const char * pVolumeLabel);
Nint         FS_MAP_CreateJournalFile   (FS_VOLUME  * pVolume,   U32 NumBytes, U32 * pFirstSector, U32 * pNumSectors);
Xint         FS_MAP_CreateJournalFile   (FS_VOLUME  * pVolume,   unsigned long NumBytes, unsigned long * pFirstSector, unsigned long * pNumSectors);
Nint         FS_MAP_OpenJournalFile     (FS_VOLUME  * pVolume);
NU32         FS_MAP_GetIndexOfLastSector(FS_VOLUME  * pVolume);
Xunsigned long         FS_MAP_GetIndexOfLastSector(FS_VOLUME  * pVolume);
Nint         FS_MAP_CheckDisk           (FS_VOLUME  * pVolume,   FS_DISK_INFO * pDiskInfo, void * pBuffer, U32 BufferSize, int MaxRecursionLevel, FS_QUERY_F_TYPE * pfOnError);
Xint         FS_MAP_CheckDisk           (FS_VOLUME  * pVolume,   FS_DISK_INFO * pDiskInfo, void * pBuffer, unsigned long BufferSize, int MaxRecursionLevel, FS_QUERY_F_TYPE * pfOnError);
Nvoid        FS_MAP_UpdateFile          (FS_FILE    * pFile);
N
N
N
N/*********************************************************************
N*
N*       CLIB
N*
N*   Optional replacements for standard "C" library routines.
N*
N**********************************************************************
N*/
N
Nint            FS__CLIB_atoi    (const char *s);
Nint            FS__CLIB_memcmp  (const void *s1, const void *s2, unsigned n);
Nvoid *         FS__CLIB_memset  (void *s, int c, U32 n);
Xvoid *         FS__CLIB_memset  (void *s, int c, unsigned long n);
Nint            FS__CLIB_strcmp  (const char *s1, const char *s2);
Nchar *         FS__CLIB_strcpy  (char *s1, const char *s2);
Nunsigned       FS__CLIB_strlen  (const char *s);
Nint            FS__CLIB_strncmp (const char *s1, const char *s2, int n);
Nchar *         FS__CLIB_strncpy (char *s1, const char *s2, U32 n);
Xchar *         FS__CLIB_strncpy (char *s1, const char *s2, unsigned long n);
Nint            FS__CLIB_toupper (int c);
Nchar *         FS__CLIB_strcat  (char *s1, const char *s2);
Nchar *         FS__CLIB_strncat (char *s1, const char *s2, U32 n);
Xchar *         FS__CLIB_strncat (char *s1, const char *s2, unsigned long n);
N
N
N#if FS_NO_CLIB
X#if 0
S  #define FS_ATOI(s)             FS__CLIB_atoi(s)
S  #define FS_MEMCMP(s1,s2,n)     FS__CLIB_memcmp(s1,s2,n)
S#ifndef FS_MEMCPY
S  #define FS_MEMCPY(s1,s2,n)     FS_memcpy(s1,s2,n)
S#endif
S  #define FS_MEMSET(s,c,n)       FS__CLIB_memset(s,c,n)
S  #define FS_STRCAT(s1,s2)       FS__CLIB_strcat(s1, s2)
S  #define FS_STRCMP(s1,s2)       FS__CLIB_strcmp(s1,s2)
S  #define FS_STRCPY(s1,s2)       FS__CLIB_strcpy(s1,s2)
S  #define FS_STRLEN(s)           FS__CLIB_strlen(s)
S  #define FS_STRNCAT(s1,s2,n)    FS__CLIB_strncat(s1, s2, n)
S  #define FS_STRNCMP(s1,s2,n)    FS__CLIB_strncmp(s1,s2,n)
S  #define FS_STRNCPY(s1,s2,n)    FS__CLIB_strncpy(s1,s2,n)
S  #define FS_TOUPPER(c)          FS__CLIB_toupper(c)
N#else
N  #define FS_ATOI(s)             atoi(s)
N  #define FS_MEMCMP(s1,s2,n)     memcmp(s1,s2,n)
N#ifndef FS_MEMCPY
N  #ifdef __ICCARM__
S    #define FS_MEMCPY(s1,s2,n)     FS_memcpy(s1,s2,n)
N  #else
N    #define FS_MEMCPY(s1,s2,n)     memcpy(s1,s2,n)
N  #endif
N#endif
N  #define FS_MEMSET(s,c,n)       memset(s,c,n)
N  #define FS_STRCAT(s1,s2)       strcat(s1,s2)
N  #define FS_STRCMP(s1,s2)       strcmp(s1,s2)
N  #define FS_STRCPY(s1,s2)       strcpy(s1,s2)
N  #define FS_STRLEN(s)           strlen(s)
N  #define FS_STRNCAT(s1,s2,n)    strncat(s1, s2, n)
N  #define FS_STRNCMP(s1,s2,n)    strncmp(s1,s2,n)
N  #define FS_STRNCPY(s1,s2,n)    strncpy(s1,s2,n)
N  #define FS_TOUPPER(c)          toupper(c)
N#endif
N
N
N
N/*********************************************************************
N*
N*       FS_LB
N*
N*       Logical block layer
N*
N**********************************************************************
N*/
N
Nint    FS_LB_GetStatus           (FS_DEVICE    * pDevice);
NU16    FS_GetSectorSize          (FS_DEVICE    * pDevice);
Xunsigned short    FS_GetSectorSize          (FS_DEVICE    * pDevice);
Nint    FS_LB_GetDeviceInfo       (FS_DEVICE    * pDevice, FS_DEV_INFO * pDevInfo);
Nint    FS_LB_InitMedium          (FS_DEVICE    * pDevice);
Nint    FS_LB_InitMediumIfRequired(FS_DEVICE    * pDevice);
Nint    FS_LB_Ioctl               (FS_DEVICE    * pDevice, I32 Cmd,         I32 Aux,              void * pBuffer);
Xint    FS_LB_Ioctl               (FS_DEVICE    * pDevice, signed long Cmd,         signed long Aux,              void * pBuffer);
Nvoid   FS_LB_FreePartSectors     (FS_PARTITION * pPart,   U32 SectorIndex, U32 NumSectors);
Xvoid   FS_LB_FreePartSectors     (FS_PARTITION * pPart,   unsigned long SectorIndex, unsigned long NumSectors);
Nint    FS_LB_ReadBurst           (FS_PARTITION * pPart,   U32 SectorNo,    U32 NumSectors,       void * pBuffer, U8 Type);
Xint    FS_LB_ReadBurst           (FS_PARTITION * pPart,   unsigned long SectorNo,    unsigned long NumSectors,       void * pBuffer, unsigned char Type);
Nint    FS_LB_ReadDevice          (FS_DEVICE    * pDevice, U32 Sector,                            void * pBuffer, U8 Type);
Xint    FS_LB_ReadDevice          (FS_DEVICE    * pDevice, unsigned long Sector,                            void * pBuffer, unsigned char Type);
Nint    FS_LB_ReadPart            (FS_PARTITION * pPart,   U32 Sector,                            void * pBuffer, U8 Type);
Xint    FS_LB_ReadPart            (FS_PARTITION * pPart,   unsigned long Sector,                            void * pBuffer, unsigned char Type);
Nint    FS_LB_WriteBurst          (FS_PARTITION * pPart,   U32 SectorNo,    U32 NumSectors, const void * pBuffer, U8 Type);
Xint    FS_LB_WriteBurst          (FS_PARTITION * pPart,   unsigned long SectorNo,    unsigned long NumSectors, const void * pBuffer, unsigned char Type);
Nint    FS_LB_WriteDevice         (FS_DEVICE    * pDevice, U32 Sector,                      const void * pBuffer, U8 Type);
Xint    FS_LB_WriteDevice         (FS_DEVICE    * pDevice, unsigned long Sector,                      const void * pBuffer, unsigned char Type);
Nint    FS_LB_WritePart           (FS_PARTITION * pPart,   U32 Sector,                      const void * pBuffer, U8 Type);
Xint    FS_LB_WritePart           (FS_PARTITION * pPart,   unsigned long Sector,                      const void * pBuffer, unsigned char Type);
Nint    FS_LB_WriteMultiple       (FS_PARTITION * pPart,   U32 Sector,      U32 NumSectors, const void * pBuffer, U8 Type);
Xint    FS_LB_WriteMultiple       (FS_PARTITION * pPart,   unsigned long Sector,      unsigned long NumSectors, const void * pBuffer, unsigned char Type);
N
N
N/*********************************************************************
N*
N*       FS_JOURNAL
N*
N*       Journal to make file system layer transaction and fail safe
N*
N**********************************************************************
N*/
N
Nint FS__JOURNAL_Create           (FS_VOLUME * pVolume, U32 FirstSector, U32 NumSectors);
Xint FS__JOURNAL_Create           (FS_VOLUME * pVolume, unsigned long FirstSector, unsigned long NumSectors);
Nint FS__JOURNAL_GetNumFreeSectors(FS_VOLUME * pVolume);
Nint FS__JOURNAL_IsPresent        (FS_VOLUME * pVolume);
Nint FS__JOURNAL_Mount            (FS_VOLUME * pVolume);
Nint FS__JOURNAL_Read             (const FS_DEVICE * pDevice, U32 SectorNo, void * pBuffer, U32 NumSectors);
Xint FS__JOURNAL_Read             (const FS_DEVICE * pDevice, unsigned long SectorNo, void * pBuffer, unsigned long NumSectors);
Nint FS__JOURNAL_Write            (const FS_DEVICE * pDevice, U32 SectorNo, const void * pBuffer, U32 NumSectors, U8 RepeatSame);
Xint FS__JOURNAL_Write            (const FS_DEVICE * pDevice, unsigned long SectorNo, const void * pBuffer, unsigned long NumSectors, unsigned char RepeatSame);
Nvoid FS__JOURNAL_DeInit          (FS_VOLUME * pVolume);
N
N/*********************************************************************
N*
N*       Public const
N*
N**********************************************************************
N*/
N#if FS_SUPPORT_MULTIPLE_FS
X#if ((0) && (1))
S  extern const FS_FS_API FS_FAT_API;
S  extern const FS_FS_API FS_EFS_API;
N#endif
N
N#if defined(__cplusplus)
X#if 0L
S}                /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#endif                // Avoid multiple/recursive inclusion
N
N/*************************** End of file ****************************/
L 28 "FS\FS_X_embOS.c" 2
N#include "FS_OS.h"
N
N#include "RTOS.h"
L 1 "OS\RTOS.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : RTOS.h
NPurpose : include file for embOS,
N          to be included in every C-module accessing embOS-routines
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef RTOS_H_INCLUDED        /* Avoid multiple inclusion          */
N#define RTOS_H_INCLUDED
N
N/*********************************************************************
N*
N*       Chip specifics for ARM7TDMI / ARM9TDMI and KEIL ARM MDK
N*
N**********************************************************************
N*/
N
N#include <string.h>                            /* req. for memset.h */
N
N/*********************************************************************
N*
N*     Specifics for ARM cores and KEIL-MDK compiler
N*
N**********************************************************************
N*/
N
N#define OS_PORT_REVISION          (1)                // Port specific revision
N#define OS_PTR_OP_IS_ATOMIC       (1)
N#define OS_GetTime()              (OS_Time)
N#define OS_GetTime32()            (OS_Time)
N#define OS_I32                    int
N#define OS_SIZEOF_INT             (4)                // Size of integer in bytes
N#define OS_BIG_ENDIAN             (0)                
N#define OS_SUPPORT_SYSSTACK_INFO  (1)                // Option to supply more info  to viewer
N#define OS_SUPPORT_OS_ALLOC       (1)                // Define whether OS_Alloc is supported
N#define OS_SP_ADJUST              (0)
N#define OS_EnterIntStack()                           // Int stack is automatically used by ARM
N#define OS_LeaveIntStack()                           // Int stack is automatically used by ARM
N
N/*****  Core specific configuration *********************************/
N
N#define OS_SUPPORT_INTSTACK_INFO            (1)      // Option to supply more info  to viewer
N#define OS_SWITCH_FROM_INT_MODIFIES_STACK   (1)
N#define OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY (0)
N#define OS_SUPPORT_INT_PRIORITY             (0)              // No selectable interrupt priorities with ARM
N
N/*****  End of configuration settings *******************************/
N
N#ifdef __TARGET_ARCH_4T
N  #define OS_CPU "ARM4/KEIL_MDK"
N#else
S  #define OS_CPU "ARM5/KEIL_MDK"
N#endif
N
N#define OS_DI() __disable_irq()    /* We use the default intrinsic function */
N#define OS_EI() __enable_irq()     /* We use the default intrinsic function */
N
N
N/* Option to get Stack pointer information  */
N#define OS_INIT_STACK_INFO()
N
N/*********************************************************************
N*
N*       Port specific (non OS generic) functions
N*/
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N  typedef void    OS_ISR_HANDLER(void);
N  void            OS_irq_handler(void);     /* Declare function to make sure it is arm pcs */
N  void            OS_IRQ_SERVICE(void);     /* embOS int handler in RTOSVect.asm  */
N  void            OS_USER_irq_func(void);   /* User interrupt handler from UserIrq.c */
N  OS_ISR_HANDLER* OS_ARM_InstallISRHandler (int ISRIndex, OS_ISR_HANDLER* pFunc);
N  void            OS_ARM_EnableISR         (int ISRIndex);
N  void            OS_ARM_DisableISR        (int ISRIndex);
N  int             OS_ARM_ISRSetPrio        (int ISRIndex, int Prio);
N  void            OS_ARM_AssignISRSource   (int ISRIndex, int Source);
N  void            OS_ARM_EnableISRSource   (int SourceIndex);
N  void            OS_ARM_DisableISRSource  (int SourceIndex);
N  void            OS_StartTask             (void);
N  void            OS_InitPLL               (void);
N
N/*********************************************************************
N*
N*       Core specific implementation
N*/
N
N/****** Support for ARM VFP *****************************************/
N  
Nextern const struct OS_EXTEND_TASK_CONTEXT OS_VFP_ExtendContext;
N
N/****** Support for ARM MMU and caches ******************************/
N
Nvoid OS_ARM_ICACHE_Enable(void);
Nvoid OS_ARM_DCACHE_Enable(void);
Nvoid OS_ARM_DCACHE_CleanRange     (void* p, unsigned int NumBytes);
Nvoid OS_ARM_DCACHE_InvalidateRange(void* p, unsigned int NumBytes);
Nvoid OS_ARM_CACHE_Sync(void);
N
Nvoid OS_ARM_MMU_Enable(unsigned int* pTranslationTable);
Nvoid OS_ARM_MMU_InitTT(unsigned int* pTranslationTable);
Nvoid OS_ARM_MMU_AddTTEntries(unsigned int* pTranslationTable, unsigned int CacheMode, unsigned int VIndex, unsigned int PIndex, unsigned int NumEntries);
N
Nvoid OS_ARM720_CACHE_Enable(void);
Nvoid OS_ARM720_CACHE_CleanRange(void* p, unsigned int NumBytes);
Nvoid OS_ARM720_CACHE_InvalidateRange(void* p, unsigned int NumBytes);
N
Nvoid OS_ARM720_MMU_Enable(unsigned int* pTranslationTable);
Nvoid OS_ARM720_MMU_InitTT(unsigned int* pTranslationTable);
Nvoid OS_ARM720_MMU_AddTTEntries(unsigned int* pTranslationTable, unsigned int CacheMode, unsigned int VIndex, unsigned int PIndex, unsigned int NumEntries);
N
N#define OS_ARM_CACHEMODE_NC_NB    ((0 << 3) | (0 << 2))
N#define OS_ARM_CACHEMODE_C_NB     ((1 << 3) | (0 << 2))
N#define OS_ARM_CACHEMODE_NC_B     ((0 << 3) | (1 << 2))
N#define OS_ARM_CACHEMODE_C_B      ((1 << 3) | (1 << 2))
N#define OS_ARM_CACHEMODE_ILLEGAL  (0x01)
N
N#ifdef __cplusplus
S  } 
N#endif
N
N/*********************************************************************
N*
N*     Port specific revision
N*/
N
N/*********************************************************************
N*
N*       Check configuration
N*
N**********************************************************************
N
NThis is required in order to automatically create the correct identifiers
Nin order to be able to autoamitcally remap the identifiers.
N
N*/
N
N#ifdef __thumb
N  #define OS_CPUMODE_PREFIX "T"
N#else
S  #define OS_CPUMODE_PREFIX "A"
N#endif
N
N#ifdef __TARGET_ARCH_4T
N  #define OS_CPU_PREFIX "4"
N#else
S  #define OS_CPU_PREFIX "5"
N#endif
N
N#ifdef __BIG_ENDIAN
S  #define OS_ENDIAN_PREFIX "B"
N#else
N  #define OS_ENDIAN_PREFIX "L"
N#endif
N
N#define OS_MODEL OS_CPUMODE_PREFIX OS_CPU_PREFIX OS_ENDIAN_PREFIX
N
N
N/****** End of chip / compiler specific part ************************/
N
N/*********************************************************************
N*
N*       Generic portion of the OS starts here
N*
N**********************************************************************
NThis file (original name OS_RAW.h) is part of RTOS.h, the include
Nfile for the OS.
N*/
N
N#if (!defined(OS_LIBMODE_XR) && !defined(OS_LIBMODE_R)  &&   \
N     !defined(OS_LIBMODE_S)  && !defined(OS_LIBMODE_SP) &&   \
N     !defined(OS_LIBMODE_D)  && !defined(OS_LIBMODE_DP) &&   \
N     !defined(OS_LIBMODE_DT))
X#if (!0L && !0L  &&        !0L  && !0L &&        !0L  && !0L &&        !0L)
N#include "OS_Config.h"
L 1 "Config\OS_Config.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef OS_CONFIG_H                     /* Avoid multiple inclusion */
N#define OS_CONFIG_H
N
N/*********************************************************************
N*
N*       Configuration for RTOS build and UART
N*
N*  One of the following builds needs to be selected for both DEBUG and Release builds:
N*
N*  OS_LIBMODE_XR    Extremly small release build without Round robin
N*  OS_LIBMODE_R     Release build
N*  OS_LIBMODE_S     Release build with stack check
N*  OS_LIBMODE_SP    Release build with stack check and profiling
N*  OS_LIBMODE_D     Debug build
N*  OS_LIBMODE_DP    Debug build with profiling
N*  OS_LIBMODE_DT    Debug build with trace
N*/
N
N#ifndef   DEBUG
N  #define DEBUG 0
N#endif
N
N#if DEBUG
X#if 0
S  #define OS_LIBMODE_DP
N#else
N  #define OS_LIBMODE_R
N  #define OS_VIEW_ENABLE   0
N#endif
N
N#endif                                  /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 187 "OS\RTOS.h" 2
N#endif
N
N#define OS_VERSION_GENERIC (36004)      /*   Generic version 3.60d  */
N
N#ifndef   OS_PORT_REVISION
S  #define OS_PORT_REVISION 0
N#endif
N
N#define OS_VERSION OS_VERSION_GENERIC + (OS_PORT_REVISION * 25)
N
N/*********************************************************************
N*
N*       Defines for library types
N*
N**********************************************************************
N*/
N
N/* If library type is not selected yet (on project level,
N   for example), then select DP by default
N*/
N#if (!defined(OS_LIBMODE_XR) && !defined(OS_LIBMODE_R)  &&   \
N     !defined(OS_LIBMODE_S)  && !defined(OS_LIBMODE_SP) &&   \
N     !defined(OS_LIBMODE_D)  && !defined(OS_LIBMODE_DP) &&   \
N     !defined(OS_LIBMODE_DT))
X#if (!0L && !1L  &&        !0L  && !0L &&        !0L  && !0L &&        !0L)
S#define OS_LIBMODE_DP
N#endif
N
N#if defined(OS_LIBMODE_XR)                                   // Extremely small release - without Round robin support
X#if 0L                                   
S  #define OS_CHECKSTACK       0
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_RR_SUPPORTED     0
S  #define OS_TRACKNAME        0
S  #define OS_SUPPORT_SAVE_RESTORE_HOOK 0
S  #define OS_CreateTask   OS_CreateTask_XR
S  #define OS_CreateTaskEx OS_CreateTaskEx_XR
S  #define OS_LIBMODE "XR"
N#elif defined(OS_LIBMODE_R)                                  // Release build
X#elif 1L                                  
N  #define OS_CHECKSTACK       0
N  #define OS_DEBUG            0
N  #define OS_PROFILE          0
N  #define OS_SUPPORT_TICKSTEP 0
N  #define OS_TRACE            0
N  #define OS_CreateTask   OS_CreateTask_R
N  #define OS_CreateTaskEx OS_CreateTaskEx_R
N  #define OS_LIBMODE "R"
N#elif defined(OS_LIBMODE_S)                                  // Release build with stack check
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_S
S  #define OS_CreateTaskEx OS_CreateTaskEx_S
S  #define OS_LIBMODE "S"
S#elif defined(OS_LIBMODE_SP)                                 // Release build with stack check and profiling
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            0
S  #define OS_PROFILE          1
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_SP
S  #define OS_CreateTaskEx OS_CreateTaskEx_SP
S  #define OS_LIBMODE "SP"
S#elif defined(OS_LIBMODE_D)                                  // Debug build
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            1
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_D
S  #define OS_CreateTaskEx OS_CreateTaskEx_D
S  #define OS_LIBMODE "D"
S#elif defined(OS_LIBMODE_DP)                                  // Debug build with profiling
S  #define OS_CHECKSTACK       1
S  #define OS_PROFILE          1
S  #define OS_DEBUG            1
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_DP
S  #define OS_CreateTaskEx OS_CreateTaskEx_DP
S  #define OS_LIBMODE "DP"
S#elif defined(OS_LIBMODE_DT)                                  // Debug build with profiling and trace
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            1
S  #define OS_PROFILE          1
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            1
S  #define OS_CreateTask   OS_CreateTask_DT
S  #define OS_CreateTaskEx OS_CreateTaskEx_DT
S  #define OS_LIBMODE "DT"
S#else
S  #error Please define library type used !
N#endif
N
N/*********************************************************************
N*
N*       OS compile time switches
N*
N**********************************************************************
N
NThese compile time switches can be modified when recompiling
Nthe library. Usually, the values are in OSCHIP.H, which is then
Nmerged with OS_RAW.H to form RTOS.H.
NIf the values are not defined in OSCHIP.H, the default values
Nbelow are used.
N*/
N
N/* Make it possible to place const data in RAM via
N   define and therefore via command line. This is required
N   for some smaller CPUs in small memory models
N   It is defined to be "const" by default, but can be defined to nothing
N   by simply adding a -DOS_CONST_DATA on the commandline
N*/
N
N#ifndef   OS_CONST_DATA
N  #define OS_CONST_DATA const  /* Default      */
N#else
S  #undef  OS_CONST_DATA
S  #define OS_CONST_DATA        /* define blank */
N#endif
N
N#ifndef   OS_INTERWORK
N  #define OS_INTERWORK
N#endif
N
N#ifndef   OS_SCHEDULER_ACTIVATED_BY_EXCEPTION
N  #define OS_SCHEDULER_ACTIVATED_BY_EXCEPTION   (0)
N#endif
N
N#ifndef   OS_STACK_ADR
N  #define OS_STACK_ADR OS_U32
N#endif
N
N#ifndef   OS_MODEL
S  #define OS_MODEL ""
N#endif
N
N#ifndef   OS_MEMSET
N  #define OS_MEMSET(a,v,s) memset(a,v,s)
N#endif
N
N#ifndef   OS_MEMCPY
N  #define OS_MEMCPY(dest,src,cnt) memcpy(dest,src,cnt)
N#endif
N
N#ifndef   OS_STRLEN
N  #define OS_STRLEN(s) strlen(s)
N#endif
N
N#ifndef   OS_DUMMY_STATEMENT
N  #define OS_DUMMY_STATEMENT()
N#endif
N
N#ifndef   OS_USEPARA
N  #define OS_USEPARA(para) para=para
N#endif
N
N#ifndef   OS_SUPPORT_TICKSTEP
S  #define OS_SUPPORT_TICKSTEP 0
N#endif
N
N#ifndef   OS_TRACKNAME
N  #define OS_TRACKNAME (1)
N#endif
N
N#ifndef   OS_TRACE
S  #define OS_TRACE (0)
N#endif
N
N#ifndef   OS_SUPPORT_SAVE_RESTORE_HOOK
N  #define OS_SUPPORT_SAVE_RESTORE_HOOK  (1)
N#endif
N
N#ifndef   OS_RR_SUPPORTED
N  #define OS_RR_SUPPORTED (1)
N#endif
N
N#ifndef   OS_STACK_AT_BOTTOM
N  #define OS_STACK_AT_BOTTOM (0)
N#endif
N
N/*  Settings for NON-ANSI compiler syntax
N    The default behaviour complies with IAR.
N*/
N#ifndef   OS_COMPILER_LOCATION_LEFT
N  #define OS_COMPILER_LOCATION_LEFT 1  /* (req. for IAR) */
N#endif
N
N#ifndef   OS_COMPILER_STORAGE_MODIFIER_LEFT
N  #define OS_COMPILER_STORAGE_MODIFIER_LEFT 1  /* default for all except KEIL */
N#endif
N
N#define OS_LINK_MAILBOXES (OS_DEBUG)
N
N#ifndef   OS_CHECK
N  #define OS_CHECK 0
N#endif
N
N#ifndef   OS_ALIGN_PTR
N  #define OS_ALIGN_PTR (1)
N#endif
N
N#ifndef   OS_ALIGN_INT
N  #define OS_ALIGN_INT (1)
N#endif
N
N#ifndef   OS_PTR_TO_VALUE
N  #define OS_PTR_TO_VALUE(p) (p)
N#endif
N
N#ifndef   OS_IDLE
N  #define OS_IDLE() OS_Idle()
N#endif
N
N#ifndef   OS_PTR_OP_IS_ATOMIC
S  #define OS_PTR_OP_IS_ATOMIC   (0)         // Helps to minimize code size and execution time. Some code is not required if setting pointers is an atomic operation (32 bit CPUs or 16 bit CPUs in near model)
N#endif
N
N#ifndef   OS_SUSPEND_TASK_ON_TERMINATE      // Sets the task state of a terminated task to "suspended". Primarily used in the OS simulation, because the windows scheduler might re-activate a suspended task
N  #define OS_SUSPEND_TASK_ON_TERMINATE (0)
N#endif
N
N#ifndef   OS_INIT_EXPLICITLY
N  #define OS_INIT_EXPLICITLY  (0)           // If enabled, OS_InitKern() initializes Non-Zero globals. Required only for faulty compiler (or startup-code) which do not perform proper init of globals during startup.
N#endif
N
N#ifndef   OS_TASK_LIST_HAS_PPREV
N  #define OS_TASK_LIST_HAS_PPREV   OS_RR_SUPPORTED
N#else
S  #if (OS_TASK_LIST_HAS_PPREV == 0) && OS_RR_SUPPORTED
S    #error  "Invalid combination of config switches"
S  #endif
N#endif
N
N#ifndef   OS_SUPPORT_CALL_ISR
N  #define OS_SUPPORT_CALL_ISR (1)
N#endif
N
N#ifndef   OS_PREPARE_STACKPOINTER
N  #define OS_PREPARE_STACKPOINTER()
N#endif
N
N#ifndef   OS_SUPPORT_POWER
N  #define OS_SUPPORT_POWER (1)
N#endif
N
N#ifndef   OS_POWER_NUM_COUNTERS
N  #define OS_POWER_NUM_COUNTERS (5)
N#endif
N
N/*********************************************************************
N*
N*       Check Compile time switches
N*
N**********************************************************************
N*/
N
N#ifndef OS_SIZEOF_INT
S  #error "Please define OS_SIZEOF_INT (OSChip.h)"
N#endif
N#ifndef OS_BIG_ENDIAN
S  #error "Please define OS_BIG_ENDIAN (OSChip.h)"
N#endif
N
N#if (OS_STACK_AT_BOTTOM != 0) && (OS_STACK_AT_BOTTOM != 1)
X#if ((0) != 0) && ((0) != 1)
S  /*
S  *  Only 0 or 1 is allowed, because OS_STACK_AT_BOTTOM is used for calculations!
S  */
S  #error "OS_STACK_AT_BOTTOM has to be defined to 0 or 1"
N#endif
N
N/*********************************************************************
N*
N*       Basic type defines
N*
N**********************************************************************
N*/
N
N#ifndef   OS_I8
N  #define OS_I8 signed char
N#endif
N
N#ifndef   OS_U8
N  #define OS_U8 unsigned char
N#endif
N
N#ifndef   OS_I16
N  #define OS_I16 signed short
N#endif
N
N#ifndef   OS_U16
N  #define OS_U16 unsigned short
N#endif
N
N#ifndef   OS_I32
S  #define OS_I32 long
N#endif
N
N#ifndef   OS_U32
N  #define OS_U32 unsigned OS_I32
N#endif
N
N/* Defines a true integer. This type is guaranteed
N   a) to have at least 8 bits,
N   b) to compile and execute best on the target CPU
N   It will normally be the same as an int, but on most
N   8-bit CPUs it will be replaced by a character because
N   the CPU can deal with 8 bits more efficient than with
N   16 bit integers.
N   Use with care !
N*/
N#ifndef   OS_INT
N  #define OS_INT       int
N#endif
N
N#ifndef   OS_UINT
N  #define OS_UINT      unsigned OS_INT
N#endif
N
N#ifndef   OS_TIME
N  #define OS_TIME      int
N#endif
N
N
N/*********************************************************************
N*
N*       Error codes
N*
N**********************************************************************
N*/
N
N/* User 0..99  ***********************************/
N
N/* Port 100..119 *********************************/
N#define OS_ERR_ISR_INDEX                      (100)
N#define OS_ERR_ISR_VECTOR                     (101)
N#define OS_ERR_ISR_PRIO                       (102)
N
N/* OS generic ************************************/
N/* stack overflow or invalid stack */
N#define OS_ERR_STACK                          (120)
N
N/* Counting semaphore overflow */
N#define OS_ERR_CSEMA_OVERFLOW                 (121)
N
N/* Power management module */
N#define OS_ERR_POWER_OVER                     (122)
N#define OS_ERR_POWER_UNDER                    (123)
N#define OS_ERR_POWER_INDEX                    (124)
N
N
N/* invalid or non-initialized data structures */
N#define OS_ERR_INV_TASK                       (128)
N#define OS_ERR_INV_TIMER                      (129)
N#define OS_ERR_INV_MAILBOX                    (130)
N#define OS_ERR_INV_CSEMA                      (132)
N#define OS_ERR_INV_RSEMA                      (133)
N
N/* Using GetMail1 or PutMail1 or GetMailCond1 or PutMailCond1 on
N   a non-1 byte mailbox  */
N#define OS_ERR_MAILBOX_NOT1                   (135)
N
N/* Waitable objects deleted with waiting tasks or occupied by task */
N#define OS_ERR_MAILBOX_DELETE                 (136)
N#define OS_ERR_CSEMA_DELETE                   (137)
N#define OS_ERR_RSEMA_DELETE                   (138)
N
N/* internal errors, please contact SEGGER Microcontrollersysteme */
N#define OS_ERR_MAILBOX_NOT_IN_LIST            (140)
N#define OS_ERR_TASKLIST_CORRUPT               (142)
N
N/* not matching routine calls or macro usage */
N#define OS_ERR_UNUSE_BEFORE_USE               (150)
N#define OS_ERR_LEAVEREGION_BEFORE_ENTERREGION (151)
N#define OS_ERR_LEAVEINT                       (152)
N#define OS_ERR_DICNT                          (153)
N#define OS_ERR_INTERRUPT_DISABLED             (154)
N#define OS_ERR_TASK_ENDS_WITHOUT_TERMINATE    (155)
N#define OS_ERR_RESOURCE_OWNER                 (156)
N
N#define OS_ERR_ILLEGAL_IN_ISR                 (160)  /* not a legal system call during interrupt */
N#define OS_ERR_ILLEGAL_IN_TIMER               (161)  /* not a legal system call during timer */
N#define OS_ERR_ILLEGAL_OUT_ISR                (162)  /* not a legal system call outside interrupt */
N#define OS_ERR_NOT_IN_ISR                     (163)  /* OS_EnterInterrupt() has been called, but CPU is not in ISR state */
N#define OS_ERR_IN_ISR                         (164)  /* OS_EnterInterrupt() has not been called, but CPU is in ISR state */
N
N#define OS_ERR_INIT_NOT_CALLED                (165)  /* OS_InitKern() was not called */
N
N/* Double used data structures */
N#define OS_ERR_2USE_TASK                      (170)
N#define OS_ERR_2USE_TIMER                     (171)
N#define OS_ERR_2USE_MAILBOX                   (172)
N#define OS_ERR_2USE_BSEMA                     (173)
N#define OS_ERR_2USE_CSEMA                     (174)
N#define OS_ERR_2USE_RSEMA                     (175)
N#define OS_ERR_2USE_MEMF                      (176)
N
N/* Communication errors (OSCOM) */
N#define OS_ERR_NESTED_RX_INT                  (180)
N
N/* Fixed block memory pool  */
N#define OS_ERR_MEMF_INV                       (190)
N#define OS_ERR_MEMF_INV_PTR                   (191)
N#define OS_ERR_MEMF_PTR_FREE                  (192)
N#define OS_ERR_MEMF_RELEASE                   (193)
N#define OS_ERR_POOLADDR                       (194)
N#define OS_ERR_BLOCKSIZE                      (195)
N
N/* Task suspend / resume errors */
N#define OS_ERR_SUSPEND_TOO_OFTEN              (200)
N#define OS_ERR_RESUME_BEFORE_SUSPEND          (201)
N
N/* Other task related errors */
N#define OS_ERR_TASK_PRIORITY                  (202)
N
N/* Event object */
N#define OS_ERR_EVENT_INVALID                  (210)
N#define OS_ERR_2USE_EVENTOBJ                  (211)
N#define OS_ERR_EVENT_DELETE                   (212)
N
N/* Waitlist (checked build) */
N#define OS_ERR_WAITLIST_RING                  (220)
N#define OS_ERR_WAITLIST_PREV                  (221)
N#define OS_ERR_WAITLIST_NEXT                  (222)
N
N/* Other potential problems discovered in checked build */
N#define OS_ERR_NOT_IN_REGION                  (225)
N
N/* Cache related */
N#define OS_ERR_NON_ALIGNED_INVALIDATE         (230)
N
N/* OS special build, or internal */
N#define OS_ERR_TRIAL_LIMIT                    (254)
N
N/*********************************************************************
N*
N*       Trace identifier
N*
N**********************************************************************
N
NIdentifier from 0 to 99 are reserved for the OS
NEven when not all of those are currently used,
Nthey may be defined in the future
N
N*/
N
N#define OS_TRACE_ID_DEACTIVATE      (1)
N#define OS_TRACE_ID_ACTIVATE        (2)
N#define OS_TRACE_ID_TIMERCALLBACK   (3)
N
N/* Task group */
N#define OS_TRACE_ID_DELAY           (10)
N#define OS_TRACE_ID_DELAYUNTIL      (11)
N#define OS_TRACE_ID_SETPRIORITY     (12)
N#define OS_TRACE_ID_WAKETASK        (13)
N#define OS_TRACE_ID_CREATETASK      (14)
N#define OS_TRACE_ID_TERMINATETASK   (15)
N#define OS_TRACE_ID_SUSPENDTASK     (16)
N#define OS_TRACE_ID_RESUMETASK      (17)
N#define OS_TRACE_ID_CREATETASK_EX   (18)
N#define OS_TRACE_ID_YIELD           (19)
N
N/* Event group */
N#define OS_TRACE_ID_WAITEVENT       (20)
N#define OS_TRACE_ID_WAITEVENT_TIMED (21)
N#define OS_TRACE_ID_SIGNALEVENT     (22)
N#define OS_TRACE_ID_CLEAREVENTS     (23)
N
N/* Mailbox group  */
N#define OS_TRACE_ID_CREATEMB        (30)
N#define OS_TRACE_ID_CLEARMB         (31)
N#define OS_TRACE_ID_DELETEMB        (32)
N#define OS_TRACE_ID_PUTMAIL         (33)
N#define OS_TRACE_ID_GETMAIL         (34)
N#define OS_TRACE_ID_PUTMAILCOND     (35)
N#define OS_TRACE_ID_GETMAILCOND     (36)
N#define OS_TRACE_ID_PUTMAIL_TIMED   (37)
N#define OS_TRACE_ID_GETMAIL_TIMED   (38)
N#define OS_TRACE_ID_WAITMAIL        (39)
N
N#define OS_TRACE_ID_PUTMAIL1        (40)
N#define OS_TRACE_ID_GETMAIL1        (41)
N#define OS_TRACE_ID_PUTMAILCOND1    (42)
N#define OS_TRACE_ID_GETMAILCOND1    (43)
N#define OS_TRACE_ID_PUTMAIL_TIMED1  (44)
N#define OS_TRACE_ID_GETMAIL_TIMED1  (45)
N
N#define OS_TRACE_ID_PUTMAIL_F       (46)
N#define OS_TRACE_ID_PUTMAIL_F1      (47)
N#define OS_TRACE_ID_PUTMAIL_FCOND   (48)
N#define OS_TRACE_ID_PUTMAIL_FCOND1  (49)
N
N/* Resource group */
N#define OS_TRACE_ID_CREATERSEMA     (50)
N#define OS_TRACE_ID_USE             (51)
N#define OS_TRACE_ID_UNUSE           (52)
N#define OS_TRACE_ID_REQUEST         (53)
N#define OS_TRACE_ID_GETSEMAVALUE    (54)
N#define OS_TRACE_ID_DELETE_RSEMA    (55)
N
N/* Counting Semaphore group */
N#define OS_TRACE_ID_CREATECSEMA     (60)
N#define OS_TRACE_ID_DELETECSEMA     (61)
N#define OS_TRACE_ID_SIGNALCSEMA     (62)
N#define OS_TRACE_ID_WAITCSEMA       (63)
N#define OS_TRACE_ID_WAITCSEMATIMED  (64)
N#define OS_TRACE_ID_SIGNALCSEMA_MAX (65)
N#define OS_TRACE_ID_SET_CSEMAVALUE  (66)
N#define OS_TRACE_ID_CSEMAREQUEST    (67)
N
N/* Timer group    */
N#define OS_TRACE_ID_CREATETIMER     (70)
N#define OS_TRACE_ID_DELETETIMER     (71)
N#define OS_TRACE_ID_STARTTIMER      (72)
N#define OS_TRACE_ID_STOPTIMER       (73)
N#define OS_TRACE_ID_RETRIGGERTIMER  (74)
N#define OS_TRACE_ID_SETTIMERPERIOD  (75)
N#define OS_TRACE_ID_CREATETIMER_EX  (76)
N
N/* Heap type memory management  */
N#define OS_TRACE_ID_MALLOC          (80)
N#define OS_TRACE_ID_FREE            (81)
N#define OS_TRACE_ID_REALLOC         (82)
N
N/* Fixed block type memory management  */
N#define OS_TRACE_ID_MEMF_CREATE     (90)
N#define OS_TRACE_ID_MEMF_DELETE     (91)
N#define OS_TRACE_ID_MEMF_ALLOC      (92)
N
N
N/*********************************************************************
N*
N*       Assertions
N*
N**********************************************************************
N
N  Assertions are used to generate code in the debug version
N  of the OS in order catch programming faults like
N  bad pointers or uninitialized data structures
N*/
N
N#if OS_DEBUG
X#if 0
S  #define OS_ASSERT(Exp, ErrCode) { if (!(Exp)) OS_Error(ErrCode); }
N#else
N  #define OS_ASSERT(Exp, ErrCode)
N#endif
N
N#define OS_ASSERT_INT()           OS_ASSERT((OS_InInt != 0),          OS_ERR_ILLEGAL_OUT_ISR)
N#define OS_ASSERT_NOINT()         OS_ASSERT((OS_InInt == 0),          OS_ERR_ILLEGAL_IN_ISR)
N#define OS_ASSERT_NOTIMER()       OS_ASSERT((OS_InTimer == 0),        OS_ERR_ILLEGAL_IN_TIMER)
N#define OS_ASSERT_DICnt()         OS_ASSERT(((OS_DICnt & 0xf0) == 0), OS_ERR_DICNT)
N#define OS_ASSERT_INIT_CALLED()   OS_ASSERT((OS_InitCalled != 0),     OS_ERR_INIT_NOT_CALLED)
N
N/*********************************************************************
N*
N*       Memory attributes
N*
N**********************************************************************
N*/
N
N#ifndef OS_STACKPTR
N  #define OS_STACKPTR
N#endif
N
N#ifndef OS_SADDR
N  #ifdef SADDR
S    #define OS_SADDR SADDR
N  #else
N    #define OS_SADDR
N  #endif
N#endif
N
N/* pointer modifier for data items */
N#ifndef OS_DATAPTR
N  #define OS_DATAPTR
N#endif
N
N#ifndef OS_RSEMAPTR
N  #define OS_RSEMAPTR
N#endif
N
N#ifndef   OS_CSEMAPTR
N  #define OS_CSEMAPTR
N#endif
N
N#ifndef   OS_MBPTR
N  #define OS_MBPTR
N#endif
N
N#ifndef   OS_TCBPTR
N  #define OS_TCBPTR
N#endif
N
N#ifndef   OS_TIMERPTR
N  #define OS_TIMERPTR
N#endif
N
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N/*********************************************************************
N*
N*       Data structures
N*
N**********************************************************************
N*/
N
Ntypedef struct OS_TASK         OS_TASK;
Ntypedef struct OS_WAIT_LIST    OS_WAIT_LIST;
Ntypedef struct OS_WAIT_OBJ     OS_WAIT_OBJ;
Ntypedef struct OS_WAIT_OBJ_EX  OS_WAIT_OBJ_EX;
Ntypedef struct OS_REGS         OS_REGS;
N
Ntypedef void voidRoutine(void);
Ntypedef void OS_RX_CALLBACK(OS_U8 Data);
Xtypedef void OS_RX_CALLBACK(unsigned char Data);
Ntypedef void OS_TIMERROUTINE(void);
Ntypedef void OS_TIMER_EX_ROUTINE(void *);
Ntypedef void OS_ON_TERMINATE_FUNC(OS_TASK *);
N
Ntypedef void OS_TICK_HOOK_ROUTINE(void);
N
N/**********************************************************************
N*
N*       OS_WAIT_OBJ
N*       OS_WAIT_LIST
N*       OS_WAIT_OBJ_EX
N*/
Nstruct OS_WAIT_OBJ {
N  OS_WAIT_LIST * pWaitList;
N};
N
Nstruct OS_WAIT_OBJ_EX {
N  OS_WAIT_OBJ WaitObj;
N  int v;
N};
N
Nstruct OS_WAIT_LIST {
N  OS_WAIT_LIST * pNext;    /* Needs to be first element ! */
N  OS_WAIT_LIST * pPrev;
N  OS_WAIT_OBJ  * pWaitObj;
N  OS_TASK      * pTask;
N};
N
N
N/**********************************************************************
N*
N*       OS_EXTEND_TASK_CONTEXT
N*
N*  This structure is used to define a save and restore function for
N*  extension of the task context.
N*  A pointer to this structure is part of the task control block
N*  It is initialized by OS_ExtendTaskContext();
N*/
Ntypedef struct OS_EXTEND_TASK_CONTEXT {
N  void (*pfSave)   (      void * pStack);
N  void (*pfRestore)(const void * pStack);
N} OS_EXTEND_TASK_CONTEXT;
N
N
N/**********************************************************************
N*
N*       OS_TASK
N*
N*  This structure (referred to as "task control block" or TCB) holds all relevant information
N*  about a single task. Note that some elements are optional, depending on the compile time
N*  options, especially the type of build
N*/
Nstruct OS_TASK {
N  //
N  // Elements required for all builds
N  //
N  // Start of assembly relevant section. Do not move these elements
N  OS_TASK * pNext;                        // Points to the TCB of the next task in the list (with equal or lower priority). Needs to be first element !
N  OS_REGS OS_STACKPTR * pStack;           // Typically contains the stack pointer if the task is suspended.                 Needs to be second element !
X  OS_REGS  * pStack;           
N  // End of assembly relevant section
N  OS_WAIT_LIST * pWaitList;               // Points to a waitable object if task is suspended.
N  OS_TIME        Timeout;
X  int        Timeout;
N  OS_U8          Priority;
X  unsigned char          Priority;
N  OS_U8          Stat;
X  unsigned char          Stat;
N  OS_U8          Events;                  // Event storage
X  unsigned char          Events;                  
N  OS_U8          EventMask;               // Event mask
X  unsigned char          EventMask;               
N  //
N  // PPrev is required only in builds with doubly-linked task lists
N  //
N  #if OS_TASK_LIST_HAS_PPREV
X  #if (1)
N    OS_TASK      * pPrev;                   //
N  #endif
N  //
N  // Elements required with "Track-name" functionality only. Typically available in all builds, but can be disabled at compile time
N  //
N  #if OS_TRACKNAME
X  #if (1)
N    const char * Name;
N  #endif
N  //
N  // Elements required with "Stack-check" functionality only. Available in stack-check and debug builds.
N  //
N  #if OS_CHECKSTACK
X  #if 0
S    OS_UINT  StackSize;            // Stack size in bytes. Not required for functionality, just for analysis
S    OS_U8 OS_STACKPTR* pStackBot;  // First byte of stack. Not required for functionality, just for analysis
N  #endif
N  //
N  // Elements required with profiling or debug builds
N  //
N  #if (OS_PROFILE || OS_DEBUG)
X  #if (0 || 0)
S    OS_U32 NumActivations;         // Counts how many times task has been activated
S    OS_U32 NumPreemptions;         // Counts how many times task has been preempted
N  #endif
N  //
N  // Elements required with profiling builds
N  //
N  #if OS_PROFILE
X  #if 0
S    OS_U32 ExecTotal;              // Time spent executing
S    OS_U32 ExecLast;               // Time spent executing (Reference)
S    OS_U32 Load;                   // Profiling builds only:
N  #endif
N  //
N  // Elements required with Round-robin functionality only. Typically available in all builds, but can be disabled at compile time
N  //
N  #if OS_RR_SUPPORTED
X  #if (1)
N    OS_U8  TimeSliceRem;
X    unsigned char  TimeSliceRem;
N    OS_U8  TimeSliceReload;
X    unsigned char  TimeSliceReload;
N  #endif
N  //
N  // Optional Save & Restore hook support (usually only for bigger CPUs)
N  //
N  #if OS_SUPPORT_SAVE_RESTORE_HOOK
X  #if (1)
N    const OS_EXTEND_TASK_CONTEXT * pExtendContext;
N  #endif
N  //
N  // Elements required with debug builds
N  //
N  #if OS_DEBUG
X  #if 0
S    char Id;                       // Debug builds only: Id of this control block.
N  #endif
N  //
N  // Allow port specific extension to the task control block. Not used in most ports
N  //
N  #ifdef OS_TCB_CPU_EX
S    OS_TCB_CPU_EX
N  #endif
N};
N
N/**********************************************************************
N*
N*       OS_TIMER
N*/
Ntypedef struct OS_timer OS_TIMER;
Nstruct OS_timer {
N  OS_TIMER * pNext;
N  voidRoutine* Hook;
N  OS_TIME Time;
X  int Time;
N  OS_TIME Period;
X  int Period;
N  char    Active;
N#if OS_DEBUG
X#if 0
S  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_TIMER_EX
N*/
Ntypedef struct {
N  OS_TIMER Timer;
N  OS_TIMER_EX_ROUTINE * pfUser;
N  void * pData;
N} OS_TIMER_EX;
N
N/**********************************************************************
N*
N*       OS_TICK_HOOK
N*/
Ntypedef struct OS_TICK_HOOK OS_TICK_HOOK;
Nstruct OS_TICK_HOOK {
N  OS_TICK_HOOK*          pNext;
N  OS_TICK_HOOK_ROUTINE * pfUser;
N};
N
N/**********************************************************************
N*
N*       OS_RSEMA
N*/
Ntypedef struct OS_RSEMA OS_RSEMA;
Nstruct OS_RSEMA {
N  OS_WAIT_OBJ WaitObj;
N  OS_TASK * pTask;                /* Owner */
N  OS_U8 UseCnt;
X  unsigned char UseCnt;
N  OS_RSEMA * pNext;
N#if OS_DEBUG
X#if 0
S  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_CSEMA
N*/
Ntypedef struct OS_CSEMA OS_CSEMA;
Nstruct OS_CSEMA {
N  OS_WAIT_OBJ WaitObj;
N  OS_UINT Cnt;
X  unsigned int Cnt;
N#if OS_DEBUG
X#if 0
S  OS_CSEMA * pNext;
S  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_MAILBOX
N*/
Ntypedef struct OS_MAILBOX OS_MAILBOX;
Nstruct OS_MAILBOX {
N  OS_WAIT_OBJ WaitObj;
N#if OS_LINK_MAILBOXES
X#if (0)
S  OS_MAILBOX * pNext;
N#endif
N  char *pData;
N  OS_UINT nofMsg;
X  unsigned int nofMsg;
N  OS_UINT maxMsg;
X  unsigned int maxMsg;
N  OS_UINT iRd;
X  unsigned int iRd;
N  OS_U8  sizeofMsg;
X  unsigned char  sizeofMsg;
N#if OS_DEBUG
X#if 0
S  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_Q
N*/
Ntypedef struct OS_Q OS_Q;
Nstruct OS_Q {
N  OS_WAIT_OBJ WaitObj;
N  OS_Q*    pNext;          /* ptr to next queue (for debugging / monitoring) */
N  OS_U8*   pData;
X  unsigned char*   pData;
N  OS_UINT  Size;
X  unsigned int  Size;
N  OS_UINT  MsgCnt;
X  unsigned int  MsgCnt;
N  OS_UINT  offFirst;
X  unsigned int  offFirst;
N  OS_UINT  offLast;
X  unsigned int  offLast;
N#if OS_DEBUG
X#if 0
S  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_MEMF
N*/
N#ifndef   OS_MEMF_MAX_ITEMS
N  #define OS_MEMF_MAX_ITEMS 20
N#endif
N
N#define OS_MEMF_SIZEOF_BLOCKCONTROL 0  /* sizeof(int) in future version for debugging */
N
Ntypedef struct OS_MEMF OS_MEMF;
Nstruct OS_MEMF {
N  OS_WAIT_OBJ WaitObj;
N  OS_MEMF* pNext;          /* ptr to next memory pool */
N  void*    pPool;
N  OS_U16   NumBlocks;
X  unsigned short   NumBlocks;
N  OS_U16   BlockSize;
X  unsigned short   BlockSize;
N  OS_U16   NumFreeBlocks;
X  unsigned short   NumFreeBlocks;
N  OS_U16   MaxUsed;
X  unsigned short   MaxUsed;
N  void*    pFree;
N  #if OS_DEBUG
X  #if 0
S    int  aiPurpose[OS_MEMF_MAX_ITEMS];
S    char Id;
N  #endif
N};
N
N/**********************************************************************
N*
N*       OS_EVENT
N*/
Ntypedef struct  OS_EVENT OS_EVENT;
N
Nstruct OS_EVENT {
N  OS_WAIT_OBJ WaitObj;
N  OS_U8       Signaled;
X  unsigned char       Signaled;
N#if OS_DEBUG
X#if 0
S  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_TRACE_ENTRY
N*/
Ntypedef struct {
N  OS_U32  Time;
X  unsigned int  Time;
N  void    *pCurrentTask;
N  void    *p;
N  OS_U32  v;
X  unsigned int  v;
N  OS_U8   iRout;
X  unsigned char   iRout;
N} OS_TRACE_ENTRY;
N
N
N/*********************************************************************
N*
N*       Globals
N*
N**********************************************************************
N*/
N
N/*
N    Handle DEFinition (storage is actually allocted) versus DEClaration
N    (reference) of RTOS variables depending upon who includes this header file.
N*/
N#ifdef __OSGLOBAL_C__
S  #define OS_EXTERN        /* Declare variables if included by RTOSKERN.C */
S  #define OS_EXTERN_INIT(Var, Val) Var=Val
N#else
N  #define OS_EXTERN extern /* Define variables if included by anyone else */
N  #define OS_EXTERN_INIT(Var, Val) Var
N#endif
N
N/*****  Mark start of memory pragma area ****************************/
N
N/* Some compilers can not deal with memory attributes and need pragmas */
N#if defined(__ghs_zda)
X#if 0L
S  #pragma ghs startzda
N#endif
N
N/********************************************************************/
N
Ntypedef union {
N  int Dummy;            // Make sure a full integer (32 bit on 32 bit CPUs) is used.
N  struct {
N    OS_U8 Region;
X    unsigned char Region;
N    OS_U8 DI;
X    unsigned char DI;
N  } Cnt;
N} OS_COUNTERS;
N
N
N#if OS_COMPILER_STORAGE_MODIFIER_LEFT  /* default */
X#if 1   
N  OS_EXTERN OS_SADDR  volatile OS_I32 OS_Time;
X  extern   volatile int OS_Time;
N  OS_EXTERN OS_SADDR  OS_TIME         OS_EXTERN_INIT(OS_TimeDex, 16384);
X  extern   int         OS_TimeDex;
N  OS_EXTERN OS_SADDR  OS_COUNTERS OS_Counters;
X  extern   OS_COUNTERS OS_Counters;
N
N  OS_EXTERN OS_SADDR  OS_U8  OS_EXTERN_INIT(OS_IntMSInc, 1);
X  extern   unsigned char  OS_IntMSInc;
N  OS_EXTERN OS_SADDR  OS_U8  OS_Pending;
X  extern   unsigned char  OS_Pending;
N  OS_EXTERN OS_SADDR  volatile OS_U8  OS_Status;
X  extern   volatile unsigned char  OS_Status;
N
N  #if OS_RR_SUPPORTED
X  #if (1)
N    OS_EXTERN OS_SADDR  OS_U8  OS_TimeSlice;
X    extern   unsigned char  OS_TimeSlice;
N    OS_EXTERN OS_SADDR  OS_U8  OS_TimeSliceAtStart;
X    extern   unsigned char  OS_TimeSliceAtStart;
N  #endif
N  #if OS_SUPPORT_TICKSTEP
X  #if 0
S    OS_EXTERN OS_SADDR  volatile OS_U8   OS_TickStep;
S    OS_EXTERN OS_SADDR  volatile int     OS_TickStepTime;
N  #endif
N  OS_EXTERN OS_SADDR        OS_UINT OS_TicksPerMS;
X  extern         unsigned int OS_TicksPerMS;
N  OS_EXTERN OS_SADDR        int     OS_IntTicksInc;
X  extern         int     OS_IntTicksInc;
N  #if OS_PROFILE
X  #if 0
S    OS_EXTERN OS_SADDR OS_U32 OS_TS_ExecStart;
S    OS_EXTERN OS_SADDR OS_U8  ProfilingOn;
N  #endif
N  #if OS_DEBUG
X  #if 0
S    OS_EXTERN OS_SADDR OS_U8 OS_InInt;
S    OS_EXTERN OS_SADDR OS_U8 OS_InTimer;
S    OS_EXTERN OS_SADDR OS_U8 OS_InitCalled;
N  #endif
N
N  #if OS_SUPPORT_POWER
X  #if (1)
N    OS_EXTERN OS_SADDR OS_U8 OS_POWER_Levels[OS_POWER_NUM_COUNTERS];
X    extern  unsigned char OS_POWER_Levels[(5)];
N  #endif
N
N  /*** Pointers ***
N    Unfortunately there is no real standard on how to define/declare
N    pointers properly with extended memory attributes. There are
N    currently 2 different standards, which we both support.
N  */
N  #if OS_COMPILER_LOCATION_LEFT
X  #if 1
N    OS_EXTERN OS_SADDR  OS_TASK      * OS_pTask;             /* linked list of all Tasks */
X    extern   OS_TASK      * OS_pTask;              
N    OS_EXTERN OS_SADDR  OS_TASK      * OS_pCurrentTask;      /* pointer to current Task */
X    extern   OS_TASK      * OS_pCurrentTask;       
N    OS_EXTERN OS_SADDR  OS_TASK volatile * volatile OS_pActiveTask;
X    extern   OS_TASK volatile * volatile OS_pActiveTask;
N    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pTimer;            /* linked list of all active Timers */
X    extern   OS_TIMER     * OS_pTimer;             
N    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pCurrentTimer;     /* Actual expired timer which called callback */
X    extern   OS_TIMER     * OS_pCurrentTimer;      
N    OS_EXTERN OS_SADDR OS_RSEMA      * OS_pRSema;
X    extern  OS_RSEMA      * OS_pRSema;
N    #if OS_LINK_MAILBOXES
X    #if (0)
S      OS_EXTERN OS_SADDR OS_MAILBOX  * OS_pMailbox;
N    #endif
N    #if OS_DEBUG
X    #if 0
S      OS_EXTERN OS_SADDR OS_CSEMA    * OS_pCSema;
N    #endif
N    OS_EXTERN   OS_SADDR OS_MEMF      * OS_pMEMF;            /* linked list of all fixed size memory pools */
X    extern    OS_MEMF      * OS_pMEMF;             
N    OS_EXTERN   OS_SADDR OS_TICK_HOOK * OS_pTickHook;        /* linked list of all tick hook functions */
X    extern    OS_TICK_HOOK * OS_pTickHook;         
N  #else
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pTask;          /* linked list of all Tasks */
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pCurrentTask;   /* pointer to current Task */
S    OS_EXTERN OS_TASK    volatile * OS_SADDR volatile OS_pActiveTask;
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pTimer;         /* linked list of all active Timers */
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pCurrentTimer;  /* Actual expired timer which called callback */
S    OS_EXTERN OS_RSEMA            * OS_SADDR OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_MAILBOX        * OS_SADDR OS_pMailbox;
S    #endif
S
S    #if OS_DEBUG
S      OS_EXTERN  OS_CSEMA         * OS_SADDR OS_pCSema;
S    #endif
S    OS_EXTERN OS_MEMF             * OS_SADDR OS_pMEMF;          /* linked list of all fixed size memory pools */
S    OS_EXTERN OS_TICK_HOOK        * OS_SADDR OS_pTickHook;      /* linked list of all tick hook functions */
N  #endif
N
N#else  /*  OS_COMPILER_STORAGE_MODIFIER_LEFT == 0, needed for Keil 166 */
S  OS_EXTERN volatile OS_I32 OS_SADDR OS_Time;
S  OS_EXTERN OS_TIME         OS_SADDR OS_EXTERN_INIT(OS_TimeDex, 16384);
S  OS_EXTERN OS_COUNTERS OS_SADDR OS_Counters;
S
S  OS_EXTERN OS_U8 OS_SADDR OS_EXTERN_INIT(OS_IntMSInc, 1);
S  OS_EXTERN OS_U8 OS_SADDR OS_Pending;
S  OS_EXTERN volatile OS_U8 OS_SADDR OS_Status;
S  #if OS_RR_SUPPORTED
S    OS_EXTERN OS_U8 OS_SADDR OS_TimeSlice;
S    OS_EXTERN OS_U8 OS_SADDR OS_TimeSliceAtStart;
S  #endif
S  #if OS_SUPPORT_TICKSTEP
S    OS_EXTERN volatile OS_U8 OS_SADDR OS_TickStep;
S    OS_EXTERN volatile int   OS_SADDR OS_TickStepTime;
S  #endif
S  OS_EXTERN OS_UINT OS_SADDR OS_TicksPerMS;
S  OS_EXTERN int     OS_SADDR OS_IntTicksInc;
S  #if OS_PROFILE
S    OS_EXTERN OS_U32 OS_SADDR OS_TS_ExecStart;
S    OS_EXTERN OS_U8  OS_SADDR ProfilingOn;
S  #endif
S  #if OS_DEBUG
S    OS_EXTERN OS_U8 OS_SADDR OS_InInt;
S    OS_EXTERN OS_U8 OS_SADDR OS_InTimer;
S    OS_EXTERN OS_U8 OS_SADDR OS_InitCalled;
S  #endif
S
S  #if OS_SUPPORT_POWER
S    OS_EXTERN OS_U8 OS_SADDR OS_POWER_Levels[OS_POWER_NUM_COUNTERS];
S  #endif
S
S  /*** Pointers ***
S    Unfortunately there is no real standard on how to define/declare
S    pointers properly with extended memory attributes. There are
S    currently 2 different standards, which we both support.
S  */
S  #if OS_COMPILER_LOCATION_LEFT
S    OS_EXTERN OS_SADDR  OS_TASK      * OS_pTask;             /* linked list of all Tasks */
S    OS_EXTERN OS_SADDR  OS_TASK      * OS_pCurrentTask;      /* pointer to current Task */
S    OS_EXTERN OS_SADDR  OS_TASK volatile * volatile OS_pActiveTask;
S    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pTimer;            /* linked list of all active Timers */
S    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pCurrentTimer;     /* Actual expired timer which called callback */
S    OS_EXTERN OS_SADDR OS_RSEMA      * OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_SADDR OS_MAILBOX  * OS_pMailbox;
S    #endif
S    #if OS_DEBUG
S      OS_EXTERN OS_SADDR OS_CSEMA    * OS_pCSema;
S    #endif
S      OS_EXTERN OS_SADDR OS_MEMF      * OS_pMEMF;            /* linked list of all fixed size memory pools */
S      OS_EXTERN OS_SADDR OS_TICK_HOOK * OS_pTickHook;        /* linked list of all tick hook functions */
S
S  #else
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pTask;          /* linked list of all Tasks */
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pCurrentTask;   /* pointer to current Task */
S    OS_EXTERN OS_TASK    volatile * volatile OS_SADDR OS_pActiveTask;
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pTimer;         /* linked list of all active Timers */
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pCurrentTimer;  /* Actual expired timer which called callback */
S    OS_EXTERN OS_RSEMA            * OS_SADDR OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_MAILBOX        * OS_SADDR OS_pMailbox;
S    #endif
S    #if OS_DEBUG
S      OS_EXTERN OS_CSEMA          * OS_SADDR OS_pCSema;
S    #endif
S
S    OS_EXTERN OS_MEMF             * OS_SADDR OS_pMEMF;          /* linked list of all fixed size memory pools */
S    OS_EXTERN OS_TICK_HOOK        * OS_SADDR OS_pTickHook;      /* linked list of all tick hook functions */
S  #endif
S
N#endif  /*  OS_COMPILER_STORAGE_MODIFIER_LEFT  */
N
N/***** Mark end of memory pragma area *******************************/
N#if defined(__ghs_zda)
X#if 0L
S  #pragma ghs endzda
N#endif
N
N/********************************************************************/
N
N#define OS_RegionCnt OS_Counters.Cnt.Region
N#define OS_DICnt     OS_Counters.Cnt.DI
N
N/*********************************************************************
N*
N*       OS_CREATETASK macro
N*       OS_CREATETASK_EX macro
N*/
N#if OS_RR_SUPPORTED
X#if (1)
N  #define CTPARA_TIMESLICE ,2
N#else
S  #define CTPARA_TIMESLICE
N#endif
N
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack) \
N  OS_CreateTask (pTask,                                      \
N                  Name,                                      \
N                  Priority,                                  \
N                  Hook,                                      \
N                  (void OS_STACKPTR*)pStack,                 \
N                  sizeof(pStack)                             \
N                  CTPARA_TIMESLICE                           \
N               )
X  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack)   OS_CreateTask (pTask,                                                        Name,                                                        Priority,                                                    Hook,                                                        (void OS_STACKPTR*)pStack,                                   sizeof(pStack)                                               CTPARA_TIMESLICE                                          )
N#else
S  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack) \
S  OS_CreateTask (pTask,                                      \
S                  Priority,                                  \
S                  Hook,                                      \
S                  (void OS_STACKPTR*)pStack,                 \
S                  sizeof(pStack)                             \
S                  CTPARA_TIMESLICE                           \
S               )
X  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack)   OS_CreateTask (pTask,                                                        Priority,                                                    Hook,                                                        (void OS_STACKPTR*)pStack,                                   sizeof(pStack)                                               CTPARA_TIMESLICE                                          )
N#endif
N
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext) \
N  OS_CreateTaskEx  (pTask,                                                \
N                    Name,                                                 \
N                    Priority,                                             \
N                    Hook,                                                 \
N                    (void OS_STACKPTR*)pStack,                            \
N                    sizeof(pStack)                                        \
N                    CTPARA_TIMESLICE,                                     \
N                    pContext                                              \
N               )
X  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext)   OS_CreateTaskEx  (pTask,                                                                    Name,                                                                     Priority,                                                                 Hook,                                                                     (void OS_STACKPTR*)pStack,                                                sizeof(pStack)                                                            CTPARA_TIMESLICE,                                                         pContext                                                             )
N#else
S  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext) \
S  OS_CreateTaskEx  (pTask,                                                \
S                    Priority,                                             \
S                    Hook,                                                 \
S                    (void OS_STACKPTR*)pStack,                            \
S                    sizeof(pStack)                                        \
S                    CTPARA_TIMESLICE,                                     \
S                    pContext                                              \
S               )
X  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext)   OS_CreateTaskEx  (pTask,                                                                    Priority,                                                                 Hook,                                                                     (void OS_STACKPTR*)pStack,                                                sizeof(pStack)                                                            CTPARA_TIMESLICE,                                                         pContext                                                             )
N#endif
N
N/*********************************************************************
N*
N*       OS_CreateTask
N*       OS_CreateTaskEx
N*/
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATE_TASK_PARA_NAME      const char*Name,
N#else
S  #define OS_CREATE_TASK_PARA_NAME
N#endif
N
N#if OS_RR_SUPPORTED
X#if (1)
N  #define OS_CREATE_TASK_PARA_TS   ,OS_UINT TimeSlice
N#else
S  #define OS_CREATE_TASK_PARA_TS
N#endif
N
Nvoid OS_CreateTask  ( OS_TASK * pTask,
Xvoid OS_CreateTask_R  ( OS_TASK * pTask,
N                      OS_CREATE_TASK_PARA_NAME
X                      const char*Name,
N                      OS_U8 Priority,
X                      unsigned char Priority,
N                      void (*pRoutine)(void),
N                      void OS_STACKPTR *pStack,
X                      void  *pStack,
N                      OS_UINT StackSize
X                      unsigned int StackSize
N                      OS_CREATE_TASK_PARA_TS
X                      ,unsigned int TimeSlice
N        );
Nvoid OS_CreateTaskEx  ( OS_TASK * pTask,
Xvoid OS_CreateTaskEx_R  ( OS_TASK * pTask,
N                        OS_CREATE_TASK_PARA_NAME
X                        const char*Name,
N                        OS_U8 Priority,
X                        unsigned char Priority,
N                        void (*pRoutine)(void *),
N                        void OS_STACKPTR *pStack,
X                        void  *pStack,
N                        OS_UINT StackSize
X                        unsigned int StackSize
N                        OS_CREATE_TASK_PARA_TS,
X                        ,unsigned int TimeSlice,
N                        void * pContext
N        );
N#if OS_SUPPORT_SAVE_RESTORE_HOOK
X#if (1)
Nvoid OS_ExtendTaskContext(const OS_EXTEND_TASK_CONTEXT * pExtendContext);
N#endif
N/*********************************************************************
N*
N*       Task related routines
N*
N**********************************************************************
N*/
N
Nvoid  OS_Delay(OS_TIME ms);                /* OSKern.c              */
Xvoid  OS_Delay(int ms);                 
Nvoid  OS_DelayUntil(OS_TIME t);            /* OSKern.c              */
Xvoid  OS_DelayUntil(int t);             
NOS_U8 OS_GetSuspendCnt  (OS_TASK* pTask);  /* OS_GetSuspendCnt.c    */
Xunsigned char OS_GetSuspendCnt  (OS_TASK* pTask);   
Nvoid  OS_GetState       (OS_TASK* pTask);
Nchar  OS_IsTask         (OS_TASK* pTask);  /* OSIsTask.c            */
Nvoid  OS_Resume         (OS_TASK* pTask);  /* OS_Suspend.c          */
Nvoid  OS_SetTaskName    (OS_TASK * pTask, const char* s);
Nvoid  OS_SetPriority    (OS_TASK* pTask, OS_U8 Prio); /* OSSetP.c   */
Xvoid  OS_SetPriority    (OS_TASK* pTask, unsigned char Prio);  
Nvoid  OS_Suspend        (OS_TASK* pTask);  /* OS_Suspend.c          */
Nvoid  OS_Terminate      (OS_TASK* pTask);  /* OSTerm.c              */
Nvoid  OS_TerminateError (void);            /* OSTermE.c             */
Nvoid  OS_WakeTask       (OS_TASK* pTask);  /* OSWake.c              */
Nvoid  OS_Yield          (void);            /* OS_Yield              */
N
N#if OS_SUSPEND_TASK_ON_TERMINATE           /* Set task state of a terminated task to "suspended" */
X#if (0)            
S  #define OS_SUSPEND_TERMINATED_TASK(pTask) (pTask->Stat = 0x01)
N#else
N  #define OS_SUSPEND_TERMINATED_TASK(pTask)
N#endif
N
N/*********************************************************************
N*
N*       Info routines (OSInfo.c)
N*
N**********************************************************************
N*/
N
Nconst char* OS_GetCPU(void);
Nconst char* OS_GetLibMode(void);
Nconst char* OS_GetModel(void);
Nconst char* OS_GetLibName(void);
N
NOS_UINT OS_GetVersion(void);
Xunsigned int OS_GetVersion(void);
N#define OS_GetType() OS_GetLibMode()
N
N#define OS_TASKID OS_TASK *
N#define OS_GetTaskID() OS_pCurrentTask
N
N#define OS_GetpCurrentTask()    OS_pCurrentTask
N#define OS_GetpCurrentTimer()   OS_pCurrentTimer
N#define OS_GetpCurrentTimerEx() ((OS_TIMER_EX*)OS_pCurrentTimer)
N
N#if OS_TRACKNAME
X#if (1)
N  const char* OS_GetTaskName(OS_TASK *);
N#else
S  #define OS_GetTaskName(pt)  ("n/a")
N#endif
N
N#if OS_CHECKSTACK
X#if 0
S  void OS_CheckStack(void);              /* internal usage */
S  int  OS_GetStackSpace(OS_TASK * pTask);
S  int  OS_GetStackUsed (OS_TASK * pTask);
S  int  OS_GetStackSize (OS_TASK OS_TCBPTR * pTask);
S  void OS_STACKPTR* OS_GetStackBase(OS_TASK OS_TCBPTR *pTask);
N#else
N  #define OS_CheckStack()
N  #define OS_GetStackSpace(pt) 0
N  #define OS_GetStackUsed(pt)  0
N  #define OS_GetStackSize(pt)  0
N  #define OS_GetStackBase(pt)  0
N#endif
N
NOS_STACK_ADR OS_GetSysStackBase(void);  /* RTOS asm part */
Xunsigned int OS_GetSysStackBase(void);   
Nunsigned int OS_GetSysStackSize(void);  /* RTOS asm part */
NOS_STACK_ADR OS_GetIntStackBase(void);  /* RTOS asm part */
Xunsigned int OS_GetIntStackBase(void);   
Nunsigned int OS_GetIntStackSize(void);  /* RTOS asm part */
N
N#if OS_RR_SUPPORTED
X#if (1)
N  OS_U8 OS_SetTimeSlice(OS_TASK * pTask, OS_U8 TimeSlice);
X  unsigned char OS_SetTimeSlice(OS_TASK * pTask, unsigned char TimeSlice);
N  OS_U8 OS_GetTimeSliceRem(OS_TASK OS_TCBPTR * pTask);
X  unsigned char OS_GetTimeSliceRem(OS_TASK  * pTask);
N  #define OS_GetTimeSliceReload(pTask)  pTask->TimeSliceReload
N#else
S  #define OS_GetTimeSliceRem(pTask)     0
S  #define OS_GetTimeSliceReload(pTask)  0
N#endif
N
NOS_U8    OS_GetPriority(OS_TASK * pTask);  /* OS_GetPrio.c       */
Xunsigned char    OS_GetPriority(OS_TASK * pTask);   
N#define OS_GET_PRIORITY(pt) pt->Priority
N
Nint     OS_GetNumTasks(void);              /* OS_GetNumTasks.c   */
N
NOS_TASK* OS_TaskIndex2Ptr(int TaskIndex);  /* OS_TaskIndex2Ptr.c */
N
N#if OS_PROFILE >=1
X#if 0 >=1
S  OS_U32 OS_STAT_GetExecTime_Cycles (OS_TASK *pTask);  /* OSStat.c   */
S  int    OS_STAT_GetLoad            (OS_TASK *pTask);  /* OSStatGL.c */
S  void   OS_STAT_NotifyReadyStart   (OS_TASK *pTask);  /* OSStat.c   */
S  void   OS_STAT_Sample(void);                         /* OSStat.c   */
N#else
N  #define OS_STAT_NotifyExecEnd()
N  #define OS_STAT_GetExecTime_Cycles(pTask)   0
N  #define OS_STAT_GetLoad(pTask)              0
N  #define OS_STAT_Sample()
N  #define OS_STAT_SetClocksPerUnit(ClocksPerUnit)
N  #define OS_STAT_NOTIFYREADYSTART(pTask)
N#endif
N
N
N#if ((OS_PROFILE >= 1) || (OS_DEBUG > 0))  /* Also available in Debug build since V3.32b */
X#if ((0 >= 1) || (0 > 0))   
S  OS_U32 OS_STAT_GetNumActivations  (OS_TASK *pTask);  /* OSStat.c   */
S  OS_U32 OS_STAT_GetNumPreemptions  (OS_TASK *pTask);  /* OSStat.c   */
N#else
N  #define OS_STAT_GetNumActivations(pTask)    0
N  #define OS_STAT_GetNumPreemptions(pTask)    0
N#endif
N
N/*********************************************************************
N*
N*       Size info routines (OS_GetSize.c)
N*
N**********************************************************************
N*/
N
Nint OS_WAIT_OBJ_GetSize(void);
Nint OS_WAIT_OBJ_EX_GetSize(void);
Nint OS_WAIT_LIST_GetSize(void);
Nint OS_EXTEND_TASK_CONTEXT_GetSize(void);
Nint OS_TASK_GetSize(void);
Nint OS_REGS_GetSize(void);
Nint OS_TIMER_GetSize(void);
Nint OS_TIMER_EX_GetSize(void);
Nint OS_TICK_HOOK_GetSize(void);
Nint OS_RSEMA_GetSize(void);
Nint OS_CSEMA_GetSize(void);
Nint OS_MAILBOX_GetSize(void);
Nint OS_Q_GetSize(void);
Nint OS_MEMF_GetSize(void);
Nint OS_EVENT_GetSize(void);
Nint OS_TRACE_ENTRY_GetSize(void);
N
N/*********************************************************************
N*
N*       Critical regions (OsKern.c)
N*
N**********************************************************************
N*/
N
N#define OS_EnterRegion() {OS_RegionCnt++; }
Nvoid OS_LeaveRegion(void);
N
N/* Macro for OS_Leaveregion.
N   Main purposes:
N   - Used in OS-Kernel
N   - Offers the high speed variant (macro) instead of the function call
N*/
N
N#define OS_LEAVEREGION_STD()        \
N  if (--OS_RegionCnt == 0) {        \
N    OS_DI();                        \
N    if (OS_Pending) {               \
N      OS_RegionCnt = 1;             \
N      OS_Switch();                  \
N      OS_RegionCnt = 0;             \
N    }                               \
N    OS_RESTORE_I();                 \
N  }
X#define OS_LEAVEREGION_STD()          if (--OS_RegionCnt == 0) {            OS_DI();                            if (OS_Pending) {                     OS_RegionCnt = 1;                   OS_Switch();                        OS_RegionCnt = 0;                 }                                   OS_RESTORE_I();                   }
N
N#if OS_DEBUG
X#if 0
S #define OS_LEAVEREGION() \
S   if (!OS_RegionCnt) OS_Error(OS_ERR_LEAVEREGION_BEFORE_ENTERREGION); \
S   OS_LEAVEREGION_STD()
X #define OS_LEAVEREGION()    if (!OS_RegionCnt) OS_Error(OS_ERR_LEAVEREGION_BEFORE_ENTERREGION);    OS_LEAVEREGION_STD()
N#else
N  #define OS_LEAVEREGION()  OS_LEAVEREGION_STD()
N#endif
N
N/*********************************************************************
N*
N*       Interrupt save/disable/restore macros
N*
N**********************************************************************
N*/
N#define OS_IncDI()       { OS_ASSERT_DICnt(); OS_DI(); OS_DICnt++; }
N#define OS_DecRI()       { OS_ASSERT_DICnt(); if (--OS_DICnt==0) OS_EI(); }
N#define OS_RESTORE_I()   { OS_ASSERT_DICnt(); if (OS_DICnt==0)   OS_EI(); }
N
Nvoid OS_RestoreI(void);  /* OS_Kern.c */
N
N/*********************************************************************
N*
N*       ISR (Interrupt service routine) support
N*
N**********************************************************************
N*/
N
N#define RTOS_PPENDING           (1)     /*      Preemption  pending */
N#define RTOS_TSPENDING          (2)     /*      Task switch pending */
N#define RTOS_RRPENDING          (4)     /*      Round robin pending */
N
N
N#ifndef   OS_SUPPORT_INT_PRIORITY
S  #define OS_SUPPORT_INT_PRIORITY (1)
N#endif
N
N#if OS_SUPPORT_INT_PRIORITY
X#if (0)
S  #ifndef   OS_IPL_EI_DEFAULT
S    #error "Please define OS_IPL_EI_DEFAULT (OSChip.h)"
S  #endif
S
S  #ifndef   OS_IPL_DI_DEFAULT
S    #error "Please define OS_IPL_DI_DEFAULT (OSChip.h)"
S  #endif
S
S  #if OS_COMPILER_STORAGE_MODIFIER_LEFT
S    OS_EXTERN OS_SADDR unsigned int  OS_EXTERN_INIT(OS_Ipl_EI, OS_IPL_EI_DEFAULT);
S    OS_EXTERN OS_SADDR unsigned int  OS_EXTERN_INIT(OS_Ipl_DI, OS_IPL_DI_DEFAULT);
S  #else
S    OS_EXTERN unsigned int OS_SADDR  OS_EXTERN_INIT(OS_Ipl_EI, OS_IPL_EI_DEFAULT);
S    OS_EXTERN unsigned int OS_SADDR  OS_EXTERN_INIT(OS_Ipl_DI, OS_IPL_DI_DEFAULT);
S  #endif
N#endif
N
N#if OS_DEBUG
X#if 0
S  #define OS_MARK_IN_ISR()         {OS_InInt++;}
S  #define OS_MARK_OUTOF_ISR()      {if (!OS_InInt--) OS_Error(OS_ERR_LEAVEINT);}
N#else
N  #define OS_MARK_IN_ISR()
N  #define OS_MARK_OUTOF_ISR()
N#endif
N
N#if OS_SUPPORT_CALL_ISR            // Not allowed for some CPUs
X#if (1)            
Nvoid OS_CallISR        (void (*pRoutine)(void));
Nvoid OS_CallNestableISR(void (*pRoutine)(void));
N#endif
N
N#if (OS_SWITCH_FROM_INT_MODIFIES_STACK == 0) && (OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY != 0) && (OS_SCHEDULER_ACTIVATED_BY_EXCEPTION == 0)
X#if ((1) == 0) && ((0) != 0) && ((0) == 0)
S  //
S  // FOR CPUs without separate interrupt stack which do not disable interrupts on entry,
S  // OS_Enter- / Leave- Interrupt() is not defined.
S  // OS_CallISR() has to be used
S  //
N#else
N
N  #ifndef   OS_ENABLE_INTS_SAVE_IPL
N    #define OS_ENABLE_INTS_SAVE_IPL() OS_EI()
N  #endif
N
N  #ifndef   OS_RESTORE_IPL
N    #define OS_RESTORE_IPL()
N  #endif
N
N  #ifndef   OS_EI_ON_LEAVE
N    #define OS_EI_ON_LEAVE()        // Required for CPUs with do not restore DI-flag by RETI. Currently only CM3.
N  #endif
N
N  #if OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY
X  #if (0)
S    #define OS_DI_ON_ENTRY() OS_DI()
N  #else
N    #define OS_DI_ON_ENTRY()
N  #endif
N
N  #if OS_SWITCH_FROM_INT_MODIFIES_STACK
X  #if (1)
N    #define OS_HANDLE_REGION_CNT_ON_LI()                                          \
N      else {                                                                      \
N        OS_RegionCnt--;                                                           \
N      }
X    #define OS_HANDLE_REGION_CNT_ON_LI()                                                else {                                                                              OS_RegionCnt--;                                                                 }
N  #else
S    #define OS_HANDLE_REGION_CNT_ON_LI()                                          \
S      OS_RegionCnt--;
X    #define OS_HANDLE_REGION_CNT_ON_LI()                                                OS_RegionCnt--;
N  #endif
N
N
N  #define OS_SWITCH_FROM_INT_IF_REQUIRED()                                      \
N    if ((OS_RegionCnt == 1) && OS_Pending) {                                    \
N      OS_SwitchFromInt();                                                       \
N    }
X  #define OS_SWITCH_FROM_INT_IF_REQUIRED()                                          if ((OS_RegionCnt == 1) && OS_Pending) {                                          OS_SwitchFromInt();                                                           }
N
N  #define OS_EnterInterrupt() { \
N    OS_DI_ON_ENTRY();           \
N    OS_MARK_IN_ISR();           \
N    OS_RegionCnt++;             \
N    OS_DICnt++;                 \
N  }
X  #define OS_EnterInterrupt() {     OS_DI_ON_ENTRY();               OS_MARK_IN_ISR();               OS_RegionCnt++;                 OS_DICnt++;                   }
N
N  #define OS_LeaveInterrupt() {                                                 \
N    OS_MARK_OUTOF_ISR();                                                        \
N    OS_DICnt--; /* Must have been zero initially ! (We could put =0 instead) */ \
N    OS_SWITCH_FROM_INT_IF_REQUIRED()                                            \
N    OS_HANDLE_REGION_CNT_ON_LI();                                               \
N    OS_EI_ON_LEAVE();                                                           \
N  }
X  #define OS_LeaveInterrupt() {                                                     OS_MARK_OUTOF_ISR();                                                            OS_DICnt--;       OS_SWITCH_FROM_INT_IF_REQUIRED()                                                OS_HANDLE_REGION_CNT_ON_LI();                                                   OS_EI_ON_LEAVE();                                                             }
N
N  #define OS_LeaveInterruptNoSwitch() { \
N    OS_MARK_OUTOF_ISR();                \
N    OS_DICnt--;                         \
N    OS_RegionCnt--;                     \
N    OS_EI_ON_LEAVE();                   \
N  }
X  #define OS_LeaveInterruptNoSwitch() {     OS_MARK_OUTOF_ISR();                    OS_DICnt--;                             OS_RegionCnt--;                         OS_EI_ON_LEAVE();                     }
N
N  #define OS_EnterNestableInterrupt() { \
N    OS_MARK_IN_ISR();                   \
N    OS_RegionCnt++;                     \
N    OS_ENABLE_INTS_SAVE_IPL();          \
N  }
X  #define OS_EnterNestableInterrupt() {     OS_MARK_IN_ISR();                       OS_RegionCnt++;                         OS_ENABLE_INTS_SAVE_IPL();            }
N
N  #define OS_LeaveNestableInterrupt() {                                         \
N    OS_DI();                                                                    \
N    OS_MARK_OUTOF_ISR();                                                        \
N    OS_SWITCH_FROM_INT_IF_REQUIRED()                                            \
N    OS_HANDLE_REGION_CNT_ON_LI();                                               \
N    OS_RESTORE_IPL();                                                           \
N    OS_EI_ON_LEAVE();                                                           \
N  }
X  #define OS_LeaveNestableInterrupt() {                                             OS_DI();                                                                        OS_MARK_OUTOF_ISR();                                                            OS_SWITCH_FROM_INT_IF_REQUIRED()                                                OS_HANDLE_REGION_CNT_ON_LI();                                                   OS_RESTORE_IPL();                                                               OS_EI_ON_LEAVE();                                                             }
N
N  #define OS_LeaveNestableInterruptNoSwitch() { \
N    OS_DI();                                    \
N    OS_MARK_OUTOF_ISR();                        \
N    OS_RegionCnt--;                             \
N    OS_RESTORE_IPL();                           \
N    OS_EI_ON_LEAVE();                           \
N  }
X  #define OS_LeaveNestableInterruptNoSwitch() {     OS_DI();                                        OS_MARK_OUTOF_ISR();                            OS_RegionCnt--;                                 OS_RESTORE_IPL();                               OS_EI_ON_LEAVE();                             }
N#endif
N
N#ifndef OS_EnterIntStack
S  void OS__EnterIntStack(void);
S  #define OS_EnterIntStack() {OS_DI(); OS__EnterIntStack(); OS_RESTORE_I(); }
N#endif
N
N#ifndef OS_LeaveIntStack
S  void OS__LeaveIntStack(void);
S  #define OS_LeaveIntStack() {OS_DI(); OS__LeaveIntStack(); }
N#endif
N
Nvoid OS_SetFastIntPriorityLimit(OS_UINT Priority);
Xvoid OS_SetFastIntPriorityLimit(unsigned int Priority);
N
N/*********************************************************************
N*
N*       Resource semaphores
N*
N**********************************************************************
N*/
N
Nint      OS_Use             (OS_RSEMA * pRSema); /* OSRsem.c   */
Nvoid     OS_Unuse           (OS_RSEMA * pRSema); /* OSRsem.c   */
Nchar     OS_Request         (OS_RSEMA * pRSema); /* OSRsemRQ.c */
Nint      OS_GetSemaValue    (OS_RSEMA * pRSema); /* OSRSemGV.c */
NOS_TASK* OS_GetResourceOwner(OS_RSEMA * pRSema); /* OSRsemGO.c */
N
Nvoid     OS_CreateRSema     (OS_RSEMA * pRSema); /* OSRsem.c   */
Nvoid     OS_DeleteRSema     (OS_RSEMA * pRSema); /* OSDelRS.c  */
N
N#define  OS_CREATERSEMA(ps) OS_CreateRSema(ps)
N
N/*********************************************************************
N*
N*       Counting semaphores
N*
N**********************************************************************
N*/
N
Nvoid  OS_CreateCSema    (OS_CSEMA * pCSema, OS_UINT InitValue);  /* OSCSEM.c             */
Xvoid  OS_CreateCSema    (OS_CSEMA * pCSema, unsigned int InitValue);   
Nvoid  OS_DeleteCSema    (OS_CSEMA * pCSema);                     /* OSDELCS.c            */
Nint   OS_GetCSemaValue  (OS_CSEMA * pCSema);                     /* OSCSEMGV.c           */
NOS_U8 OS_SetCSemaValue  (OS_CSEMA * pCSema, OS_UINT value);      /* OS_SetCSemaValue.c   */
Xunsigned char OS_SetCSemaValue  (OS_CSEMA * pCSema, unsigned int value);       
Nvoid  OS_SignalCSema    (OS_CSEMA * pCSema);                     /* OSCSEM.c             */
Nvoid  OS_SignalCSemaMax (OS_CSEMA * pCSema, OS_UINT MaxValue);   /* OS_CSEMA_SignalMax.c */
Xvoid  OS_SignalCSemaMax (OS_CSEMA * pCSema, unsigned int MaxValue);    
Nvoid  OS_WaitCSema      (OS_CSEMA * pCSema);                     /* OSCSEM.c             */
Nint   OS_WaitCSemaTimed (OS_CSEMA * pCSema, OS_TIME TimeOut);    /* OSCSEMT.c            */
Xint   OS_WaitCSemaTimed (OS_CSEMA * pCSema, int TimeOut);     
Nchar  OS_CSemaRequest   (OS_CSEMA * pCSema);                     /* OSCSEMRQ.c           */
N
N#define OS_CREATECSEMA(ps) OS_CreateCSema(ps,0)
N
N/*********************************************************************
N*
N*       Mailboxes
N*
N**********************************************************************
N*/
N#define CREATEMB(MAILBOX, size, max, Buffer) OS_CreateMB(MAILBOX,size, max, Buffer);
Nvoid OS_CreateMB          (OS_MAILBOX * pMB, OS_U8 sizeofMsg, OS_UINT maxnofMsg, void* Buffer);    /* initialize mailbox */
Xvoid OS_CreateMB          (OS_MAILBOX * pMB, unsigned char sizeofMsg, unsigned int maxnofMsg, void* Buffer);     
Nvoid OS_ClearMB           (OS_MAILBOX * pMB);
Nvoid OS_PutMail           (OS_MAILBOX * pMB, void* pMail);
Nchar OS_PutMailCond       (OS_MAILBOX * pMB, void* pMail);
Nvoid OS_PutMailFront      (OS_MAILBOX * pMB, void* pMail);
Nchar OS_PutMailFrontCond  (OS_MAILBOX * pMB, void* pMail);
Nvoid OS_GetMail           (OS_MAILBOX * pMB, void* pDest);
Nchar OS_GetMailCond       (OS_MAILBOX * pMB, void* pDest);
Nvoid OS_PutMail1          (OS_MAILBOX * pMB, const char* pMail);
Nchar OS_PutMailCond1      (OS_MAILBOX * pMB, const char* pMail);
Nvoid OS_PutMailFront1     (OS_MAILBOX * pMB, const char* pMail);
Nchar OS_PutMailFrontCond1 (OS_MAILBOX * pMB, const char* pMail);
Nvoid OS_GetMail1          (OS_MAILBOX * pMB, char* pDest);
Nchar OS_GetMailCond1      (OS_MAILBOX * pMB, char* pDest);
Nchar OS_GetMailTimed      (OS_MAILBOX * pMB, void* pDest, OS_TIME Timeout);
Xchar OS_GetMailTimed      (OS_MAILBOX * pMB, void* pDest, int Timeout);
Nvoid OS_DeleteMB          (OS_MAILBOX * pMB);
Nvoid OS_WaitMail          (OS_MAILBOX * pMB);
N
N#if OS_DEBUG == 0
X#if 0 == 0
N  #define OS_GetMessageCnt(pMB) (*pMB).nofMsg
N#else
S  OS_UINT OS_GetMessageCnt(OS_MAILBOX * pMB);   /* get no. of available Messages */
N#endif
N
N/*********************************************************************
N*
N*       Message Queues (OSQ.c)
N*
N**********************************************************************
N*/
N
Nvoid    OS_Q_Create       (OS_Q* pQ, void*pData, OS_UINT Size);
Xvoid    OS_Q_Create       (OS_Q* pQ, void*pData, unsigned int Size);
Nvoid    OS_Q_Clear        (OS_Q* pQ);                                /* OSQCL.c  */
Nint     OS_Q_GetMessageCnt(OS_Q* pQ);                                /* OSQGMC.c */
Nint     OS_Q_Put          (OS_Q* pQ, const void* pSrc, OS_UINT Size);
Xint     OS_Q_Put          (OS_Q* pQ, const void* pSrc, unsigned int Size);
Nint     OS_Q_GetPtr       (OS_Q* pQ, void**ppData);
Nint     OS_Q_GetPtrCond   (OS_Q* pQ, void**ppData);                  /* OSQGPC.c */
Nint     OS_Q_GetPtrTimed  (OS_Q* pQ, void**ppData, OS_TIME Timeout); /* OSQGPT.c */
Xint     OS_Q_GetPtrTimed  (OS_Q* pQ, void**ppData, int Timeout);  
Nvoid    OS_Q_Purge        (OS_Q* pQ);
N
N/*********************************************************************
N*
N*       Events
N*
N**********************************************************************
N*/
N
Nchar OS_ClearEvents          (OS_TASK * pTask);                 /* OSEVENCL.c  */
Nchar OS_GetEventsOccured     (OS_TASK * pTask);                 /* OSEVENGE.c  */
Nvoid OS_SignalEvent          (char Event, OS_TASK * pTask);     /* OSENENS.c   */
Nchar OS_WaitEvent            (char EventMask);                  /* OSEVENW.c   */
Nchar OS_WaitEventTimed       (char EventMask, OS_TIME TimeOut); /* OSEVENT.c   */
Xchar OS_WaitEventTimed       (char EventMask, int TimeOut);  
Nchar OS_WaitSingleEvent      (char EventMask);                  /* OSEVENWS.c  */
Nchar OS_WaitSingleEventTimed (char EventMask, OS_TIME TimeOut); /* OSEVENWST.c */
Xchar OS_WaitSingleEventTimed (char EventMask, int TimeOut);  
N
N/*********************************************************************
N*
N*       Timers(OSTIME.c)
N*
N**********************************************************************
N*/
N
N#ifdef OS_SIZEOF_INT
N  #if OS_SIZEOF_INT == 2
X  #if (4) == 2
S    #define OS_TIMER_MAX_TIME 0x7F00
N  #elif OS_SIZEOF_INT == 4
X  #elif (4) == 4
N    #define OS_TIMER_MAX_TIME 0x7FFFFF00
N  #else
S    #error "OS_SIZEOF_INT not correctly defined"
N  #endif
N#endif
N
Nvoid    OS_CreateTimer    (OS_TIMER * pTimer, OS_TIMERROUTINE* Callback, OS_TIME Timeout);
Xvoid    OS_CreateTimer    (OS_TIMER * pTimer, OS_TIMERROUTINE* Callback, int Timeout);
Nvoid    OS_RetriggerTimer (OS_TIMER * pTimer);
Nvoid    OS_StartTimer     (OS_TIMER * pTimer);
Nvoid    OS_StopTimer      (OS_TIMER * pTimer);
Nvoid    OS_DeleteTimer    (OS_TIMER * pTimer);                  /* OSTIMED.c  */
NOS_TIME OS_GetTimerPeriod (OS_TIMER * pTimer);                  /* OSTIMEGP.c */
Xint OS_GetTimerPeriod (OS_TIMER * pTimer);                   
NOS_U8   OS_GetTimerStatus (OS_TIMER * pTimer);                  /* OSTIMEGS.c */
Xunsigned char   OS_GetTimerStatus (OS_TIMER * pTimer);                   
NOS_TIME OS_GetTimerValue  (OS_TIMER * pTimer);                  /* OSTIMEGV.c */
Xint OS_GetTimerValue  (OS_TIMER * pTimer);                   
Nvoid    OS_SetTimerPeriod (OS_TIMER * pTimer, OS_TIME Period);  /* OSTIMES.c  */
Xvoid    OS_SetTimerPeriod (OS_TIMER * pTimer, int Period);   
N
N#define OS_CREATETIMER(pTimer,c,d)  \
N        OS_CreateTimer(pTimer,c,d); \
N        OS_StartTimer(pTimer);
X#define OS_CREATETIMER(pTimer,c,d)          OS_CreateTimer(pTimer,c,d);         OS_StartTimer(pTimer);
N
N/*********************************************************************
N*
N*       Extended timers (OSTIMERX.c)
N*
N**********************************************************************
N*/
Nvoid    OS_CreateTimerEx (OS_TIMER_EX * pTimerEx, OS_TIMER_EX_ROUTINE* Callback, OS_TIME Timeout, void * pData);
Xvoid    OS_CreateTimerEx (OS_TIMER_EX * pTimerEx, OS_TIMER_EX_ROUTINE* Callback, int Timeout, void * pData);
N
N#define OS_RetriggerTimerEx(pTimerEx)         OS_RetriggerTimer(&(pTimerEx)->Timer)
N#define OS_StartTimerEx(pTimerEx)             OS_StartTimer(&(pTimerEx)->Timer)
N#define OS_StopTimerEx(pTimerEx)              OS_StopTimer(&(pTimerEx)->Timer)
N#define OS_DeleteTimerEx(pTimerEx)            OS_DeleteTimer(&(pTimerEx)->Timer)
N#define OS_GetTimerPeriodEx(pTimerEx)         OS_GetTimerPeriod(&(pTimerEx)->Timer)
N#define OS_GetTimerStatusEx(pTimerEx)         OS_GetTimerStatus(&(pTimerEx)->Timer)
N#define OS_GetTimerValueEx(pTimerEx)          OS_GetTimerValue(&(pTimerEx)->Timer)
N#define OS_SetTimerPeriodEx(pTimerEx,Period)  OS_SetTimerPeriod(&(pTimerEx)->Timer, Period)
N
N#define OS_CREATETIMER_EX(pTimerEx,cb,Timeout,pData) \
N        OS_CreateTimerEx(pTimerEx,cb,Timeout,pData); \
N        OS_StartTimerEx(pTimerEx)
X#define OS_CREATETIMER_EX(pTimerEx,cb,Timeout,pData)         OS_CreateTimerEx(pTimerEx,cb,Timeout,pData);         OS_StartTimerEx(pTimerEx)
N
N/*********************************************************************
N*
N*       Heap type memory management (OS_Alloc.c)
N*
N**********************************************************************
N
N  This functions might not be implemented in all OS ports.
N  Therefore declaration depends on condition OS_SUPPORT_OS_ALLOC
N  which has to be defined in CPU specific part
N
N*/
N
N#if OS_SUPPORT_OS_ALLOC
X#if (1)
N  void* OS_malloc(unsigned int);
N  void  OS_free  (void* pMemBlock);
N  void* OS_realloc  (void* pMemBlock, unsigned NewSize);
N#endif
N
N/*********************************************************************
N*
N*       Fixed Block memory management
N*
N**********************************************************************
N*/
N
Nvoid  OS_MEMF_Create(OS_MEMF* pMEMF, void* pPool, OS_U16 NumBlocks, OS_U16 BlockSize);
Xvoid  OS_MEMF_Create(OS_MEMF* pMEMF, void* pPool, unsigned short NumBlocks, unsigned short BlockSize);
Nvoid  OS_MEMF_Delete(OS_MEMF* pMEMF);
Nvoid* OS_MEMF_Alloc(OS_MEMF* pMEMF, int Purpose);
Nvoid* OS_MEMF_AllocTimed(OS_MEMF* pMEMF, OS_TIME Timeout, int Purpose);
Xvoid* OS_MEMF_AllocTimed(OS_MEMF* pMEMF, int Timeout, int Purpose);
Nvoid* OS_MEMF_Request(OS_MEMF* pMEMF, int Purpose);
Nvoid  OS_MEMF_Release(OS_MEMF* pMEMF, void* pMemBlock);
Nvoid  OS_MEMF_FreeBlock(void* pMemBlock);
Nint   OS_MEMF_GetNumFreeBlocks(OS_MEMF* pMEMF);
Nchar  OS_MEMF_IsInPool(OS_MEMF* pMEMF, void* pMemBlock);
Nint   OS_MEMF_GetMaxUsed(OS_MEMF* pMEMF);
Nint   OS_MEMF_GetNumBlocks(OS_MEMF* pMEMF);
Nint   OS_MEMF_GetBlockSize(OS_MEMF* pMEMF);
N
N/*********************************************************************
N*
N*       Event object module
N*
N**********************************************************************
N*/
N
N/****** Simple OS_EVENT functions ************************************/
N
Nvoid  OS_EVENT_Create    (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Delete    (OS_EVENT* pEvent);
N
NOS_U8 OS_EVENT_Get       (OS_EVENT* pEvent);
Xunsigned char OS_EVENT_Get       (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Pulse     (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Reset     (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Set       (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Wait      (OS_EVENT* pEvent);
Nchar  OS_EVENT_WaitTimed (OS_EVENT* pEvent, OS_TIME Timeout);
Xchar  OS_EVENT_WaitTimed (OS_EVENT* pEvent, int Timeout);
N
N/*********************************************************************
N*
N*       Timing support (OSTiming.c)
N*
N**********************************************************************
N
N New in V3.04, but not yet documented to the end user. Great for
N run-time measurement.
N*/
N
N#define OS_TIMING OS_U32
Nvoid    OS_Timing_Start(OS_TIMING* pCycle);
Xvoid    OS_Timing_Start(unsigned int* pCycle);
Nvoid    OS_Timing_End(OS_TIMING* pCycle);
Xvoid    OS_Timing_End(unsigned int* pCycle);
NOS_U32  OS_Timing_Getus(OS_TIMING* pCycle);
Xunsigned int  OS_Timing_Getus(unsigned int* pCycle);
N#define OS_Timing_GetCycles(pPara) (*pPara)
N
N
N/*********************************************************************
N*
N*       OS Power control module OS_Power.c
N*
N**********************************************************************
N*/
N#if OS_SUPPORT_POWER
X#if (1)
N#define OS_POWER_LEVEL0  (0x0001)
N#define OS_POWER_LEVEL1  (0x0002)
N#define OS_POWER_LEVEL2  (0x0004)
N#define OS_POWER_LEVEL3  (0x0008)
N#define OS_POWER_LEVEL4  (0x0010)
N#define OS_POWER_LEVEL5  (0x0020)
N#define OS_POWER_LEVEL6  (0x0040)
N#define OS_POWER_LEVEL8  (0x0080)
N
Nvoid    OS_POWER_UsageInc(OS_UINT Level);
Xvoid    OS_POWER_UsageInc(unsigned int Level);
Nvoid    OS_POWER_UsageDec(OS_UINT Level);
Xvoid    OS_POWER_UsageDec(unsigned int Level);
NOS_UINT OS_POWER_GetMask(void);
Xunsigned int OS_POWER_GetMask(void);
N#endif
N
N/*********************************************************************
N*
N*       Advanced profiling support (Module OsKern.c)
N*
N**********************************************************************
N*/
N#if OS_PROFILE >= 1
X#if 0 >= 1
S  void OS_EnableProfiling(int Period);
S  #define OS_DisableProfiling() { OS_ProfilingOn=0; }
N#else
N  #define OS_EnableProfiling(Period);
N  #define OS_DisableProfiling()
N#endif
N
N/*********************************************************************
N*
N*       Configuration
N*
N**********************************************************************
N*/
N
N#define OS_CONFIG_FRACT(f, div)                    \
N  OS_TicksPerMS  = f/1000;                         \
N  OS_IntMSInc    = div*1000L/f;                    \
N  OS_IntTicksInc = div-(f/1000)*(div*1000L/f);
X#define OS_CONFIG_FRACT(f, div)                      OS_TicksPerMS  = f/1000;                           OS_IntMSInc    = div*1000L/f;                      OS_IntTicksInc = div-(f/1000)*(div*1000L/f);
N
N#define OS_CONFIG(f, div)     \
N  OS_IntMSInc    = div*1000L/f;
X#define OS_CONFIG(f, div)       OS_IntMSInc    = div*1000L/f;
N
N
N/*********************************************************************
N*
N*       Trace support (OSTrace.c)
N*
N**********************************************************************
N
NTrace support is enabled by defining OS_TRACE 1.
NThis is automatically done, when OS_LIBMODE_T is defined.
N
N*/
N
N#if OS_TRACE
X#if 0
S  /* Declare trace function prototypes */
S  void OS_TraceVoid (OS_U8 id);
S  void OS_TracePtr  (OS_U8 id, void* p);
S  void OS_TraceData (OS_U8 id, int v);
S  void OS_TraceDataPtr (OS_U8 id, int v, void*p);
S  void OS_TraceU32Ptr  (OS_U8 id, OS_U32 p0, void*p1);
S  void OS_TraceEnable(void);
S  void OS_TraceDisable(void);
S  void OS_TraceEnableAll(void);                              /* OSTrace1.c */
S  void OS_TraceDisableAll(void);                             /* OSTrace1.c */
S  void OS_TraceEnableId(OS_U8 id);                           /* OSTrace1.c */
S  void OS_TraceDisableId(OS_U8 id);                          /* OSTrace1.c */
S  void OS_TraceEnableFilterId(OS_U8 FilterIndex, OS_U8 id);  /* OSTrace1.c */
S  void OS_TraceDisableFilterId(OS_U8 FilterIndex, OS_U8 id); /* OSTrace1.c */
S
S  /* Trace function macros, used in API functions */
S  #define OS_TRACE_VOID(id)            OS_TraceVoid(id)
S  #define OS_TRACE_PTR(id, p)          OS_TracePtr(id, p)
S  #define OS_TRACE_DATA(id, v)         OS_TraceData(id, v)
S  #define OS_TRACE_DATA_PTR(id, v, p)  OS_TraceDataPtr(id, v, p)
S  #define OS_TRACE_U32_PTR(id, p0, p1) OS_TraceU32Ptr(id, p0, p1)
S
S  #define OS_TRACE_START()                    { OS_EnterRegion();                                }
S  #define OS_TRACE_START_VOID(id)             { OS_EnterRegion(); OS_TraceVoid(id);              }
S  #define OS_TRACE_START_PTR(id, p)           { OS_EnterRegion(); OS_TracePtr(id, p);            }
S  #define OS_TRACE_START_DATA(id, v)          { OS_EnterRegion(); OS_TraceData(id, v);           }
S  #define OS_TRACE_START_DATA_PTR(id, v, p)   { OS_EnterRegion(); OS_TraceDataPtr(id, v, p);     }
S  #define OS_TRACE_START_U32_PTR(id, p0, p1)  { OS_EnterRegion(); OS_TraceU32Ptr(id, u, p);      }
S  #define OS_TRACE_END()                      { OS_LeaveRegion();                                }
S
N#else
N  /* Replace trace functions by empty macros if trace is not enabled */
N  #define OS_TraceVoid(id)
N  #define OS_TracePtr(id, p)
N  #define OS_TraceData(id, v)
N  #define OS_TraceDataPtr(id, v, p)
N  #define OS_TraceU32Ptr(id, p0, p1)
N  #define OS_TraceEnable()
N  #define OS_TraceDisable()
N  #define OS_TraceEnableAll()
N  #define OS_TraceDisableAll()
N  #define OS_TraceEnableId(id)
N  #define OS_TraceDisableId(id)
N  #define OS_TraceEnableFilterId(FilterIndex, id)
N  #define OS_TraceDisableFilterId(FilterIndex, id)
N  /* Trace function macros, used in API functions. */
N  /* Expand to nothing if trace is disabled       */
N  #define OS_TRACE_VOID(id)
N  #define OS_TRACE_PTR(id, p)
N  #define OS_TRACE_DATA(id, v)
N  #define OS_TRACE_DATA_PTR(id, v, p)
N  #define OS_TRACE_U32_PTR(id, p0, p1)
N
N  #define OS_TRACE_START()
N  #define OS_TRACE_START_VOID(id)
N  #define OS_TRACE_START_PTR(id, p)
N  #define OS_TRACE_START_DATA(id, v)
N  #define OS_TRACE_START_DATA_PTR(id, v, p)
N  #define OS_TRACE_START_U32_PTR(id, p0, p1)
N  #define OS_TRACE_END()
N#endif
N
N/*********************************************************************
N*
N*        RTOSInit and misc.
N*
N**********************************************************************
N
NThe routines declared below are available on all targets.
N
N*/
N
N/* Routines in RTOSInit.c */
Nvoid   OS_InitHW(void);
Nvoid   OS_Idle(void);
NOS_U32 OS_ConvertCycles2us(OS_U32 Cycles);
Xunsigned int OS_ConvertCycles2us(unsigned int Cycles);
NOS_U32 OS_GetTime_Cycles(void);
Xunsigned int OS_GetTime_Cycles(void);
Nvoid   OS_COM_Init(void);
Nvoid   OS_COM_Send1(unsigned char c);
N
N/* Routines in OS_Error.c, delivered as source file */
Nvoid   OS_Error(int code);
N
NOS_INTERWORK void  OS_Start(void);                  /* RTOS ASM part   */
X void  OS_Start(void);                   
NOS_INTERWORK void  OS_Switch(void);                 /* RTOS ASM part   */
X void  OS_Switch(void);                  
NOS_INTERWORK int   OS_SwitchFromInt(void);          /* RTOS ASM part   */
X int   OS_SwitchFromInt(void);           
N
Nvoid  OS_InitKern(void);             /* OSKern.c        */
NOS_U8 OS_OnTx(void);                 /* OSComRxTx1.c, Returns 1 on last byte */
Xunsigned char OS_OnTx(void);                  
Nvoid  OS_OnRx(unsigned char c);      /* OSComRxTx1.c    */
Nvoid  OS_Send1(OS_U8 c);             /* not implemented */
Xvoid  OS_Send1(unsigned char c);              
Nvoid  OS_SendString(const char* s);  /* OSSend.c        */
NOS_RX_CALLBACK* OS_SetRxCallback(OS_RX_CALLBACK* cb);
NOS_U8 OS_EvaPacketEx(const OS_U8 * pSrc, OS_U16 SrcLen, OS_U8** pReturn);  /* OS_EvaPacketEx.c */
Xunsigned char OS_EvaPacketEx(const unsigned char * pSrc, unsigned short SrcLen, unsigned char** pReturn);   
N
Nvoid  OS_COM_ClearTxActive(void);    /* OSCom2.c */
N
N/*********************************************************************
N*
N*        RTOS misc. optional
N*
N**********************************************************************
N
NThe routines declared below are available on some targets
Nonly. (Because they do not make much sense on others)
N*/
N
N/* Timing routines. Their existance depends on the CPU. In general,
N  8-bit CPUs require both routines, where 16-bit CPUs require one
N  and 32-bit CPUs require none of these.
N*/
N#ifndef OS_GetTime
S  OS_TIME OS_GetTime(void);
N#endif
N#ifndef OS_GetTime32
S  #if (OS_SIZEOF_INT == 4)
S    #define OS_GetTime32() (OS_Time)
S  #else
S    OS_I32 OS_GetTime32(void);
S  #endif
N#endif
N
Nvoid OS__di(void);
Nvoid OS__ei(void);
Nvoid OS__SaveIPL(void);
Nvoid OS__RestIPL(void);
Nvoid OS_SIM_Init(void);
N
N/* Standard tick handler which increment OS time variable by one on each interrupt */
Nvoid OS_HandleTick(void);       /* New version of OS_TickHandler() without Enter- Leave-Interrupt    */
Nvoid OS_HandleTickDI(void);     /* OSTickDI.c */
N
N/* Non standard tick handler which increment the OS time variable by OS_IntMsInc once on each interrupt */
N/* One of these handler has to be used when OS_CONFIG() is used to set a tick increment unequal to 0    */
Nvoid OS_HandleTick_Ex(void);    /* OS_HandleTick_Ex.c */
Nvoid OS_HandleTickDI_Ex(void);  /* OSTickDI_Ex.c      */
N
Nvoid OS_AddTickHook(OS_TICK_HOOK* pHook, OS_TICK_HOOK_ROUTINE * pfUser);
Nvoid OS_RemoveTickHook(OS_TICK_HOOK* pHook);
N
N/* Routines for the PC-version running in native mode (non-windows) */
Nvoid OS_SetIntFreq(OS_UINT f);
Xvoid OS_SetIntFreq(unsigned int f);
Nvoid OS_Exit(int code);
Nvoid OS_UseDos(void);
Nvoid OS_UnuseDos(void);
Nint  OS_GetKey(void);
Nint  OS_WaitKey(void);
N
N/* Compatibility with manual */
N#define OS_CREATEMB          OS_CreateMB
N#define OS_GetUseCnt         OS_GetSemaValue
N#define OS_WaitCSema_Timed   OS_WaitCSemaTimed
N#define OS_WaitEvent_Timed   OS_WaitEventTimed
N
N/********************************************************************/
N
N#ifdef __cplusplus
S  }
N#endif
N
N#endif /* RTOS_H_INCLUDED */
N
N/*****  EOF  ********************************************************/
N
L 31 "FS\FS_X_embOS.c" 2
N
N/*********************************************************************
N*
N*       Static data
N*
N**********************************************************************
N*/
Nstatic OS_RSEMA * _paSema;
Nstatic char       _NumLocks;
Nstatic OS_EVENT   _Event;
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       FS_X_OS_Lock
N*
N*/
Nvoid FS_X_OS_Lock(unsigned LockIndex) {
N  OS_RSEMA * pSema;
N
N  pSema = _paSema + LockIndex;
N  if (pSema) {
N    OS_Use(pSema);
N  }
N}
N
N/*********************************************************************
N*
N*       FS_X_OS_Unlock
N*
N*/
Nvoid FS_X_OS_Unlock(unsigned LockIndex) {
N  OS_RSEMA * pSema;
N
N  pSema = _paSema + LockIndex;
N  if (pSema) {
N    OS_Unuse(pSema);
N  }
N}
N
N/*********************************************************************
N*
N*       FS_X_OS_Init
N*
N*  Description:
N*    Initializes the OS resources. Specifically, you will need to
N*    create four binary semaphores. This function is called by
N*    FS_Init(). You should create all resources required by the
N*    OS to support multi threading of the file system.
N*
N*  Parameters:
N*    None.
N*
N*  Return value:
N*    0    - on success
N*    -1   - on failure.
N*/
Nvoid FS_X_OS_Init(unsigned NumLocks) {
N  unsigned i;
N  OS_RSEMA * pSema;
N
N  _paSema = (OS_RSEMA *)FS_AllocZeroed(NumLocks* sizeof(OS_RSEMA));
N  pSema =_paSema;
N  for (i = 0; i < NumLocks; i++) {
N    OS_CREATERSEMA(pSema++);
X    OS_CreateRSema(pSema++);
N  }
N  OS_EVENT_Create(&_Event);
N}
N
N
N/*********************************************************************
N*
N*       FS_X_OS_DeInit
N*
N*  Description:
N*    Delete all locks that have been created by FS_X_OS_Init().
N*    This makes sure that a
N*
N*  Parameters:
N*    None.
N*
N*/
Nvoid FS_X_OS_DeInit(void) {
N  unsigned i;
N  OS_RSEMA  * pSema;
N  unsigned    NumLocks;
N
N  NumLocks = _NumLocks;
N  pSema   = &_paSema[0];
N  for (i = 0; i < NumLocks; i++) {
N    OS_DeleteRSema(pSema);
N    pSema++;
N  }
N  OS_EVENT_Delete(&_Event);
N  FS_Free(_paSema);
N  _paSema  = NULL;
X  _paSema  = 0;
N  _NumLocks = 0;
N}
N
N/*********************************************************************
N*
N*       FS_X_OS_GetTime
N*
N*/
NU32  FS_X_OS_GetTime(void) {
Xunsigned long  FS_X_OS_GetTime(void) {
N  return (U32)OS_GetTime32();
X  return (unsigned long)(OS_Time);
N}
N
N/*********************************************************************
N*
N*       FS_X_OS_Wait
N*
N*  Function description:
N*    Wait for an event to be signaled.
N*
N*  Parameters:
N*    Timeout    - Time to be wait for the event object.
N*
N*  Return value:
N*    0       - Event object was signaled within the timeout value
N*   -1       - An error or a timeout occurred.
N*/
Nint FS_X_OS_Wait(int Timeout) {
N  int r;
N
N  r = -1;
N  if (OS_EVENT_WaitTimed(&_Event, Timeout) == 0) {
N    r = 0;
N  }
N  return r;
N}
N
N/*********************************************************************
N*
N*       FS_X_OS_Signal
N*
N*  Function description:
N*    Signals a event
N*
N*/
Nvoid FS_X_OS_Signal(void) {
N  OS_EVENT_Set(&_Event);
N}
N
N
N/*************************** End of file ****************************/
