; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--thumb --list -c --asm --interleave -o.\output\lpc2478_ea\release_flash_j-link\obj\i2cpca9532.o --asm_dir=.\Output\LPC2478_EA\Release_FLASH_J-Link\LST\ --list_dir=.\Output\LPC2478_EA\Release_FLASH_J-Link\LST\ --depend=.\output\lpc2478_ea\release_flash_j-link\obj\i2cpca9532.d --apcs=interwork -O3 -IApplication\SEGGERDEMO -IApplication\SEGGERDEMO\Src -ISetup -IInc -IConfig -IFS -IIP -IIP\IP_FS\FS_RO\Generated -IGUI -IOS -IUSB -IUSBH -I"C:\Program Files (x86)\Keil\V473\ARM\RV31\INC" -I"C:\Program Files (x86)\Keil\V473\ARM\CMSIS\Include" -I"C:\Program Files (x86)\Keil\V473\ARM\Inc\Philips" Setup\I2CPCA9532.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _I2C_WriteWithWait PROC
;;;266    */
;;;267    static unsigned char _I2C_WriteWithWait(unsigned char Data) {
000000  b510              PUSH     {r4,lr}
000002  0004              MOVS     r4,r0
                  |L1.4|
;;;268      unsigned char r = 0;
;;;269    
;;;270      r = _I2C_PutChar(Data);
000004  f7fffffe          BL       _I2C_PutChar
;;;271      while(r == I2C_CODE_BUSY) {
000008  2806              CMP      r0,#6
00000a  d00d              BEQ      |L1.40|
;;;272        r = _I2C_PutChar(Data);
;;;273      }
;;;274      if(r == I2C_CODE_OK)
00000c  2800              CMP      r0,#0
00000e  d108              BNE      |L1.34|
                  |L1.16|
000010  f7fffffe          BL       _I2C_CheckStatus
000014  2818              CMP      r0,#0x18
000016  d009              BEQ      |L1.44|
000018  2828              CMP      r0,#0x28
00001a  d007              BEQ      |L1.44|
00001c  28f8              CMP      r0,#0xf8
00001e  d0f7              BEQ      |L1.16|
000020  2003              MOVS     r0,#3
                  |L1.34|
;;;275        r = _I2C_WaitTransmit();
;;;276    
;;;277      return r;
;;;278    }
000022  bc10              POP      {r4}
000024  bc08              POP      {r3}
000026  4718              BX       r3
                  |L1.40|
000028  0020              MOVS     r0,r4                 ;272
00002a  e7eb              B        |L1.4|
                  |L1.44|
00002c  2000              MOVS     r0,#0                 ;272
00002e  e7f8              B        |L1.34|
;;;279    
                          ENDP

                  _I2C_GetChar PROC
;;;352    */
;;;353    static unsigned char _I2C_GetChar(unsigned char Mode, unsigned char * pBuf) {
000030  b430              PUSH     {r4,r5}
;;;354      unsigned char r = I2C_CODE_OK;
;;;355    
;;;356      if(Mode == I2C_MODE_ACK0) {
;;;357        //
;;;358        // Operation mode is changed from master transmit to master receive
;;;359        // Set ACK = 0 (informs slave to send next byte)
;;;360        //
;;;361        I20CONSET |= (1 << 2);  // AA = 1
000032  4a75              LDR      r2,|L1.520|
000034  2300              MOVS     r3,#0                 ;354
000036  2504              MOVS     r5,#4
;;;362        I20CONCLR  = (1 << 3);  // Clear SI flag
000038  2408              MOVS     r4,#8
00003a  2800              CMP      r0,#0                 ;356
00003c  d004              BEQ      |L1.72|
;;;363      } else if (Mode == I2C_MODE_ACK1) {
00003e  2801              CMP      r0,#1
000040  d006              BEQ      |L1.80|
;;;364        I20CONCLR = (1 << 2);   // Set ACK = 1 (informs slave to send last byte)
;;;365        I20CONCLR = (1 << 3);   // Clear SI flag
;;;366      } else if (Mode == I2C_MODE_READ) {
000042  2802              CMP      r0,#2
000044  d007              BEQ      |L1.86|
000046  e00d              B        |L1.100|
                  |L1.72|
000048  6810              LDR      r0,[r2,#0]            ;361
00004a  4328              ORRS     r0,r0,r5              ;361
00004c  6010              STR      r0,[r2,#0]            ;361
00004e  e000              B        |L1.82|
                  |L1.80|
000050  6195              STR      r5,[r2,#0x18]         ;364
                  |L1.82|
000052  6194              STR      r4,[r2,#0x18]         ;365
000054  e006              B        |L1.100|
                  |L1.86|
;;;367        //
;;;368        // Check if I2C Data register can be accessed
;;;369        //
;;;370        if (I20CONSET & (1 << 3)) {       // SI = 1
000056  6810              LDR      r0,[r2,#0]
000058  0700              LSLS     r0,r0,#28
00005a  d502              BPL      |L1.98|
;;;371          *pBuf = (unsigned char)I20DAT;  // Read data
00005c  6890              LDR      r0,[r2,#8]
00005e  7008              STRB     r0,[r1,#0]
000060  e000              B        |L1.100|
                  |L1.98|
;;;372        } else {
;;;373          r = I2C_CODE_EMPTY;  // No data available
000062  2305              MOVS     r3,#5
                  |L1.100|
;;;374        }
;;;375      }
;;;376    
;;;377      return r;
;;;378    }
000064  bc30              POP      {r4,r5}
000066  0018              MOVS     r0,r3                 ;377
000068  4770              BX       lr
;;;379    
                          ENDP

                  I2CPCA9532_WriteRead PROC
;;;390    */
;;;391    unsigned char I2CPCA9532_WriteRead(unsigned char * pData, unsigned short NumBytesToWrite, unsigned char * pBuf, unsigned short NumBytesToRead) {
00006a  b5ff              PUSH     {r0-r7,lr}
00006c  4d66              LDR      r5,|L1.520|
00006e  001e              MOVS     r6,r3
000070  6828              LDR      r0,[r5,#0]
000072  b081              SUB      sp,sp,#4
000074  2720              MOVS     r7,#0x20
000076  4338              ORRS     r0,r0,r7
000078  6028              STR      r0,[r5,#0]
                  |L1.122|
00007a  f7fffffe          BL       _I2C_CheckStatus
00007e  2808              CMP      r0,#8
000080  d004              BEQ      |L1.140|
000082  2810              CMP      r0,#0x10
000084  d002              BEQ      |L1.140|
000086  28f8              CMP      r0,#0xf8
000088  d101              BNE      |L1.142|
00008a  e005              B        |L1.152|
                  |L1.140|
00008c  2000              MOVS     r0,#0
                  |L1.142|
00008e  2120              MOVS     r1,#0x20
000090  61a9              STR      r1,[r5,#0x18]
;;;392      unsigned char  r       = 0;
;;;393      unsigned char  Status  = 0;
;;;394      unsigned short i       = 0;
;;;395    
;;;396      r = _I2C_Start();  // Generate Start condition
000092  0004              MOVS     r4,r0
;;;397      if(r != I2C_CODE_OK) {
000094  d119              BNE      |L1.202|
000096  e002              B        |L1.158|
                  |L1.152|
000098  2008              MOVS     r0,#8
00009a  61a8              STR      r0,[r5,#0x18]
00009c  e7ed              B        |L1.122|
                  |L1.158|
;;;398        goto STOPWRITE;
;;;399      }
;;;400      r = _I2C_WriteWithWait(0xC0);  // Write PCA9532 address
00009e  20c0              MOVS     r0,#0xc0
0000a0  f7fffffe          BL       _I2C_WriteWithWait
0000a4  0004              MOVS     r4,r0
;;;401      if (r != I2C_CODE_OK) {
0000a6  d110              BNE      |L1.202|
;;;402        goto STOPWRITE;
;;;403      }
;;;404      //
;;;405      // Write data
;;;406      //
;;;407      for (i = 0; i < NumBytesToWrite; i++) {
0000a8  2700              MOVS     r7,#0
0000aa  e00b              B        |L1.196|
                  |L1.172|
;;;408        r = _I2C_WriteWithWait(*pData);
0000ac  9801              LDR      r0,[sp,#4]
0000ae  7800              LDRB     r0,[r0,#0]
0000b0  f7fffffe          BL       _I2C_WriteWithWait
0000b4  0004              MOVS     r4,r0
;;;409        if (r != I2C_CODE_OK) {
0000b6  d108              BNE      |L1.202|
;;;410          goto STOPWRITE;
;;;411        }
;;;412        pData++;
0000b8  9801              LDR      r0,[sp,#4]
0000ba  1c40              ADDS     r0,r0,#1
0000bc  1c7f              ADDS     r7,r7,#1              ;407
0000be  043f              LSLS     r7,r7,#16             ;407
0000c0  0c3f              LSRS     r7,r7,#16             ;407
0000c2  9001              STR      r0,[sp,#4]            ;407
                  |L1.196|
0000c4  9802              LDR      r0,[sp,#8]            ;407
0000c6  4287              CMP      r7,r0                 ;407
0000c8  d3f0              BCC      |L1.172|
                  |L1.202|
;;;413      }
;;;414    STOPWRITE:
;;;415      if (NumBytesToRead > 0) {
0000ca  2e00              CMP      r6,#0
0000cc  d038              BEQ      |L1.320|
0000ce  6828              LDR      r0,[r5,#0]
0000d0  2420              MOVS     r4,#0x20
0000d2  4320              ORRS     r0,r0,r4
0000d4  6028              STR      r0,[r5,#0]
0000d6  2708              MOVS     r7,#8
0000d8  e009              B        |L1.238|
                  |L1.218|
0000da  2810              CMP      r0,#0x10
0000dc  d002              BEQ      |L1.228|
0000de  28f8              CMP      r0,#0xf8
0000e0  d005              BEQ      |L1.238|
0000e2  e000              B        |L1.230|
                  |L1.228|
0000e4  2000              MOVS     r0,#0
                  |L1.230|
0000e6  61ac              STR      r4,[r5,#0x18]
;;;416        r = _I2C_RepeatStart();  // Generate Start condition
0000e8  0004              MOVS     r4,r0
;;;417        //
;;;418        // Transmit device address
;;;419        //
;;;420        if (r == I2C_CODE_OK) {
0000ea  d006              BEQ      |L1.250|
0000ec  e00b              B        |L1.262|
                  |L1.238|
0000ee  61af              STR      r7,[r5,#0x18]
0000f0  f7fffffe          BL       _I2C_CheckStatus
0000f4  2808              CMP      r0,#8
0000f6  d0f5              BEQ      |L1.228|
0000f8  e7ef              B        |L1.218|
                  |L1.250|
;;;421          r = _I2C_PutChar(0xc0 + 0x01);  // Write SLA+R
0000fa  20c1              MOVS     r0,#0xc1
0000fc  f7fffffe          BL       _I2C_PutChar
000100  0004              MOVS     r4,r0
;;;422          while(r == I2C_CODE_BUSY) {
000102  2806              CMP      r0,#6
000104  d0f9              BEQ      |L1.250|
                  |L1.262|
;;;423            r = _I2C_PutChar(0xc0 + 0x01);
;;;424          }
;;;425        }
;;;426        //
;;;427        // Wait until SLA+R transmitted
;;;428        //
;;;429        while (1) {
;;;430          Status = _I2C_CheckStatus();
000106  f7fffffe          BL       _I2C_CheckStatus
;;;431          if (Status == 0x40) {         // Data transmitted and ACK received
00010a  2840              CMP      r0,#0x40
00010c  d003              BEQ      |L1.278|
;;;432            break;
;;;433          } else if (Status != 0xF8) {  // Error
00010e  28f8              CMP      r0,#0xf8
000110  d0f9              BEQ      |L1.262|
;;;434            r = I2C_CODE_ERROR;
000112  2403              MOVS     r4,#3
;;;435            break;
000114  e014              B        |L1.320|
                  |L1.278|
;;;436          }
;;;437        }
;;;438        if (r == I2C_CODE_OK) {
000116  2c00              CMP      r4,#0
000118  d112              BNE      |L1.320|
;;;439          //
;;;440          // Wait until address transmitted and receive data
;;;441          //
;;;442          for (i = 1; i <= NumBytesToRead; i++) {
00011a  2701              MOVS     r7,#1
00011c  e00e              B        |L1.316|
                  |L1.286|
;;;443            //
;;;444            // Wait until data transmitted
;;;445            //
;;;446            while (1) {
;;;447              Status = _I2C_CheckStatus();
00011e  f7fffffe          BL       _I2C_CheckStatus
;;;448              if ((Status == 0x40) || (Status == 0x48) || (Status == 0x50 )) {  // Data received
000122  2840              CMP      r0,#0x40
000124  d01a              BEQ      |L1.348|
000126  2848              CMP      r0,#0x48
000128  d018              BEQ      |L1.348|
00012a  2850              CMP      r0,#0x50
00012c  d016              BEQ      |L1.348|
;;;449                //
;;;450                // Set generate NACK
;;;451                //
;;;452                if (i == NumBytesToRead) {
;;;453                  r = _I2C_GetChar(I2C_MODE_ACK1, pBuf);
;;;454                } else {
;;;455                  r = _I2C_GetChar(I2C_MODE_ACK0, pBuf);
;;;456                }
;;;457                r = _I2C_GetChar(I2C_MODE_READ, pBuf);  // Read data
;;;458                while (r == I2C_CODE_EMPTY) {
;;;459                  r = _I2C_GetChar(I2C_MODE_READ, pBuf);
;;;460                }
;;;461                pBuf++;
;;;462                break;
;;;463              } else if (Status != 0xF8) {  // Error
00012e  28f8              CMP      r0,#0xf8
000130  d0f5              BEQ      |L1.286|
;;;464                i = NumBytesToRead;
000132  0037              MOVS     r7,r6
;;;465                r = I2C_CODE_ERROR;
000134  2403              MOVS     r4,#3
                  |L1.310|
000136  1c7f              ADDS     r7,r7,#1              ;442
000138  043f              LSLS     r7,r7,#16             ;442
00013a  0c3f              LSRS     r7,r7,#16             ;442
                  |L1.316|
00013c  42b7              CMP      r7,r6                 ;442
00013e  d9ee              BLS      |L1.286|
                  |L1.320|
000140  6828              LDR      r0,[r5,#0]            ;442
000142  2110              MOVS     r1,#0x10              ;442
000144  4308              ORRS     r0,r0,r1              ;442
000146  6028              STR      r0,[r5,#0]            ;442
000148  2008              MOVS     r0,#8                 ;442
00014a  61a8              STR      r0,[r5,#0x18]         ;442
                  |L1.332|
00014c  6828              LDR      r0,[r5,#0]            ;442
00014e  06c0              LSLS     r0,r0,#27             ;442
000150  d4fc              BMI      |L1.332|
;;;466                break;
;;;467              }
;;;468            }
;;;469          }
;;;470        }
;;;471      }
;;;472      _I2C_Stop();  // Generate Stop condition
;;;473    
;;;474      return r;
000152  0020              MOVS     r0,r4
;;;475    }
000154  b005              ADD      sp,sp,#0x14
000156  bcf0              POP      {r4-r7}
000158  bc08              POP      {r3}
00015a  4718              BX       r3
                  |L1.348|
00015c  9903              LDR      r1,[sp,#0xc]          ;452
00015e  42b7              CMP      r7,r6                 ;452
000160  d101              BNE      |L1.358|
000162  2001              MOVS     r0,#1                 ;453
000164  e000              B        |L1.360|
                  |L1.358|
000166  2000              MOVS     r0,#0                 ;455
                  |L1.360|
000168  f7fffffe          BL       _I2C_GetChar
                  |L1.364|
00016c  9903              LDR      r1,[sp,#0xc]          ;457
00016e  2002              MOVS     r0,#2                 ;457
000170  f7fffffe          BL       _I2C_GetChar
000174  0004              MOVS     r4,r0                 ;457
000176  2805              CMP      r0,#5                 ;458
000178  d0f8              BEQ      |L1.364|
00017a  9803              LDR      r0,[sp,#0xc]          ;461
00017c  1c40              ADDS     r0,r0,#1              ;461
00017e  9003              STR      r0,[sp,#0xc]          ;462
000180  e7d9              B        |L1.310|
;;;476    
                          ENDP

                  I2CPCA9532_Init PROC
;;;480    */
;;;481    void I2CPCA9532_Init(void) {
000182  b50e              PUSH     {r1-r3,lr}
;;;482      unsigned char InitCommand[] = {0x12, 0x97, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00};
000184  a221              ADR      r2,|L1.524|
000186  ca07              LDM      r2,{r0-r2}
;;;483    
;;;484      if ((I20CONSET & (1 << 6)) == 0) {  // I2C was not intialized before
000188  466b              MOV      r3,sp
00018a  c307              STM      r3!,{r0-r2}
00018c  481e              LDR      r0,|L1.520|
00018e  6801              LDR      r1,[r0,#0]
000190  0649              LSLS     r1,r1,#25
000192  d421              BMI      |L1.472|
;;;485        PINSEL1 &= 0
000194  4920              LDR      r1,|L1.536|
000196  684a              LDR      r2,[r1,#4]
000198  230f              MOVS     r3,#0xf
00019a  059b              LSLS     r3,r3,#22
00019c  439a              BICS     r2,r2,r3
00019e  604a              STR      r2,[r1,#4]
;;;486                   | (0x3   << 0)  // SSEL
;;;487                   | (0x3   << 2)  // MISO
;;;488                   | (0x3   << 4)  // MOSI
;;;489                   | (0x3   << 6)  // SDA1
;;;490                   | (0x3   << 8)  // SCL1
;;;491                   | (0x3   << 10) // RD1
;;;492                   | (0x3   << 12) // TD1
;;;493                   | (0x3   << 14) // CAP3[0]
;;;494                   | (0x3   << 16) // CAP3[1]
;;;495                   | (0x3   << 18) // TXD3
;;;496                   | (0x3   << 20) // RXD3
;;;497                   | (0x3   << 26) // Reserved
;;;498                   | (0x3   << 28) // Reserved
;;;499                   | (0x3uL << 30) // Reserved
;;;500                   ;
;;;501        PINSEL1 |= 0
0001a0  684a              LDR      r2,[r1,#4]
0001a2  2305              MOVS     r3,#5
0001a4  059b              LSLS     r3,r3,#22
0001a6  431a              ORRS     r2,r2,r3
0001a8  604a              STR      r2,[r1,#4]
;;;502                   | (0x1 << 22) // GPIO port 0.27 SDA0
;;;503                   | (0x1 << 24) // GPIO port 0.28 SCL0
;;;504                   ;
;;;505        //
;;;506        // Clear flags
;;;507        //
;;;508        I20CONCLR = 0
0001aa  216c              MOVS     r1,#0x6c
0001ac  6181              STR      r1,[r0,#0x18]
;;;509                    | (1 << 2)   // AAC,   Assert acknowledge clear bit
;;;510                    | (1 << 3)   // SIC,   I2C interrupt clear bit
;;;511                    | (1 << 5)   // STAC,  START flag clear bit
;;;512                    | (1 << 6)   // I2ENC, I2C interface disable bit
;;;513                    ;
;;;514        //
;;;515        // Reset registers
;;;516        //
;;;517        I20SCLL    = (I20SCLL   & 0xFFFF0000) | 0x00000160;  // SCL Duty Cycle low register
0001ae  6941              LDR      r1,[r0,#0x14]
0001b0  0c09              LSRS     r1,r1,#16
0001b2  0409              LSLS     r1,r1,#16
0001b4  31ff              ADDS     r1,r1,#0xff
0001b6  3161              ADDS     r1,r1,#0x61
0001b8  6141              STR      r1,[r0,#0x14]
;;;518        I20SCLH    = (I20SCLH   & 0xFFFF0000) | 0x000000F0;  // SCL Duty Cycle high register
0001ba  6901              LDR      r1,[r0,#0x10]
0001bc  0c09              LSRS     r1,r1,#16
0001be  0409              LSLS     r1,r1,#16
0001c0  31f0              ADDS     r1,r1,#0xf0
0001c2  6101              STR      r1,[r0,#0x10]
;;;519        I20CONSET |= (1 << 6);                                // I2EN, I2C interface enable bit
0001c4  6801              LDR      r1,[r0,#0]
0001c6  2240              MOVS     r2,#0x40
0001c8  4311              ORRS     r1,r1,r2
0001ca  6001              STR      r1,[r0,#0]
;;;520        I2CPCA9532_WriteRead(InitCommand, sizeof(InitCommand), 0, 0);
0001cc  2300              MOVS     r3,#0
0001ce  001a              MOVS     r2,r3
0001d0  2109              MOVS     r1,#9
0001d2  4668              MOV      r0,sp
0001d4  f7fffffe          BL       I2CPCA9532_WriteRead
                  |L1.472|
;;;521      }
;;;522    }
0001d8  b003              ADD      sp,sp,#0xc
0001da  bc08              POP      {r3}
0001dc  4718              BX       r3
                          ENDP

                  _I2C_CheckStatus PROC
;;;158    */
;;;159    static unsigned char _I2C_CheckStatus(void) {
0001de  480a              LDR      r0,|L1.520|
                  |L1.480|
;;;160      unsigned char r = 0;
;;;161    
;;;162      //
;;;163      // Wait for I2C status to change
;;;164      //
;;;165      while ((I20CONSET & (1 << 3)) == 0) {  // SI == 0
0001e0  6801              LDR      r1,[r0,#0]
0001e2  0709              LSLS     r1,r1,#28
0001e4  d5fc              BPL      |L1.480|
;;;166      }
;;;167      //
;;;168      // Read I2C state
;;;169      //
;;;170      r = I20STAT;
0001e6  6840              LDR      r0,[r0,#4]
0001e8  0600              LSLS     r0,r0,#24
0001ea  0e00              LSRS     r0,r0,#24
;;;171    
;;;172      return r;
;;;173    }
0001ec  4770              BX       lr
;;;174    
                          ENDP

                  _I2C_PutChar PROC
;;;220    */
;;;221    static unsigned  char _I2C_PutChar(unsigned char Data) {
0001ee  4906              LDR      r1,|L1.520|
0001f0  0002              MOVS     r2,r0
;;;222      unsigned char r = 0;
;;;223    
;;;224      /* check if I2C Data register can be accessed */
;;;225      if ((I20CONSET & (1 << 3)) != 0) {  // SI = 1
0001f2  680b              LDR      r3,[r1,#0]
0001f4  2000              MOVS     r0,#0                 ;222
0001f6  071b              LSLS     r3,r3,#28
0001f8  d503              BPL      |L1.514|
;;;226        //
;;;227        // Send data
;;;228        //
;;;229        I20DAT    = Data;
0001fa  608a              STR      r2,[r1,#8]
;;;230        I20CONCLR = (1 << 3);  // Clear SI flag
0001fc  2208              MOVS     r2,#8
0001fe  618a              STR      r2,[r1,#0x18]
;;;231        r         = I2C_CODE_OK;
;;;232      } else {
;;;233        r = I2C_CODE_BUSY;  // Data register not ready
;;;234      }
;;;235    
;;;236      return r;
;;;237    }
000200  4770              BX       lr
                  |L1.514|
000202  2006              MOVS     r0,#6                 ;233
000204  4770              BX       lr
;;;238    
                          ENDP

000206  0000              DCW      0x0000
                  |L1.520|
                          DCD      0xe001c000
                  |L1.524|
00020c  12978000          DCB      18,151,128,0
000210  4000              DCB      "@",0
000212  00                DCB      0
000213  00                DCB      0
000214  00                DCB      0
000215  00                DCB      0
000216  00                DCB      0
000217  00                DCB      0
                  |L1.536|
                          DCD      0xe002c000
