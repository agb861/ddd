L 1 "Setup\IP_Config_LPC24xx.c"
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : IP_Config_LPC24xx.c
NPurpose     : Configuration file for TCP/IP with NXP LPC24xx
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#include <stdio.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030076
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 19 "Setup\IP_Config_LPC24xx.c" 2
N#include "IP.h"
L 1 "IP\IP.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : IP.h
NPurpose     : API of the TCP/IP stack
N---------------------------END-OF-HEADER------------------------------
N*/
N/* Additional Copyrights: */
N/* Copyright  2000 By InterNiche Technologies Inc. All rights reserved */
N/* Portions Copyright 1990,1993 by NetPort Software. */
N/* Portions Copyright 1986 by Carnegie Mellon */
N/* Portions Copyright 1983 by the Massachusetts Institute of Technology */
N
N#ifndef _IP_H_
N#define _IP_H_
N
N#include "Global.h"
L 1 "GUI\Global.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : GLOBAL.h
NPurpose : Global types etc.
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GLOBAL_H            // Guard against multiple inclusion
N#define GLOBAL_H
N
N/*********************************************************************
N*
N*       Macros
N*
N**********************************************************************
N*/
N#define U8    unsigned char
N#define U16   unsigned short
N#define U32   unsigned long
N#define I8    signed char
N#define I16   signed short
N#define I32   signed long
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 27 "IP\IP.h" 2
N#include "IP_ConfDefaults.h"
L 1 "IP\IP_ConfDefaults.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : IP_ConfDefaults.h
NPurpose :
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef IP_CONFDEFAULTS_H
N#define IP_CONFDEFAULTS_H
N
N#include "IP_Conf.h"
L 1 "Setup\IP_Conf.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef _IP_CONF_H_
N#define _IP_CONF_H_ 1
N
N//
N// IAR ARM compiler related macros
N//
N#ifdef __ICCARM__
S  #if ((__TID__ >> 4) & 0x0F) < 6   // For any ARM CPU core < v7, we will use optimized routines
S    #include "Util.h"
S    #define IP_MEMCPY(pDest, pSrc, NumBytes) ARM_memcpy(pDest, pSrc, NumBytes)    // Speed optimization: Our memcpy is much faster!
S    U16 ARM_IP_cksum(void * ptr, unsigned NumHWords);
S    #define IP_CKSUM(p, NumItems) ARM_IP_cksum((p), (NumItems))
S  #endif
S  #define IP_IS_BIG_ENDIAN (1 - __LITTLE_ENDIAN__)
N#endif
N
N//
N// Change endianess if required, default is IP_IS_BIG_ENDIAN == 0
N//
N//#define IP_IS_BIG_ENDIAN    1
N//#define IP_MEMCPY(pDest, pSrc, NumBytes) UTIL_memcpy(pDest, pSrc, NumBytes)    // Speed optimization: Our memcpy is much faster!
N
N#ifdef DEBUG
S  #if DEBUG
S    #define IP_DEBUG        2   // Debug level: 1: Support "Panic" checks, 2: Support warn & log
S  #endif
N#endif
N
N#endif     // Avoid multiple inclusion
N
N
L 22 "IP\IP_ConfDefaults.h" 2
N
N
N#ifndef   IP_DEBUG
N  #define IP_DEBUG                  (0)
N#endif
N
N#ifndef   IP_MEMCPY
N  #define IP_MEMCPY  memcpy
N#endif
N
N#ifndef   IP_MEMSET
N  #define IP_MEMSET  memset
N#endif
N
N#ifndef   IP_MEMMOVE
N  #define IP_MEMMOVE memmove
N#endif
N
N#ifndef   IP_MEMCMP
N  #define IP_MEMCMP  memcmp
N#endif
N
N#ifndef   IP_CKSUM
N  #define IP_CKSUM(p, NumHWords) IP_cksum(p, NumHWords)
N#endif
N
N#ifndef   IP_OPTIMIZE
N  #define IP_OPTIMIZE
N#endif
N
N#ifndef   IP_IS_BIG_ENDIAN
N  #define IP_IS_BIG_ENDIAN 0      // Little endian is default
N#endif
N
N
N
N#ifndef   IP_INCLUDE_STAT         // Allow override in IP_Conf.h
N  #if IP_DEBUG > 0
X  #if (0) > 0
S    #define IP_INCLUDE_STAT 1     // Can be set to 0 to disable statistics for extremly small release builds
N  #else
N    #define IP_INCLUDE_STAT 0
N  #endif
N#endif
N
N#ifndef IP_DEBUG_Q                // Allow override in IP_Conf.h
N  #if IP_DEBUG
X  #if (0)
S    #define IP_DEBUG_Q 1
N  #else
N    #define IP_DEBUG_Q 0
N  #endif
N#endif
N//
N// TCP retransmission range defaults
N//
N#ifndef   IP_TCP_RETRANS_MIN
N  #define IP_TCP_RETRANS_MIN   200   // Min. delay for retransmit. Real delay is computed, this minimum applies only if computed delay is shorter.
N#endif
N
N#ifndef   IP_TCP_RETRANS_MAX
N  #define IP_TCP_RETRANS_MAX  5000   // Max. delay for retransmit. Real delay is computed, this maximum applies only if computed delay is longer.
N#endif
N
N//
N// TCP keep-alive defaults
N//
N#ifndef IP_TCP_KEEPALIVE_INIT
N  #define  IP_TCP_KEEPALIVE_INIT     20000       // Initial connect keep alive, 20 sec.
N#endif
N
N#ifndef IP_TCP_KEEPALIVE_IDLE
N  #define  IP_TCP_KEEPALIVE_IDLE     60000       // Default time before probing
N#endif
N
N#ifndef IP_TCP_KEEPALIVE_PERIOD
N  #define  IP_TCP_KEEPALIVE_PERIOD   10000       // Default probe interval
N#endif
N
N#ifndef IP_TCP_KEEPALIVE_MAX_REPS
N  #define  IP_TCP_KEEPALIVE_MAX_REPS     8       // Max probes before drop
N#endif
N
N#ifndef IP_TCP_MSL
N  #define  IP_TCP_MSL                 2000       // Max segment lifetime
N#endif
N
N
N#define IP_TCP_DACK_PERIOD    10   // Time base for delayed acknowledges
N#define IP_TCP_SLOW_PERIOD    10
N
N
N#define INCLUDE_ARP          1   // Include Ethernet ARP ?
N#define INCLUDE_ICMP         1   // Include ICMP || ping only
N#define INCLUDE_TCP          1
N#define INCLUDE_UDP          1
N#define TCP_ZEROCOPY         1  // Enable zero-copy Socket extension
N#define TCP_TIMESTAMP        1  // Are we using RFC-1323 TCP timestamp feature to compute RTT ?
N#ifndef   IP_SUPPORT_MULTICAST
N  #define IP_SUPPORT_MULTICAST  0   // Experimental
N#endif
N
N#ifndef IP_MAX_DNS_SERVERS
N  #define IP_MAX_DNS_SERVERS  2
N#endif
N
N#ifndef IP_PANIC
N  #if   IP_DEBUG
X  #if   (0)
S    #define IP_PANIC(s)     IP_Panic(s)
N  #else
N    #define IP_PANIC(s)
N  #endif
N#endif
N
N#ifndef   IP_SUPPORT_LOG
N  #if   IP_DEBUG > 1
X  #if   (0) > 1
S    #define IP_SUPPORT_LOG  1
N  #else
N    #define IP_SUPPORT_LOG  0
N  #endif
N#endif
N
N#ifndef   IP_SUPPORT_WARN
N  #if   IP_DEBUG > 1
X  #if   (0) > 1
S    #define IP_SUPPORT_WARN  1
N  #else
N    #define IP_SUPPORT_WARN  0
N  #endif
N#endif
N
N
N
N#if   IP_INCLUDE_STAT
X#if   0
S  #define IP_STAT_DEC(Cnt)     (Cnt)--
S  #define IP_STAT_INC(Cnt)     (Cnt)++
S  #define IP_STAT_ADD(Cnt, v) { Cnt += v; }
N#else
N  #define IP_STAT_DEC(Cnt)
N  #define IP_STAT_INC(Cnt)
N  #define IP_STAT_ADD(Cnt, v)
N#endif
N
N#define TPS        1000    /* cticks per second */
N
N#define IP_TTL        64 /* define IP hop count for this port */
N#define IP_TCP_DELAY_ACK_DEFAULT 200       // [ms]
N
N#define DO_DELAY_ACKS  (1)   // Defining enables delayed acks
N//#define TCP_SACK       (1)
N#define TCP_WIN_SCALE  (0)     // We do not want to use it per default, since it requires a sufficiently big buffer in the hardware.
N#define IP_PTR_OP_IS_ATOMIC       (1)
N
N#define IP_MAX_IFACES       1  /* max ifaces to support at one time */
N
N#endif // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
N
N
N
L 28 "IP\IP.h" 2
N#include "IP_socket.h"
L 1 "IP\IP_socket.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : IP_socket.h
NPurpose :
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N/* Additional Copyrights: */
N/* Copyright 1997 - 2000 By InterNiche Technologies Inc. All rights reserved */
N/* Copyright (c) 1982, 1986 Regents of the University of California.
N* All rights reserved.
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N* 1. Redistributions of source code must retain the above copyright
N*    notice, this list of conditions and the following disclaimer.
N* 2. Redistributions in binary form must reproduce the above copyright
N*    notice, this list of conditions and the following disclaimer in the
N*    documentation and/or other materials provided with the distribution.
N* 3. [rescinded 22 July 1999]
N* 4. Neither the name of the University nor the names of its contributors
N*    may be used to endorse or promote products derived from this software
N*    without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
N* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N* ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
N* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N* SUCH DAMAGE.
N*/
N
N
N
N#ifndef SOCKET_H                         // Avoid multiple inclusion
N#define  SOCKET_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*
N * Address families, for socket() call and "domain" variables.
N */
N
N#define  AF_INET     2     /* internetwork: UDP, TCP, etc. */
N#define  AF_INET6    3     /* IPv6 */
N#define  PF_INET6    AF_INET6
N
N
N/* IPPROTO_... definitions, from BSD <netinet/in.h> */
N#define     IPPROTO_IP     0  /* added for IP multicasting changes */
N#define     IPPROTO_IGMP   2  /* added for IP multicasting changes */
N#define     IPPROTO_TCP    6
N#define     IPPROTO_UDP    17
N#define     IPPROTO_RAW    255
N
N
N
N/* BSD sockets errors */
N
N#define     ENOBUFS        1
N#define     ETIMEDOUT      2
N#define     EISCONN        3
N#define     EOPNOTSUPP     4
N#define     ECONNABORTED   5
N#define     EWOULDBLOCK    6
N#define     ECONNREFUSED   7
N#define     ECONNRESET     8
N#define     ENOTCONN       9
N#define     EALREADY       10
N#define     EINVAL         11
N#define     EMSGSIZE       12
N#define     EPIPE          13
N#define     EDESTADDRREQ   14
N#define     ESHUTDOWN      15
N#define     ENOPROTOOPT    16
N#define     EHAVEOOB       17
N#define     ENOMEM         18
N#define     EADDRNOTAVAIL  19
N#define     EADDRINUSE     20
N#define     EAFNOSUPPORT   21
N#define     EINPROGRESS    22
N#define     ELOWER         23    /* lower layer (IP) error */
N#define     ENOTSOCK       24    /* Includes sockets which closed while blocked */
N#define     EIEIO 27 /* bad input/output on Old Macdonald's farm :-) */
N#define     ETOOMANYREFS   28    // Multicast only
N#define     EFAULT         29
N#define     ENETUNREACH    30
N
N
N
N
N
N
N
N
N
N/*
N * Types
N */
N#define     SOCK_STREAM    1     /* stream socket */
N#define     SOCK_DGRAM     2     /* datagram socket */
N#define     SOCK_RAW       3     /* raw-protocol interface */
N#define     SOCK_RDM       4     /* reliably-delivered message */
N#define     SOCK_SEQPACKET 5     /* sequenced packet stream */
N
N/*
N * Option flags per-socket.
N */
N#define     SO_DEBUG       0x00001     /* turn on debugging info recording */
N#define     SO_ACCEPTCONN  0x00002     /* socket has had listen() */
N#define     SO_REUSEADDR   0x00004     /* allow local address reuse */
N#define     SO_KEEPALIVE   0x00008     /* keep connections alive */
N#define     SO_DONTROUTE   0x00010     /* just use interface addresses */
N#define     SO_BROADCAST   0x00020     /* permit sending of broadcast msgs */
N#define     SO_USELOOPBACK 0x00040     /* bypass hardware when possible */
N#define     SO_LINGER      0x00080     /* linger on close if data present */
N#define     SO_OOBINLINE   0x00100     /* leave received OOB data in line */
N#define     SO_TCPSACK     0x00200     /* Allow TCP SACK (Selective acknowledgment) */
N#define     SO_WINSCALE    0x00400     /* Set scaling window option */
N#define     SO_TIMESTAMP   0x00800     /* Set TCP timestamp option */
N#define     SO_BIGCWND     0x01000     /* Large initial TCP Congenstion window */
N#define     SO_HDRINCL     0x02000     /* user access to IP hdr for SOCK_RAW */
N#define     SO_NOSLOWSTART 0x04000     /* suppress slowstart on this socket */
N#define     SO_FULLMSS     0x08000     /* force packets to all be MAX size */
N
N/* for compatability with second-rate stacks: */
N#define SO_EXPEDITE     SO_NOSLOWSTART
N#define SO_THROUGHPUT   SO_FULLMSS
N
N/*
N * Additional options, not kept in so_options.
N */
N#define  SO_SNDBUF      0x1001      /* send buffer size */
N#define  SO_RCVBUF      0x1002      /* receive buffer size */
N#define  SO_SNDLOWAT    0x1003      /* send low-water mark */
N#define  SO_RCVLOWAT    0x1004      /* receive low-water mark */
N#define  SO_SNDTIMEO    0x1005      /* send timeout */
N#define  SO_RCVTIMEO    0x1006      /* receive timeout */
N#define  SO_ERROR       0x1007      /* get error status and clear */
N#define  SO_TYPE        0x1008      /* get socket type */
N#define  SO_HOPCNT      0x1009      /* Hop count to get to dst   */
N#define  SO_MAXMSG      0x1010      /* get TCP_MSS (max segment size) */
N
N/* ...And some netport additions to setsockopt: */
N#define  SO_RXDATA      0x1011      /* get count of bytes in sb_rcv */
N#define  SO_TXDATA      0x1012      /* get count of bytes in sb_snd */
N#define  SO_MYADDR      0x1013      /* return my IP address */
N#define  SO_NBIO        0x1014      /* set socket into NON-blocking mode */
N#define  SO_BIO         0x1015      /* set socket into blocking mode */
N#define  SO_NONBLOCK    0x1016      /* set/get blocking mode via optval param */
N#define  SO_CALLBACK    0x1017      /* set/get zero_copy callback routine */
N
N/*
N * TCP User-settable options (used with setsockopt).
N * TCP-specific socket options use the 0x2000 number space.
N */
N
N#define  TCP_ACKDELAYTIME 0x2001    /* Set time for delayed acks */
N#define  TCP_NOACKDELAY   0x2002    /* suppress delayed ACKs */
N#define  TCP_MAXSEG       0x2003    /* set maximum segment size */
N#define  TCP_NODELAY      0x2004    /* Disable Nagle Algorithm */
N
N
N/*
N * Structure used for manipulating linger option.
N */
Nstruct   linger {
N   int   l_onoff;    /* option on/off */
N   int   l_linger;   /* linger time */
N};
N
N
N/*
N * Structure used by kernel to store most
N * addresses.
N */
Nstruct sockaddr {
N   U16     sa_family;     /* address family */
X   unsigned short     sa_family;      
N   char     sa_data[14];      /* up to 14 bytes of direct address */
N};
N
N
N/* Berkeley style "Internet address" */
N
Nstruct in_addr {
N   U32  s_addr;
X   unsigned long  s_addr;
N};
N
N#define  INADDR_ANY     0L
N
N/* Berkeley style "Socket address" */
Nstruct sockaddr_in {
N  U16      sin_family;
X  unsigned short      sin_family;
N  U16      sin_port;
X  unsigned short      sin_port;
N  struct   in_addr  sin_addr;
N  char     sin_zero[8];
N};
N
N
N
N
N/*
N * Structure used by kernel to pass protocol
N * information in raw sockets.
N */
Nstruct sockproto {
N   U16     sp_family;     /* address family */
X   unsigned short     sp_family;      
N   U16     sp_protocol;   /* protocol */
X   unsigned short     sp_protocol;    
N};
N
N/* Support for Large initial congestion window */
N#ifdef TCP_BIGCWND
Sextern   int      use_default_cwnd;    /* Flag to use this on all sockets */
Sextern   U32   default_cwnd;        /* initial cwnd value to use */
N#endif   /* TCP_BIGCWND */
N
N/*
N * Protocol families, same as address families for now.
N */
N#define  PF_UNSPEC   AF_UNSPEC
N#define  PF_UNIX     AF_UNIX
N#define  PF_INET     AF_INET
N#define  PF_IMPLINK  AF_IMPLINK
N#define  PF_PUP      AF_PUP
N#define  PF_CHAOS    AF_CHAOS
N#define  PF_NS       AF_NS
N#define  PF_NBS      AF_NBS
N#define  PF_ECMA     AF_ECMA
N#define  PF_DATAKIT  AF_DATAKIT
N#define  PF_CCITT    AF_CCITT
N#define  PF_SNA      AF_SNA
N#define  PF_DECnet   AF_DECnet
N#define  PF_DLI      AF_DLI
N#define  PF_LAT      AF_LAT
N#define  PF_HYLINK   AF_HYLINK
N#define  PF_APPLETALK   AF_APPLETALK
N
N
N/*
N * Maximum queue length specifiable by listen.
N */
N#define     SOMAXCONN   5
N
N#define     MSG_PEEK       0x2      /* peek at incoming message */
N#define     MSG_DONTROUTE  0x4      /* send without using routing tables */
N#define     MSG_NEWPIPE    0x8      /* New pipe for recvfrom call   */
N#define     MSG_EOR        0x10     /* data completes record */
N#define     MSG_DONTWAIT   0x20     /* this message should be nonblocking */
N
N/* utility functions defined in misclib\parseip.c */
Nint inet46_addr(char *str, struct sockaddr *address);
N
Nlong  t_socket (int, int, int);
Nint   t_bind (long, struct sockaddr *, int);
Nint   t_listen (long, int);
Nlong  t_accept (long, struct sockaddr *, int *);
Nint   t_connect (long, struct sockaddr *, int);
Nint   t_getpeername (long, struct sockaddr *, int * addrlen);
Nint   t_getsockname (long, struct sockaddr *, int * addrlen);
Nint   t_setsockopt (long sock, int level, int op, void * data, int dlen);
Nint   t_getsockopt (long sock, int level, int op, void * data, int dlen);
Nint   t_recv (long, char *, int, int);
Nint   t_send (long, const char *, int, int);
Nint   t_recvfrom (long s, char * buf, int len, int flags, struct sockaddr *, int*);
Nint   t_sendto (long s, const char * buf, int len, int flags, struct sockaddr *, int);
Nint   t_shutdown (long, int);
Nint   t_socketclose (long);
Nint   t_errno(long s);
N
Nchar * so_perror(int);  /* return an error string for a socket error */
N
N//
N// Map plain BSD socket routine names to Interniche t_" names.
N//
N#define  socket(x,y,z)           t_socket(x,y,z)
N#define  bind(s,a,l)             t_bind(s,a,l)
N#define  connect(s,a,l)          t_connect(s,a,l)
N#define  listen(s,c)             t_listen(s,c)
N#define  send(s, b, l, f)        t_send(s, b, l, f)
N#define  recv(s, b, l, f)        t_recv(s, b, l, f)
N#define  accept(s,a,l)           t_accept(s, a, l)
N#define  sendto(s,b,l,f,a,x)     t_sendto(s,b,l,f,a,x)
N#define  recvfrom(s,b,l,f,a,x)   t_recvfrom(s,b,l,f,a,x)
N#define  socketclose(s)          t_socketclose(s)
N#define  closesocket(s)          t_socketclose(s)
N#define  setsockopt(s,l,o,d,x)   t_setsockopt(s,l,o,d,x)
N#define  getsockopt(s,l,o,d,x)   t_getsockopt(s,l,o,d,x)
N#define  shutdown(s,how)         t_shutdown(s,how)
N#define  select(i,o,e,tv)        t_select(i,o,e,tv)
N#define  getpeername(s,a,al)     t_getpeername(s,a,al)
N#define  getsockname(s,a,al)     t_getsockname(s,a,al)
N
Nstruct hostent *  gethostbyname (char * name);
N
N
N
N#define  SOCKTYPE    long     /* preferred generic socket type */
N
N#define  SYS_SOCKETNULL -1    /* error return from sys_socket. */
N#define  INVALID_SOCKET -1    /* WINsock-ish synonym for SYS_SOCKETNULL */
N#define  SOCKET_ERROR   -1    /* error return from send(), sendto(), et.al. */
N#define  SOL_SOCKET     -1    /* compatability parm for set/get sockopt */
N
N#define  SO_SELECT      1  /* support select() call */
N
N
N#ifdef SO_SELECT
N/* define the size of the sockets arrays passed to select(). On UNIX
N * and winsock this is usually 64, but most embedded systems don't
N * need more than 1 or 2, and can't always afford to waste the space.
N * NOTE: These determine the size of set_fd structs, which are often
N */
N#ifndef FD_SETSIZE   /* let h_h files override */
N#define  FD_SETSIZE     12
N#endif   /* FD_SETSIZE */
N#endif   /* SO_SELECT */
N
N
N
N
N/* the definitions to support the select() function. These are about
N * as UNIX-like as we can make 'em on embedded code. They are also
N * fairly compatable with WinSock's select() definitions.
N */
N
Ntypedef struct IP_FD_SET   /* the select socket array manager */
N{
N   unsigned fd_count;               /* how many are SET? */
N   long     fd_array[FD_SETSIZE];   /* an array of SOCKETs */
X   long     fd_array[12];    
N} IP_fd_set;
N
N/* our select call - note the traditional "width" parameter is absent */
Nint t_select(IP_fd_set * in, IP_fd_set * out, IP_fd_set * ev, long tmo_seconds);
N
N//
N// Select-related functions are calls (not macros) to save space
N//
Nvoid  IP_FD_CLR  (long so, IP_fd_set * set);
Nvoid  IP_FD_SET  (long so, IP_fd_set * set);
Nint   IP_FD_ISSET(long so, IP_fd_set * set);
N// and one actual macro:
N#define  IP_FD_ZERO(set)   (((IP_fd_set *)(set))->fd_count=0)
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* SOCKET_H */
N
N/* end of file socket.h */
N
N
L 29 "IP\IP.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#define IP_VERSION   15601   // Format: Mmmrr. Example: 10201 is 1.02a
N
N/*********************************************************************
N*
N*       IP_MTYPE
N*
N*  Ids to distinguish different message types
N*/
N#define IP_MTYPE_INIT         (1UL << 0)
N#define IP_MTYPE_CORE         (1UL << 1)
N#define IP_MTYPE_ALLOC        (1UL << 2)
N#define IP_MTYPE_DRIVER       (1UL << 3)
N#define IP_MTYPE_ARP          (1UL << 4)
N#define IP_MTYPE_IP           (1UL << 5)
N
N#define IP_MTYPE_TCP_CLOSE    (1UL << 6)
N#define IP_MTYPE_TCP_OPEN     (1UL << 7)
N#define IP_MTYPE_TCP_IN       (1UL << 8)
N#define IP_MTYPE_TCP_OUT      (1UL << 9)
N#define IP_MTYPE_TCP_RTT      (1UL << 10)
N#define IP_MTYPE_TCP_RXWIN    (1UL << 11)
N#define IP_MTYPE_TCP          (IP_MTYPE_TCP_OPEN | IP_MTYPE_TCP_CLOSE | IP_MTYPE_TCP_IN | IP_MTYPE_TCP_OUT | IP_MTYPE_TCP_RTT)
N
N#define IP_MTYPE_UDP_IN       (1UL << 12)
N#define IP_MTYPE_UDP_OUT      (1UL << 13)
N#define IP_MTYPE_UDP          (IP_MTYPE_UDP_IN | IP_MTYPE_UDP_OUT)
N
N#define IP_MTYPE_LINK_CHANGE  (1UL << 14)
N#define IP_MTYPE_DHCP         (1UL << 17)
N#define IP_MTYPE_DHCP_EXT     (1UL << 18)
N
N#define IP_MTYPE_APPLICATION  (1UL << 19)
N
N
N#define IP_MTYPE_ICMP         (1UL << 20)
N#define IP_MTYPE_NET_IN       (1UL << 21)
N#define IP_MTYPE_NET_OUT      (1UL << 22)
N
N#define IP_MTYPE_DNS          (1UL << 24)
N
N#define IP_MTYPE_SOCKET_STATE (1UL << 26)
N#define IP_MTYPE_SOCKET_READ  (1UL << 27)
N#define IP_MTYPE_SOCKET_WRITE (1UL << 28)
N#define IP_MTYPE_SOCKET       (IP_MTYPE_SOCKET_STATE | IP_MTYPE_SOCKET_READ | IP_MTYPE_SOCKET_WRITE)
N#define IP_MTYPE_DNSC         (1UL << 29)
N
Nvoid IP_Logf_Application(const char * sFormat, ...);
Nvoid IP_Warnf_Application(const char * sFormat, ...);
N
N/*********************************************************************
N*
N*       IP_ERR_
N*
N*  Ids to distinguish different message types
N*
N* Stack generic error codes: generally full success is 0,
N* definite errors are negative numbers, and indeterminate conditions
N* are positive numbers. These may be changed if they conflict with
N* defines in the target system.
N* If you have to change
N* these values, be sure to recompile ALL NetPort sources.
N*/
N
N/* programming errors */
N#define IP_ERR_PARAM      -10 /* bad parameter */
N#define IP_ERR_LOGIC      -11 /* sequence of events that shouldn't happen */
N#define IP_ERR_NOCIPHER   -12 /* No corresponding cipher found for the cipher id */
N
N/* system errors */
N#define IP_ERR_NOMEM      -20 /* malloc or calloc failed */
N#define IP_ERR_NOBUFFER   -21 /* ran out of free packets */
N#define IP_ERR_RESOURCE   -22 /* ran out of other queue-able resource */
N#define SEND_DROPPED IP_ERR_RESOURCE /* full queue or similar lack of resource */
N#define IP_ERR_BAD_STATE  -23 /* TCP layer error */
N#define IP_ERR_TIMEOUT    -24 /* TCP layer error */
N
N#define IP_ERR_NOFILE     -25 /* expected file was missing */
N#define IP_ERR_FILEIO     -26 /* file IO error */
N
N/* net errors */
N#define IP_ERR_SENDERR    -30 /* send to net failed at low layer */
N#define IP_ERR_NOARPREP   -31 /* no ARP for a given host */
N#define IP_ERR_BAD_HEADER -32 /* bad header at upper layer (for upcalls) */
N#define IP_ERR_NO_ROUTE   -33 /* can't find a reasonable next IP hop */
N#define IP_ERR_NO_IFACE   -34 /* can't find a reasonable interface */
N#define IP_ERR_HARDWARE   -35 /* detected hardware failure */
N
N/* conditions that are not really fatal OR success: */
N#define IP_ERR_SEND_PENDING 1 /* packet queued pending an ARP reply */
N#define IP_ERR_NOT_MINE     2 /* packet was not of interest (upcall reply) */
N
N
N
N/*********************************************************************
N*
N*  Convert little/big endian - these should be efficient,
N*  inline code or MACROs
N*/
N#if IP_IS_BIG_ENDIAN
X#if 0
S  #define htonl(l) (l)
S  #define htons(s) (s)
S  #define IP_HTONL_FAST(l) (l)
N#else
N  #define htonl(l) IP_SwapU32(l)
N  #define htons(s) ((U16)((U16)(s) >> 8) | (U16)((U16)(s) << 8))   /* Amazingly, some compilers really need all these U16 casts: */
N//  #define htons(s) (((s) >> 8) | (U16)((s) << 8))
N  #define IP_HTONL_FAST(v) (                      \
N      (((U32)((v) << 0)  >> 24) << 0) | \
N      (((U32)((v) << 8)  >> 24) << 8) | \
N      (((U32)((v) << 16) >> 24) << 16) | \
N      (((U32)((v) << 24) >> 24) << 24))
X  #define IP_HTONL_FAST(v) (                            (((U32)((v) << 0)  >> 24) << 0) |       (((U32)((v) << 8)  >> 24) << 8) |       (((U32)((v) << 16) >> 24) << 16) |       (((U32)((v) << 24) >> 24) << 24))
N#endif
N
N#define ntohl(l) htonl(l)
N#define ntohs(s) htons(s)
N
N
NU32 IP_SwapU32(U32 v);
Xunsigned long IP_SwapU32(unsigned long v);
N
N
N/*********************************************************************
N*
N*  IP_OS_
N*/
Nvoid IP_OS_Delay(unsigned ms);
Nvoid IP_OS_DisableInterrupt(void);
Nvoid IP_OS_EnableInterrupt(void);
Nvoid IP_OS_Init(void);
Nvoid IP_OS_Unlock(void);
Nvoid IP_OS_AssertLock(void);
Nvoid IP_OS_Lock  (void);
NU32  IP_OS_GetTime32(void);
Xunsigned long  IP_OS_GetTime32(void);
N// Wait and signal for Net task
Nvoid IP_OS_WaitNetEvent  (unsigned ms);
Nvoid IP_OS_SignalNetEvent(void);
N// Wait and signal for the optional Rx task
Nvoid IP_OS_WaitRxEvent  (void);
Nvoid IP_OS_SignalRxEvent(void);
N// Wait and signal for application tasks
Nvoid IP_OS_WaitItem      (void * pWaitItem);
Nvoid IP_OS_WaitItemTimed (void * pWaitItem, unsigned Timeout);
Nvoid IP_OS_SignalItem(void * pWaitItem);
Nvoid IP_OS_AddTickHook(void (* pfHook)(void));
N
N
N/*********************************************************************
N*
N*       IP_PACKET
N*
N* INCOMING: Incoming packets are always front-aligned in the
N* pBuffer field. The pData pointer is set to pBuffer by the
N* receiver and advanced by each layer of the stack before
N* upcalling the next; ie the ethernet driver bumps the prot field
N* by 14 and decrements plen by 14. PACKETs are pk_alloc()ed by
N* the receiving net layer and pk_free()ed by the transport layer
N* or application when it's finished with them. OUTGOING:
N* Protocols install data into pBuffer with a front pad big enough
N* to accomadate the biggest likely protocol headers, ususally
N* about 62 bytes (14 ether + 24 IP + 24 TCP, where IP & TCP each
N* have option fields.) prot plen are set for this data, and the
N* protocol headers are prepended as the packet goes down the
N* stack. pBuffer is not used in this case except for overflow
N* checks. PACKETs are pk_alloc()ed by the sending protocol and
N* freed by the lower layer level that dispatches them, usually
N* net link layer driver. They can be held by ARP for several
N* seconds while awaiting arp replys on initial sends to a new IP
N* host, and the ARP code will free them when a reply comes in or
N* times out.
N*/
Ntypedef   U32 ip_addr;
Xtypedef   unsigned long ip_addr;
N
Ntypedef struct IP_PACKET {
N  struct IP_PACKET * pNext;
N  struct net       * pNet;          // The interface (net) it came in on
N  char             * pBuffer;       // Beginning of raw buffer
N  char             * pData;         // Beginning of protocol/data. This is always >= pBuffer.
N  ip_addr          fhost;           // IP address asociated with packet
N  U16              NumBytes;        // Number of bytes in buffer
X  unsigned short              NumBytes;        
N  U16              BufferSize;      // Length of raw buffer */
X  unsigned short              BufferSize;      
N  U16              UseCnt;          // Use count, for cloning buffer
X  unsigned short              UseCnt;          
N} IP_PACKET;
N
Ntypedef struct IP_PHY_CONTEXT IP_PHY_CONTEXT;
N
Ntypedef struct {
N  unsigned (*pfRead)         (IP_PHY_CONTEXT* pContext, unsigned RegIndex);
N  void     (*pfWrite)        (IP_PHY_CONTEXT* pContext, unsigned RegIndex, unsigned  val);
N} IP_PHY_ACCESS;
N
Nstruct IP_PHY_CONTEXT {
N  const IP_PHY_ACCESS * pAccess;
N  void * pContext;   // Context needed for low level functions
N  U8   Addr;
X  unsigned char   Addr;
N  U8   UseRMII;      // 0: MII, 1: RMII
X  unsigned char   UseRMII;      
N  U16  Anar;         // Value written to ANAR (Auto-negotiation Advertisement register)
X  unsigned short  Anar;         
N  U16  Bmcr;         // Value written to BMCR (basic mode control register)
X  unsigned short  Bmcr;         
N};
N
Ntypedef struct {
N  int   (*pfInit)         (IP_PHY_CONTEXT * pContext);
N  void  (*pfGetLinkState) (IP_PHY_CONTEXT * pContext, U32 * pDuplex, U32 * pSpeed);
X  void  (*pfGetLinkState) (IP_PHY_CONTEXT * pContext, unsigned long * pDuplex, unsigned long * pSpeed);
N} IP_PHY_DRIVER;
N
Nextern const IP_PHY_DRIVER IP_PHY_Generic;
N
Ntypedef struct {
N  int   (*pfInit)         (unsigned Unit);
N  int   (*pfSendPacket)   (unsigned Unit);
N  int   (*pfGetPacketSize)(unsigned Unit);                                   // Return the number of bytes in next packet, <= 0 if there is no more packet.
N  int   (*pfReadPacket)   (unsigned Unit, U8 * pDest, unsigned NumBytes);    // Read (if pDest is valid) and discard packet.
X  int   (*pfReadPacket)   (unsigned Unit, unsigned char * pDest, unsigned NumBytes);    
N  void  (*pfTimer)        (unsigned Unit);                                   // Routine is called periodically
N  int   (*pfControl)      (unsigned Unit, int Cmd, void * p);                // Various control functions
N} IP_HW_DRIVER;
N
N
Ntypedef struct {
N  unsigned NumAddr;
N  const U8 * pHWAddr;                // Hardware addresses
X  const unsigned char * pHWAddr;                
N} IP_NI_CMD_SET_FILTER_DATA;
N
N
N
N/*********************************************************************
N*
N*       Drivers commands
N*/
N#define IP_NI_CMD_SET_FILTER          0   // Set filter. Can handle multiple MAC-addresses.
N#define IP_NI_CMD_CLR_BPRESSURE       1   // Clear back-pressure
N#define IP_NI_CMD_SET_BPRESSURE       2   // Set back-pressure, to avoid receiving more data until the current data is handled
N#define IP_NI_CMD_GET_CAPS            3   // Retrieves the capabilites, which are a logical-or combination of the IP_NI_CAPS below
N#define IP_NI_CMD_SET_PHY_ADDR        4   // Allows settings the PHY address
N#define IP_NI_CMD_SET_PHY_MODE        5   // Allows settings the PHY in a specific mode (duplex, speed)
N#define IP_NI_CMD_POLL                6   // Poll MAC (typically once per ms) in cases where MAC does not trigger an interrupt.
N#define IP_NI_CMD_GET_MAC_ADDR        7   // Retrieve the MAC address from the MAC. This is used for hardware which stores the MAC addr. in an attached EEPROM.
N#define IP_NI_CMD_DISABLE             8   // Disable the network interface (MAC unit + PHY)
N#define IP_NI_CMD_ENABLE              9   // Enable the network interface (MAC unit + PHY)
N#define IP_NI_CMD_SET_TX_BUFFER_SIZE 10   // Allows setting the size of the Tx buffer.
N
N
N/*********************************************************************
N*
N*       Drivers capabilities
N*/
N#define IP_NI_CAPS_WRITE_IP_CHKSUM     (1 << 0)    // Driver capable of inserting the IP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_WRITE_UDP_CHKSUM    (1 << 1)    // Driver capable of inserting the UDP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_WRITE_TCP_CHKSUM    (1 << 2)    // Driver capable of inserting the TCP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_WRITE_ICMP_CHKSUM   (1 << 3)    // Driver capable of inserting the ICMP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_CHECK_IP_CHKSUM     (1 << 4)    // Driver capable of computing and comparing the IP-checksum of an incoming packet ?
N#define IP_NI_CAPS_CHECK_UDP_CHKSUM    (1 << 5)    // Driver capable of computing and comparing the UDP-checksum of an incoming packet ?
N#define IP_NI_CAPS_CHECK_TCP_CHKSUM    (1 << 6)    // Driver capable of computing and comparing the TCP-checksum of an incoming packet ?
N#define IP_NI_CAPS_CHECK_ICMP_CHKSUM   (1 << 7)    // Driver capable of computing and comparing the ICMP-checksum of an incoming packet ?
N
N
Nvoid IP_NI_ClrBPressure  (unsigned Unit);
Nvoid IP_NI_SetBPressure  (unsigned Unit);
N
N/*********************************************************************
N*
N*       Drivers supplied by SEGGER.
N*
N*  Other drivers can always be added or developped by end user.
N*/
Nextern const IP_HW_DRIVER IP_Driver_AT32AP7000;
Nextern const IP_HW_DRIVER IP_Driver_AT91RM9200;
Nextern const IP_HW_DRIVER IP_Driver_CAP9;
Nextern const IP_HW_DRIVER IP_Driver_DM9000;
Nextern const IP_HW_DRIVER IP_Driver_LAN9115;
Nextern const IP_HW_DRIVER IP_Driver_LPC17xx;
Nextern const IP_HW_DRIVER IP_Driver_LPC24xx;
Nextern const IP_HW_DRIVER IP_Driver_LPC32xx;
Nextern const IP_HW_DRIVER IP_Driver_SAM7X;
Nextern const IP_HW_DRIVER IP_Driver_SAM9260;
Nextern const IP_HW_DRIVER IP_Driver_SAM9263;
Nextern const IP_HW_DRIVER IP_Driver_SAM9XE;
Nextern const IP_HW_DRIVER IP_Driver_STR912;
Nextern const IP_HW_DRIVER IP_Driver_NIOSII_MaCo;
Nextern const IP_HW_DRIVER IP_Driver_GMACII;
Nextern const IP_HW_DRIVER IP_Driver_MCF5329;
Nextern const IP_HW_DRIVER IP_Driver_MCF5223x;
Nextern const IP_HW_DRIVER IP_Driver_H8S2472;
Nextern const IP_HW_DRIVER IP_Driver_LAN9118;
Nextern const IP_HW_DRIVER IP_Driver_LAN91C111;
Nextern const IP_HW_DRIVER IP_Driver_LM3S6965;
Nextern const IP_HW_DRIVER IP_Driver_LM3S9B90;
Nextern const IP_HW_DRIVER IP_Driver_SH7670;
N
Nvoid IP_NI_AT32AP7000_ConfigNumRxBuffers(U16 NumRxBuffers);
Xvoid IP_NI_AT32AP7000_ConfigNumRxBuffers(unsigned short NumRxBuffers);
Nvoid IP_NI_AT91RM9200_ConfigNumRxBuffers(U16 NumRxBuffers);
Xvoid IP_NI_AT91RM9200_ConfigNumRxBuffers(unsigned short NumRxBuffers);
Nvoid IP_NI_SAM7X_ConfigNumRxBuffers     (U16 NumRxBuffers);
Xvoid IP_NI_SAM7X_ConfigNumRxBuffers     (unsigned short NumRxBuffers);
Nvoid IP_NI_SAM9260_ConfigNumRxBuffers   (U16 NumRxBuffers);
Xvoid IP_NI_SAM9260_ConfigNumRxBuffers   (unsigned short NumRxBuffers);
Nvoid IP_NI_SAM9263_ConfigNumRxBuffers   (U16 NumRxBuffers);
Xvoid IP_NI_SAM9263_ConfigNumRxBuffers   (unsigned short NumRxBuffers);
Nvoid IP_NI_SAM9XE_ConfigNumRxBuffers    (U16 NumRxBuffers);
Xvoid IP_NI_SAM9XE_ConfigNumRxBuffers    (unsigned short NumRxBuffers);
Nvoid IP_NI_CAP9_ConfigNumRxBuffers      (U16 NumRxBuffers);
Xvoid IP_NI_CAP9_ConfigNumRxBuffers      (unsigned short NumRxBuffers);
N
Ntypedef struct IP_NI_DM9000_ACCESS  IP_NI_DM9000_ACCESS;
Ntypedef struct DM9000_INST DM9000_INST;
N
Nstruct DM9000_INST {
N  U8 *  pHardware;
X  unsigned char *  pHardware;
N  U8 *  pValue;
X  unsigned char *  pValue;
N  U8    BusWidth;    // 8, 16 or 32 bits
X  unsigned char    BusWidth;    
N  IP_NI_DM9000_ACCESS* pAccess;
N};
N
Nstruct IP_NI_DM9000_ACCESS {
N  void (*pf_WriteReg8)    (DM9000_INST * pInst, unsigned RegIndex,  unsigned  val);
N  U16  (*pf_ReadReg8)     (DM9000_INST * pInst, unsigned RegIndex);
X  unsigned short  (*pf_ReadReg8)     (DM9000_INST * pInst, unsigned RegIndex);
N  void (*pf_ReadData)     (DM9000_INST * pInst, U8*   pDest, U32 NumBytes);
X  void (*pf_ReadData)     (DM9000_INST * pInst, unsigned char*   pDest, unsigned long NumBytes);
N  void (*pf_WriteData)    (DM9000_INST * pInst, void* pPacket, U32 NumBytes);
X  void (*pf_WriteData)    (DM9000_INST * pInst, void* pPacket, unsigned long NumBytes);
N};
N
Nvoid IP_NI_DM9000_ISR_Handler (unsigned Unit);
Nvoid IP_NI_DM9000_ConfigAddr  (unsigned Unit, void* pBase, void* pValue);
Nvoid IP_NI_DM9000_ConfigAccess(unsigned Unit, IP_NI_DM9000_ACCESS * pAccess);
N
Nvoid IP_NI_LAN91C111_ISR_Handler(unsigned Unit);
Nvoid IP_NI_LAN91C111_ConfigAddr (unsigned Unit, void* pBase);
N
Nvoid IP_NI_LAN9115_ISR_Handler   (unsigned Unit);
Nvoid IP_NI_LAN9115_ConfigBaseAddr(unsigned Unit, void* pBase);
N
Nvoid IP_NI_NIOSII_MaCo_ConfigNumRxBuffers(unsigned Unit, U16 NumRxBuffers);
Xvoid IP_NI_NIOSII_MaCo_ConfigNumRxBuffers(unsigned Unit, unsigned short NumRxBuffers);
Nvoid IP_NI_NIOSII_MaCo_ConfigBaseAddr    (unsigned Unit, void* pBase, unsigned IrqNumber);
N
Nvoid IP_NI_GMACII_ConfigBaseAddr(unsigned Unit, void* pBase, unsigned IrqNumber);
N
N/*********************************************************************
N*
N*       PHY configuration
N*/
N#define IP_PHY_MODE_MII  0
N#define IP_PHY_MODE_RMII 1
N
N#define IP_PHY_ADDR_ANY       0xFF                          // IP_PHY_ADDR_ANY is used as PHY addr to initiate automatic scan for PHY
N#define IP_PHY_ADDR_INTERNAL  0xFE                          // IP_PHY_ADDR_INTERNAL is used as PHY addr to select internal PHY
N
Nvoid IP_NI_ConfigPHYAddr (unsigned Unit, U8 Addr);          // Configure PHY Addr (5-bit)
Xvoid IP_NI_ConfigPHYAddr (unsigned Unit, unsigned char Addr);          
Nvoid IP_NI_ConfigPHYMode (unsigned Unit, U8 Mode);          // Configure PHY Mode: 0: MII, 1: RMII
Xvoid IP_NI_ConfigPHYMode (unsigned Unit, unsigned char Mode);          
Nvoid IP_NI_ConfigPoll    (unsigned Unit);
Nvoid IP_NI_SetError      (unsigned Unit);
Nint  IP_NI_SetTxBufferSize(unsigned Unit, unsigned NumBytes);
N
N
N/*********************************************************************
N*
N*       IP stack tasks
N*/
Nvoid IP_Task(void);
Nvoid IP_RxTask(void);
Nvoid IP_ShellServer(void);
N
N
Ntypedef int (IP_RX_HOOK)(IP_PACKET * pPacket);
N
N/*********************************************************************
N*
N*       Core functions
N*/
Nvoid IP_AddBuffers                (int NumBuffers, int BytesPerBuffer);
Nvoid IP_AddEtherInterface         (const IP_HW_DRIVER *pDriver);
Nvoid IP_AllowBackPressure         (char v);
Nvoid IP_AssignMemory              (U32 * pMem, U32 NumBytes);
Xvoid IP_AssignMemory              (unsigned long * pMem, unsigned long NumBytes);
Nvoid IP_ConfTCPSpace              (unsigned SendSpace, unsigned RecvSpace);  // Set window sizes
Nvoid IP_Exec                      (void);
Nvoid IP_GetAddrMask               (U8 IFace, U32 * pAddr, U32 * pMask);
Xvoid IP_GetAddrMask               (unsigned char IFace, unsigned long * pAddr, unsigned long * pMask);
Nint  IP_GetCurrentLinkSpeed       (void);
NU32  IP_GetGWAddr                 (U8 IFace);
Xunsigned long  IP_GetGWAddr                 (unsigned char IFace);
Nvoid IP_GetHWAddr                 (U8 IFace, U8 * pDest, unsigned Len);
Xvoid IP_GetHWAddr                 (unsigned char IFace, unsigned char * pDest, unsigned Len);
NU32  IP_GetIPAddr                 (U8 IFace);
Xunsigned long  IP_GetIPAddr                 (unsigned char IFace);
Nconst char * IP_GetIPPacketInfo   (IP_PACKET * pPacket);
Nint  IP_GetVersion                (void);                   // Format: Mmmrr. Sample 10201 is 1.02a
Nvoid IP_ICMP_SetRxHook            (IP_RX_HOOK * pfRxHook);
Nint  IP_IFaceIsReady              (void);
Nvoid IP_Init                      (void);
Nint  IP_NI_GetCaps                (unsigned Unit);
Nint  IP_NI_LoadHWAddr             (unsigned Unit);
Nvoid IP_Panic                     (const char * sError);
Nvoid IP_SetAddrMask               (U32 Addr, U32 Mask);
Xvoid IP_SetAddrMask               (unsigned long Addr, unsigned long Mask);
Nint  IP_SetCurrentLinkState       (U32 Duplex, U32 Speed);  // Called from driver
Xint  IP_SetCurrentLinkState       (unsigned long Duplex, unsigned long Speed);  
Nvoid IP_SetDefaultTTL             (int v);
Nvoid IP_SetGWAddr                 (U8 IFace, U32 GWAddr);
Xvoid IP_SetGWAddr                 (unsigned char IFace, unsigned long GWAddr);
Nvoid IP_SetHWAddr                 (const U8 * pHWAddr);
Xvoid IP_SetHWAddr                 (const unsigned char * pHWAddr);
Nvoid IP_SetMTU                    (U8 IFace, U32 Mtu);
Xvoid IP_SetMTU                    (unsigned char IFace, unsigned long Mtu);
Nint  IP_SendPacket                (unsigned IFace, void * pData, int NumBytes);
Nint  IP_SendPing                  (ip_addr, char* pData, unsigned NumBytes, U16 SeqNo);
Xint  IP_SendPing                  (ip_addr, char* pData, unsigned NumBytes, unsigned short SeqNo);
Nvoid IP_SetRxHook                 (IP_RX_HOOK * pfRxHook);
Nvoid IP_SOCKET_SetDefaultOptions  (U16 v);
Xvoid IP_SOCKET_SetDefaultOptions  (unsigned short v);
Nvoid IP_SOCKET_SetLimit           (unsigned Limit);
Nvoid IP_TCP_Set2MSLDelay          (unsigned v);
Nvoid IP_TCP_SetConnKeepaliveOpt   (U32 Init, U32 Idle, U32 Period, U32 Cnt);
Xvoid IP_TCP_SetConnKeepaliveOpt   (unsigned long Init, unsigned long Idle, unsigned long Period, unsigned long Cnt);
Nvoid IP_TCP_SetRetransDelayRange  (unsigned RetransDelayMin, unsigned RetransDelayMax);
Nvoid IP_X_Config                  (void);
N
N/*********************************************************************
N*
N*       Log/Warn functions
N*/
Nvoid IP_Log           (const char * s);
Nvoid IP_Warn          (const char * s);
Nvoid IP_SetLogFilter  (U32 FilterMask);
Xvoid IP_SetLogFilter  (unsigned long FilterMask);
Nvoid IP_SetWarnFilter (U32 FilterMask);
Xvoid IP_SetWarnFilter (unsigned long FilterMask);
Nvoid IP_AddLogFilter  (U32 FilterMask);
Xvoid IP_AddLogFilter  (unsigned long FilterMask);
Nvoid IP_AddWarnFilter (U32 FilterMask);
Xvoid IP_AddWarnFilter (unsigned long FilterMask);
N
N
N/*********************************************************************
N*
N*       DNS (Domain name system)
N*
N*  Name resolution
N*/
N// Description of data base entry for a single host.
Nstruct hostent {
N  char *  h_name;        // Official name of host.
N  char ** h_aliases;     // Alias list.
N  int     h_addrtype;    // Host address type.
N  int     h_length;      // Length of address.
N  char ** h_addr_list;   // List of addresses from name server.
N#define h_addr h_addr_list[0] /* Address, for backward compatibility.  */
N#ifdef DNS_CLIENT_UPDT
S  // Extra variables passed in to Dynamic DNS updates.
S  char *  h_z_name;      // IN- zone name for UPDATE packet.
S  ip_addr h_add_ipaddr;  // IN- add this ip address for host name in zone.
S  U32     h_ttl;         // IN- time-to-live field for UPDATE packet.
N#endif
N};
N
N
Nstruct hostent * gethostbyname (char * name);
Nint              IP_ResolveHost(char * host, ip_addr *   address,  int   flags);
Nvoid             IP_DNS_SetServer (U32 DNSServerAddr);
Xvoid             IP_DNS_SetServer (unsigned long DNSServerAddr);
NU32              IP_DNS_GetServer (void);
Xunsigned long              IP_DNS_GetServer (void);
Nint              IP_DNS_SetServerEx (U8 IFace, U8 DNSServer, const U8 * pDNSAddr, int AddrLen);
Xint              IP_DNS_SetServerEx (unsigned char IFace, unsigned char DNSServer, const unsigned char * pDNSAddr, int AddrLen);
Nvoid             IP_DNS_GetServerEx (U8 IFace, U8 DNSServer, U8 * pDNSAddr, int * pAddrLen);
Xvoid             IP_DNS_GetServerEx (unsigned char IFace, unsigned char DNSServer, unsigned char * pDNSAddr, int * pAddrLen);
Nchar           * IP_ParseIPAddr(ip_addr * ipout,  unsigned *  sbits, char *   stringin);
Nvoid             IP_DNSC_SetMaxTTL(U32 TTL);
Xvoid             IP_DNSC_SetMaxTTL(unsigned long TTL);
N
N
N/*********************************************************************
N*
N*       Utility functions
N*
N* RS: Maybe we should move them into a UTIL module some time ? (We can keep macros here for compatibility)
N*/
NI32  IP_BringInBounds(I32 v, I32 Min, I32 Max);
Xsigned long  IP_BringInBounds(signed long v, signed long Min, signed long Max);
NU32  IP_LoadU32BE(const U8 * pData);
Xunsigned long  IP_LoadU32BE(const unsigned char * pData);
NU32  IP_LoadU32LE(const U8 * pData);
Xunsigned long  IP_LoadU32LE(const unsigned char * pData);
NU32  IP_LoadU32TE(const U8 * pData);
Xunsigned long  IP_LoadU32TE(const unsigned char * pData);
NU32  IP_LoadU16BE(const U8 * pData);
Xunsigned long  IP_LoadU16BE(const unsigned char * pData);
NU32  IP_LoadU16LE(const U8 * pData);
Xunsigned long  IP_LoadU16LE(const unsigned char * pData);
Nvoid IP_StoreU32BE(U8 * p, U32 v);
Xvoid IP_StoreU32BE(unsigned char * p, unsigned long v);
Nvoid IP_StoreU32LE(U8 * p, U32 v);
Xvoid IP_StoreU32LE(unsigned char * p, unsigned long v);
N
Nchar IP_tolower(char c);
Nchar IP_isalpha(char c);
Nchar IP_isalnum(char c);
Nint  IP_PrintIPAddr(char * pDest, U32 IPAddr, int BufferSize);
Xint  IP_PrintIPAddr(char * pDest, unsigned long IPAddr, int BufferSize);
N
N
N
N/*********************************************************************
N*
N*       UDP
N*/
Ntypedef  struct udp_conn * UDPCONN;
Ntypedef  U32 IP_ADDR;
Xtypedef  unsigned long IP_ADDR;
N
N#define IP_RX_ERROR        -1
N#define IP_OK               0
N#define IP_OK_KEEP_PACKET   1
N
Ntypedef UDPCONN IP_UDP_CONN;
N
NIP_UDP_CONN IP_UDP_Open(IP_ADDR IPAddr, U16 fport, U16 lport, int(*)(IP_PACKET *, void * pContext) , void * pContext);
XIP_UDP_CONN IP_UDP_Open(IP_ADDR IPAddr, unsigned short fport, unsigned short lport, int(*)(IP_PACKET *, void * pContext) , void * pContext);
Nvoid        IP_UDP_Close(IP_UDP_CONN);
NIP_PACKET * IP_UDP_Alloc(int NumBytes);
Nint         IP_UDP_Send       (int IFace, IP_ADDR FHost, U16 fport, U16 lport, IP_PACKET * pPacket);
Xint         IP_UDP_Send       (int IFace, IP_ADDR FHost, unsigned short fport, unsigned short lport, IP_PACKET * pPacket);
Nint         IP_UDP_SendAndFree(int IFace, IP_ADDR FHost, U16 fport, U16 lport, IP_PACKET * pPacket);
Xint         IP_UDP_SendAndFree(int IFace, IP_ADDR FHost, unsigned short fport, unsigned short lport, IP_PACKET * pPacket);
Nvoid        IP_UDP_Free       (IP_PACKET * pPacket);
NU16         IP_UDP_FindFreePort(void);
Xunsigned short         IP_UDP_FindFreePort(void);
NU16         IP_UDP_GetLPort  (const IP_PACKET *pPacket);
Xunsigned short         IP_UDP_GetLPort  (const IP_PACKET *pPacket);
Nvoid *      IP_UDP_GetDataPtr(const IP_PACKET *pPacket);
Nvoid        IP_UDP_GetSrcAddr(const IP_PACKET *pPacket, void * pSrcAddr, int AddrLen);
N
Nvoid        IP_UDP_EnableRxChecksum(void);
Nvoid        IP_UDP_DisableRxChecksum(void);
Nvoid        IP_UDP_EnableTxChecksum(void);
Nvoid        IP_UDP_DisableTxChecksum(void);
N
N
N/*********************************************************************
N*
N*       TCP Zero copy
N*/
NIP_PACKET * IP_TCP_Alloc      (int datasize);
Nvoid        IP_TCP_Free       (        IP_PACKET * pPacket);
Nint         IP_TCP_Send       (long s, IP_PACKET * pPacket);
Nint         IP_TCP_SendAndFree(long s, IP_PACKET * pPacket);
N
N/*********************************************************************
N*
N*       IP_DHCPC_...
N*
N*  DHCP (Dynamic host configuration protocol) functions.
N*/
Nvoid     IP_DHCPC_Activate   (int IFIndex, const char *sHost, const char *sDomain, const char *sVendor);
Nunsigned IP_DHCPC_GetState   (int IFIndex);
Nvoid     IP_DHCPC_Halt       (int IFIndex);
Nvoid     IP_DHCPC_SetCallback(int IFIndex, int (*routine)(int,int) );
Nvoid     IP_DHCPC_SetClientId(int IFIndex, const char *sClientId);
N
N
N/*********************************************************************
N*
N*       IP_Show_...
N*
N*  Text output functions informing about the state of various components of the software
N*/
Nint IP_ShowARP       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowICMP      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowTCP       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowBSDConn   (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowBSDSend   (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowBSDRcv    (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowMBuf      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowMBufList  (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowSocketList(void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowStat      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowUDP       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowUDPSockets(void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowDHCPClient(void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowDNS       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowDNS1      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
N
N
Ntypedef struct {
N  long Socket;
N  char * pBuffer;
N  int BufferSize;
N} IP_SENDF_CONTEXT;
N
Nvoid IP_Sendf(void * pContext, const char * sFormat, ...);
N
N/*********************************************************************
N*
N*       IP_CONNECTION information
N*
N*/
N
N#define IP_CONNECTION_TYPE_TCP 1
N
Ntypedef void * IP_CONNECTION_HANDLE;
Ntypedef struct {
N  void * pSock;
N  long hSock;
N  U32  ForeignAddr;
X  unsigned long  ForeignAddr;
N  U32  LocalAddr;
X  unsigned long  LocalAddr;
N  U16  ForeignPort;
X  unsigned short  ForeignPort;
N  U16  LocalPort;
X  unsigned short  LocalPort;
N  U8   Type;
X  unsigned char   Type;
N  U8   TcpState;
X  unsigned char   TcpState;
N  U16  TcpMtu;
X  unsigned short  TcpMtu;
N  U16  TcpMss;
X  unsigned short  TcpMss;
N  U32  TcpRetransDelay;
X  unsigned long  TcpRetransDelay;
N  U32  TcpIdleTime;
X  unsigned long  TcpIdleTime;
N  U32  RxWindowCur;
X  unsigned long  RxWindowCur;
N  U32  RxWindowMax;
X  unsigned long  RxWindowMax;
N  U32  TxWindow;
X  unsigned long  TxWindow;
N} IP_CONNECTION;
N
Nint IP_INFO_GetConnectionList(IP_CONNECTION_HANDLE *pDest, int MaxItems);
Nint IP_INFO_GetConnectionInfo(IP_CONNECTION_HANDLE h, IP_CONNECTION * p);
Nconst char * IP_INFO_ConnectionType2String(U8 Type);
Xconst char * IP_INFO_ConnectionType2String(unsigned char Type);
Nconst char * IP_INFO_ConnectionState2String(U8 State);
Xconst char * IP_INFO_ConnectionState2String(unsigned char State);
N
N#if defined(__cplusplus)
X#if 0L
S  }              // Make sure we have C-declarations in C++ programs
N#endif
N
N#endif   // Avoid multiple inclusion
N
N
N
L 20 "Setup\IP_Config_LPC24xx.c" 2
N
N/*********************************************************************
N*
N*       Defines, configurable
N*
N**********************************************************************
N*/
N#define ALLOC_SIZE                 0x8000      // Size of memory dedicated to the stack in bytes
N
N/*********************************************************************
N*
N*       Static data
N*
N**********************************************************************
N*/
Nstatic U32 _aPool[ALLOC_SIZE / 4];                    // This is the memory area used by the stack.
Xstatic unsigned long _aPool[0x8000 / 4];                    
N
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       IP_X_Config
N*
N*  Function description
N*    This function is called by the IP stack during IP_Init().
N*
N*  Typical memory/buffer configurations:
N*    Microcontroller system, size optimized
N*      #define ALLOC_SIZE 0x3000                    // 12KBytes RAM
N*      mtu = 576;                                   // 576 is minimum acc. to RFC, 1500 is max. for Ethernet
N*      IP_SetMTU(0, mtu);                           // Maximum Transmission Unit is 1500 for ethernet by default
N*      IP_AddBuffers(8, 256);                       // Small buffers.
N*      IP_AddBuffers(4, mtu + 16);                  // Big buffers. Size should be mtu + 16 byte for ethernet header (2 bytes type, 2*6 bytes MAC, 2 bytes padding)
N*      IP_ConfTCPSpace(1 * (mtu-40), 1 * (mtu-40)); // Define the TCP Tx and Rx window size
N*
N*    Microcontroller system, speed optimized or multiple connections
N*      #define ALLOC_SIZE 0x6000                    // 24 KBytes RAM
N*      mtu = 1500;                                  // 576 is minimum acc. to RFC, 1500 is max. for Ethernet
N*      IP_SetMTU(0, mtu);                           // Maximum Transmission Unit is 1500 for ethernet by default
N*      IP_AddBuffers(12, 256);                      // Small buffers.
N*      IP_AddBuffers(6, mtu + 16);                  // Big buffers. Size should be mtu + 16 byte for ethernet header (2 bytes type, 2*6 bytes MAC, 2 bytes padding)
N*      IP_ConfTCPSpace(3 * (mtu-40), 3 * (mtu-40)); // Define the TCP Tx and Rx window size
N*
N*    System with lots of RAM
N*      #define ALLOC_SIZE 0x20000                   // 128 KBytes RAM
N*      mtu = 1500;                                  // 576 is minimum acc. to RFC, 1500 is max. for Ethernet
N*      IP_SetMTU(0, mtu);                           // Maximum Transmission Unit is 1500 for ethernet by default
N*      IP_AddBuffers(50, 256);                      // Small buffers.
N*      IP_AddBuffers(50, mtu + 16);                 // Big buffers. Size should be mtu + 16 byte for ethernet header (2 bytes type, 2*6 bytes MAC, 2 bytes padding)
N*      IP_ConfTCPSpace(5 * (mtu-40), 5 * (mtu-40)); // Define the TCP Tx and Rx window size
N*/
Nvoid IP_X_Config(void) {
N  int mtu;
N
N  IP_AssignMemory(_aPool, sizeof(_aPool));    // Assigning memory should be the first thing
N  IP_AddEtherInterface(&IP_Driver_LPC24xx);   // Add ethernet driver for your hardware
N  IP_SetHWAddr("\x00\x22\xC7\xFF\xFF\xFF");   // MAC addr: Needs to be unique for production units
N  //
N  // Use DHCP client or define IP address, subnet mask,
N  // gateway address and DNS server according to the
N  // requirements of your application.
N  //
N  IP_DHCPC_Activate(0, "TARGET", NULL, NULL);
X  IP_DHCPC_Activate(0, "TARGET", 0, 0);
N  //IP_SetAddrMask(0xC0A805E6, 0xFFFF0000);     // Assign IP addr. (e.g. 192.168.5.230) and subnet mask (e.g. 255.255.0.0)
N  //IP_SetGWAddr(0, 0xC0A80501);                // Set gateway address, for example 192.168.5.1
N  //IP_DNS_SetServer(0xCC98B84C);               // Set DNS server address, for example 204.152.184.76
N  //
N  // Run-time configure buffers.
N  // The default setup will do for most cases.
N  //
N  mtu = 1500;                                      // 576 is minimum acc. to RFC, 1500 is max. for Ethernet
N  IP_SetMTU(0, mtu);                               // Maximum Transmission Unit is 1500 for ethernet by default
N  IP_AddBuffers(12, 256);                          // Small buffers.
N  IP_AddBuffers(8, mtu + 40 + 16);                 // Big buffers. Size should be mtu + 16 byte for ethernet header (2 bytes type, 2*6 bytes MAC, 2 bytes padding)
N  IP_ConfTCPSpace(3 * (mtu - 40), 3 * (mtu - 40)); // Define the TCP Tx and Rx window size. There should be space for 2 max size packets; otherwise communication can be very slow due to delayed Acks.
N  IP_SOCKET_SetDefaultOptions(0
N//                              | SO_TIMESTAMP     // Send TCP timestamp to optimize the round trip time measurement. Normally not used in LAN.
N                             );  
N  //
N  // Define log and warn filter
N  // Note: The terminal I/O emulation affects the timing
N  // of your communication, since the debugger stops the target
N  // for every terminal I/O output unless you use DCC!
N  //
N  IP_SetWarnFilter(0xFFFFFFFF);               // 0xFFFFFFFF: Do not filter: Output all warnings.
N  IP_SetLogFilter(IP_MTYPE_INIT               // Output all messages from init
X  IP_SetLogFilter((1UL << 0)               
N                | IP_MTYPE_LINK_CHANGE        // Output a message if link status changes
X                | (1UL << 14)        
N                | IP_MTYPE_DHCP               // Output general DHCP status messages
X                | (1UL << 17)               
N//                | IP_MTYPE_DHCP_EXT           // Output additional DHCP messages
N//                | IP_MTYPE_CORE               // Output log messages from core module
N//                | IP_MTYPE_ALLOC              // Output log messages for memory allocation
N//                | IP_MTYPE_DRIVER             // Output log messages from driver
N//                | IP_MTYPE_ARP                // Output log messages from ARP layer
N//                | IP_MTYPE_IP                 // Output log messages from IP layer
N//                | IP_MTYPE_TCP_CLOSE          // Output a log messages if a TCP connection has been closed
N//                | IP_MTYPE_TCP_OPEN           // Output a log messages if a TCP connection has been opened
N//                | IP_MTYPE_TCP_IN             // Output TCP input logs
N//                | IP_MTYPE_TCP_OUT            // Output TCP output logs
N//                | IP_MTYPE_TCP_RTT            // Output TCP round trip time (RTT) logs
N//                | IP_MTYPE_TCP_RXWIN          // Output TCP RX window related log messages
N//                | IP_MTYPE_TCP                // Output all TCP related log messages
N//                | IP_MTYPE_UDP_IN             // Output UDP input logs
N//                | IP_MTYPE_UDP_OUT            // Output UDP output logs
N//                | IP_MTYPE_UDP                // Output all UDP related messages
N//                | IP_MTYPE_ICMP               // Output ICMP related log messages
N//                | IP_MTYPE_NET_IN             // Output network input related messages
N//                | IP_MTYPE_NET_OUT            // Output network output related messages
N//                | IP_MTYPE_DNS                // Output all DNS related messages
N//                | IP_MTYPE_SOCKET_STATE       // Output socket status messages
N//                | IP_MTYPE_SOCKET_READ        // Output socket read related messages
N//                | IP_MTYPE_SOCKET_WRITE       // Output socket write related messages
N//                | IP_MTYPE_SOCKET             // Output all socket related messages
N                | IP_MTYPE_APPLICATION
X                | (1UL << 19)
N                );
N}
N
N/*************************** End of file ****************************/
