L 1 "Setup\BSP.c"
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2008     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : BSP.c
NPurpose : Dummy BSP for LPC2468
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#include "BSP.h"
L 1 "Inc\BSP.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : BSP.h
NPurpose : BSP (Board support package)
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef BSP_H                           /* avoid multiple inclusion */
N#define BSP_H
N
N#include "SEGGER.h"
L 1 "Inc\SEGGER.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : SEGGER.h
NPurpose : Global types etc & general purpose utility functions
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef SEGGER_H            // Guard against multiple inclusion
N#define SEGGER_H
N
N#include "Global.h"         // Type definitions: U8, U16, U32, I8, I16, I32
L 1 "GUI\Global.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : GLOBAL.h
NPurpose : Global types etc.
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GLOBAL_H            // Guard against multiple inclusion
N#define GLOBAL_H
N
N/*********************************************************************
N*
N*       Macros
N*
N**********************************************************************
N*/
N#define U8    unsigned char
N#define U16   unsigned short
N#define U32   unsigned long
N#define I8    signed char
N#define I16   signed short
N#define I32   signed long
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 22 "Inc\SEGGER.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N
N/*********************************************************************
N*
N*       Function-like macros
N*
N**********************************************************************
N*/
N
N#define SEGGER_COUNTOF(a)          (sizeof(a)/sizeof(a[0]))
N#define SEGGER_MIN(a,b)            (((a) < (b)) ? (a) : (b))
N#define SEGGER_MAX(a,b)            (((a) > (b)) ? (a) : (b))
N
N/*********************************************************************
N*
N*       Utiliy functions
N*
N**********************************************************************
N*/
Nvoid SEGGER_ARM_memcpy(void * pDest, const void * pSrc, int NumBytes);
Nvoid SEGGER_memcpy    (void * pDest, const void * pSrc, int NumBytes);
Nvoid SEGGER_snprintf(char * pBuffer, int BufferSize, const char * sFormat, ...);
N
N#if defined(__cplusplus)
X#if 0L
S}                /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 22 "Inc\BSP.h" 2
N
N/*********************************************************************
N*
N*       Defines, non-configurable
N*
N**********************************************************************
N*/
N#define KEY_STAT_UP       (1 << 0)
N#define KEY_STAT_DOWN     (1 << 1)
N#define KEY_STAT_LEFT     (1 << 2)
N#define KEY_STAT_RIGHT    (1 << 3)
N#define KEY_STAT_BUTTON1  (1 << 4)
N#define KEY_STAT_BUTTON2  (1 << 5)
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef BSP_USE_PARA
N  #if defined(NC30) || defined(NC308)
X  #if 0L || 0L
S    #define BSP_USE_PARA(para)
N  #else
N    #define BSP_USE_PARA(para) para=para;
N  #endif
N#endif
N
N/*********************************************************************
N*
N*       Functions
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       General
N*/
Nvoid     BSP_Init       (void);
Nvoid     BSP_SetLED     (int Index);
Nvoid     BSP_ClrLED     (int Index);
Nvoid     BSP_ToggleLED  (int Index);
Nunsigned BSP_GetKeyStat (void);
N
N/*********************************************************************
N*
N*       GUI
N*/
Nvoid BSP_GUI_Init(void);
N
N/*********************************************************************
N*
N*       USB
N*/
Nvoid BSP_USB_Attach         (void);
Nvoid BSP_USB_InstallISR     (void (*pfISR)(void));
Nvoid BSP_USB_InstallISR_Ex  (int ISRIndex, void (*pfISR)(void), int Prio);
Nvoid BSP_USB_ISR_Handler    (void);
N
N/*********************************************************************
N*
N*       USBH
N*/
Nvoid BSP_USBH_InstallISR    (void (*pfISR)(void));
Nvoid BSP_USBH_Init          (void);
N
N/*********************************************************************
N*
N*       ETH
N*
N*  Functions for ethernet controllers (as far as present)
N*/
Nvoid BSP_ETH_Init          (unsigned Unit);
Nvoid BSP_ETH_InstallISR    (void (*pfISR)(void));
Nvoid BSP_ETH_InstallISR_Ex (int ISRIndex, void (*pfISR)(void), int Prio);
Nvoid BSP_ETH_ISR_Handler   (void);
N
N/*********************************************************************
N*
N*       CACHE
N*/
Nvoid BSP_CACHE_CleanInvalidateRange (void * p, unsigned NumBytes);
Nvoid BSP_CACHE_CleanRange           (void * p, unsigned NumBytes);
Nvoid BSP_CACHE_InvalidateRange      (void * p, unsigned NumBytes);
N
N/*********************************************************************
N*
N*       UART
N*/
Nvoid BSP_UART_SetReadCallback(unsigned Unit, void (*pfOnRx) (unsigned Unit, unsigned char Data));
Nvoid BSP_UART_SetWriteCallback(unsigned Unit, void (*pfOnTx) (unsigned Unit));
Nvoid BSP_UART_Write1(U8 Data);
Xvoid BSP_UART_Write1(unsigned char Data);
Nvoid BSP_UART_SetBaudrate(unsigned Baudrate);
Nvoid BSP_UART_Init(void);
N
N#endif                                  /* avoid multiple inclusion */
N
N/*************************** End of file ****************************/
N
N
L 19 "Setup\BSP.c" 2
N#include "RTOS.h"
L 1 "OS\RTOS.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : RTOS.h
NPurpose : include file for embOS,
N          to be included in every C-module accessing embOS-routines
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef RTOS_H_INCLUDED        /* Avoid multiple inclusion          */
N#define RTOS_H_INCLUDED
N
N/*********************************************************************
N*
N*       Chip specifics for ARM7TDMI / ARM9TDMI and KEIL ARM MDK
N*
N**********************************************************************
N*/
N
N#include <string.h>                            /* req. for memset.h */
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 30 "OS\RTOS.h" 2
N
N/*********************************************************************
N*
N*     Specifics for ARM cores and KEIL-MDK compiler
N*
N**********************************************************************
N*/
N
N#define OS_PORT_REVISION          (1)                // Port specific revision
N#define OS_PTR_OP_IS_ATOMIC       (1)
N#define OS_GetTime()              (OS_Time)
N#define OS_GetTime32()            (OS_Time)
N#define OS_I32                    int
N#define OS_SIZEOF_INT             (4)                // Size of integer in bytes
N#define OS_BIG_ENDIAN             (0)                
N#define OS_SUPPORT_SYSSTACK_INFO  (1)                // Option to supply more info  to viewer
N#define OS_SUPPORT_OS_ALLOC       (1)                // Define whether OS_Alloc is supported
N#define OS_SP_ADJUST              (0)
N#define OS_EnterIntStack()                           // Int stack is automatically used by ARM
N#define OS_LeaveIntStack()                           // Int stack is automatically used by ARM
N
N/*****  Core specific configuration *********************************/
N
N#define OS_SUPPORT_INTSTACK_INFO            (1)      // Option to supply more info  to viewer
N#define OS_SWITCH_FROM_INT_MODIFIES_STACK   (1)
N#define OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY (0)
N#define OS_SUPPORT_INT_PRIORITY             (0)              // No selectable interrupt priorities with ARM
N
N/*****  End of configuration settings *******************************/
N
N#ifdef __TARGET_ARCH_4T
N  #define OS_CPU "ARM4/KEIL_MDK"
N#else
S  #define OS_CPU "ARM5/KEIL_MDK"
N#endif
N
N#define OS_DI() __disable_irq()    /* We use the default intrinsic function */
N#define OS_EI() __enable_irq()     /* We use the default intrinsic function */
N
N
N/* Option to get Stack pointer information  */
N#define OS_INIT_STACK_INFO()
N
N/*********************************************************************
N*
N*       Port specific (non OS generic) functions
N*/
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N  typedef void    OS_ISR_HANDLER(void);
N  void            OS_irq_handler(void);     /* Declare function to make sure it is arm pcs */
N  void            OS_IRQ_SERVICE(void);     /* embOS int handler in RTOSVect.asm  */
N  void            OS_USER_irq_func(void);   /* User interrupt handler from UserIrq.c */
N  OS_ISR_HANDLER* OS_ARM_InstallISRHandler (int ISRIndex, OS_ISR_HANDLER* pFunc);
N  void            OS_ARM_EnableISR         (int ISRIndex);
N  void            OS_ARM_DisableISR        (int ISRIndex);
N  int             OS_ARM_ISRSetPrio        (int ISRIndex, int Prio);
N  void            OS_ARM_AssignISRSource   (int ISRIndex, int Source);
N  void            OS_ARM_EnableISRSource   (int SourceIndex);
N  void            OS_ARM_DisableISRSource  (int SourceIndex);
N  void            OS_StartTask             (void);
N  void            OS_InitPLL               (void);
N
N/*********************************************************************
N*
N*       Core specific implementation
N*/
N
N/****** Support for ARM VFP *****************************************/
N  
Nextern const struct OS_EXTEND_TASK_CONTEXT OS_VFP_ExtendContext;
N
N/****** Support for ARM MMU and caches ******************************/
N
Nvoid OS_ARM_ICACHE_Enable(void);
Nvoid OS_ARM_DCACHE_Enable(void);
Nvoid OS_ARM_DCACHE_CleanRange     (void* p, unsigned int NumBytes);
Nvoid OS_ARM_DCACHE_InvalidateRange(void* p, unsigned int NumBytes);
Nvoid OS_ARM_CACHE_Sync(void);
N
Nvoid OS_ARM_MMU_Enable(unsigned int* pTranslationTable);
Nvoid OS_ARM_MMU_InitTT(unsigned int* pTranslationTable);
Nvoid OS_ARM_MMU_AddTTEntries(unsigned int* pTranslationTable, unsigned int CacheMode, unsigned int VIndex, unsigned int PIndex, unsigned int NumEntries);
N
Nvoid OS_ARM720_CACHE_Enable(void);
Nvoid OS_ARM720_CACHE_CleanRange(void* p, unsigned int NumBytes);
Nvoid OS_ARM720_CACHE_InvalidateRange(void* p, unsigned int NumBytes);
N
Nvoid OS_ARM720_MMU_Enable(unsigned int* pTranslationTable);
Nvoid OS_ARM720_MMU_InitTT(unsigned int* pTranslationTable);
Nvoid OS_ARM720_MMU_AddTTEntries(unsigned int* pTranslationTable, unsigned int CacheMode, unsigned int VIndex, unsigned int PIndex, unsigned int NumEntries);
N
N#define OS_ARM_CACHEMODE_NC_NB    ((0 << 3) | (0 << 2))
N#define OS_ARM_CACHEMODE_C_NB     ((1 << 3) | (0 << 2))
N#define OS_ARM_CACHEMODE_NC_B     ((0 << 3) | (1 << 2))
N#define OS_ARM_CACHEMODE_C_B      ((1 << 3) | (1 << 2))
N#define OS_ARM_CACHEMODE_ILLEGAL  (0x01)
N
N#ifdef __cplusplus
S  } 
N#endif
N
N/*********************************************************************
N*
N*     Port specific revision
N*/
N
N/*********************************************************************
N*
N*       Check configuration
N*
N**********************************************************************
N
NThis is required in order to automatically create the correct identifiers
Nin order to be able to autoamitcally remap the identifiers.
N
N*/
N
N#ifdef __thumb
N  #define OS_CPUMODE_PREFIX "T"
N#else
S  #define OS_CPUMODE_PREFIX "A"
N#endif
N
N#ifdef __TARGET_ARCH_4T
N  #define OS_CPU_PREFIX "4"
N#else
S  #define OS_CPU_PREFIX "5"
N#endif
N
N#ifdef __BIG_ENDIAN
S  #define OS_ENDIAN_PREFIX "B"
N#else
N  #define OS_ENDIAN_PREFIX "L"
N#endif
N
N#define OS_MODEL OS_CPUMODE_PREFIX OS_CPU_PREFIX OS_ENDIAN_PREFIX
N
N
N/****** End of chip / compiler specific part ************************/
N
N/*********************************************************************
N*
N*       Generic portion of the OS starts here
N*
N**********************************************************************
NThis file (original name OS_RAW.h) is part of RTOS.h, the include
Nfile for the OS.
N*/
N
N#if (!defined(OS_LIBMODE_XR) && !defined(OS_LIBMODE_R)  &&   \
N     !defined(OS_LIBMODE_S)  && !defined(OS_LIBMODE_SP) &&   \
N     !defined(OS_LIBMODE_D)  && !defined(OS_LIBMODE_DP) &&   \
N     !defined(OS_LIBMODE_DT))
X#if (!0L && !0L  &&        !0L  && !0L &&        !0L  && !0L &&        !0L)
N#include "OS_Config.h"
L 1 "Config\OS_Config.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef OS_CONFIG_H                     /* Avoid multiple inclusion */
N#define OS_CONFIG_H
N
N/*********************************************************************
N*
N*       Configuration for RTOS build and UART
N*
N*  One of the following builds needs to be selected for both DEBUG and Release builds:
N*
N*  OS_LIBMODE_XR    Extremly small release build without Round robin
N*  OS_LIBMODE_R     Release build
N*  OS_LIBMODE_S     Release build with stack check
N*  OS_LIBMODE_SP    Release build with stack check and profiling
N*  OS_LIBMODE_D     Debug build
N*  OS_LIBMODE_DP    Debug build with profiling
N*  OS_LIBMODE_DT    Debug build with trace
N*/
N
N#ifndef   DEBUG
S  #define DEBUG 0
N#endif
N
N#if DEBUG
X#if 1
N  #define OS_LIBMODE_DP
N#else
S  #define OS_LIBMODE_R
S  #define OS_VIEW_ENABLE   0
N#endif
N
N#endif                                  /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 187 "OS\RTOS.h" 2
N#endif
N
N#define OS_VERSION_GENERIC (36004)      /*   Generic version 3.60d  */
N
N#ifndef   OS_PORT_REVISION
S  #define OS_PORT_REVISION 0
N#endif
N
N#define OS_VERSION OS_VERSION_GENERIC + (OS_PORT_REVISION * 25)
N
N/*********************************************************************
N*
N*       Defines for library types
N*
N**********************************************************************
N*/
N
N/* If library type is not selected yet (on project level,
N   for example), then select DP by default
N*/
N#if (!defined(OS_LIBMODE_XR) && !defined(OS_LIBMODE_R)  &&   \
N     !defined(OS_LIBMODE_S)  && !defined(OS_LIBMODE_SP) &&   \
N     !defined(OS_LIBMODE_D)  && !defined(OS_LIBMODE_DP) &&   \
N     !defined(OS_LIBMODE_DT))
X#if (!0L && !0L  &&        !0L  && !0L &&        !0L  && !1L &&        !0L)
S#define OS_LIBMODE_DP
N#endif
N
N#if defined(OS_LIBMODE_XR)                                   // Extremely small release - without Round robin support
X#if 0L                                   
S  #define OS_CHECKSTACK       0
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_RR_SUPPORTED     0
S  #define OS_TRACKNAME        0
S  #define OS_SUPPORT_SAVE_RESTORE_HOOK 0
S  #define OS_CreateTask   OS_CreateTask_XR
S  #define OS_CreateTaskEx OS_CreateTaskEx_XR
S  #define OS_LIBMODE "XR"
S#elif defined(OS_LIBMODE_R)                                  // Release build
X#elif 0L                                  
S  #define OS_CHECKSTACK       0
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_R
S  #define OS_CreateTaskEx OS_CreateTaskEx_R
S  #define OS_LIBMODE "R"
S#elif defined(OS_LIBMODE_S)                                  // Release build with stack check
X#elif 0L                                  
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_S
S  #define OS_CreateTaskEx OS_CreateTaskEx_S
S  #define OS_LIBMODE "S"
S#elif defined(OS_LIBMODE_SP)                                 // Release build with stack check and profiling
X#elif 0L                                 
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            0
S  #define OS_PROFILE          1
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_SP
S  #define OS_CreateTaskEx OS_CreateTaskEx_SP
S  #define OS_LIBMODE "SP"
S#elif defined(OS_LIBMODE_D)                                  // Debug build
X#elif 0L                                  
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            1
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_D
S  #define OS_CreateTaskEx OS_CreateTaskEx_D
S  #define OS_LIBMODE "D"
N#elif defined(OS_LIBMODE_DP)                                  // Debug build with profiling
X#elif 1L                                  
N  #define OS_CHECKSTACK       1
N  #define OS_PROFILE          1
N  #define OS_DEBUG            1
N  #define OS_SUPPORT_TICKSTEP 1
N  #define OS_TRACE            0
N  #define OS_CreateTask   OS_CreateTask_DP
N  #define OS_CreateTaskEx OS_CreateTaskEx_DP
N  #define OS_LIBMODE "DP"
N#elif defined(OS_LIBMODE_DT)                                  // Debug build with profiling and trace
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            1
S  #define OS_PROFILE          1
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            1
S  #define OS_CreateTask   OS_CreateTask_DT
S  #define OS_CreateTaskEx OS_CreateTaskEx_DT
S  #define OS_LIBMODE "DT"
S#else
S  #error Please define library type used !
N#endif
N
N/*********************************************************************
N*
N*       OS compile time switches
N*
N**********************************************************************
N
NThese compile time switches can be modified when recompiling
Nthe library. Usually, the values are in OSCHIP.H, which is then
Nmerged with OS_RAW.H to form RTOS.H.
NIf the values are not defined in OSCHIP.H, the default values
Nbelow are used.
N*/
N
N/* Make it possible to place const data in RAM via
N   define and therefore via command line. This is required
N   for some smaller CPUs in small memory models
N   It is defined to be "const" by default, but can be defined to nothing
N   by simply adding a -DOS_CONST_DATA on the commandline
N*/
N
N#ifndef   OS_CONST_DATA
N  #define OS_CONST_DATA const  /* Default      */
N#else
S  #undef  OS_CONST_DATA
S  #define OS_CONST_DATA        /* define blank */
N#endif
N
N#ifndef   OS_INTERWORK
N  #define OS_INTERWORK
N#endif
N
N#ifndef   OS_SCHEDULER_ACTIVATED_BY_EXCEPTION
N  #define OS_SCHEDULER_ACTIVATED_BY_EXCEPTION   (0)
N#endif
N
N#ifndef   OS_STACK_ADR
N  #define OS_STACK_ADR OS_U32
N#endif
N
N#ifndef   OS_MODEL
S  #define OS_MODEL ""
N#endif
N
N#ifndef   OS_MEMSET
N  #define OS_MEMSET(a,v,s) memset(a,v,s)
N#endif
N
N#ifndef   OS_MEMCPY
N  #define OS_MEMCPY(dest,src,cnt) memcpy(dest,src,cnt)
N#endif
N
N#ifndef   OS_STRLEN
N  #define OS_STRLEN(s) strlen(s)
N#endif
N
N#ifndef   OS_DUMMY_STATEMENT
N  #define OS_DUMMY_STATEMENT()
N#endif
N
N#ifndef   OS_USEPARA
N  #define OS_USEPARA(para) para=para
N#endif
N
N#ifndef   OS_SUPPORT_TICKSTEP
S  #define OS_SUPPORT_TICKSTEP 0
N#endif
N
N#ifndef   OS_TRACKNAME
N  #define OS_TRACKNAME (1)
N#endif
N
N#ifndef   OS_TRACE
S  #define OS_TRACE (0)
N#endif
N
N#ifndef   OS_SUPPORT_SAVE_RESTORE_HOOK
N  #define OS_SUPPORT_SAVE_RESTORE_HOOK  (1)
N#endif
N
N#ifndef   OS_RR_SUPPORTED
N  #define OS_RR_SUPPORTED (1)
N#endif
N
N#ifndef   OS_STACK_AT_BOTTOM
N  #define OS_STACK_AT_BOTTOM (0)
N#endif
N
N/*  Settings for NON-ANSI compiler syntax
N    The default behaviour complies with IAR.
N*/
N#ifndef   OS_COMPILER_LOCATION_LEFT
N  #define OS_COMPILER_LOCATION_LEFT 1  /* (req. for IAR) */
N#endif
N
N#ifndef   OS_COMPILER_STORAGE_MODIFIER_LEFT
N  #define OS_COMPILER_STORAGE_MODIFIER_LEFT 1  /* default for all except KEIL */
N#endif
N
N#define OS_LINK_MAILBOXES (OS_DEBUG)
N
N#ifndef   OS_CHECK
N  #define OS_CHECK 0
N#endif
N
N#ifndef   OS_ALIGN_PTR
N  #define OS_ALIGN_PTR (1)
N#endif
N
N#ifndef   OS_ALIGN_INT
N  #define OS_ALIGN_INT (1)
N#endif
N
N#ifndef   OS_PTR_TO_VALUE
N  #define OS_PTR_TO_VALUE(p) (p)
N#endif
N
N#ifndef   OS_IDLE
N  #define OS_IDLE() OS_Idle()
N#endif
N
N#ifndef   OS_PTR_OP_IS_ATOMIC
S  #define OS_PTR_OP_IS_ATOMIC   (0)         // Helps to minimize code size and execution time. Some code is not required if setting pointers is an atomic operation (32 bit CPUs or 16 bit CPUs in near model)
N#endif
N
N#ifndef   OS_SUSPEND_TASK_ON_TERMINATE      // Sets the task state of a terminated task to "suspended". Primarily used in the OS simulation, because the windows scheduler might re-activate a suspended task
N  #define OS_SUSPEND_TASK_ON_TERMINATE (0)
N#endif
N
N#ifndef   OS_INIT_EXPLICITLY
N  #define OS_INIT_EXPLICITLY  (0)           // If enabled, OS_InitKern() initializes Non-Zero globals. Required only for faulty compiler (or startup-code) which do not perform proper init of globals during startup.
N#endif
N
N#ifndef   OS_TASK_LIST_HAS_PPREV
N  #define OS_TASK_LIST_HAS_PPREV   OS_RR_SUPPORTED
N#else
S  #if (OS_TASK_LIST_HAS_PPREV == 0) && OS_RR_SUPPORTED
S    #error  "Invalid combination of config switches"
S  #endif
N#endif
N
N#ifndef   OS_SUPPORT_CALL_ISR
N  #define OS_SUPPORT_CALL_ISR (1)
N#endif
N
N#ifndef   OS_PREPARE_STACKPOINTER
N  #define OS_PREPARE_STACKPOINTER()
N#endif
N
N#ifndef   OS_SUPPORT_POWER
N  #define OS_SUPPORT_POWER (1)
N#endif
N
N#ifndef   OS_POWER_NUM_COUNTERS
N  #define OS_POWER_NUM_COUNTERS (5)
N#endif
N
N/*********************************************************************
N*
N*       Check Compile time switches
N*
N**********************************************************************
N*/
N
N#ifndef OS_SIZEOF_INT
S  #error "Please define OS_SIZEOF_INT (OSChip.h)"
N#endif
N#ifndef OS_BIG_ENDIAN
S  #error "Please define OS_BIG_ENDIAN (OSChip.h)"
N#endif
N
N#if (OS_STACK_AT_BOTTOM != 0) && (OS_STACK_AT_BOTTOM != 1)
X#if ((0) != 0) && ((0) != 1)
S  /*
S  *  Only 0 or 1 is allowed, because OS_STACK_AT_BOTTOM is used for calculations!
S  */
S  #error "OS_STACK_AT_BOTTOM has to be defined to 0 or 1"
N#endif
N
N/*********************************************************************
N*
N*       Basic type defines
N*
N**********************************************************************
N*/
N
N#ifndef   OS_I8
N  #define OS_I8 signed char
N#endif
N
N#ifndef   OS_U8
N  #define OS_U8 unsigned char
N#endif
N
N#ifndef   OS_I16
N  #define OS_I16 signed short
N#endif
N
N#ifndef   OS_U16
N  #define OS_U16 unsigned short
N#endif
N
N#ifndef   OS_I32
S  #define OS_I32 long
N#endif
N
N#ifndef   OS_U32
N  #define OS_U32 unsigned OS_I32
N#endif
N
N/* Defines a true integer. This type is guaranteed
N   a) to have at least 8 bits,
N   b) to compile and execute best on the target CPU
N   It will normally be the same as an int, but on most
N   8-bit CPUs it will be replaced by a character because
N   the CPU can deal with 8 bits more efficient than with
N   16 bit integers.
N   Use with care !
N*/
N#ifndef   OS_INT
N  #define OS_INT       int
N#endif
N
N#ifndef   OS_UINT
N  #define OS_UINT      unsigned OS_INT
N#endif
N
N#ifndef   OS_TIME
N  #define OS_TIME      int
N#endif
N
N
N/*********************************************************************
N*
N*       Error codes
N*
N**********************************************************************
N*/
N
N/* User 0..99  ***********************************/
N
N/* Port 100..119 *********************************/
N#define OS_ERR_ISR_INDEX                      (100)
N#define OS_ERR_ISR_VECTOR                     (101)
N#define OS_ERR_ISR_PRIO                       (102)
N
N/* OS generic ************************************/
N/* stack overflow or invalid stack */
N#define OS_ERR_STACK                          (120)
N
N/* Counting semaphore overflow */
N#define OS_ERR_CSEMA_OVERFLOW                 (121)
N
N/* Power management module */
N#define OS_ERR_POWER_OVER                     (122)
N#define OS_ERR_POWER_UNDER                    (123)
N#define OS_ERR_POWER_INDEX                    (124)
N
N
N/* invalid or non-initialized data structures */
N#define OS_ERR_INV_TASK                       (128)
N#define OS_ERR_INV_TIMER                      (129)
N#define OS_ERR_INV_MAILBOX                    (130)
N#define OS_ERR_INV_CSEMA                      (132)
N#define OS_ERR_INV_RSEMA                      (133)
N
N/* Using GetMail1 or PutMail1 or GetMailCond1 or PutMailCond1 on
N   a non-1 byte mailbox  */
N#define OS_ERR_MAILBOX_NOT1                   (135)
N
N/* Waitable objects deleted with waiting tasks or occupied by task */
N#define OS_ERR_MAILBOX_DELETE                 (136)
N#define OS_ERR_CSEMA_DELETE                   (137)
N#define OS_ERR_RSEMA_DELETE                   (138)
N
N/* internal errors, please contact SEGGER Microcontrollersysteme */
N#define OS_ERR_MAILBOX_NOT_IN_LIST            (140)
N#define OS_ERR_TASKLIST_CORRUPT               (142)
N
N/* not matching routine calls or macro usage */
N#define OS_ERR_UNUSE_BEFORE_USE               (150)
N#define OS_ERR_LEAVEREGION_BEFORE_ENTERREGION (151)
N#define OS_ERR_LEAVEINT                       (152)
N#define OS_ERR_DICNT                          (153)
N#define OS_ERR_INTERRUPT_DISABLED             (154)
N#define OS_ERR_TASK_ENDS_WITHOUT_TERMINATE    (155)
N#define OS_ERR_RESOURCE_OWNER                 (156)
N
N#define OS_ERR_ILLEGAL_IN_ISR                 (160)  /* not a legal system call during interrupt */
N#define OS_ERR_ILLEGAL_IN_TIMER               (161)  /* not a legal system call during timer */
N#define OS_ERR_ILLEGAL_OUT_ISR                (162)  /* not a legal system call outside interrupt */
N#define OS_ERR_NOT_IN_ISR                     (163)  /* OS_EnterInterrupt() has been called, but CPU is not in ISR state */
N#define OS_ERR_IN_ISR                         (164)  /* OS_EnterInterrupt() has not been called, but CPU is in ISR state */
N
N#define OS_ERR_INIT_NOT_CALLED                (165)  /* OS_InitKern() was not called */
N
N/* Double used data structures */
N#define OS_ERR_2USE_TASK                      (170)
N#define OS_ERR_2USE_TIMER                     (171)
N#define OS_ERR_2USE_MAILBOX                   (172)
N#define OS_ERR_2USE_BSEMA                     (173)
N#define OS_ERR_2USE_CSEMA                     (174)
N#define OS_ERR_2USE_RSEMA                     (175)
N#define OS_ERR_2USE_MEMF                      (176)
N
N/* Communication errors (OSCOM) */
N#define OS_ERR_NESTED_RX_INT                  (180)
N
N/* Fixed block memory pool  */
N#define OS_ERR_MEMF_INV                       (190)
N#define OS_ERR_MEMF_INV_PTR                   (191)
N#define OS_ERR_MEMF_PTR_FREE                  (192)
N#define OS_ERR_MEMF_RELEASE                   (193)
N#define OS_ERR_POOLADDR                       (194)
N#define OS_ERR_BLOCKSIZE                      (195)
N
N/* Task suspend / resume errors */
N#define OS_ERR_SUSPEND_TOO_OFTEN              (200)
N#define OS_ERR_RESUME_BEFORE_SUSPEND          (201)
N
N/* Other task related errors */
N#define OS_ERR_TASK_PRIORITY                  (202)
N
N/* Event object */
N#define OS_ERR_EVENT_INVALID                  (210)
N#define OS_ERR_2USE_EVENTOBJ                  (211)
N#define OS_ERR_EVENT_DELETE                   (212)
N
N/* Waitlist (checked build) */
N#define OS_ERR_WAITLIST_RING                  (220)
N#define OS_ERR_WAITLIST_PREV                  (221)
N#define OS_ERR_WAITLIST_NEXT                  (222)
N
N/* Other potential problems discovered in checked build */
N#define OS_ERR_NOT_IN_REGION                  (225)
N
N/* Cache related */
N#define OS_ERR_NON_ALIGNED_INVALIDATE         (230)
N
N/* OS special build, or internal */
N#define OS_ERR_TRIAL_LIMIT                    (254)
N
N/*********************************************************************
N*
N*       Trace identifier
N*
N**********************************************************************
N
NIdentifier from 0 to 99 are reserved for the OS
NEven when not all of those are currently used,
Nthey may be defined in the future
N
N*/
N
N#define OS_TRACE_ID_DEACTIVATE      (1)
N#define OS_TRACE_ID_ACTIVATE        (2)
N#define OS_TRACE_ID_TIMERCALLBACK   (3)
N
N/* Task group */
N#define OS_TRACE_ID_DELAY           (10)
N#define OS_TRACE_ID_DELAYUNTIL      (11)
N#define OS_TRACE_ID_SETPRIORITY     (12)
N#define OS_TRACE_ID_WAKETASK        (13)
N#define OS_TRACE_ID_CREATETASK      (14)
N#define OS_TRACE_ID_TERMINATETASK   (15)
N#define OS_TRACE_ID_SUSPENDTASK     (16)
N#define OS_TRACE_ID_RESUMETASK      (17)
N#define OS_TRACE_ID_CREATETASK_EX   (18)
N#define OS_TRACE_ID_YIELD           (19)
N
N/* Event group */
N#define OS_TRACE_ID_WAITEVENT       (20)
N#define OS_TRACE_ID_WAITEVENT_TIMED (21)
N#define OS_TRACE_ID_SIGNALEVENT     (22)
N#define OS_TRACE_ID_CLEAREVENTS     (23)
N
N/* Mailbox group  */
N#define OS_TRACE_ID_CREATEMB        (30)
N#define OS_TRACE_ID_CLEARMB         (31)
N#define OS_TRACE_ID_DELETEMB        (32)
N#define OS_TRACE_ID_PUTMAIL         (33)
N#define OS_TRACE_ID_GETMAIL         (34)
N#define OS_TRACE_ID_PUTMAILCOND     (35)
N#define OS_TRACE_ID_GETMAILCOND     (36)
N#define OS_TRACE_ID_PUTMAIL_TIMED   (37)
N#define OS_TRACE_ID_GETMAIL_TIMED   (38)
N#define OS_TRACE_ID_WAITMAIL        (39)
N
N#define OS_TRACE_ID_PUTMAIL1        (40)
N#define OS_TRACE_ID_GETMAIL1        (41)
N#define OS_TRACE_ID_PUTMAILCOND1    (42)
N#define OS_TRACE_ID_GETMAILCOND1    (43)
N#define OS_TRACE_ID_PUTMAIL_TIMED1  (44)
N#define OS_TRACE_ID_GETMAIL_TIMED1  (45)
N
N#define OS_TRACE_ID_PUTMAIL_F       (46)
N#define OS_TRACE_ID_PUTMAIL_F1      (47)
N#define OS_TRACE_ID_PUTMAIL_FCOND   (48)
N#define OS_TRACE_ID_PUTMAIL_FCOND1  (49)
N
N/* Resource group */
N#define OS_TRACE_ID_CREATERSEMA     (50)
N#define OS_TRACE_ID_USE             (51)
N#define OS_TRACE_ID_UNUSE           (52)
N#define OS_TRACE_ID_REQUEST         (53)
N#define OS_TRACE_ID_GETSEMAVALUE    (54)
N#define OS_TRACE_ID_DELETE_RSEMA    (55)
N
N/* Counting Semaphore group */
N#define OS_TRACE_ID_CREATECSEMA     (60)
N#define OS_TRACE_ID_DELETECSEMA     (61)
N#define OS_TRACE_ID_SIGNALCSEMA     (62)
N#define OS_TRACE_ID_WAITCSEMA       (63)
N#define OS_TRACE_ID_WAITCSEMATIMED  (64)
N#define OS_TRACE_ID_SIGNALCSEMA_MAX (65)
N#define OS_TRACE_ID_SET_CSEMAVALUE  (66)
N#define OS_TRACE_ID_CSEMAREQUEST    (67)
N
N/* Timer group    */
N#define OS_TRACE_ID_CREATETIMER     (70)
N#define OS_TRACE_ID_DELETETIMER     (71)
N#define OS_TRACE_ID_STARTTIMER      (72)
N#define OS_TRACE_ID_STOPTIMER       (73)
N#define OS_TRACE_ID_RETRIGGERTIMER  (74)
N#define OS_TRACE_ID_SETTIMERPERIOD  (75)
N#define OS_TRACE_ID_CREATETIMER_EX  (76)
N
N/* Heap type memory management  */
N#define OS_TRACE_ID_MALLOC          (80)
N#define OS_TRACE_ID_FREE            (81)
N#define OS_TRACE_ID_REALLOC         (82)
N
N/* Fixed block type memory management  */
N#define OS_TRACE_ID_MEMF_CREATE     (90)
N#define OS_TRACE_ID_MEMF_DELETE     (91)
N#define OS_TRACE_ID_MEMF_ALLOC      (92)
N
N
N/*********************************************************************
N*
N*       Assertions
N*
N**********************************************************************
N
N  Assertions are used to generate code in the debug version
N  of the OS in order catch programming faults like
N  bad pointers or uninitialized data structures
N*/
N
N#if OS_DEBUG
X#if 1
N  #define OS_ASSERT(Exp, ErrCode) { if (!(Exp)) OS_Error(ErrCode); }
N#else
S  #define OS_ASSERT(Exp, ErrCode)
N#endif
N
N#define OS_ASSERT_INT()           OS_ASSERT((OS_InInt != 0),          OS_ERR_ILLEGAL_OUT_ISR)
N#define OS_ASSERT_NOINT()         OS_ASSERT((OS_InInt == 0),          OS_ERR_ILLEGAL_IN_ISR)
N#define OS_ASSERT_NOTIMER()       OS_ASSERT((OS_InTimer == 0),        OS_ERR_ILLEGAL_IN_TIMER)
N#define OS_ASSERT_DICnt()         OS_ASSERT(((OS_DICnt & 0xf0) == 0), OS_ERR_DICNT)
N#define OS_ASSERT_INIT_CALLED()   OS_ASSERT((OS_InitCalled != 0),     OS_ERR_INIT_NOT_CALLED)
N
N/*********************************************************************
N*
N*       Memory attributes
N*
N**********************************************************************
N*/
N
N#ifndef OS_STACKPTR
N  #define OS_STACKPTR
N#endif
N
N#ifndef OS_SADDR
N  #ifdef SADDR
S    #define OS_SADDR SADDR
N  #else
N    #define OS_SADDR
N  #endif
N#endif
N
N/* pointer modifier for data items */
N#ifndef OS_DATAPTR
N  #define OS_DATAPTR
N#endif
N
N#ifndef OS_RSEMAPTR
N  #define OS_RSEMAPTR
N#endif
N
N#ifndef   OS_CSEMAPTR
N  #define OS_CSEMAPTR
N#endif
N
N#ifndef   OS_MBPTR
N  #define OS_MBPTR
N#endif
N
N#ifndef   OS_TCBPTR
N  #define OS_TCBPTR
N#endif
N
N#ifndef   OS_TIMERPTR
N  #define OS_TIMERPTR
N#endif
N
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N/*********************************************************************
N*
N*       Data structures
N*
N**********************************************************************
N*/
N
Ntypedef struct OS_TASK         OS_TASK;
Ntypedef struct OS_WAIT_LIST    OS_WAIT_LIST;
Ntypedef struct OS_WAIT_OBJ     OS_WAIT_OBJ;
Ntypedef struct OS_WAIT_OBJ_EX  OS_WAIT_OBJ_EX;
Ntypedef struct OS_REGS         OS_REGS;
N
Ntypedef void voidRoutine(void);
Ntypedef void OS_RX_CALLBACK(OS_U8 Data);
Xtypedef void OS_RX_CALLBACK(unsigned char Data);
Ntypedef void OS_TIMERROUTINE(void);
Ntypedef void OS_TIMER_EX_ROUTINE(void *);
Ntypedef void OS_ON_TERMINATE_FUNC(OS_TASK *);
N
Ntypedef void OS_TICK_HOOK_ROUTINE(void);
N
N/**********************************************************************
N*
N*       OS_WAIT_OBJ
N*       OS_WAIT_LIST
N*       OS_WAIT_OBJ_EX
N*/
Nstruct OS_WAIT_OBJ {
N  OS_WAIT_LIST * pWaitList;
N};
N
Nstruct OS_WAIT_OBJ_EX {
N  OS_WAIT_OBJ WaitObj;
N  int v;
N};
N
Nstruct OS_WAIT_LIST {
N  OS_WAIT_LIST * pNext;    /* Needs to be first element ! */
N  OS_WAIT_LIST * pPrev;
N  OS_WAIT_OBJ  * pWaitObj;
N  OS_TASK      * pTask;
N};
N
N
N/**********************************************************************
N*
N*       OS_EXTEND_TASK_CONTEXT
N*
N*  This structure is used to define a save and restore function for
N*  extension of the task context.
N*  A pointer to this structure is part of the task control block
N*  It is initialized by OS_ExtendTaskContext();
N*/
Ntypedef struct OS_EXTEND_TASK_CONTEXT {
N  void (*pfSave)   (      void * pStack);
N  void (*pfRestore)(const void * pStack);
N} OS_EXTEND_TASK_CONTEXT;
N
N
N/**********************************************************************
N*
N*       OS_TASK
N*
N*  This structure (referred to as "task control block" or TCB) holds all relevant information
N*  about a single task. Note that some elements are optional, depending on the compile time
N*  options, especially the type of build
N*/
Nstruct OS_TASK {
N  //
N  // Elements required for all builds
N  //
N  // Start of assembly relevant section. Do not move these elements
N  OS_TASK * pNext;                        // Points to the TCB of the next task in the list (with equal or lower priority). Needs to be first element !
N  OS_REGS OS_STACKPTR * pStack;           // Typically contains the stack pointer if the task is suspended.                 Needs to be second element !
X  OS_REGS  * pStack;           
N  // End of assembly relevant section
N  OS_WAIT_LIST * pWaitList;               // Points to a waitable object if task is suspended.
N  OS_TIME        Timeout;
X  int        Timeout;
N  OS_U8          Priority;
X  unsigned char          Priority;
N  OS_U8          Stat;
X  unsigned char          Stat;
N  OS_U8          Events;                  // Event storage
X  unsigned char          Events;                  
N  OS_U8          EventMask;               // Event mask
X  unsigned char          EventMask;               
N  //
N  // PPrev is required only in builds with doubly-linked task lists
N  //
N  #if OS_TASK_LIST_HAS_PPREV
X  #if (1)
N    OS_TASK      * pPrev;                   //
N  #endif
N  //
N  // Elements required with "Track-name" functionality only. Typically available in all builds, but can be disabled at compile time
N  //
N  #if OS_TRACKNAME
X  #if (1)
N    const char * Name;
N  #endif
N  //
N  // Elements required with "Stack-check" functionality only. Available in stack-check and debug builds.
N  //
N  #if OS_CHECKSTACK
X  #if 1
N    OS_UINT  StackSize;            // Stack size in bytes. Not required for functionality, just for analysis
X    unsigned int  StackSize;            
N    OS_U8 OS_STACKPTR* pStackBot;  // First byte of stack. Not required for functionality, just for analysis
X    unsigned char * pStackBot;  
N  #endif
N  //
N  // Elements required with profiling or debug builds
N  //
N  #if (OS_PROFILE || OS_DEBUG)
X  #if (1 || 1)
N    OS_U32 NumActivations;         // Counts how many times task has been activated
X    unsigned int NumActivations;         
N    OS_U32 NumPreemptions;         // Counts how many times task has been preempted
X    unsigned int NumPreemptions;         
N  #endif
N  //
N  // Elements required with profiling builds
N  //
N  #if OS_PROFILE
X  #if 1
N    OS_U32 ExecTotal;              // Time spent executing
X    unsigned int ExecTotal;              
N    OS_U32 ExecLast;               // Time spent executing (Reference)
X    unsigned int ExecLast;               
N    OS_U32 Load;                   // Profiling builds only:
X    unsigned int Load;                   
N  #endif
N  //
N  // Elements required with Round-robin functionality only. Typically available in all builds, but can be disabled at compile time
N  //
N  #if OS_RR_SUPPORTED
X  #if (1)
N    OS_U8  TimeSliceRem;
X    unsigned char  TimeSliceRem;
N    OS_U8  TimeSliceReload;
X    unsigned char  TimeSliceReload;
N  #endif
N  //
N  // Optional Save & Restore hook support (usually only for bigger CPUs)
N  //
N  #if OS_SUPPORT_SAVE_RESTORE_HOOK
X  #if (1)
N    const OS_EXTEND_TASK_CONTEXT * pExtendContext;
N  #endif
N  //
N  // Elements required with debug builds
N  //
N  #if OS_DEBUG
X  #if 1
N    char Id;                       // Debug builds only: Id of this control block.
N  #endif
N  //
N  // Allow port specific extension to the task control block. Not used in most ports
N  //
N  #ifdef OS_TCB_CPU_EX
S    OS_TCB_CPU_EX
N  #endif
N};
N
N/**********************************************************************
N*
N*       OS_TIMER
N*/
Ntypedef struct OS_timer OS_TIMER;
Nstruct OS_timer {
N  OS_TIMER * pNext;
N  voidRoutine* Hook;
N  OS_TIME Time;
X  int Time;
N  OS_TIME Period;
X  int Period;
N  char    Active;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_TIMER_EX
N*/
Ntypedef struct {
N  OS_TIMER Timer;
N  OS_TIMER_EX_ROUTINE * pfUser;
N  void * pData;
N} OS_TIMER_EX;
N
N/**********************************************************************
N*
N*       OS_TICK_HOOK
N*/
Ntypedef struct OS_TICK_HOOK OS_TICK_HOOK;
Nstruct OS_TICK_HOOK {
N  OS_TICK_HOOK*          pNext;
N  OS_TICK_HOOK_ROUTINE * pfUser;
N};
N
N/**********************************************************************
N*
N*       OS_RSEMA
N*/
Ntypedef struct OS_RSEMA OS_RSEMA;
Nstruct OS_RSEMA {
N  OS_WAIT_OBJ WaitObj;
N  OS_TASK * pTask;                /* Owner */
N  OS_U8 UseCnt;
X  unsigned char UseCnt;
N  OS_RSEMA * pNext;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_CSEMA
N*/
Ntypedef struct OS_CSEMA OS_CSEMA;
Nstruct OS_CSEMA {
N  OS_WAIT_OBJ WaitObj;
N  OS_UINT Cnt;
X  unsigned int Cnt;
N#if OS_DEBUG
X#if 1
N  OS_CSEMA * pNext;
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_MAILBOX
N*/
Ntypedef struct OS_MAILBOX OS_MAILBOX;
Nstruct OS_MAILBOX {
N  OS_WAIT_OBJ WaitObj;
N#if OS_LINK_MAILBOXES
X#if (1)
N  OS_MAILBOX * pNext;
N#endif
N  char *pData;
N  OS_UINT nofMsg;
X  unsigned int nofMsg;
N  OS_UINT maxMsg;
X  unsigned int maxMsg;
N  OS_UINT iRd;
X  unsigned int iRd;
N  OS_U8  sizeofMsg;
X  unsigned char  sizeofMsg;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_Q
N*/
Ntypedef struct OS_Q OS_Q;
Nstruct OS_Q {
N  OS_WAIT_OBJ WaitObj;
N  OS_Q*    pNext;          /* ptr to next queue (for debugging / monitoring) */
N  OS_U8*   pData;
X  unsigned char*   pData;
N  OS_UINT  Size;
X  unsigned int  Size;
N  OS_UINT  MsgCnt;
X  unsigned int  MsgCnt;
N  OS_UINT  offFirst;
X  unsigned int  offFirst;
N  OS_UINT  offLast;
X  unsigned int  offLast;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_MEMF
N*/
N#ifndef   OS_MEMF_MAX_ITEMS
N  #define OS_MEMF_MAX_ITEMS 20
N#endif
N
N#define OS_MEMF_SIZEOF_BLOCKCONTROL 0  /* sizeof(int) in future version for debugging */
N
Ntypedef struct OS_MEMF OS_MEMF;
Nstruct OS_MEMF {
N  OS_WAIT_OBJ WaitObj;
N  OS_MEMF* pNext;          /* ptr to next memory pool */
N  void*    pPool;
N  OS_U16   NumBlocks;
X  unsigned short   NumBlocks;
N  OS_U16   BlockSize;
X  unsigned short   BlockSize;
N  OS_U16   NumFreeBlocks;
X  unsigned short   NumFreeBlocks;
N  OS_U16   MaxUsed;
X  unsigned short   MaxUsed;
N  void*    pFree;
N  #if OS_DEBUG
X  #if 1
N    int  aiPurpose[OS_MEMF_MAX_ITEMS];
X    int  aiPurpose[20];
N    char Id;
N  #endif
N};
N
N/**********************************************************************
N*
N*       OS_EVENT
N*/
Ntypedef struct  OS_EVENT OS_EVENT;
N
Nstruct OS_EVENT {
N  OS_WAIT_OBJ WaitObj;
N  OS_U8       Signaled;
X  unsigned char       Signaled;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_TRACE_ENTRY
N*/
Ntypedef struct {
N  OS_U32  Time;
X  unsigned int  Time;
N  void    *pCurrentTask;
N  void    *p;
N  OS_U32  v;
X  unsigned int  v;
N  OS_U8   iRout;
X  unsigned char   iRout;
N} OS_TRACE_ENTRY;
N
N
N/*********************************************************************
N*
N*       Globals
N*
N**********************************************************************
N*/
N
N/*
N    Handle DEFinition (storage is actually allocted) versus DEClaration
N    (reference) of RTOS variables depending upon who includes this header file.
N*/
N#ifdef __OSGLOBAL_C__
S  #define OS_EXTERN        /* Declare variables if included by RTOSKERN.C */
S  #define OS_EXTERN_INIT(Var, Val) Var=Val
N#else
N  #define OS_EXTERN extern /* Define variables if included by anyone else */
N  #define OS_EXTERN_INIT(Var, Val) Var
N#endif
N
N/*****  Mark start of memory pragma area ****************************/
N
N/* Some compilers can not deal with memory attributes and need pragmas */
N#if defined(__ghs_zda)
X#if 0L
S  #pragma ghs startzda
N#endif
N
N/********************************************************************/
N
Ntypedef union {
N  int Dummy;            // Make sure a full integer (32 bit on 32 bit CPUs) is used.
N  struct {
N    OS_U8 Region;
X    unsigned char Region;
N    OS_U8 DI;
X    unsigned char DI;
N  } Cnt;
N} OS_COUNTERS;
N
N
N#if OS_COMPILER_STORAGE_MODIFIER_LEFT  /* default */
X#if 1   
N  OS_EXTERN OS_SADDR  volatile OS_I32 OS_Time;
X  extern   volatile int OS_Time;
N  OS_EXTERN OS_SADDR  OS_TIME         OS_EXTERN_INIT(OS_TimeDex, 16384);
X  extern   int         OS_TimeDex;
N  OS_EXTERN OS_SADDR  OS_COUNTERS OS_Counters;
X  extern   OS_COUNTERS OS_Counters;
N
N  OS_EXTERN OS_SADDR  OS_U8  OS_EXTERN_INIT(OS_IntMSInc, 1);
X  extern   unsigned char  OS_IntMSInc;
N  OS_EXTERN OS_SADDR  OS_U8  OS_Pending;
X  extern   unsigned char  OS_Pending;
N  OS_EXTERN OS_SADDR  volatile OS_U8  OS_Status;
X  extern   volatile unsigned char  OS_Status;
N
N  #if OS_RR_SUPPORTED
X  #if (1)
N    OS_EXTERN OS_SADDR  OS_U8  OS_TimeSlice;
X    extern   unsigned char  OS_TimeSlice;
N    OS_EXTERN OS_SADDR  OS_U8  OS_TimeSliceAtStart;
X    extern   unsigned char  OS_TimeSliceAtStart;
N  #endif
N  #if OS_SUPPORT_TICKSTEP
X  #if 1
N    OS_EXTERN OS_SADDR  volatile OS_U8   OS_TickStep;
X    extern   volatile unsigned char   OS_TickStep;
N    OS_EXTERN OS_SADDR  volatile int     OS_TickStepTime;
X    extern   volatile int     OS_TickStepTime;
N  #endif
N  OS_EXTERN OS_SADDR        OS_UINT OS_TicksPerMS;
X  extern         unsigned int OS_TicksPerMS;
N  OS_EXTERN OS_SADDR        int     OS_IntTicksInc;
X  extern         int     OS_IntTicksInc;
N  #if OS_PROFILE
X  #if 1
N    OS_EXTERN OS_SADDR OS_U32 OS_TS_ExecStart;
X    extern  unsigned int OS_TS_ExecStart;
N    OS_EXTERN OS_SADDR OS_U8  ProfilingOn;
X    extern  unsigned char  ProfilingOn;
N  #endif
N  #if OS_DEBUG
X  #if 1
N    OS_EXTERN OS_SADDR OS_U8 OS_InInt;
X    extern  unsigned char OS_InInt;
N    OS_EXTERN OS_SADDR OS_U8 OS_InTimer;
X    extern  unsigned char OS_InTimer;
N    OS_EXTERN OS_SADDR OS_U8 OS_InitCalled;
X    extern  unsigned char OS_InitCalled;
N  #endif
N
N  #if OS_SUPPORT_POWER
X  #if (1)
N    OS_EXTERN OS_SADDR OS_U8 OS_POWER_Levels[OS_POWER_NUM_COUNTERS];
X    extern  unsigned char OS_POWER_Levels[(5)];
N  #endif
N
N  /*** Pointers ***
N    Unfortunately there is no real standard on how to define/declare
N    pointers properly with extended memory attributes. There are
N    currently 2 different standards, which we both support.
N  */
N  #if OS_COMPILER_LOCATION_LEFT
X  #if 1
N    OS_EXTERN OS_SADDR  OS_TASK      * OS_pTask;             /* linked list of all Tasks */
X    extern   OS_TASK      * OS_pTask;              
N    OS_EXTERN OS_SADDR  OS_TASK      * OS_pCurrentTask;      /* pointer to current Task */
X    extern   OS_TASK      * OS_pCurrentTask;       
N    OS_EXTERN OS_SADDR  OS_TASK volatile * volatile OS_pActiveTask;
X    extern   OS_TASK volatile * volatile OS_pActiveTask;
N    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pTimer;            /* linked list of all active Timers */
X    extern   OS_TIMER     * OS_pTimer;             
N    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pCurrentTimer;     /* Actual expired timer which called callback */
X    extern   OS_TIMER     * OS_pCurrentTimer;      
N    OS_EXTERN OS_SADDR OS_RSEMA      * OS_pRSema;
X    extern  OS_RSEMA      * OS_pRSema;
N    #if OS_LINK_MAILBOXES
X    #if (1)
N      OS_EXTERN OS_SADDR OS_MAILBOX  * OS_pMailbox;
X      extern  OS_MAILBOX  * OS_pMailbox;
N    #endif
N    #if OS_DEBUG
X    #if 1
N      OS_EXTERN OS_SADDR OS_CSEMA    * OS_pCSema;
X      extern  OS_CSEMA    * OS_pCSema;
N    #endif
N    OS_EXTERN   OS_SADDR OS_MEMF      * OS_pMEMF;            /* linked list of all fixed size memory pools */
X    extern    OS_MEMF      * OS_pMEMF;             
N    OS_EXTERN   OS_SADDR OS_TICK_HOOK * OS_pTickHook;        /* linked list of all tick hook functions */
X    extern    OS_TICK_HOOK * OS_pTickHook;         
N  #else
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pTask;          /* linked list of all Tasks */
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pCurrentTask;   /* pointer to current Task */
S    OS_EXTERN OS_TASK    volatile * OS_SADDR volatile OS_pActiveTask;
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pTimer;         /* linked list of all active Timers */
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pCurrentTimer;  /* Actual expired timer which called callback */
S    OS_EXTERN OS_RSEMA            * OS_SADDR OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_MAILBOX        * OS_SADDR OS_pMailbox;
S    #endif
S
S    #if OS_DEBUG
S      OS_EXTERN  OS_CSEMA         * OS_SADDR OS_pCSema;
S    #endif
S    OS_EXTERN OS_MEMF             * OS_SADDR OS_pMEMF;          /* linked list of all fixed size memory pools */
S    OS_EXTERN OS_TICK_HOOK        * OS_SADDR OS_pTickHook;      /* linked list of all tick hook functions */
N  #endif
N
N#else  /*  OS_COMPILER_STORAGE_MODIFIER_LEFT == 0, needed for Keil 166 */
S  OS_EXTERN volatile OS_I32 OS_SADDR OS_Time;
S  OS_EXTERN OS_TIME         OS_SADDR OS_EXTERN_INIT(OS_TimeDex, 16384);
S  OS_EXTERN OS_COUNTERS OS_SADDR OS_Counters;
S
S  OS_EXTERN OS_U8 OS_SADDR OS_EXTERN_INIT(OS_IntMSInc, 1);
S  OS_EXTERN OS_U8 OS_SADDR OS_Pending;
S  OS_EXTERN volatile OS_U8 OS_SADDR OS_Status;
S  #if OS_RR_SUPPORTED
S    OS_EXTERN OS_U8 OS_SADDR OS_TimeSlice;
S    OS_EXTERN OS_U8 OS_SADDR OS_TimeSliceAtStart;
S  #endif
S  #if OS_SUPPORT_TICKSTEP
S    OS_EXTERN volatile OS_U8 OS_SADDR OS_TickStep;
S    OS_EXTERN volatile int   OS_SADDR OS_TickStepTime;
S  #endif
S  OS_EXTERN OS_UINT OS_SADDR OS_TicksPerMS;
S  OS_EXTERN int     OS_SADDR OS_IntTicksInc;
S  #if OS_PROFILE
S    OS_EXTERN OS_U32 OS_SADDR OS_TS_ExecStart;
S    OS_EXTERN OS_U8  OS_SADDR ProfilingOn;
S  #endif
S  #if OS_DEBUG
S    OS_EXTERN OS_U8 OS_SADDR OS_InInt;
S    OS_EXTERN OS_U8 OS_SADDR OS_InTimer;
S    OS_EXTERN OS_U8 OS_SADDR OS_InitCalled;
S  #endif
S
S  #if OS_SUPPORT_POWER
S    OS_EXTERN OS_U8 OS_SADDR OS_POWER_Levels[OS_POWER_NUM_COUNTERS];
S  #endif
S
S  /*** Pointers ***
S    Unfortunately there is no real standard on how to define/declare
S    pointers properly with extended memory attributes. There are
S    currently 2 different standards, which we both support.
S  */
S  #if OS_COMPILER_LOCATION_LEFT
S    OS_EXTERN OS_SADDR  OS_TASK      * OS_pTask;             /* linked list of all Tasks */
S    OS_EXTERN OS_SADDR  OS_TASK      * OS_pCurrentTask;      /* pointer to current Task */
S    OS_EXTERN OS_SADDR  OS_TASK volatile * volatile OS_pActiveTask;
S    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pTimer;            /* linked list of all active Timers */
S    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pCurrentTimer;     /* Actual expired timer which called callback */
S    OS_EXTERN OS_SADDR OS_RSEMA      * OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_SADDR OS_MAILBOX  * OS_pMailbox;
S    #endif
S    #if OS_DEBUG
S      OS_EXTERN OS_SADDR OS_CSEMA    * OS_pCSema;
S    #endif
S      OS_EXTERN OS_SADDR OS_MEMF      * OS_pMEMF;            /* linked list of all fixed size memory pools */
S      OS_EXTERN OS_SADDR OS_TICK_HOOK * OS_pTickHook;        /* linked list of all tick hook functions */
S
S  #else
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pTask;          /* linked list of all Tasks */
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pCurrentTask;   /* pointer to current Task */
S    OS_EXTERN OS_TASK    volatile * volatile OS_SADDR OS_pActiveTask;
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pTimer;         /* linked list of all active Timers */
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pCurrentTimer;  /* Actual expired timer which called callback */
S    OS_EXTERN OS_RSEMA            * OS_SADDR OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_MAILBOX        * OS_SADDR OS_pMailbox;
S    #endif
S    #if OS_DEBUG
S      OS_EXTERN OS_CSEMA          * OS_SADDR OS_pCSema;
S    #endif
S
S    OS_EXTERN OS_MEMF             * OS_SADDR OS_pMEMF;          /* linked list of all fixed size memory pools */
S    OS_EXTERN OS_TICK_HOOK        * OS_SADDR OS_pTickHook;      /* linked list of all tick hook functions */
S  #endif
S
N#endif  /*  OS_COMPILER_STORAGE_MODIFIER_LEFT  */
N
N/***** Mark end of memory pragma area *******************************/
N#if defined(__ghs_zda)
X#if 0L
S  #pragma ghs endzda
N#endif
N
N/********************************************************************/
N
N#define OS_RegionCnt OS_Counters.Cnt.Region
N#define OS_DICnt     OS_Counters.Cnt.DI
N
N/*********************************************************************
N*
N*       OS_CREATETASK macro
N*       OS_CREATETASK_EX macro
N*/
N#if OS_RR_SUPPORTED
X#if (1)
N  #define CTPARA_TIMESLICE ,2
N#else
S  #define CTPARA_TIMESLICE
N#endif
N
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack) \
N  OS_CreateTask (pTask,                                      \
N                  Name,                                      \
N                  Priority,                                  \
N                  Hook,                                      \
N                  (void OS_STACKPTR*)pStack,                 \
N                  sizeof(pStack)                             \
N                  CTPARA_TIMESLICE                           \
N               )
X  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack)   OS_CreateTask (pTask,                                                        Name,                                                        Priority,                                                    Hook,                                                        (void OS_STACKPTR*)pStack,                                   sizeof(pStack)                                               CTPARA_TIMESLICE                                          )
N#else
S  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack) \
S  OS_CreateTask (pTask,                                      \
S                  Priority,                                  \
S                  Hook,                                      \
S                  (void OS_STACKPTR*)pStack,                 \
S                  sizeof(pStack)                             \
S                  CTPARA_TIMESLICE                           \
S               )
X  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack)   OS_CreateTask (pTask,                                                        Priority,                                                    Hook,                                                        (void OS_STACKPTR*)pStack,                                   sizeof(pStack)                                               CTPARA_TIMESLICE                                          )
N#endif
N
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext) \
N  OS_CreateTaskEx  (pTask,                                                \
N                    Name,                                                 \
N                    Priority,                                             \
N                    Hook,                                                 \
N                    (void OS_STACKPTR*)pStack,                            \
N                    sizeof(pStack)                                        \
N                    CTPARA_TIMESLICE,                                     \
N                    pContext                                              \
N               )
X  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext)   OS_CreateTaskEx  (pTask,                                                                    Name,                                                                     Priority,                                                                 Hook,                                                                     (void OS_STACKPTR*)pStack,                                                sizeof(pStack)                                                            CTPARA_TIMESLICE,                                                         pContext                                                             )
N#else
S  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext) \
S  OS_CreateTaskEx  (pTask,                                                \
S                    Priority,                                             \
S                    Hook,                                                 \
S                    (void OS_STACKPTR*)pStack,                            \
S                    sizeof(pStack)                                        \
S                    CTPARA_TIMESLICE,                                     \
S                    pContext                                              \
S               )
X  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext)   OS_CreateTaskEx  (pTask,                                                                    Priority,                                                                 Hook,                                                                     (void OS_STACKPTR*)pStack,                                                sizeof(pStack)                                                            CTPARA_TIMESLICE,                                                         pContext                                                             )
N#endif
N
N/*********************************************************************
N*
N*       OS_CreateTask
N*       OS_CreateTaskEx
N*/
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATE_TASK_PARA_NAME      const char*Name,
N#else
S  #define OS_CREATE_TASK_PARA_NAME
N#endif
N
N#if OS_RR_SUPPORTED
X#if (1)
N  #define OS_CREATE_TASK_PARA_TS   ,OS_UINT TimeSlice
N#else
S  #define OS_CREATE_TASK_PARA_TS
N#endif
N
Nvoid OS_CreateTask  ( OS_TASK * pTask,
Xvoid OS_CreateTask_DP  ( OS_TASK * pTask,
N                      OS_CREATE_TASK_PARA_NAME
X                      const char*Name,
N                      OS_U8 Priority,
X                      unsigned char Priority,
N                      void (*pRoutine)(void),
N                      void OS_STACKPTR *pStack,
X                      void  *pStack,
N                      OS_UINT StackSize
X                      unsigned int StackSize
N                      OS_CREATE_TASK_PARA_TS
X                      ,unsigned int TimeSlice
N        );
Nvoid OS_CreateTaskEx  ( OS_TASK * pTask,
Xvoid OS_CreateTaskEx_DP  ( OS_TASK * pTask,
N                        OS_CREATE_TASK_PARA_NAME
X                        const char*Name,
N                        OS_U8 Priority,
X                        unsigned char Priority,
N                        void (*pRoutine)(void *),
N                        void OS_STACKPTR *pStack,
X                        void  *pStack,
N                        OS_UINT StackSize
X                        unsigned int StackSize
N                        OS_CREATE_TASK_PARA_TS,
X                        ,unsigned int TimeSlice,
N                        void * pContext
N        );
N#if OS_SUPPORT_SAVE_RESTORE_HOOK
X#if (1)
Nvoid OS_ExtendTaskContext(const OS_EXTEND_TASK_CONTEXT * pExtendContext);
N#endif
N/*********************************************************************
N*
N*       Task related routines
N*
N**********************************************************************
N*/
N
Nvoid  OS_Delay(OS_TIME ms);                /* OSKern.c              */
Xvoid  OS_Delay(int ms);                 
Nvoid  OS_DelayUntil(OS_TIME t);            /* OSKern.c              */
Xvoid  OS_DelayUntil(int t);             
NOS_U8 OS_GetSuspendCnt  (OS_TASK* pTask);  /* OS_GetSuspendCnt.c    */
Xunsigned char OS_GetSuspendCnt  (OS_TASK* pTask);   
Nvoid  OS_GetState       (OS_TASK* pTask);
Nchar  OS_IsTask         (OS_TASK* pTask);  /* OSIsTask.c            */
Nvoid  OS_Resume         (OS_TASK* pTask);  /* OS_Suspend.c          */
Nvoid  OS_SetTaskName    (OS_TASK * pTask, const char* s);
Nvoid  OS_SetPriority    (OS_TASK* pTask, OS_U8 Prio); /* OSSetP.c   */
Xvoid  OS_SetPriority    (OS_TASK* pTask, unsigned char Prio);  
Nvoid  OS_Suspend        (OS_TASK* pTask);  /* OS_Suspend.c          */
Nvoid  OS_Terminate      (OS_TASK* pTask);  /* OSTerm.c              */
Nvoid  OS_TerminateError (void);            /* OSTermE.c             */
Nvoid  OS_WakeTask       (OS_TASK* pTask);  /* OSWake.c              */
Nvoid  OS_Yield          (void);            /* OS_Yield              */
N
N#if OS_SUSPEND_TASK_ON_TERMINATE           /* Set task state of a terminated task to "suspended" */
X#if (0)            
S  #define OS_SUSPEND_TERMINATED_TASK(pTask) (pTask->Stat = 0x01)
N#else
N  #define OS_SUSPEND_TERMINATED_TASK(pTask)
N#endif
N
N/*********************************************************************
N*
N*       Info routines (OSInfo.c)
N*
N**********************************************************************
N*/
N
Nconst char* OS_GetCPU(void);
Nconst char* OS_GetLibMode(void);
Nconst char* OS_GetModel(void);
Nconst char* OS_GetLibName(void);
N
NOS_UINT OS_GetVersion(void);
Xunsigned int OS_GetVersion(void);
N#define OS_GetType() OS_GetLibMode()
N
N#define OS_TASKID OS_TASK *
N#define OS_GetTaskID() OS_pCurrentTask
N
N#define OS_GetpCurrentTask()    OS_pCurrentTask
N#define OS_GetpCurrentTimer()   OS_pCurrentTimer
N#define OS_GetpCurrentTimerEx() ((OS_TIMER_EX*)OS_pCurrentTimer)
N
N#if OS_TRACKNAME
X#if (1)
N  const char* OS_GetTaskName(OS_TASK *);
N#else
S  #define OS_GetTaskName(pt)  ("n/a")
N#endif
N
N#if OS_CHECKSTACK
X#if 1
N  void OS_CheckStack(void);              /* internal usage */
N  int  OS_GetStackSpace(OS_TASK * pTask);
N  int  OS_GetStackUsed (OS_TASK * pTask);
N  int  OS_GetStackSize (OS_TASK OS_TCBPTR * pTask);
X  int  OS_GetStackSize (OS_TASK  * pTask);
N  void OS_STACKPTR* OS_GetStackBase(OS_TASK OS_TCBPTR *pTask);
X  void * OS_GetStackBase(OS_TASK  *pTask);
N#else
S  #define OS_CheckStack()
S  #define OS_GetStackSpace(pt) 0
S  #define OS_GetStackUsed(pt)  0
S  #define OS_GetStackSize(pt)  0
S  #define OS_GetStackBase(pt)  0
N#endif
N
NOS_STACK_ADR OS_GetSysStackBase(void);  /* RTOS asm part */
Xunsigned int OS_GetSysStackBase(void);   
Nunsigned int OS_GetSysStackSize(void);  /* RTOS asm part */
NOS_STACK_ADR OS_GetIntStackBase(void);  /* RTOS asm part */
Xunsigned int OS_GetIntStackBase(void);   
Nunsigned int OS_GetIntStackSize(void);  /* RTOS asm part */
N
N#if OS_RR_SUPPORTED
X#if (1)
N  OS_U8 OS_SetTimeSlice(OS_TASK * pTask, OS_U8 TimeSlice);
X  unsigned char OS_SetTimeSlice(OS_TASK * pTask, unsigned char TimeSlice);
N  OS_U8 OS_GetTimeSliceRem(OS_TASK OS_TCBPTR * pTask);
X  unsigned char OS_GetTimeSliceRem(OS_TASK  * pTask);
N  #define OS_GetTimeSliceReload(pTask)  pTask->TimeSliceReload
N#else
S  #define OS_GetTimeSliceRem(pTask)     0
S  #define OS_GetTimeSliceReload(pTask)  0
N#endif
N
NOS_U8    OS_GetPriority(OS_TASK * pTask);  /* OS_GetPrio.c       */
Xunsigned char    OS_GetPriority(OS_TASK * pTask);   
N#define OS_GET_PRIORITY(pt) pt->Priority
N
Nint     OS_GetNumTasks(void);              /* OS_GetNumTasks.c   */
N
NOS_TASK* OS_TaskIndex2Ptr(int TaskIndex);  /* OS_TaskIndex2Ptr.c */
N
N#if OS_PROFILE >=1
X#if 1 >=1
N  OS_U32 OS_STAT_GetExecTime_Cycles (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetExecTime_Cycles (OS_TASK *pTask);   
N  int    OS_STAT_GetLoad            (OS_TASK *pTask);  /* OSStatGL.c */
N  void   OS_STAT_NotifyReadyStart   (OS_TASK *pTask);  /* OSStat.c   */
N  void   OS_STAT_Sample(void);                         /* OSStat.c   */
N#else
S  #define OS_STAT_NotifyExecEnd()
S  #define OS_STAT_GetExecTime_Cycles(pTask)   0
S  #define OS_STAT_GetLoad(pTask)              0
S  #define OS_STAT_Sample()
S  #define OS_STAT_SetClocksPerUnit(ClocksPerUnit)
S  #define OS_STAT_NOTIFYREADYSTART(pTask)
N#endif
N
N
N#if ((OS_PROFILE >= 1) || (OS_DEBUG > 0))  /* Also available in Debug build since V3.32b */
X#if ((1 >= 1) || (1 > 0))   
N  OS_U32 OS_STAT_GetNumActivations  (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetNumActivations  (OS_TASK *pTask);   
N  OS_U32 OS_STAT_GetNumPreemptions  (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetNumPreemptions  (OS_TASK *pTask);   
N#else
S  #define OS_STAT_GetNumActivations(pTask)    0
S  #define OS_STAT_GetNumPreemptions(pTask)    0
N#endif
N
N/*********************************************************************
N*
N*       Size info routines (OS_GetSize.c)
N*
N**********************************************************************
N*/
N
Nint OS_WAIT_OBJ_GetSize(void);
Nint OS_WAIT_OBJ_EX_GetSize(void);
Nint OS_WAIT_LIST_GetSize(void);
Nint OS_EXTEND_TASK_CONTEXT_GetSize(void);
Nint OS_TASK_GetSize(void);
Nint OS_REGS_GetSize(void);
Nint OS_TIMER_GetSize(void);
Nint OS_TIMER_EX_GetSize(void);
Nint OS_TICK_HOOK_GetSize(void);
Nint OS_RSEMA_GetSize(void);
Nint OS_CSEMA_GetSize(void);
Nint OS_MAILBOX_GetSize(void);
Nint OS_Q_GetSize(void);
Nint OS_MEMF_GetSize(void);
Nint OS_EVENT_GetSize(void);
Nint OS_TRACE_ENTRY_GetSize(void);
N
N/*********************************************************************
N*
N*       Critical regions (OsKern.c)
N*
N**********************************************************************
N*/
N
N#define OS_EnterRegion() {OS_RegionCnt++; }
Nvoid OS_LeaveRegion(void);
N
N/* Macro for OS_Leaveregion.
N   Main purposes:
N   - Used in OS-Kernel
N   - Offers the high speed variant (macro) instead of the function call
N*/
N
N#define OS_LEAVEREGION_STD()        \
N  if (--OS_RegionCnt == 0) {        \
N    OS_DI();                        \
N    if (OS_Pending) {               \
N      OS_RegionCnt = 1;             \
N      OS_Switch();                  \
N      OS_RegionCnt = 0;             \
N    }                               \
N    OS_RESTORE_I();                 \
N  }
X#define OS_LEAVEREGION_STD()          if (--OS_RegionCnt == 0) {            OS_DI();                            if (OS_Pending) {                     OS_RegionCnt = 1;                   OS_Switch();                        OS_RegionCnt = 0;                 }                                   OS_RESTORE_I();                   }
N
N#if OS_DEBUG
X#if 1
N #define OS_LEAVEREGION() \
N   if (!OS_RegionCnt) OS_Error(OS_ERR_LEAVEREGION_BEFORE_ENTERREGION); \
N   OS_LEAVEREGION_STD()
X #define OS_LEAVEREGION()    if (!OS_RegionCnt) OS_Error(OS_ERR_LEAVEREGION_BEFORE_ENTERREGION);    OS_LEAVEREGION_STD()
N#else
S  #define OS_LEAVEREGION()  OS_LEAVEREGION_STD()
N#endif
N
N/*********************************************************************
N*
N*       Interrupt save/disable/restore macros
N*
N**********************************************************************
N*/
N#define OS_IncDI()       { OS_ASSERT_DICnt(); OS_DI(); OS_DICnt++; }
N#define OS_DecRI()       { OS_ASSERT_DICnt(); if (--OS_DICnt==0) OS_EI(); }
N#define OS_RESTORE_I()   { OS_ASSERT_DICnt(); if (OS_DICnt==0)   OS_EI(); }
N
Nvoid OS_RestoreI(void);  /* OS_Kern.c */
N
N/*********************************************************************
N*
N*       ISR (Interrupt service routine) support
N*
N**********************************************************************
N*/
N
N#define RTOS_PPENDING           (1)     /*      Preemption  pending */
N#define RTOS_TSPENDING          (2)     /*      Task switch pending */
N#define RTOS_RRPENDING          (4)     /*      Round robin pending */
N
N
N#ifndef   OS_SUPPORT_INT_PRIORITY
S  #define OS_SUPPORT_INT_PRIORITY (1)
N#endif
N
N#if OS_SUPPORT_INT_PRIORITY
X#if (0)
S  #ifndef   OS_IPL_EI_DEFAULT
S    #error "Please define OS_IPL_EI_DEFAULT (OSChip.h)"
S  #endif
S
S  #ifndef   OS_IPL_DI_DEFAULT
S    #error "Please define OS_IPL_DI_DEFAULT (OSChip.h)"
S  #endif
S
S  #if OS_COMPILER_STORAGE_MODIFIER_LEFT
S    OS_EXTERN OS_SADDR unsigned int  OS_EXTERN_INIT(OS_Ipl_EI, OS_IPL_EI_DEFAULT);
S    OS_EXTERN OS_SADDR unsigned int  OS_EXTERN_INIT(OS_Ipl_DI, OS_IPL_DI_DEFAULT);
S  #else
S    OS_EXTERN unsigned int OS_SADDR  OS_EXTERN_INIT(OS_Ipl_EI, OS_IPL_EI_DEFAULT);
S    OS_EXTERN unsigned int OS_SADDR  OS_EXTERN_INIT(OS_Ipl_DI, OS_IPL_DI_DEFAULT);
S  #endif
N#endif
N
N#if OS_DEBUG
X#if 1
N  #define OS_MARK_IN_ISR()         {OS_InInt++;}
N  #define OS_MARK_OUTOF_ISR()      {if (!OS_InInt--) OS_Error(OS_ERR_LEAVEINT);}
N#else
S  #define OS_MARK_IN_ISR()
S  #define OS_MARK_OUTOF_ISR()
N#endif
N
N#if OS_SUPPORT_CALL_ISR            // Not allowed for some CPUs
X#if (1)            
Nvoid OS_CallISR        (void (*pRoutine)(void));
Nvoid OS_CallNestableISR(void (*pRoutine)(void));
N#endif
N
N#if (OS_SWITCH_FROM_INT_MODIFIES_STACK == 0) && (OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY != 0) && (OS_SCHEDULER_ACTIVATED_BY_EXCEPTION == 0)
X#if ((1) == 0) && ((0) != 0) && ((0) == 0)
S  //
S  // FOR CPUs without separate interrupt stack which do not disable interrupts on entry,
S  // OS_Enter- / Leave- Interrupt() is not defined.
S  // OS_CallISR() has to be used
S  //
N#else
N
N  #ifndef   OS_ENABLE_INTS_SAVE_IPL
N    #define OS_ENABLE_INTS_SAVE_IPL() OS_EI()
N  #endif
N
N  #ifndef   OS_RESTORE_IPL
N    #define OS_RESTORE_IPL()
N  #endif
N
N  #ifndef   OS_EI_ON_LEAVE
N    #define OS_EI_ON_LEAVE()        // Required for CPUs with do not restore DI-flag by RETI. Currently only CM3.
N  #endif
N
N  #if OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY
X  #if (0)
S    #define OS_DI_ON_ENTRY() OS_DI()
N  #else
N    #define OS_DI_ON_ENTRY()
N  #endif
N
N  #if OS_SWITCH_FROM_INT_MODIFIES_STACK
X  #if (1)
N    #define OS_HANDLE_REGION_CNT_ON_LI()                                          \
N      else {                                                                      \
N        OS_RegionCnt--;                                                           \
N      }
X    #define OS_HANDLE_REGION_CNT_ON_LI()                                                else {                                                                              OS_RegionCnt--;                                                                 }
N  #else
S    #define OS_HANDLE_REGION_CNT_ON_LI()                                          \
S      OS_RegionCnt--;
X    #define OS_HANDLE_REGION_CNT_ON_LI()                                                OS_RegionCnt--;
N  #endif
N
N
N  #define OS_SWITCH_FROM_INT_IF_REQUIRED()                                      \
N    if ((OS_RegionCnt == 1) && OS_Pending) {                                    \
N      OS_SwitchFromInt();                                                       \
N    }
X  #define OS_SWITCH_FROM_INT_IF_REQUIRED()                                          if ((OS_RegionCnt == 1) && OS_Pending) {                                          OS_SwitchFromInt();                                                           }
N
N  #define OS_EnterInterrupt() { \
N    OS_DI_ON_ENTRY();           \
N    OS_MARK_IN_ISR();           \
N    OS_RegionCnt++;             \
N    OS_DICnt++;                 \
N  }
X  #define OS_EnterInterrupt() {     OS_DI_ON_ENTRY();               OS_MARK_IN_ISR();               OS_RegionCnt++;                 OS_DICnt++;                   }
N
N  #define OS_LeaveInterrupt() {                                                 \
N    OS_MARK_OUTOF_ISR();                                                        \
N    OS_DICnt--; /* Must have been zero initially ! (We could put =0 instead) */ \
N    OS_SWITCH_FROM_INT_IF_REQUIRED()                                            \
N    OS_HANDLE_REGION_CNT_ON_LI();                                               \
N    OS_EI_ON_LEAVE();                                                           \
N  }
X  #define OS_LeaveInterrupt() {                                                     OS_MARK_OUTOF_ISR();                                                            OS_DICnt--;       OS_SWITCH_FROM_INT_IF_REQUIRED()                                                OS_HANDLE_REGION_CNT_ON_LI();                                                   OS_EI_ON_LEAVE();                                                             }
N
N  #define OS_LeaveInterruptNoSwitch() { \
N    OS_MARK_OUTOF_ISR();                \
N    OS_DICnt--;                         \
N    OS_RegionCnt--;                     \
N    OS_EI_ON_LEAVE();                   \
N  }
X  #define OS_LeaveInterruptNoSwitch() {     OS_MARK_OUTOF_ISR();                    OS_DICnt--;                             OS_RegionCnt--;                         OS_EI_ON_LEAVE();                     }
N
N  #define OS_EnterNestableInterrupt() { \
N    OS_MARK_IN_ISR();                   \
N    OS_RegionCnt++;                     \
N    OS_ENABLE_INTS_SAVE_IPL();          \
N  }
X  #define OS_EnterNestableInterrupt() {     OS_MARK_IN_ISR();                       OS_RegionCnt++;                         OS_ENABLE_INTS_SAVE_IPL();            }
N
N  #define OS_LeaveNestableInterrupt() {                                         \
N    OS_DI();                                                                    \
N    OS_MARK_OUTOF_ISR();                                                        \
N    OS_SWITCH_FROM_INT_IF_REQUIRED()                                            \
N    OS_HANDLE_REGION_CNT_ON_LI();                                               \
N    OS_RESTORE_IPL();                                                           \
N    OS_EI_ON_LEAVE();                                                           \
N  }
X  #define OS_LeaveNestableInterrupt() {                                             OS_DI();                                                                        OS_MARK_OUTOF_ISR();                                                            OS_SWITCH_FROM_INT_IF_REQUIRED()                                                OS_HANDLE_REGION_CNT_ON_LI();                                                   OS_RESTORE_IPL();                                                               OS_EI_ON_LEAVE();                                                             }
N
N  #define OS_LeaveNestableInterruptNoSwitch() { \
N    OS_DI();                                    \
N    OS_MARK_OUTOF_ISR();                        \
N    OS_RegionCnt--;                             \
N    OS_RESTORE_IPL();                           \
N    OS_EI_ON_LEAVE();                           \
N  }
X  #define OS_LeaveNestableInterruptNoSwitch() {     OS_DI();                                        OS_MARK_OUTOF_ISR();                            OS_RegionCnt--;                                 OS_RESTORE_IPL();                               OS_EI_ON_LEAVE();                             }
N#endif
N
N#ifndef OS_EnterIntStack
S  void OS__EnterIntStack(void);
S  #define OS_EnterIntStack() {OS_DI(); OS__EnterIntStack(); OS_RESTORE_I(); }
N#endif
N
N#ifndef OS_LeaveIntStack
S  void OS__LeaveIntStack(void);
S  #define OS_LeaveIntStack() {OS_DI(); OS__LeaveIntStack(); }
N#endif
N
Nvoid OS_SetFastIntPriorityLimit(OS_UINT Priority);
Xvoid OS_SetFastIntPriorityLimit(unsigned int Priority);
N
N/*********************************************************************
N*
N*       Resource semaphores
N*
N**********************************************************************
N*/
N
Nint      OS_Use             (OS_RSEMA * pRSema); /* OSRsem.c   */
Nvoid     OS_Unuse           (OS_RSEMA * pRSema); /* OSRsem.c   */
Nchar     OS_Request         (OS_RSEMA * pRSema); /* OSRsemRQ.c */
Nint      OS_GetSemaValue    (OS_RSEMA * pRSema); /* OSRSemGV.c */
NOS_TASK* OS_GetResourceOwner(OS_RSEMA * pRSema); /* OSRsemGO.c */
N
Nvoid     OS_CreateRSema     (OS_RSEMA * pRSema); /* OSRsem.c   */
Nvoid     OS_DeleteRSema     (OS_RSEMA * pRSema); /* OSDelRS.c  */
N
N#define  OS_CREATERSEMA(ps) OS_CreateRSema(ps)
N
N/*********************************************************************
N*
N*       Counting semaphores
N*
N**********************************************************************
N*/
N
Nvoid  OS_CreateCSema    (OS_CSEMA * pCSema, OS_UINT InitValue);  /* OSCSEM.c             */
Xvoid  OS_CreateCSema    (OS_CSEMA * pCSema, unsigned int InitValue);   
Nvoid  OS_DeleteCSema    (OS_CSEMA * pCSema);                     /* OSDELCS.c            */
Nint   OS_GetCSemaValue  (OS_CSEMA * pCSema);                     /* OSCSEMGV.c           */
NOS_U8 OS_SetCSemaValue  (OS_CSEMA * pCSema, OS_UINT value);      /* OS_SetCSemaValue.c   */
Xunsigned char OS_SetCSemaValue  (OS_CSEMA * pCSema, unsigned int value);       
Nvoid  OS_SignalCSema    (OS_CSEMA * pCSema);                     /* OSCSEM.c             */
Nvoid  OS_SignalCSemaMax (OS_CSEMA * pCSema, OS_UINT MaxValue);   /* OS_CSEMA_SignalMax.c */
Xvoid  OS_SignalCSemaMax (OS_CSEMA * pCSema, unsigned int MaxValue);    
Nvoid  OS_WaitCSema      (OS_CSEMA * pCSema);                     /* OSCSEM.c             */
Nint   OS_WaitCSemaTimed (OS_CSEMA * pCSema, OS_TIME TimeOut);    /* OSCSEMT.c            */
Xint   OS_WaitCSemaTimed (OS_CSEMA * pCSema, int TimeOut);     
Nchar  OS_CSemaRequest   (OS_CSEMA * pCSema);                     /* OSCSEMRQ.c           */
N
N#define OS_CREATECSEMA(ps) OS_CreateCSema(ps,0)
N
N/*********************************************************************
N*
N*       Mailboxes
N*
N**********************************************************************
N*/
N#define CREATEMB(MAILBOX, size, max, Buffer) OS_CreateMB(MAILBOX,size, max, Buffer);
Nvoid OS_CreateMB          (OS_MAILBOX * pMB, OS_U8 sizeofMsg, OS_UINT maxnofMsg, void* Buffer);    /* initialize mailbox */
Xvoid OS_CreateMB          (OS_MAILBOX * pMB, unsigned char sizeofMsg, unsigned int maxnofMsg, void* Buffer);     
Nvoid OS_ClearMB           (OS_MAILBOX * pMB);
Nvoid OS_PutMail           (OS_MAILBOX * pMB, void* pMail);
Nchar OS_PutMailCond       (OS_MAILBOX * pMB, void* pMail);
Nvoid OS_PutMailFront      (OS_MAILBOX * pMB, void* pMail);
Nchar OS_PutMailFrontCond  (OS_MAILBOX * pMB, void* pMail);
Nvoid OS_GetMail           (OS_MAILBOX * pMB, void* pDest);
Nchar OS_GetMailCond       (OS_MAILBOX * pMB, void* pDest);
Nvoid OS_PutMail1          (OS_MAILBOX * pMB, const char* pMail);
Nchar OS_PutMailCond1      (OS_MAILBOX * pMB, const char* pMail);
Nvoid OS_PutMailFront1     (OS_MAILBOX * pMB, const char* pMail);
Nchar OS_PutMailFrontCond1 (OS_MAILBOX * pMB, const char* pMail);
Nvoid OS_GetMail1          (OS_MAILBOX * pMB, char* pDest);
Nchar OS_GetMailCond1      (OS_MAILBOX * pMB, char* pDest);
Nchar OS_GetMailTimed      (OS_MAILBOX * pMB, void* pDest, OS_TIME Timeout);
Xchar OS_GetMailTimed      (OS_MAILBOX * pMB, void* pDest, int Timeout);
Nvoid OS_DeleteMB          (OS_MAILBOX * pMB);
Nvoid OS_WaitMail          (OS_MAILBOX * pMB);
N
N#if OS_DEBUG == 0
X#if 1 == 0
S  #define OS_GetMessageCnt(pMB) (*pMB).nofMsg
N#else
N  OS_UINT OS_GetMessageCnt(OS_MAILBOX * pMB);   /* get no. of available Messages */
X  unsigned int OS_GetMessageCnt(OS_MAILBOX * pMB);    
N#endif
N
N/*********************************************************************
N*
N*       Message Queues (OSQ.c)
N*
N**********************************************************************
N*/
N
Nvoid    OS_Q_Create       (OS_Q* pQ, void*pData, OS_UINT Size);
Xvoid    OS_Q_Create       (OS_Q* pQ, void*pData, unsigned int Size);
Nvoid    OS_Q_Clear        (OS_Q* pQ);                                /* OSQCL.c  */
Nint     OS_Q_GetMessageCnt(OS_Q* pQ);                                /* OSQGMC.c */
Nint     OS_Q_Put          (OS_Q* pQ, const void* pSrc, OS_UINT Size);
Xint     OS_Q_Put          (OS_Q* pQ, const void* pSrc, unsigned int Size);
Nint     OS_Q_GetPtr       (OS_Q* pQ, void**ppData);
Nint     OS_Q_GetPtrCond   (OS_Q* pQ, void**ppData);                  /* OSQGPC.c */
Nint     OS_Q_GetPtrTimed  (OS_Q* pQ, void**ppData, OS_TIME Timeout); /* OSQGPT.c */
Xint     OS_Q_GetPtrTimed  (OS_Q* pQ, void**ppData, int Timeout);  
Nvoid    OS_Q_Purge        (OS_Q* pQ);
N
N/*********************************************************************
N*
N*       Events
N*
N**********************************************************************
N*/
N
Nchar OS_ClearEvents          (OS_TASK * pTask);                 /* OSEVENCL.c  */
Nchar OS_GetEventsOccured     (OS_TASK * pTask);                 /* OSEVENGE.c  */
Nvoid OS_SignalEvent          (char Event, OS_TASK * pTask);     /* OSENENS.c   */
Nchar OS_WaitEvent            (char EventMask);                  /* OSEVENW.c   */
Nchar OS_WaitEventTimed       (char EventMask, OS_TIME TimeOut); /* OSEVENT.c   */
Xchar OS_WaitEventTimed       (char EventMask, int TimeOut);  
Nchar OS_WaitSingleEvent      (char EventMask);                  /* OSEVENWS.c  */
Nchar OS_WaitSingleEventTimed (char EventMask, OS_TIME TimeOut); /* OSEVENWST.c */
Xchar OS_WaitSingleEventTimed (char EventMask, int TimeOut);  
N
N/*********************************************************************
N*
N*       Timers(OSTIME.c)
N*
N**********************************************************************
N*/
N
N#ifdef OS_SIZEOF_INT
N  #if OS_SIZEOF_INT == 2
X  #if (4) == 2
S    #define OS_TIMER_MAX_TIME 0x7F00
N  #elif OS_SIZEOF_INT == 4
X  #elif (4) == 4
N    #define OS_TIMER_MAX_TIME 0x7FFFFF00
N  #else
S    #error "OS_SIZEOF_INT not correctly defined"
N  #endif
N#endif
N
Nvoid    OS_CreateTimer    (OS_TIMER * pTimer, OS_TIMERROUTINE* Callback, OS_TIME Timeout);
Xvoid    OS_CreateTimer    (OS_TIMER * pTimer, OS_TIMERROUTINE* Callback, int Timeout);
Nvoid    OS_RetriggerTimer (OS_TIMER * pTimer);
Nvoid    OS_StartTimer     (OS_TIMER * pTimer);
Nvoid    OS_StopTimer      (OS_TIMER * pTimer);
Nvoid    OS_DeleteTimer    (OS_TIMER * pTimer);                  /* OSTIMED.c  */
NOS_TIME OS_GetTimerPeriod (OS_TIMER * pTimer);                  /* OSTIMEGP.c */
Xint OS_GetTimerPeriod (OS_TIMER * pTimer);                   
NOS_U8   OS_GetTimerStatus (OS_TIMER * pTimer);                  /* OSTIMEGS.c */
Xunsigned char   OS_GetTimerStatus (OS_TIMER * pTimer);                   
NOS_TIME OS_GetTimerValue  (OS_TIMER * pTimer);                  /* OSTIMEGV.c */
Xint OS_GetTimerValue  (OS_TIMER * pTimer);                   
Nvoid    OS_SetTimerPeriod (OS_TIMER * pTimer, OS_TIME Period);  /* OSTIMES.c  */
Xvoid    OS_SetTimerPeriod (OS_TIMER * pTimer, int Period);   
N
N#define OS_CREATETIMER(pTimer,c,d)  \
N        OS_CreateTimer(pTimer,c,d); \
N        OS_StartTimer(pTimer);
X#define OS_CREATETIMER(pTimer,c,d)          OS_CreateTimer(pTimer,c,d);         OS_StartTimer(pTimer);
N
N/*********************************************************************
N*
N*       Extended timers (OSTIMERX.c)
N*
N**********************************************************************
N*/
Nvoid    OS_CreateTimerEx (OS_TIMER_EX * pTimerEx, OS_TIMER_EX_ROUTINE* Callback, OS_TIME Timeout, void * pData);
Xvoid    OS_CreateTimerEx (OS_TIMER_EX * pTimerEx, OS_TIMER_EX_ROUTINE* Callback, int Timeout, void * pData);
N
N#define OS_RetriggerTimerEx(pTimerEx)         OS_RetriggerTimer(&(pTimerEx)->Timer)
N#define OS_StartTimerEx(pTimerEx)             OS_StartTimer(&(pTimerEx)->Timer)
N#define OS_StopTimerEx(pTimerEx)              OS_StopTimer(&(pTimerEx)->Timer)
N#define OS_DeleteTimerEx(pTimerEx)            OS_DeleteTimer(&(pTimerEx)->Timer)
N#define OS_GetTimerPeriodEx(pTimerEx)         OS_GetTimerPeriod(&(pTimerEx)->Timer)
N#define OS_GetTimerStatusEx(pTimerEx)         OS_GetTimerStatus(&(pTimerEx)->Timer)
N#define OS_GetTimerValueEx(pTimerEx)          OS_GetTimerValue(&(pTimerEx)->Timer)
N#define OS_SetTimerPeriodEx(pTimerEx,Period)  OS_SetTimerPeriod(&(pTimerEx)->Timer, Period)
N
N#define OS_CREATETIMER_EX(pTimerEx,cb,Timeout,pData) \
N        OS_CreateTimerEx(pTimerEx,cb,Timeout,pData); \
N        OS_StartTimerEx(pTimerEx)
X#define OS_CREATETIMER_EX(pTimerEx,cb,Timeout,pData)         OS_CreateTimerEx(pTimerEx,cb,Timeout,pData);         OS_StartTimerEx(pTimerEx)
N
N/*********************************************************************
N*
N*       Heap type memory management (OS_Alloc.c)
N*
N**********************************************************************
N
N  This functions might not be implemented in all OS ports.
N  Therefore declaration depends on condition OS_SUPPORT_OS_ALLOC
N  which has to be defined in CPU specific part
N
N*/
N
N#if OS_SUPPORT_OS_ALLOC
X#if (1)
N  void* OS_malloc(unsigned int);
N  void  OS_free  (void* pMemBlock);
N  void* OS_realloc  (void* pMemBlock, unsigned NewSize);
N#endif
N
N/*********************************************************************
N*
N*       Fixed Block memory management
N*
N**********************************************************************
N*/
N
Nvoid  OS_MEMF_Create(OS_MEMF* pMEMF, void* pPool, OS_U16 NumBlocks, OS_U16 BlockSize);
Xvoid  OS_MEMF_Create(OS_MEMF* pMEMF, void* pPool, unsigned short NumBlocks, unsigned short BlockSize);
Nvoid  OS_MEMF_Delete(OS_MEMF* pMEMF);
Nvoid* OS_MEMF_Alloc(OS_MEMF* pMEMF, int Purpose);
Nvoid* OS_MEMF_AllocTimed(OS_MEMF* pMEMF, OS_TIME Timeout, int Purpose);
Xvoid* OS_MEMF_AllocTimed(OS_MEMF* pMEMF, int Timeout, int Purpose);
Nvoid* OS_MEMF_Request(OS_MEMF* pMEMF, int Purpose);
Nvoid  OS_MEMF_Release(OS_MEMF* pMEMF, void* pMemBlock);
Nvoid  OS_MEMF_FreeBlock(void* pMemBlock);
Nint   OS_MEMF_GetNumFreeBlocks(OS_MEMF* pMEMF);
Nchar  OS_MEMF_IsInPool(OS_MEMF* pMEMF, void* pMemBlock);
Nint   OS_MEMF_GetMaxUsed(OS_MEMF* pMEMF);
Nint   OS_MEMF_GetNumBlocks(OS_MEMF* pMEMF);
Nint   OS_MEMF_GetBlockSize(OS_MEMF* pMEMF);
N
N/*********************************************************************
N*
N*       Event object module
N*
N**********************************************************************
N*/
N
N/****** Simple OS_EVENT functions ************************************/
N
Nvoid  OS_EVENT_Create    (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Delete    (OS_EVENT* pEvent);
N
NOS_U8 OS_EVENT_Get       (OS_EVENT* pEvent);
Xunsigned char OS_EVENT_Get       (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Pulse     (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Reset     (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Set       (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Wait      (OS_EVENT* pEvent);
Nchar  OS_EVENT_WaitTimed (OS_EVENT* pEvent, OS_TIME Timeout);
Xchar  OS_EVENT_WaitTimed (OS_EVENT* pEvent, int Timeout);
N
N/*********************************************************************
N*
N*       Timing support (OSTiming.c)
N*
N**********************************************************************
N
N New in V3.04, but not yet documented to the end user. Great for
N run-time measurement.
N*/
N
N#define OS_TIMING OS_U32
Nvoid    OS_Timing_Start(OS_TIMING* pCycle);
Xvoid    OS_Timing_Start(unsigned int* pCycle);
Nvoid    OS_Timing_End(OS_TIMING* pCycle);
Xvoid    OS_Timing_End(unsigned int* pCycle);
NOS_U32  OS_Timing_Getus(OS_TIMING* pCycle);
Xunsigned int  OS_Timing_Getus(unsigned int* pCycle);
N#define OS_Timing_GetCycles(pPara) (*pPara)
N
N
N/*********************************************************************
N*
N*       OS Power control module OS_Power.c
N*
N**********************************************************************
N*/
N#if OS_SUPPORT_POWER
X#if (1)
N#define OS_POWER_LEVEL0  (0x0001)
N#define OS_POWER_LEVEL1  (0x0002)
N#define OS_POWER_LEVEL2  (0x0004)
N#define OS_POWER_LEVEL3  (0x0008)
N#define OS_POWER_LEVEL4  (0x0010)
N#define OS_POWER_LEVEL5  (0x0020)
N#define OS_POWER_LEVEL6  (0x0040)
N#define OS_POWER_LEVEL8  (0x0080)
N
Nvoid    OS_POWER_UsageInc(OS_UINT Level);
Xvoid    OS_POWER_UsageInc(unsigned int Level);
Nvoid    OS_POWER_UsageDec(OS_UINT Level);
Xvoid    OS_POWER_UsageDec(unsigned int Level);
NOS_UINT OS_POWER_GetMask(void);
Xunsigned int OS_POWER_GetMask(void);
N#endif
N
N/*********************************************************************
N*
N*       Advanced profiling support (Module OsKern.c)
N*
N**********************************************************************
N*/
N#if OS_PROFILE >= 1
X#if 1 >= 1
N  void OS_EnableProfiling(int Period);
N  #define OS_DisableProfiling() { OS_ProfilingOn=0; }
N#else
S  #define OS_EnableProfiling(Period);
S  #define OS_DisableProfiling()
N#endif
N
N/*********************************************************************
N*
N*       Configuration
N*
N**********************************************************************
N*/
N
N#define OS_CONFIG_FRACT(f, div)                    \
N  OS_TicksPerMS  = f/1000;                         \
N  OS_IntMSInc    = div*1000L/f;                    \
N  OS_IntTicksInc = div-(f/1000)*(div*1000L/f);
X#define OS_CONFIG_FRACT(f, div)                      OS_TicksPerMS  = f/1000;                           OS_IntMSInc    = div*1000L/f;                      OS_IntTicksInc = div-(f/1000)*(div*1000L/f);
N
N#define OS_CONFIG(f, div)     \
N  OS_IntMSInc    = div*1000L/f;
X#define OS_CONFIG(f, div)       OS_IntMSInc    = div*1000L/f;
N
N
N/*********************************************************************
N*
N*       Trace support (OSTrace.c)
N*
N**********************************************************************
N
NTrace support is enabled by defining OS_TRACE 1.
NThis is automatically done, when OS_LIBMODE_T is defined.
N
N*/
N
N#if OS_TRACE
X#if 0
S  /* Declare trace function prototypes */
S  void OS_TraceVoid (OS_U8 id);
S  void OS_TracePtr  (OS_U8 id, void* p);
S  void OS_TraceData (OS_U8 id, int v);
S  void OS_TraceDataPtr (OS_U8 id, int v, void*p);
S  void OS_TraceU32Ptr  (OS_U8 id, OS_U32 p0, void*p1);
S  void OS_TraceEnable(void);
S  void OS_TraceDisable(void);
S  void OS_TraceEnableAll(void);                              /* OSTrace1.c */
S  void OS_TraceDisableAll(void);                             /* OSTrace1.c */
S  void OS_TraceEnableId(OS_U8 id);                           /* OSTrace1.c */
S  void OS_TraceDisableId(OS_U8 id);                          /* OSTrace1.c */
S  void OS_TraceEnableFilterId(OS_U8 FilterIndex, OS_U8 id);  /* OSTrace1.c */
S  void OS_TraceDisableFilterId(OS_U8 FilterIndex, OS_U8 id); /* OSTrace1.c */
S
S  /* Trace function macros, used in API functions */
S  #define OS_TRACE_VOID(id)            OS_TraceVoid(id)
S  #define OS_TRACE_PTR(id, p)          OS_TracePtr(id, p)
S  #define OS_TRACE_DATA(id, v)         OS_TraceData(id, v)
S  #define OS_TRACE_DATA_PTR(id, v, p)  OS_TraceDataPtr(id, v, p)
S  #define OS_TRACE_U32_PTR(id, p0, p1) OS_TraceU32Ptr(id, p0, p1)
S
S  #define OS_TRACE_START()                    { OS_EnterRegion();                                }
S  #define OS_TRACE_START_VOID(id)             { OS_EnterRegion(); OS_TraceVoid(id);              }
S  #define OS_TRACE_START_PTR(id, p)           { OS_EnterRegion(); OS_TracePtr(id, p);            }
S  #define OS_TRACE_START_DATA(id, v)          { OS_EnterRegion(); OS_TraceData(id, v);           }
S  #define OS_TRACE_START_DATA_PTR(id, v, p)   { OS_EnterRegion(); OS_TraceDataPtr(id, v, p);     }
S  #define OS_TRACE_START_U32_PTR(id, p0, p1)  { OS_EnterRegion(); OS_TraceU32Ptr(id, u, p);      }
S  #define OS_TRACE_END()                      { OS_LeaveRegion();                                }
S
N#else
N  /* Replace trace functions by empty macros if trace is not enabled */
N  #define OS_TraceVoid(id)
N  #define OS_TracePtr(id, p)
N  #define OS_TraceData(id, v)
N  #define OS_TraceDataPtr(id, v, p)
N  #define OS_TraceU32Ptr(id, p0, p1)
N  #define OS_TraceEnable()
N  #define OS_TraceDisable()
N  #define OS_TraceEnableAll()
N  #define OS_TraceDisableAll()
N  #define OS_TraceEnableId(id)
N  #define OS_TraceDisableId(id)
N  #define OS_TraceEnableFilterId(FilterIndex, id)
N  #define OS_TraceDisableFilterId(FilterIndex, id)
N  /* Trace function macros, used in API functions. */
N  /* Expand to nothing if trace is disabled       */
N  #define OS_TRACE_VOID(id)
N  #define OS_TRACE_PTR(id, p)
N  #define OS_TRACE_DATA(id, v)
N  #define OS_TRACE_DATA_PTR(id, v, p)
N  #define OS_TRACE_U32_PTR(id, p0, p1)
N
N  #define OS_TRACE_START()
N  #define OS_TRACE_START_VOID(id)
N  #define OS_TRACE_START_PTR(id, p)
N  #define OS_TRACE_START_DATA(id, v)
N  #define OS_TRACE_START_DATA_PTR(id, v, p)
N  #define OS_TRACE_START_U32_PTR(id, p0, p1)
N  #define OS_TRACE_END()
N#endif
N
N/*********************************************************************
N*
N*        RTOSInit and misc.
N*
N**********************************************************************
N
NThe routines declared below are available on all targets.
N
N*/
N
N/* Routines in RTOSInit.c */
Nvoid   OS_InitHW(void);
Nvoid   OS_Idle(void);
NOS_U32 OS_ConvertCycles2us(OS_U32 Cycles);
Xunsigned int OS_ConvertCycles2us(unsigned int Cycles);
NOS_U32 OS_GetTime_Cycles(void);
Xunsigned int OS_GetTime_Cycles(void);
Nvoid   OS_COM_Init(void);
Nvoid   OS_COM_Send1(unsigned char c);
N
N/* Routines in OS_Error.c, delivered as source file */
Nvoid   OS_Error(int code);
N
NOS_INTERWORK void  OS_Start(void);                  /* RTOS ASM part   */
X void  OS_Start(void);                   
NOS_INTERWORK void  OS_Switch(void);                 /* RTOS ASM part   */
X void  OS_Switch(void);                  
NOS_INTERWORK int   OS_SwitchFromInt(void);          /* RTOS ASM part   */
X int   OS_SwitchFromInt(void);           
N
Nvoid  OS_InitKern(void);             /* OSKern.c        */
NOS_U8 OS_OnTx(void);                 /* OSComRxTx1.c, Returns 1 on last byte */
Xunsigned char OS_OnTx(void);                  
Nvoid  OS_OnRx(unsigned char c);      /* OSComRxTx1.c    */
Nvoid  OS_Send1(OS_U8 c);             /* not implemented */
Xvoid  OS_Send1(unsigned char c);              
Nvoid  OS_SendString(const char* s);  /* OSSend.c        */
NOS_RX_CALLBACK* OS_SetRxCallback(OS_RX_CALLBACK* cb);
NOS_U8 OS_EvaPacketEx(const OS_U8 * pSrc, OS_U16 SrcLen, OS_U8** pReturn);  /* OS_EvaPacketEx.c */
Xunsigned char OS_EvaPacketEx(const unsigned char * pSrc, unsigned short SrcLen, unsigned char** pReturn);   
N
Nvoid  OS_COM_ClearTxActive(void);    /* OSCom2.c */
N
N/*********************************************************************
N*
N*        RTOS misc. optional
N*
N**********************************************************************
N
NThe routines declared below are available on some targets
Nonly. (Because they do not make much sense on others)
N*/
N
N/* Timing routines. Their existance depends on the CPU. In general,
N  8-bit CPUs require both routines, where 16-bit CPUs require one
N  and 32-bit CPUs require none of these.
N*/
N#ifndef OS_GetTime
S  OS_TIME OS_GetTime(void);
N#endif
N#ifndef OS_GetTime32
S  #if (OS_SIZEOF_INT == 4)
S    #define OS_GetTime32() (OS_Time)
S  #else
S    OS_I32 OS_GetTime32(void);
S  #endif
N#endif
N
Nvoid OS__di(void);
Nvoid OS__ei(void);
Nvoid OS__SaveIPL(void);
Nvoid OS__RestIPL(void);
Nvoid OS_SIM_Init(void);
N
N/* Standard tick handler which increment OS time variable by one on each interrupt */
Nvoid OS_HandleTick(void);       /* New version of OS_TickHandler() without Enter- Leave-Interrupt    */
Nvoid OS_HandleTickDI(void);     /* OSTickDI.c */
N
N/* Non standard tick handler which increment the OS time variable by OS_IntMsInc once on each interrupt */
N/* One of these handler has to be used when OS_CONFIG() is used to set a tick increment unequal to 0    */
Nvoid OS_HandleTick_Ex(void);    /* OS_HandleTick_Ex.c */
Nvoid OS_HandleTickDI_Ex(void);  /* OSTickDI_Ex.c      */
N
Nvoid OS_AddTickHook(OS_TICK_HOOK* pHook, OS_TICK_HOOK_ROUTINE * pfUser);
Nvoid OS_RemoveTickHook(OS_TICK_HOOK* pHook);
N
N/* Routines for the PC-version running in native mode (non-windows) */
Nvoid OS_SetIntFreq(OS_UINT f);
Xvoid OS_SetIntFreq(unsigned int f);
Nvoid OS_Exit(int code);
Nvoid OS_UseDos(void);
Nvoid OS_UnuseDos(void);
Nint  OS_GetKey(void);
Nint  OS_WaitKey(void);
N
N/* Compatibility with manual */
N#define OS_CREATEMB          OS_CreateMB
N#define OS_GetUseCnt         OS_GetSemaValue
N#define OS_WaitCSema_Timed   OS_WaitCSemaTimed
N#define OS_WaitEvent_Timed   OS_WaitEventTimed
N
N/********************************************************************/
N
N#ifdef __cplusplus
S  }
N#endif
N
N#endif /* RTOS_H_INCLUDED */
N
N/*****  EOF  ********************************************************/
N
L 20 "Setup\BSP.c" 2
N#include "GUI.h"
L 1 "GUI\GUI.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI.h
NPurpose     : GUI API include file
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_H
N#define  GUI_H
N
N#include "GUI_ConfDefaults.h"
L 1 "GUI\GUI_ConfDefaults.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI_ConfDefaults.h
NPurpose     : Defaults for GUI config switches.
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_CONFDEFAULTS_H
N#define  GUI_CONFDEFAULTS_H
N
N#include "GUIConf.h"
L 1 "Config\GUIConf.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUIConf.h
NPurpose     : Configuration of available features and default values
N----------------------------------------------------------------------
N*/
N
N#ifndef GUICONF_H
N#define GUICONF_H
N
N/*********************************************************************
N*
N*       Multi layer/display support
N*/
N#define GUI_NUM_LAYERS            (16) // Maximum number of available layers
N
N/*********************************************************************
N*
N*       Multi tasking support
N*/
N#define GUI_OS                    (1)  // Compile with multitasking support
N
N/*********************************************************************
N*
N*       Configuration of available packages
N*/
N#ifndef   GUI_SUPPORT_TOUCH
N  #define GUI_SUPPORT_TOUCH       (1)  // Support touchscreen
N#endif
N#define GUI_SUPPORT_MOUSE         (1)  // Support a mouse
N#define GUI_SUPPORT_UNICODE       (1)  // Support mixed ASCII/UNICODE strings
N#define GUI_WINSUPPORT            (1)  // Window manager package available
N#define GUI_SUPPORT_MEMDEV        (1)  // Memory devices available
N#define GUI_SUPPORT_AA            (1)  // Anti aliasing available
N#define WM_SUPPORT_STATIC_MEMDEV  (1)  // Static memory devices available
N
N/*********************************************************************
N*
N*       Default font
N*/
N#define GUI_DEFAULT_FONT          &GUI_Font6x8
N
N#endif  /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 26 "GUI\GUI_ConfDefaults.h" 2
N
N#ifndef   LCD_MAX_LOG_COLORS
N  #define LCD_MAX_LOG_COLORS 256
N#else
S  #if (LCD_MAX_LOG_COLORS > 256)
S    #error The value of LCD_MAX_LOG_COLORS must be <= 256!
S  #endif
N#endif
N
N#ifndef GUI_BYTESPERPIXEL
N  #define GUI_BYTESPERPIXEL 4
N#endif
N
N#if   (GUI_BYTESPERPIXEL != 4)
X#if   (4 != 4)
S  #error This emWin version only supports an internal length of 4 bytes per pixel!
N#endif
N
N#if   (GUI_BYTESPERPIXEL == 1)
X#if   (4 == 1)
S  #define LCD_PIXELINDEX U8
S#elif (GUI_BYTESPERPIXEL == 2)
X#elif (4 == 2)
S  #define LCD_PIXELINDEX U16
N#elif (GUI_BYTESPERPIXEL == 4)
X#elif (4 == 4)
N  #define LCD_PIXELINDEX U32
N#else
S  #error The value of GUI_BYTESPERPIXEL needs to be 1, 2 or 4!
N#endif
N
N#ifndef LCD_YMAG
N  #define LCD_YMAG 1
N#endif
N#ifndef LCD_XMAG
N  #define LCD_XMAG 1
N#endif
N
N/**********************************************************************
N*
N*       Defaults for config switches
N*
N***********************************************************************
N*/
N
N/* Define "universal pointer". Normally, this is not needed (define will expand to nothing)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __generic),
N   since a default pointer can access RAM only, not the built-in Flash
N*/
N#ifndef GUI_UNI_PTR
N  #define GUI_UNI_PTR
N  #define GUI_UNI_PTR_USED 0
N#else
S  #define GUI_UNI_PTR_USED 1
N#endif
N
N/* Define const storage. Normally, this is not needed (define will expand to const)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __flash const),
N   since otherwise constants are copied into RAM
N*/
N#ifndef GUI_CONST_STORAGE
N  #define GUI_CONST_STORAGE const
N#endif
N
N#ifndef GUI_USE_MEMDEV_1BPP_FOR_SCREEN
N  #define GUI_USE_MEMDEV_1BPP_FOR_SCREEN 1
N#endif
N
N#ifndef GUI_BIDI_MAX_CHARS_PER_LINE
N  #define GUI_BIDI_MAX_CHARS_PER_LINE 80
N#endif
N
N#ifndef GUI_SUPPORT_BIDI
N  #define GUI_SUPPORT_BIDI 0
N#endif
N
N#ifndef GUI_ALLOC_SIZE
N  #define GUI_ALLOC_SIZE      0
N#endif
N
N#ifndef GUI_MAXBLOCKS
N  #define GUI_MAXBLOCKS (2 + GUI_ALLOC_SIZE / 32)
N#endif
N
N#ifndef GUI_SUPPORT_TOUCH
S  #define GUI_SUPPORT_TOUCH   0
N#endif
N
N#ifndef GUI_SUPPORT_MOUSE
S  #define GUI_SUPPORT_MOUSE   0
N#endif
N
N#ifndef GUI_SUPPORT_MEMDEV
S  #define GUI_SUPPORT_MEMDEV  0
N#endif
N
N#ifndef GUI_OS
S  #define GUI_OS              0
N#endif
N
N#ifndef GUI_SUPPORT_LARGE_BITMAPS
N  #if GUI_ALLOC_SIZE > 65535
X  #if 0 > 65535
S    #define GUI_SUPPORT_LARGE_BITMAPS 1
N  #else
N    #define GUI_SUPPORT_LARGE_BITMAPS 0
N  #endif
N#endif
N
N#ifndef GUI_COMPATIBLE_MODE
N  #define GUI_COMPATIBLE_MODE 1
N#endif
N
N#ifndef GUI_NUM_LAYERS
S  #define GUI_NUM_LAYERS      1
N#endif
N
N#ifndef GUI_SUPPORT_CURSOR
N  #define GUI_SUPPORT_CURSOR  (GUI_SUPPORT_MOUSE | GUI_SUPPORT_TOUCH)
N#endif
N
N#ifndef   GUI_SUPPORT_SPRITE
N  #define GUI_SUPPORT_SPRITE 1
N#endif
N
N#ifndef   GUI_CURSOR_LAYER
N  #define GUI_CURSOR_LAYER 0
N#endif
N
N#ifndef GUI_SELECT_JPEG
N  #define GUI_SELECT_JPEG 0
N#endif
N
N#ifndef GUI_MEMCPY
N  #define GUI_MEMCPY(pDest, pSrc, NumBytes) memcpy(pDest, pSrc, NumBytes)
N#endif
N
N#ifndef GUI_SUPPORT_ROTATION
N  #define GUI_SUPPORT_ROTATION 1
N#endif
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef GUI_USE_PARA
N  #if defined (__BORLANDC__) || defined(NC30) || defined(NC308)
X  #if 0L || 0L || 0L
S    #define GUI_USE_PARA(para)
N  #else
N    #define GUI_USE_PARA(para) para=para;
N  #endif
N#endif
N
N/* Default for types */
N#ifndef GUI_TIMER_TIME
N  #define GUI_TIMER_TIME int  /* default is to use 16 bits for 16 bit CPUs,
N	                           32 bits on 32 bit CPUs for timing */
N#endif
N
N/* Types used for memory allocation */
N#if (GUI_ALLOC_SIZE >= 32767) || (GUI_ALLOC_SIZE == 0)
X#if (0 >= 32767) || (0 == 0)
N  #define GUI_ALLOC_DATATYPE   I32
N  #define GUI_ALLOC_DATATYPE_U U32
N#else
S  #define GUI_ALLOC_DATATYPE   I16
S  #define GUI_ALLOC_DATATYPE_U U16
N#endif
N
N#ifndef   GUI_MAX_XBF_BYTES
N  #define GUI_MAX_XBF_BYTES 200
N#endif
N
N#ifndef   GUI_MEMSET
N  #define GUI_MEMSET GUI__memset
N#endif
N
N
N#endif   /* ifdef GUI_CONFDEFAULTS_H */
N
N/*************************** End of file ****************************/
L 22 "GUI\GUI.h" 2
N#include "GUI_Type.h"
L 1 "GUI\GUI_Type.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI_Type.h
NPurpose     : Include file define the types used for GUI
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUITYPE_H_INCLUDED
N#define  GUITYPE_H_INCLUDED
N
N#include "LCD.h"
L 1 "GUI\LCD.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : LCD.h
NPurpose     : Declares LCD interface functions
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_H
N#define LCD_H
N
N#include "GUI_ConfDefaults.h" /* Used for GUI_UNI_PTR */
N#include "Global.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Basic type defines
N*
N* The follwing are defines for types used in the LCD-driver and the
N* GUI layers on top of that. Since "C" does not provide data types of
N* fixed length which are identical on all platforms, this is done here.
N* For most 16/32 controllers, the settings will work fine. However, if
N* you have similar defines in other sections of your program, you might
N* want to change or relocate these defines, e.g. in a TYPE.h file.
N*/
N#define I16P I16              /*   signed 16 bits OR MORE ! */
N#define U16P U16              /* unsigned 16 bits OR MORE ! */
N
N/*********************************************************************
N*
N*       Settings for windows simulation
N*
N* Some settings in the configuration may conflict with the values required
N* in the Simulation. This is why we ignore the target settings for data
N* types and use the correct settings for the simulation.
N* (U32 could be defined as long, which would yield a 64 bit type on
N* the PC)
N*/
N#ifdef WIN32
S  #pragma warning( disable : 4244 )  // Disable warning messages in simulation
S  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
N#endif                                      
N
N/*********************************************************************
N*
N*       Constants
N*/
N#define LCD_ERR0 (0x10)
N#define LCD_ERR_CONTROLLER_NOT_FOUND (LCD_ERR0+1)
N#define LCD_ERR_MEMORY               (LCD_ERR0+2)
N
N/*********************************************************************
N*
N*       Drawing modes
N*/
N#define LCD_DRAWMODE_NORMAL (0)
N#define LCD_DRAWMODE_XOR    (1<<0)
N#define LCD_DRAWMODE_TRANS  (1<<1)
N#define LCD_DRAWMODE_REV    (1<<2)
N
N/*********************************************************************
N*
N*       Typedefs
N*/
Ntypedef int LCD_DRAWMODE;
Ntypedef U32 LCD_COLOR;
Xtypedef unsigned long LCD_COLOR;
N 
N/*********************************************************************
N*
N*       Data structures
N*/
Ntypedef struct { I16P x,y; } GUI_POINT;
Xtypedef struct { signed short x,y; } GUI_POINT;
Ntypedef struct { I16 x0,y0,x1,y1; } LCD_RECT;
Xtypedef struct { signed short x0,y0,x1,y1; } LCD_RECT;
N
Ntypedef struct {
N  int              NumEntries; 
N  char             HasTrans;         
N  const LCD_COLOR GUI_UNI_PTR * pPalEntries; 
X  const LCD_COLOR  * pPalEntries; 
N} LCD_LOGPALETTE; 
N
N/* This is used for the simulation only ! */
Ntypedef struct {
N  int x,y;
N  unsigned char KeyStat;
N} LCD_tMouseState;
N
Ntypedef struct {
N  int               NumEntries; 
N  const LCD_COLOR * pPalEntries; 
N} LCD_PHYSPALETTE; 
N
N/*********************************************************************
N*
N*       LCD_L0_... color conversion
N*/
Ntypedef LCD_COLOR      tLCDDEV_Index2Color  (unsigned Index);
Ntypedef unsigned int   tLCDDEV_Color2Index  (LCD_COLOR Color);
Ntypedef unsigned int   tLCDDEV_GetIndexMask (void);
N
N/*********************************************************************
N*
N*       Color conversion API tables
N*/
Ntypedef struct {
N  tLCDDEV_Color2Index  * pfColor2Index;
N  tLCDDEV_Index2Color  * pfIndex2Color;
N  tLCDDEV_GetIndexMask * pfGetIndexMask;
N} LCD_API_COLOR_CONV;
N
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_0;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_5;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_822216;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_84444;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8888;
N
N#define GUICC_0        &LCD_API_ColorConv_0
N#define GUICC_1        &LCD_API_ColorConv_1
N#define GUICC_M1       &LCD_API_ColorConv_M1
N#define GUICC_2        &LCD_API_ColorConv_2
N#define GUICC_M2       &LCD_API_ColorConv_M2
N#define GUICC_4        &LCD_API_ColorConv_4
N#define GUICC_M4       &LCD_API_ColorConv_M4
N#define GUICC_5        &LCD_API_ColorConv_5
N#define GUICC_111      &LCD_API_ColorConv_111
N#define GUICC_222      &LCD_API_ColorConv_222
N#define GUICC_233      &LCD_API_ColorConv_233
N#define GUICC_323      &LCD_API_ColorConv_323
N#define GUICC_332      &LCD_API_ColorConv_332
N#define GUICC_444_12   &LCD_API_ColorConv_444_12
N#define GUICC_444_12_1 &LCD_API_ColorConv_444_12_1
N#define GUICC_444_16   &LCD_API_ColorConv_444_16
N#define GUICC_555      &LCD_API_ColorConv_555
N#define GUICC_565      &LCD_API_ColorConv_565
N#define GUICC_556      &LCD_API_ColorConv_556
N#define GUICC_655      &LCD_API_ColorConv_655
N#define GUICC_666      &LCD_API_ColorConv_666
N#define GUICC_822216   &LCD_API_ColorConv_822216
N#define GUICC_84444    &LCD_API_ColorConv_84444
N#define GUICC_8666     &LCD_API_ColorConv_8666
N#define GUICC_8666_1   &LCD_API_ColorConv_8666_1
N#define GUICC_888      &LCD_API_ColorConv_888
N#define GUICC_8888     &LCD_API_ColorConv_8888
N#define GUICC_M111     &LCD_API_ColorConv_M111
N#define GUICC_M222     &LCD_API_ColorConv_M222
N#define GUICC_M233     &LCD_API_ColorConv_M233
N#define GUICC_M323     &LCD_API_ColorConv_M323
N#define GUICC_M332     &LCD_API_ColorConv_M332
N#define GUICC_M444_12  &LCD_API_ColorConv_M444_12
N#define GUICC_M444_16  &LCD_API_ColorConv_M444_16
N#define GUICC_M555     &LCD_API_ColorConv_M555
N#define GUICC_M565     &LCD_API_ColorConv_M565
N#define GUICC_M556     &LCD_API_ColorConv_M556
N#define GUICC_M655     &LCD_API_ColorConv_M655
N#define GUICC_M666     &LCD_API_ColorConv_M666
N#define GUICC_M8565    &LCD_API_ColorConv_M8565
N#define GUICC_M888     &LCD_API_ColorConv_M888
N#define GUICC_M8888    &LCD_API_ColorConv_M8888
N
N/*********************************************************************
N*
N*       Compatibility defines for older versions
N*/
N#define GUI_COLOR_CONV_1    GUICC_1   
N#define GUI_COLOR_CONV_2    GUICC_2   
N#define GUI_COLOR_CONV_4    GUICC_4   
N#define GUI_COLOR_CONV_8666 GUICC_8666
N#define GUI_COLOR_CONV_888  GUICC_888 
N#define GUI_COLOR_CONV_8888 GUICC_8888
N#define GUI_COLOR_CONV_565  GUICC_565 
N#define GUI_COLOR_CONV_M565 GUICC_M565
N
N/*********************************************************************
N*
N*       LCDDEV function table
N*
N*  Below the routines which need to in an LCDDEV routine table are
N*  defined. All of these routines have to be in the low-level driver
N*  (LCD_L0) or in the memory device which can be used to replace the
N*  driver.
N*  The one exception to this is the SetClipRect routine, which would
N*  be identical for all drivers and is therefor contained in the
N*  level above (LCD).
N*/
Ntypedef void         tLCDDEV_DrawPixel    (int x, int y);
Ntypedef void         tLCDDEV_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCDDEV_DrawVLine    (int x , int y0,  int y1);
Ntypedef void         tLCDDEV_FillRect     (int x0, int y0, int x1, int y1);
Ntypedef unsigned int tLCDDEV_GetPixelIndex(int x, int y);
Ntypedef void         tLCDDEV_SetPixelIndex(int x, int y, int ColorIndex);
Ntypedef void         tLCDDEV_XorPixel     (int x, int y);
Ntypedef void         tLCDDEV_FillPolygon  (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_FillPolygonAA(const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_GetRect      (LCD_RECT*pRect);
Ntypedef int          tLCDDEV_Init         (void);
Ntypedef void         tLCDDEV_On           (void);
Ntypedef void         tLCDDEV_Off          (void);
Ntypedef void         tLCDDEV_SetLUTEntry  (U8 Pos, LCD_COLOR color);
Xtypedef void         tLCDDEV_SetLUTEntry  (unsigned char Pos, LCD_COLOR color);
Ntypedef void *       tLCDDEV_GetDevFunc   (int Index);
Ntypedef I32          tLCDDEV_GetDevProp   (int Index);
Xtypedef signed long          tLCDDEV_GetDevProp   (int Index);
Ntypedef void         tLCDDEV_SetOrg       (int x, int y);
N
N/*********************************************************************
N*
N*       Memory device API tables
N*/
Ntypedef struct GUI_DEVICE     GUI_DEVICE;
Ntypedef struct GUI_DEVICE_API GUI_DEVICE_API;
N
Ntypedef void tLCDDEV_DrawBitmap   (int x0, int y0, int xsize, int ysize,
N                       int BitsPerPixel, int BytesPerLine,
N                       const U8 GUI_UNI_PTR * pData, int Diff,
X                       const unsigned char  * pData, int Diff,
N                       const void* pTrans);   /* Really LCD_PIXELINDEX, but is void to avoid compiler warnings*/
N#define GUI_MEMDEV_APILIST_1  &GUI_MEMDEV_DEVICE_1
N#define GUI_MEMDEV_APILIST_8  &GUI_MEMDEV_DEVICE_8
N#define GUI_MEMDEV_APILIST_16 &GUI_MEMDEV_DEVICE_16
N#define GUI_MEMDEV_APILIST_32 &GUI_MEMDEV_DEVICE_32
N
N/*********************************************************************
N*
N*       Defines for device capabilities
N*
N* The following is the list of device capabilities which can, but do
N* not have to be implemented in the driver. This way the driver can be
N* enhanced in the future without affecting the driver interface,
N* keeping older drivers compatible.
N* More DevCaps can always be added in the future, as older drivers
N* are guaranteed to return 0 for all unimplemented features or queries.
N*
N* The values below define the legal parameters to the LCD_GetDeviceCaps
N* and the LCD_GetpCapFunc routines.
N*/
N
N#define LCD_DEVCAP_XSIZE             0x01    /* Quest horiz. res. of display */
N#define LCD_DEVCAP_YSIZE             0x02    /* Quest vert. res. of display */
N#define LCD_DEVCAP_VXSIZE            0x03    /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_VYSIZE            0x04    /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_XORG              0x05    /* X-origin ... usually 0 */
N#define LCD_DEVCAP_YORG              0x06    /* Y-origin ... usually 0 */
N#define LCD_DEVCAP_CONTROLLER        0x07    /* LCD Controller (Numerical) */
N#define LCD_DEVCAP_BITSPERPIXEL      0x08    /* Bits per pixel ... 1/2/4/8 */
N#define LCD_DEVCAP_NUMCOLORS         0x09    /* Quest number of colors */
N#define LCD_DEVCAP_XMAG              0x0A
N#define LCD_DEVCAP_YMAG              0x0B
N#define LCD_DEVCAP_MIRROR_X          0x0C
N#define LCD_DEVCAP_MIRROR_Y          0x0D
N#define LCD_DEVCAP_SWAP_XY           0x0E
N#define LCD_DEVCAP_SWAP_RB           0x0F
N
Nint LCD_GetXSizeMax(void);
Nint LCD_GetYSizeMax(void);
Nint LCD_GetVXSizeMax(void);
Nint LCD_GetVYSizeMax(void);
Nint LCD_GetBitsPerPixelMax(void);
N
Nint LCD_GetXSizeEx          (int LayerIndex);
Nint LCD_GetYSizeEx          (int LayerIndex);
Nint LCD_GetVXSizeEx         (int LayerIndex);
Nint LCD_GetVYSizeEx         (int LayerIndex);
Nint LCD_GetBitsPerPixelEx   (int LayerIndex);
NU32 LCD_GetNumColorsEx      (int LayerIndex);
Xunsigned long LCD_GetNumColorsEx      (int LayerIndex);
Nint LCD_GetXMagEx           (int LayerIndex);
Nint LCD_GetYMagEx           (int LayerIndex);
Nint LCD_GetMirrorXEx        (int LayerIndex);
Nint LCD_GetMirrorYEx        (int LayerIndex);
Nint LCD_GetSwapXYEx         (int LayerIndex);
Nint LCD_GetReversLUTEx      (int LayerIndex);
Nint LCD_GetPhysColorsInRAMEx(int LayerIndex);
N
Nint LCD_GetXSize            (void);
Nint LCD_GetYSize            (void);
Nint LCD_GetVXSize           (void);
Nint LCD_GetVYSize           (void);
Nint LCD_GetBitsPerPixel     (void);
NU32 LCD_GetNumColors        (void);
Xunsigned long LCD_GetNumColors        (void);
Nint LCD_GetXMag             (void);
Nint LCD_GetYMag             (void);
Nint LCD_GetMirrorX          (void);
Nint LCD_GetMirrorY          (void);
Nint LCD_GetSwapXY           (void);
Nint LCD_GetReversLUT        (void);
Nint LCD_GetPhysColorsInRAM  (void);
N
NI32 LCD__GetBPP      (U32 IndexMask);
Xsigned long LCD__GetBPP      (unsigned long IndexMask);
NI32 LCD__GetBPPDevice(U32 IndexMask);
Xsigned long LCD__GetBPPDevice(unsigned long IndexMask);
N
NtLCDDEV_Index2Color * LCD_GetpfIndex2ColorEx(int LayerIndex);
NtLCDDEV_Color2Index * LCD_GetpfColor2IndexEx(int LayerIndex);
N
NtLCDDEV_Color2Index * LCD_GetpfColor2Index(void);
N
Nint LCD_GetNumLayers(void);
N
NLCD_COLOR * LCD_GetPalette  (void);
NLCD_COLOR * LCD_GetPaletteEx(int LayerIndex);
N
N/*********************************************************************
N*
N*       Values for requesting function pointers (display driver)
N*/
N                                       /* Request of a function pointer for... */
N#define LCD_DEVFUNC_READRECT      0x01 /* ...reading a rectangular display area */
N#define LCD_DEVFUNC_SETALPHA      0x02 /* ...setting the alpha blending factor */
N#define LCD_DEVFUNC_SETPOS        0x03 /* ...setting the layer position */
N#define LCD_DEVFUNC_GETPOS        0x04 /* ...getting the layer position */
N#define LCD_DEVFUNC_SETSIZE       0x05 /* ...setting the layer size */
N#define LCD_DEVFUNC_SETVIS        0x06 /* ...setting the visibility of a layer */
N#define LCD_DEVFUNC_24BPP         0x07 /* ...drawing 24bpp bitmaps */
N#define LCD_DEVFUNC_NEXT_PIXEL    0x08 /* ...drawing a bitmap pixel by pixel */
N#define LCD_DEVFUNC_SET_VRAM_ADDR 0x09 /* ...setting the VRAM address */
N#define LCD_DEVFUNC_SET_VSIZE     0x0A /* ...setting the VRAM size */
N#define LCD_DEVFUNC_SET_SIZE      0x0B /* ...setting the display size */
N#define LCD_DEVFUNC_INIT          0x0C /* ...initializing the display controller */
N#define LCD_DEVFUNC_CONTROLCACHE  0x0D /* ...controlling the cache */
N#define LCD_DEVFUNC_ON            0x0E /* ...switching the display on */
N#define LCD_DEVFUNC_OFF           0x0F /* ...switching the display off */
N#define LCD_DEVFUNC_SETLUTENTRY   0x10 /* ...setting a LUT entry */
N#define LCD_DEVFUNC_FILLPOLY      0x11 /* ...filling a polygon */
N#define LCD_DEVFUNC_FILLPOLYAA    0x12 /* ...filling an antialiased polygon */
N#define LCD_DEVFUNC_ALPHAMODE     0x13 /* ...setting the alpha blending mode */
N#define LCD_DEVFUNC_CHROMAMODE    0x14 /* ...setting the chroma blending mode */
N#define LCD_DEVFUNC_CHROMA        0x15 /* ...setting the chroma values */
N
N/*********************************************************************
N*
N*       Values for requesting function pointers (memory devices)
N*/
N                                          /* Request of a function pointer for... */
N#define MEMDEV_DEVFUNC_WRITETOACTIVE 0x16 /* ...writing the memory device */
N
N/*********************************************************************
N*
N*       Values for requesting data
N*/
N                                       /* Request pointer to... */
N#define LCD_DEVDATA_MEMDEV        0x01 /* ...default memory device API */
N#define LCD_DEVDATA_PHYSPAL       0x02 /* ...physical palette */
N
N/*********************************************************************
N*
N*       Structures for passing data to LCD_X_DisplayDriver()
N*/
Ntypedef struct {
N  void * pVRAM;
N} LCD_X_SETVRAMADDR_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N} LCD_X_SETORG_INFO;
N
Ntypedef struct {
N  LCD_COLOR Color;
N  U8 Pos;
X  unsigned char Pos;
N} LCD_X_SETLUTENTRY_INFO;
N
Ntypedef struct {
N  int xSize, ySize;
N} LCD_X_SETSIZE_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N} LCD_X_SETPOS_INFO;
N
Ntypedef struct {
N  int Alpha;
N} LCD_X_SETALPHA_INFO;
N
Ntypedef struct {
N  int OnOff;
N} LCD_X_SETVIS_INFO;
N
Ntypedef struct {
N  int AlphaMode;
N} LCD_X_SETALPHAMODE_INFO;
N
Ntypedef struct {
N  int ChromaMode;
N} LCD_X_SETCHROMAMODE_INFO;
N
Ntypedef struct {
N  LCD_COLOR ChromaMin;
N  LCD_COLOR ChromaMax;
N} LCD_X_SETCHROMA_INFO;
N
N/*********************************************************************
N*
N*       Commands for LCD_X_DisplayDriver()
N*/
N#define LCD_X_INITCONTROLLER 0x01 /* Initializing the display controller */
N#define LCD_X_SETVRAMADDR    0x02 /* Setting the video RAM address */
N#define LCD_X_SETORG         0x03 /* Setting the origin within a layer */
N#define LCD_X_SETLUTENTRY    0x04 /* Setting an entry of the LUT */
N#define LCD_X_ON             0x05 /* Switching the display on */
N#define LCD_X_OFF            0x06 /* Switching the display off */
N#define LCD_X_SETSIZE        0x07 /* Setting the layer size */
N#define LCD_X_SETPOS         0x08 /* Setting the layer position */
N#define LCD_X_SETVIS         0x09 /* Setting the visibility of a layer */
N#define LCD_X_SETALPHA       0x0A /* Setting the alpha value of the layer */
N#define LCD_X_SETALPHAMODE   0x0B /* Setting the alpha blending mode */
N#define LCD_X_SETCHROMAMODE  0x0C /* Setting the chroma blending mode */
N#define LCD_X_SETCHROMA      0x0D /* Setting the chroma values */
N
Nint  LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData);
Nvoid LCD_X_Config(void);
N
N/*********************************************************************
N*
N*       Set layer properties
N*/
Nint LCD_SetAlphaEx     (int LayerIndex, int Alpha);
Nint LCD_SetPosEx       (int LayerIndex, int xPos, int yPos);
Nint LCD_SetSizeEx      (int LayerIndex, int xSize, int ySize);
Nint LCD_SetVisEx       (int LayerIndex, int OnOff);
Nint LCD_SetVRAMAddrEx  (int LayerIndex, void * pVRAM);
Nint LCD_SetVSizeEx     (int LayerIndex, int xSize, int ySize);
Nint LCD_SetAlphaModeEx (int LayerIndex, int AlphaMode);
Nint LCD_SetChromaModeEx(int LayerIndex, int ChromaMode);
Nint LCD_SetChromaEx    (int LayerIndex, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
N
Nint LCD_SetAlpha     (int Alpha);
Nint LCD_SetVRAMAddr  (void * pVRAM);
Nint LCD_SetVSize     (int xSize, int ySize);
Nint LCD_SetSize      (int xSize, int ySize);
Nint LCD_SetVis       (int OnOff);
Nint LCD_SetPos       (int xPos, int yPos);
Nint LCD_SetAlphaMode (int AlphaMode);
Nint LCD_SetChromaMode(int ChromaMode);
Nint LCD_SetChroma    (LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
Nint LCD_SetLUTEntry  (U8 Pos, LCD_COLOR Color);
Xint LCD_SetLUTEntry  (unsigned char Pos, LCD_COLOR Color);
N
N/*********************************************************************
N*
N*       Get layer properties
N*/
Nint LCD_GetPosEx(int LayerIndex, int * pxPos, int * pyPos);
N
Nint LCD_GetPos  (int * pxPos, int * pyPos);
N
N
N/*********************************************************************
N*
N*       NEXT_PIXEL API support
N*/
Ntypedef struct {
N  void (* pfStart)   (int x0, int y0, int x1, int y1);
N  void (* pfSetPixel)(int PixelIndex);
N  void (* pfNextLine)(void);
N  void (* pfEnd)     (void);
N} LCD_API_NEXT_PIXEL;
N
NLCD_API_NEXT_PIXEL * LCD_GetNextPixelAPI(void);
N
N/*********************************************************************
N*
N*      LCD_CLIP function table
N*/
Ntypedef void         tLCD_HL_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCD_HL_DrawPixel    (int x0, int y0);
N
Ntypedef struct {
N  tLCD_HL_DrawHLine*          pfDrawHLine;
N  tLCD_HL_DrawPixel*          pfDrawPixel;
N} tLCD_HL_APIList;
N
Nvoid LCD_DrawHLine(int x0, int y0,  int x1);
Nvoid LCD_DrawPixel(int x0, int y0);
Nvoid LCD_DrawVLine  (int x, int y0,  int y1);
N
N
N/*********************************************************************
N*
N*       Declarations for LCD_
N*/
Nvoid LCD_SetClipRectEx(const LCD_RECT* pRect);
Nvoid LCD_SetClipRectMax(void);
N
N/* Get device capabilities (0 if not supported) */
NI32  LCD_GetDevCap  (int Index);
Xsigned long  LCD_GetDevCap  (int Index);
NI32  LCD_GetDevCapEx(int LayerIndex, int Index);
Xsigned long  LCD_GetDevCapEx(int LayerIndex, int Index);
N
N/* Initialize LCD using config-paramters */
Nint LCD_Init(void);
N
Nvoid LCD_SetBkColor   (LCD_COLOR Color); /* Set background color */
Nvoid LCD_SetColor     (LCD_COLOR Color); /* Set foreground color */
Nvoid LCD_SetPixelIndex(int x, int y, int ColorIndex);
N
N/* Palette routines (Not available on all drivers) */
Nvoid LCD_InitLUT(void);
Nint  LCD_SetLUTEntryEx(int LayerIndex, U8 Pos, LCD_COLOR Color);
Xint  LCD_SetLUTEntryEx(int LayerIndex, unsigned char Pos, LCD_COLOR Color);
Nvoid LCD_SetLUTEx(int LayerIndex, const LCD_PHYSPALETTE * pPalette);
Nvoid LCD_SetLUT  (const LCD_PHYSPALETTE * pPalette);
N
N/* Decompressors */
Nvoid LCD_DrawBitmap_RLE8(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid LCD_DrawBitmap_RLE8(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid LCD_DrawBitmap_RLE4(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid LCD_DrawBitmap_RLE4(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid LCD_DrawBitmap_565 (int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid LCD_DrawBitmap_565 (int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid LCD_DrawBitmap_M565(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid LCD_DrawBitmap_M565(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
N
NLCD_DRAWMODE LCD_SetDrawMode  (LCD_DRAWMODE dm);
Nvoid LCD_SetColorIndex(unsigned PixelIndex);
Nvoid LCD_SetBkColorIndex(unsigned PixelIndex);
Nvoid LCD_FillRect(int x0, int y0, int x1, int y1);
Ntypedef void tLCD_SetPixelAA(int x, int y, U8 Intens);
Xtypedef void tLCD_SetPixelAA(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA        (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA        (int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA_NoTrans(int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA_Xor    (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA_Xor    (int x, int y, unsigned char Intens);
N
NLCD_COLOR    LCD_AA_MixColors(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, unsigned Intens);
NLCD_COLOR    LCD_GetPixelColor(int x, int y);     /* Get RGB color of pixel */
Nunsigned int LCD_GetPixelIndex(int x, int y);
Nint          LCD_GetBkColorIndex (void);
Nint          LCD_GetColorIndex (void);
N
N/*********************************************************************
N*
N*       Optional support for rotatation
N*/
N#if GUI_SUPPORT_ROTATION
X#if 1
N
Ntypedef void tLCD_DrawBitmap(int x0, int y0, int xsize, int ysize,
N                             int xMul, int yMul, int BitsPerPixel, int BytesPerLine,
N                             const U8 GUI_UNI_PTR * pPixel, const void * pTrans);
X                             const unsigned char  * pPixel, const void * pTrans);
Ntypedef void tRect2TextRect (LCD_RECT * pRect);
N
Nstruct tLCD_APIList_struct {
N  tLCD_DrawBitmap   * pfDrawBitmap;
N  tRect2TextRect    * pfRect2TextRect;
N};
N
Ntypedef struct tLCD_APIList_struct tLCD_APIList;
N
Nextern tLCD_APIList LCD_APIListCCW;
Nextern tLCD_APIList LCD_APIListCW;
Nextern tLCD_APIList LCD_APIList180;
N
N#define GUI_ROTATION   tLCD_APIList
N#define GUI_ROTATE_CCW &LCD_APIListCCW
N#define GUI_ROTATE_CW  &LCD_APIListCW
N#define GUI_ROTATE_180 &LCD_APIList180
N#define GUI_ROTATE_0   0
N#endif
N
N/*********************************************************************
N*
N*       Physical color access, internally used only
N*/
Nvoid LCD__SetPhysColor(U8 Pos, LCD_COLOR Color);
Xvoid LCD__SetPhysColor(unsigned char Pos, LCD_COLOR Color);
N
N/*********************************************************************
N*
N*       Cache control
N*/
N#define LCD_CC_UNLOCK (0)    /* Default mode: Cache is transparent */
N#define LCD_CC_LOCK   (1)    /* Cache is locked, no write operations */
N#define LCD_CC_FLUSH  (2)    /* Flush cache, do not change mode */
N
Nint LCD_ControlCache  (int Cmd);
Nint LCD_ControlCacheEx(int LayerIndex, int Cmd);
N
N/*********************************************************************
N*
N*       Color conversion
N*/
Nunsigned         LCD_Color2Index     (LCD_COLOR Color);
NLCD_COLOR        LCD_Index2Color     (int Index);
NLCD_COLOR        LCD_Index2ColorEx   (int i, unsigned LayerIndex);
N
N/*********************************************************************
N*
N*       LCD_X_...
N*/
Nunsigned char LCD_X_Read00(void);
Nunsigned char LCD_X_Read01(void);
Nvoid LCD_X_Write00 (unsigned char c);
Nvoid LCD_X_Write01 (unsigned char c);
Nvoid LCD_X_WriteM01(unsigned char * pData, int NumBytes);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* LCD_H */
N
N/*************************** End of file ****************************/
L 26 "GUI\GUI_Type.h" 2
N#include "GUIConf.h"
N
N/*********************************************************************
N*
N*       Common types
N*/
Ntypedef const char *  GUI_ConstString;
N
Ntypedef LCD_COLOR       GUI_COLOR;
Ntypedef LCD_LOGPALETTE  GUI_LOGPALETTE;
Ntypedef LCD_DRAWMODE    GUI_DRAWMODE;
Ntypedef LCD_RECT        GUI_RECT;
N
Ntypedef struct {
N  void      (* pfDraw)  (int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 GUI_UNI_PTR * pPixel, 
X                         const unsigned char  * pPixel, 
N                         const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, 
X                         const LCD_LOGPALETTE  * pLogPal, 
N                         int xMag, 
N                         int yMag);
N  GUI_COLOR (* pfIndex2Color)(unsigned Index);
N  void      (* pfDrawHW)(int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 GUI_UNI_PTR * pPixel, 
X                         const unsigned char  * pPixel, 
N                         const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, 
X                         const LCD_LOGPALETTE  * pLogPal, 
N                         int xMag, 
N                         int yMag);
N} GUI_BITMAP_METHODS;
N
Ntypedef struct {
N  U16P XSize;
X  unsigned short XSize;
N  U16P YSize;
X  unsigned short YSize;
N  U16P BytesPerLine;
X  unsigned short BytesPerLine;
N  U16P BitsPerPixel;
X  unsigned short BitsPerPixel;
N  const U8 GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N  const GUI_LOGPALETTE GUI_UNI_PTR * pPal;
X  const GUI_LOGPALETTE  * pPal;
N  const GUI_BITMAP_METHODS * pMethods;
N} GUI_BITMAP;
N
N/* This structure may not be changed because the data that it
N   expects is read in binary form (via any kind of interface,
N   at runtime).
N   This structure should therefor not be changed.
N*/
Ntypedef struct {
N  U16 ID;
X  unsigned short ID;
N  U16 Format;
X  unsigned short Format;
N  U16 XSize;
X  unsigned short XSize;
N  U16 YSize;
X  unsigned short YSize;
N  U16 BytesPerLine;
X  unsigned short BytesPerLine;
N  U16 BitsPerPixel;
X  unsigned short BitsPerPixel;
N  U16 NumColors;
X  unsigned short NumColors;
N  U16 HasTrans;
X  unsigned short HasTrans;
N} GUI_BITMAP_STREAM;
N
Ntypedef struct {
N  int    Cmd;
N  U32    v;
X  unsigned long    v;
N  void * p;
N} GUI_BITMAPSTREAM_PARAM;
N
Ntypedef struct {
N  int XSize;
N  int YSize;
N  int BitsPerPixel;
N  int NumColors;
N  int HasTrans;
N} GUI_BITMAPSTREAM_INFO;
N
Ntypedef void * (* GUI_BITMAPSTREAM_CALLBACK)(GUI_BITMAPSTREAM_PARAM * pParam);
N
Ntypedef struct {
N  int x,y;
N  U8  Pressed;
X  unsigned char  Pressed;
N  U8  Layer;
X  unsigned char  Layer;
N} GUI_PID_STATE;
N
Ntypedef struct {
N  int xPos;
N  int yPos;
N  int xSize;
N  int ySize;
N  int Delay;
N} GUI_GIF_IMAGE_INFO;
N
Ntypedef struct {
N  int xSize;
N  int ySize;
N  int NumImages;
N} GUI_GIF_INFO;
N
N/*********************************************************************
N*
N*       FONT structures
N*/
N
N/* Translation list. Translates a character code into up to 2
N   indices of images to display on top of each other;
N   '' -> index('a'), index('') */
Ntypedef struct {
N  I16P c0;
X  signed short c0;
N  I16P c1;
X  signed short c1;
N} GUI_FONT_TRANSLIST;
N
Ntypedef struct {
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  const GUI_FONT_TRANSLIST GUI_UNI_PTR * pList;
X  const GUI_FONT_TRANSLIST  * pList;
N} GUI_FONT_TRANSINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N} GUI_CHARINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 YSize;
X  unsigned char YSize;
N  I8 XPos;
X  signed char XPos;
N  I8 YPos;
X  signed char YPos;
N  U8 XDist;
X  unsigned char XDist;
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N} GUI_CHARINFO_EXT;
N
Ntypedef struct GUI_FONT_PROP {
N  U16P First;                                              /* First character               */
X  unsigned short First;                                               
N  U16P Last;                                               /* Last character                */
X  unsigned short Last;                                                
N  const GUI_CHARINFO         GUI_UNI_PTR * paCharInfo;     /* Address of first character    */
X  const GUI_CHARINFO          * paCharInfo;      
N  const struct GUI_FONT_PROP GUI_UNI_PTR * pNext;          /* Pointer to next               */
X  const struct GUI_FONT_PROP  * pNext;           
N} GUI_FONT_PROP;
N
Ntypedef struct GUI_FONT_PROP_EXT {
N  U16P First;                                              /* First character               */
X  unsigned short First;                                               
N  U16P Last;                                               /* Last character                */
X  unsigned short Last;                                                
N  const GUI_CHARINFO_EXT         GUI_UNI_PTR * paCharInfo; /* Address of first character    */
X  const GUI_CHARINFO_EXT          * paCharInfo;  
N  const struct GUI_FONT_PROP_EXT GUI_UNI_PTR * pNext;      /* Pointer to next               */
X  const struct GUI_FONT_PROP_EXT  * pNext;       
N} GUI_FONT_PROP_EXT;
N
Ntypedef struct {
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N  const U8 GUI_UNI_PTR * pTransData;
X  const unsigned char  * pTransData;
N  const GUI_FONT_TRANSINFO GUI_UNI_PTR * pTrans;
X  const GUI_FONT_TRANSINFO  * pTrans;
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N} GUI_FONT_MONO;
N
N/*********************************************************************
N*
N*       FONT structures
N*
N* This structure is used when retrieving information about a font.
N* It is designed for future expansion without incompatibilities.
N*/
Ntypedef struct {
N  U16 Flags;
X  unsigned short Flags;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N} GUI_FONTINFO;
N
N#define GUI_FONTINFO_FLAG_PROP    (1 << 0)    /* Is proportional */
N#define GUI_FONTINFO_FLAG_MONO    (1 << 1)    /* Is monospaced */
N#define GUI_FONTINFO_FLAG_AA      (1 << 2)    /* Is an antialiased font */
N#define GUI_FONTINFO_FLAG_AA2     (1 << 3)    /* Is an antialiased font, 2bpp */
N#define GUI_FONTINFO_FLAG_AA4     (1 << 4)    /* Is an antialiased font, 4bpp */
N#define GUI_FONTINFO_FLAG_PROPFRM (1 << 5)    /* Is proportional, framed */
N
N/*********************************************************************
N*
N*       UNICODE Encoding
N*/
Ntypedef U16  tGUI_GetCharCode(const char GUI_UNI_PTR *s);
Xtypedef unsigned short  tGUI_GetCharCode(const char  *s);
Ntypedef int  tGUI_GetCharSize(const char GUI_UNI_PTR *s);
Xtypedef int  tGUI_GetCharSize(const char  *s);
Ntypedef int  tGUI_CalcSizeOfChar(U16 Char);
Xtypedef int  tGUI_CalcSizeOfChar(unsigned short Char);
Ntypedef int  tGUI_Encode(char *s, U16 Char);
Xtypedef int  tGUI_Encode(char *s, unsigned short Char);
N
Ntypedef struct {
N  tGUI_GetCharCode*            pfGetCharCode;
N  tGUI_GetCharSize*            pfGetCharSize;
N  tGUI_CalcSizeOfChar*         pfCalcSizeOfChar;
N  tGUI_Encode*                 pfEncode;
N} GUI_UC_ENC_APILIST;
N
N/*********************************************************************
N*
N*       FONT Encoding
N*/
Ntypedef int  tGUI_GetLineDistX(const char GUI_UNI_PTR *s, int Len);
Xtypedef int  tGUI_GetLineDistX(const char  *s, int Len);
Ntypedef int  tGUI_GetLineLen(const char GUI_UNI_PTR *s, int MaxLen);
Xtypedef int  tGUI_GetLineLen(const char  *s, int MaxLen);
Ntypedef void tGL_DispLine(const char GUI_UNI_PTR *s, int Len);
Xtypedef void tGL_DispLine(const char  *s, int Len);
N
Ntypedef struct {
N  tGUI_GetLineDistX*          pfGetLineDistX;
N  tGUI_GetLineLen*            pfGetLineLen;
N  tGL_DispLine*               pfDispLine;
N} tGUI_ENC_APIList;
N
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_SJIS;
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_EXT;
N
N/*********************************************************************
N*
N*       FONT methods
N*/
Ntypedef struct GUI_FONT GUI_FONT;
N
Ntypedef void GUI_DISPCHAR    (U16 c);
Xtypedef void GUI_DISPCHAR    (unsigned short c);
Ntypedef int  GUI_GETCHARDISTX(U16P c);
Xtypedef int  GUI_GETCHARDISTX(unsigned short c);
Ntypedef void GUI_GETFONTINFO (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi);
Xtypedef void GUI_GETFONTINFO (const GUI_FONT  * pFont, GUI_FONTINFO * pfi);
Ntypedef char GUI_ISINFONT    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xtypedef char GUI_ISINFONT    (const GUI_FONT  * pFont, unsigned short c);
Ntypedef int  GUI_GETCHARINFO (U16P c, GUI_CHARINFO_EXT * pInfo);
Xtypedef int  GUI_GETCHARINFO (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N
N#define DECLARE_FONT(Type)                                     \
Nvoid GUI##Type##_DispChar    (U16P c);                         \
Nint  GUI##Type##_GetCharDistX(U16P c);                         \
Nvoid GUI##Type##_GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi); \
Nchar GUI##Type##_IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c); \
Nint  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
X#define DECLARE_FONT(Type)                                     void GUI##Type##_DispChar    (U16P c);                         int  GUI##Type##_GetCharDistX(U16P c);                         void GUI##Type##_GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi); char GUI##Type##_IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c); int  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/* MONO: Monospaced fonts */
NDECLARE_FONT(MONO);
Xvoid GUIMONO_DispChar (unsigned short c); int GUIMONO_GetCharDistX(unsigned short c); void GUIMONO_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIMONO_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIMONO_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_MONO       \
N  GUIMONO_DispChar,             \
N  GUIMONO_GetCharDistX,         \
N  GUIMONO_GetFontInfo,          \
N  GUIMONO_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_MONO         GUIMONO_DispChar,               GUIMONO_GetCharDistX,           GUIMONO_GetFontInfo,            GUIMONO_IsInFont,               (GUI_GETCHARINFO *)0,           (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts */
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c); void GUIPROP_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP       \
N  GUIPROP_DispChar,             \
N  GUIPROP_GetCharDistX,         \
N  GUIPROP_GetFontInfo,          \
N  GUIPROP_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP         GUIPROP_DispChar,               GUIPROP_GetCharDistX,           GUIPROP_GetFontInfo,            GUIPROP_IsInFont,               (GUI_GETCHARINFO *)0,           (tGUI_ENC_APIList*)0
N
N/* PROP_EXT: Extended proportional fonts */
NDECLARE_FONT(PROP_EXT);
Xvoid GUIPROP_EXT_DispChar (unsigned short c); int GUIPROP_EXT_GetCharDistX(unsigned short c); void GUIPROP_EXT_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_EXT_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_EXT       \
N  GUIPROP_EXT_DispChar,             \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_EXT         GUIPROP_EXT_DispChar,               GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_FRM: Extended proportional fonts, framed */
NDECLARE_FONT(PROP_FRM);
Xvoid GUIPROP_FRM_DispChar (unsigned short c); int GUIPROP_FRM_GetCharDistX(unsigned short c); void GUIPROP_FRM_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_FRM_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_FRM_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_FRM       \
N  GUIPROP_FRM_DispChar,             \
N  GUIPROP_FRM_GetCharDistX,         \
N  GUIPROP_FRM_GetFontInfo,          \
N  GUIPROP_FRM_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_FRM         GUIPROP_FRM_DispChar,               GUIPROP_FRM_GetCharDistX,           GUIPROP_FRM_GetFontInfo,            GUIPROP_FRM_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts SJIS */
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c); void GUIPROP_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_SJIS  \
N  GUIPROP_DispChar,             \
N  GUIPROP_GetCharDistX,         \
N  GUIPROP_GetFontInfo,          \
N  GUIPROP_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_SJIS    GUIPROP_DispChar,               GUIPROP_GetCharDistX,           GUIPROP_GetFontInfo,            GUIPROP_IsInFont,               (GUI_GETCHARINFO *)0,           &GUI_ENC_APIList_SJIS
N
N/* PROPAA: Proportional, antialiased fonts */
NDECLARE_FONT(PROPAA);
Xvoid GUIPROPAA_DispChar (unsigned short c); int GUIPROPAA_GetCharDistX(unsigned short c); void GUIPROPAA_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROPAA_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROPAA_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROPAA       \
N  GUIPROPAA_DispChar,             \
N  GUIPROPAA_GetCharDistX,         \
N  GUIPROPAA_GetFontInfo,          \
N  GUIPROPAA_IsInFont,             \
N  (GUI_GETCHARINFO *)0,           \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROPAA         GUIPROPAA_DispChar,               GUIPROPAA_GetCharDistX,           GUIPROPAA_GetFontInfo,            GUIPROPAA_IsInFont,               (GUI_GETCHARINFO *)0,             (tGUI_ENC_APIList*)0
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp */
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c); void GUIPROP_AA2_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA2_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA2       \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA2         GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA2_EXT: Proportional, antialiased fonts, 2bpp, extended font information */
NDECLARE_FONT(PROP_AA2_EXT);
Xvoid GUIPROP_AA2_EXT_DispChar (unsigned short c); int GUIPROP_AA2_EXT_GetCharDistX(unsigned short c); void GUIPROP_AA2_EXT_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_EXT_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA2_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA2_EXT   \
N  GUIPROP_AA2_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA2_EXT     GUIPROP_AA2_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp, SJIS encoding */
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c); void GUIPROP_AA2_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA2_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA2_SJIS  \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  GUI_ENCODE_SJIS
X#define GUI_FONTTYPE_PROP_AA2_SJIS    GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               GUI_ENCODE_SJIS
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp */
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c); void GUIPROP_AA4_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA4_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA4       \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA4         GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA4_EXT: Proportional, antialiased fonts, 4bpp, extended font information */
NDECLARE_FONT(PROP_AA4_EXT);
Xvoid GUIPROP_AA4_EXT_DispChar (unsigned short c); int GUIPROP_AA4_EXT_GetCharDistX(unsigned short c); void GUIPROP_AA4_EXT_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_EXT_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA4_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA4_EXT   \
N  GUIPROP_AA4_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA4_EXT     GUIPROP_AA4_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp, SJIS encoding */
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c); void GUIPROP_AA4_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA4_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA4_SJIS  \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  GUI_ENCODE_SJIS
X#define GUI_FONTTYPE_PROP_AA4_SJIS    GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               GUI_ENCODE_SJIS
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
Nstruct GUI_FONT {
N  GUI_DISPCHAR     * pfDispChar; 
N  GUI_GETCHARDISTX * pfGetCharDistX; 
N  GUI_GETFONTINFO  * pfGetFontInfo; 
N  GUI_ISINFONT     * pfIsInFont;
N  GUI_GETCHARINFO  * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N  U8 YSize;
X  unsigned char YSize;
N  U8 YDist;
X  unsigned char YDist;
N  U8 XMag;
X  unsigned char XMag;
N  U8 YMag;
X  unsigned char YMag;
N  union {
N    const void              GUI_UNI_PTR * pFontData;
X    const void               * pFontData;
N    const GUI_FONT_MONO     GUI_UNI_PTR * pMono;
X    const GUI_FONT_MONO      * pMono;
N    const GUI_FONT_PROP     GUI_UNI_PTR * pProp;
X    const GUI_FONT_PROP      * pProp;
N    const GUI_FONT_PROP_EXT GUI_UNI_PTR * pPropExt;
X    const GUI_FONT_PROP_EXT  * pPropExt;
N  } p;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* Height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* Height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N};
N
N/*********************************************************************
N*
N*       System independent font structures (SIF)
N*/
Ntypedef struct {
N  U32 ID;           /* Font file ID */
X  unsigned long ID;            
N  U16 YSize;        /* Height of font */
X  unsigned short YSize;         
N  U16 YDist;        /* Space of font Y */
X  unsigned short YDist;         
N  U16 Baseline;     /* Index of baseline */
X  unsigned short Baseline;      
N  U16 LHeight;      /* Height of a small lower case character (a) */
X  unsigned short LHeight;       
N  U16 CHeight;      /* Height of a upper case character (A) */
X  unsigned short CHeight;       
N  U16 NumAreas;     /* Number of character areas */
X  unsigned short NumAreas;      
N} GUI_SI_FONT;
N
Ntypedef struct {
N  U16 First;        /* Index of first character */
X  unsigned short First;         
N  U16 Last;         /* Index of last character */
X  unsigned short Last;          
N} GUI_SIF_CHAR_AREA;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 BytesPerLine; /* Number of bytes per line */
X  unsigned short BytesPerLine;  
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 YSize;        /* Size of bitmap data in X */
X  unsigned short YSize;         
N  I16 XOff;         /* Display offset of bitmap data in X */
X  signed short XOff;          
N  I16 YOff;         /* Display offset of bitmap data in Y */
X  signed short YOff;          
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO_EXT;
N
Ntypedef struct tGUI_SIF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_SIF_APIList;
N
N#define GUI_SIF_TYPE              tGUI_SIF_APIList
N#define GUI_SIF_TYPE_PROP         &GUI_SIF_APIList_Prop
N#define GUI_SIF_TYPE_PROP_EXT     &GUI_SIF_APIList_Prop_Ext
N#define GUI_SIF_TYPE_PROP_FRM     &GUI_SIF_APIList_Prop_Frm
N#define GUI_SIF_TYPE_PROP_AA2     &GUI_SIF_APIList_Prop_AA2
N#define GUI_SIF_TYPE_PROP_AA4     &GUI_SIF_APIList_Prop_AA4
N#define GUI_SIF_TYPE_PROP_AA2_EXT &GUI_SIF_APIList_Prop_AA2_EXT
N#define GUI_SIF_TYPE_PROP_AA4_EXT &GUI_SIF_APIList_Prop_AA4_EXT
N
N/*********************************************************************
N*
N*       External binary font structures (XBF)
N*/
Ntypedef int GUI_XBF_GET_DATA_FUNC(U32 Off, U16 NumBytes, void * pVoid, void * pBuffer);
Xtypedef int GUI_XBF_GET_DATA_FUNC(unsigned long Off, unsigned short NumBytes, void * pVoid, void * pBuffer);
N
Ntypedef struct {
N  U16 First;                         /* First character of font */
X  unsigned short First;                          
N  U16 Last;                          /* Last character of font */
X  unsigned short Last;                           
N  void * pVoid;                      /* Void pointer passed to GetData-function */
N  GUI_XBF_GET_DATA_FUNC * pfGetData; /* Pointer to callback function */
N} GUI_XBF_DATA;
N
Ntypedef struct tGUI_XBF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_XBF_APIList;
N
N#define GUI_XBF_TYPE              tGUI_XBF_APIList
N#define GUI_XBF_TYPE_PROP         &GUI_XBF_APIList_Prop
N#define GUI_XBF_TYPE_PROP_EXT     &GUI_XBF_APIList_Prop_Ext
N#define GUI_XBF_TYPE_PROP_FRM     &GUI_XBF_APIList_Prop_Frm
N#define GUI_XBF_TYPE_PROP_AA2_EXT &GUI_XBF_APIList_Prop_AA2_Ext
N#define GUI_XBF_TYPE_PROP_AA4_EXT &GUI_XBF_APIList_Prop_AA4_Ext
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
Ntypedef struct {
N  const void * pData;      /* Pointer to TTF font file in addressable memory area */
N  U32 NumBytes;            /* Size of file in bytes */
X  unsigned long NumBytes;             
N} GUI_TTF_DATA;
N
Ntypedef struct {
N  GUI_TTF_DATA * pTTF;     /* Pointer to GUI_TTF_DATA structure which contains location and size of font file */
N  U32 aImageTypeBuffer[4]; /* Buffer for image type structure */
X  unsigned long aImageTypeBuffer[4];  
N  int PixelHeight;         /* Pixel height of new font. It means the height of the surrounding rectangle
N                            * between the glyphs 'g' anf 'f'. Please notice that it is not the distance
N                            * between two lines of text. With other words the value returned byGUI_GetFontSizeY()
N                            * is not identically with this value. */
N  int FaceIndex;           /* Some font files can contain more than one font face. In case of more than one face
N                            * this index specifies the zero based face index to be used to create the font. 
N                            * Usually 0. */
N} GUI_TTF_CS;
N
N/*********************************************************************
N*
N*       Memory management
N*/
N#ifndef     GUI_HMEM
N  #define     GUI_HMEM        I32
N#endif
N#define     GUI_HMEM_NULL     (0)
Ntypedef     GUI_HMEM      GUI_HWIN;
Xtypedef     signed long      GUI_HWIN;
Ntypedef     GUI_HMEM      GUI_HSPRITE;
Xtypedef     signed long      GUI_HSPRITE;
N
N/*********************************************************************
N*
N*       Hardware routines
N*/
Ntypedef struct {
N  //
N  // 8 Bit access
N  //
N  void (* pfWrite8_A0)  (U8 Data);
X  void (* pfWrite8_A0)  (unsigned char Data);
N  void (* pfWrite8_A1)  (U8 Data);
X  void (* pfWrite8_A1)  (unsigned char Data);
N  void (* pfWriteM8_A0) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A0) (unsigned char * pData, int NumItems);
N  void (* pfWriteM8_A1) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A1) (unsigned char * pData, int NumItems);
N  U8   (* pfRead8_A0)   (void);
X  unsigned char   (* pfRead8_A0)   (void);
N  U8   (* pfRead8_A1)   (void);
X  unsigned char   (* pfRead8_A1)   (void);
N  void (* pfReadM8_A0)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A0)  (unsigned char * pData, int NumItems);
N  void (* pfReadM8_A1)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A1)  (unsigned char * pData, int NumItems);
N  //
N  // 16 Bit access
N  //
N  void (* pfWrite16_A0) (U16 Data);
X  void (* pfWrite16_A0) (unsigned short Data);
N  void (* pfWrite16_A1) (U16 Data);
X  void (* pfWrite16_A1) (unsigned short Data);
N  void (* pfWriteM16_A0)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A0)(unsigned short * pData, int NumItems);
N  void (* pfWriteM16_A1)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A1)(unsigned short * pData, int NumItems);
N  U16  (* pfRead16_A0)  (void);
X  unsigned short  (* pfRead16_A0)  (void);
N  U16  (* pfRead16_A1)  (void);
X  unsigned short  (* pfRead16_A1)  (void);
N  void (* pfReadM16_A0) (U16 * pData, int NumItems);
X  void (* pfReadM16_A0) (unsigned short * pData, int NumItems);
N  void (* pfReadM16_A1) (U16 * pData, int NumItems);
X  void (* pfReadM16_A1) (unsigned short * pData, int NumItems);
N  //
N  // Optional 'flush'
N  //
N  void (* pfFlushBuffer)(void);
N} GUI_PORT_API;
N
N#endif  /* GUITYPE_H_INCLUDED */
N
N/*************************** End of file ****************************/
L 23 "GUI\GUI.h" 2
N#include "GUI_Version.h"
L 1 "GUI\GUI_Version.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI_Version.h
NPurpose     : Include file defining current GUI version
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_VERSION_H
N#define  GUI_VERSION_H
N
N#define GUI_VERSION 50500
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 24 "GUI\GUI.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Disable string function warning with newer MSVC versions
N*/
N#if defined (_MSC_VER)
X#if 0L
S  #if (_MSC_VER > 1200)
S    #pragma warning( disable : 4996)
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       Macros, function replacement
N*/
N#define GUI_COUNTOF(a)          (sizeof(a) / sizeof(a[0]))
N#define GUI_MIN(a,b)            (((a) < (b)) ? (a) : (b))
N#define GUI_MAX(a,b)            (((a) > (b)) ? (a) : (b))
N#define GUI_ZEROFILL(p, Size)   (memset(p, 0, Size))
N
N/*********************************************************************
N*
N*       Support for multitasking systems (locking)
N*/
Ntypedef struct GUI_CONTEXT GUI_CONTEXT;
N
N#if !GUI_OS
X#if !(1)
S  #define GUI_LOCK()
S  #define GUI_UNLOCK()
S  #define GUITASK_INIT()
S  #define GUITASK_COPY_CONTEXT()
N#else
N  void GUI_Lock(void);
N  void GUI_Unlock(void);
N  void GUITASK_Init(void);
N  void GUITASK_CopyContext(void);
N  GUI_CONTEXT * GUITASK_GetpContext(int Index);
N  #define GUI_LOCK()             GUI_Lock()
N  #define GUI_UNLOCK()           GUI_Unlock()
N  #define GUITASK_INIT()         GUITASK_Init()
N  #define GUITASK_COPY_CONTEXT() GUITASK_CopyContext()
N#endif
N
N/*********************************************************************
N*
N*       API table of a display driver
N*/
Nstruct GUI_DEVICE_API {
N  //
N  // Data
N  //
N  int DeviceClassIndex;
N  //
N  // Drawing functions
N  //
N  void     (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void     (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char  * pData, int Diff, const unsigned long * pTrans);
N  void     (* pfDrawHLine    )(GUI_DEVICE * pDevice, int x0, int y0,  int x1);
N  void     (* pfDrawVLine    )(GUI_DEVICE * pDevice, int x , int y0,  int y1);
N  void     (* pfFillRect     )(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1);
N  unsigned (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
N  void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
N  void     (* pfXorPixel     )(GUI_DEVICE * pDevice, int x, int y);
N  //
N  // Set origin
N  //
N  void     (* pfSetOrg       )(GUI_DEVICE * pDevice, int x, int y);
N  //
N  // Request information
N  //
N  void   (*(* pfGetDevFunc)   (GUI_DEVICE * pDevice, int Index))(void);
N  I32      (* pfGetDevProp   )(GUI_DEVICE * pDevice, int Index);
X  signed long      (* pfGetDevProp   )(GUI_DEVICE * pDevice, int Index);
N  void    *(* pfGetDevData   )(GUI_DEVICE * pDevice, int Index);
N  void     (* pfGetRect      )(GUI_DEVICE * pDevice, LCD_RECT * pRect);
N};
N
N/*********************************************************************
N*
N*       Device classes
N*/
Ntypedef enum { 
N  DEVICE_CLASS_DRIVER,
N  DEVICE_CLASS_DRIVER_MODIFIER,   // Zoom or delta-pixel modifier
N  DEVICE_CLASS_VNC,
N  DEVICE_CLASS_SPRITE,
N  DEVICE_CLASS_MEMDEV,
N  DEVICE_CLASS_ALPHA,
N  DEVICE_CLASS_AUTOALPHA,
N  DEVICE_CLASS_MEASDEV
N} DEVICE_CLASS;
N
N#define GUI_DEVICE_STAYONTOP 1
N
N/*********************************************************************
N*
N*       Display drivers
N*/
N//
N// Addresses
N//
Nextern const GUI_DEVICE_API GUIDRV_Win_API;
N
Nextern const GUI_DEVICE_API GUIDRV_Template_API;
N
N//
N// Macros to be used in configuration files
N//
N#define GUIDRV_WIN32       &GUIDRV_Win_API
N
N#if defined(WIN32) && !defined(LCD_SIMCONTROLLER)
X#if 0L && !0L
S
S  #define GUIDRV_TEMPLATE         &GUIDRV_Win_API
S
N#else
N
N  #define GUIDRV_TEMPLATE         &GUIDRV_Template_API
N
N#endif
N
N/*********************************************************************
N*
N*       Definition of GUI_DEVICE structure
N*/
Nstruct GUI_DEVICE {
N  //
N  // Linking
N  //
N  GUI_DEVICE * pNext;
N  GUI_DEVICE * pPrev;
N  //
N  // Data
N  //
N  union {
N    GUI_HMEM hContext; // Handle of payload data like sprite- or memory device context
X    signed long hContext; 
N    void   * pContext; // Pointer for context data in a fixed block
N  } u;
N  //
N  // API pointers
N  //
N  const GUI_DEVICE_API     * pDeviceAPI;
N  const LCD_API_COLOR_CONV * pColorConvAPI;
N  U16 Flags;
X  unsigned short Flags;
N  int LayerIndex;
N};
N
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_1;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_8;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_16;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_32;
N
N/*********************************************************************
N*
N*       GUI_CONTEXT
N*
N*  This structure is public for one reason only:
N*  To allow the application to save and restore the context.
N*/
Ntypedef union {
N  U8  aColorIndex8[2];
X  unsigned char  aColorIndex8[2];
N  U16 aColorIndex16[2];
X  unsigned short aColorIndex16[2];
N  U32 aColorIndex32[2];
X  unsigned long aColorIndex32[2];
N} LCD_COLORINDEX_UNION;
N
Nstruct GUI_CONTEXT {
N  //
N  // Variables in LCD module
N  //
N  LCD_COLORINDEX_UNION LCD;
N  LCD_RECT       ClipRect;
N  U8             DrawMode;
X  unsigned char             DrawMode;
N  U8             SelLayer;
X  unsigned char             SelLayer;
N  U8             TextStyle;
X  unsigned char             TextStyle;
N  //
N  // Variables in GL module
N  //
N  GUI_RECT * pClipRect_HL;                 // High level clip rectangle ... Speed optimization so drawing routines can optimize
N  U8         PenSize;
X  unsigned char         PenSize;
N  U8         PenShape;
X  unsigned char         PenShape;
N  U8         LineStyle;
X  unsigned char         LineStyle;
N  //
N  // Variables in GUICHAR module
N  //
N  const GUI_FONT           GUI_UNI_PTR * pAFont;
X  const GUI_FONT            * pAFont;
N  const GUI_UC_ENC_APILIST * pUC_API;    // Unicode encoding API
N  I16P LBorder;
X  signed short LBorder;
N  I16P DispPosX, DispPosY;
X  signed short DispPosX, DispPosY;
N  I16P DrawPosX, DrawPosY;
X  signed short DrawPosX, DrawPosY;
N  I16P TextMode, TextAlign;
X  signed short TextMode, TextAlign;
N  GUI_COLOR Color, BkColor;                // Required only when changing devices and for speed opt (caching)
N  //
N  // Variables in WM module
N  //
N  #if GUI_WINSUPPORT
X  #if (1)
N    const GUI_RECT* WM__pUserClipRect;
N    GUI_HWIN hAWin;
N    int xOff, yOff;
N  #endif
N  //
N  // Array of pointers to device chains
N  //
N  GUI_DEVICE * apDevice[GUI_NUM_LAYERS];
X  GUI_DEVICE * apDevice[(16)];
N  //
N  // Variables in MEMDEV module (with memory devices only)
N  //
N  GUI_HMEM    hDevData;
X  signed long    hDevData;
N  GUI_RECT    ClipRectPrev;
N  //
N  // Variables in Anitaliasing module
N  //
N  const tLCD_HL_APIList * pLCD_HL;       // Required to reroute drawing (HLine & Pixel) to the AA module
N  U8 AA_Factor;
X  unsigned char AA_Factor;
N  U8 AA_HiResEnable;
X  unsigned char AA_HiResEnable;
N};
N
N/* Rename GUI_SaveContext in order to avoid crashes if wrong GUIConf is used */
N#if (GUI_WINSUPPORT == 1)
X#if ((1) == 1)
N  #define GUI_SaveContext GUI_SaveContext_W
N#else
S  #define GUI_SaveContext GUI_SaveContext_
N#endif
N
N/*********************************************************************
N*
N*       Device management
N*/
NGUI_DEVICE * GUI_DEVICE_Create       (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_Create       (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
NGUI_DEVICE * GUI_DEVICE_CreateAndLink(const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_CreateAndLink(const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
Nvoid         GUI_DEVICE_Delete       (GUI_DEVICE * pDevice);
Nint          GUI_DEVICE_Link         (GUI_DEVICE * pDevice);
Nvoid         GUI_DEVICE_Unlink       (GUI_DEVICE * pDevice);
NGUI_DEVICE * GUI_DEVICE__GetpDriver  (int LayerIndex);
NGUI_DEVICE * GUI_DEVICE__GetpDevice  (int LayerIndex, int DeviceClass);
N
N/*********************************************************************
N*
N*       General routines
N*/
Nint          GUI_Init             (void);
Nvoid         GUI_SetDefault       (void);
NGUI_DRAWMODE GUI_SetDrawMode      (GUI_DRAWMODE dm);
Nconst char * GUI_GetVersionString (void);
Nvoid         GUI_SaveContext      (      GUI_CONTEXT* pContext);
Xvoid         GUI_SaveContext_W      (      GUI_CONTEXT* pContext);
Nvoid         GUI_RestoreContext   (const GUI_CONTEXT* pContext);
Nvoid         GUI_SetScreenSizeX   (int xSize);
Nvoid         GUI_SetScreenSizeY   (int ySize);
Nint          GUI_GetScreenSizeX   (void);
Nint          GUI_GetScreenSizeY   (void);
Nconst GUI_RECT * GUI_SetClipRect  (const GUI_RECT * pRect);
N
N/*********************************************************************
N*
N*       Rectangle helper functions
N*/
Nint  GUI_RectsIntersect(const GUI_RECT* pr0, const GUI_RECT* pr1);
Nvoid GUI_MoveRect       (GUI_RECT *pRect, int x, int y);
Nvoid GUI_MergeRect      (GUI_RECT* pDest, const GUI_RECT* pr0, const GUI_RECT* pr1);
Nint  GUI__IntersectRects(GUI_RECT* pDest, const GUI_RECT* pr0, const GUI_RECT* pr1);
Nvoid GUI__IntersectRect (GUI_RECT* pDest, const GUI_RECT* pr0);
Nvoid GUI__ReduceRect    (GUI_RECT* pDest, const GUI_RECT *pRect, int Dist);
N
N/*********************************************************************
N*
N*       Misc helper functions
N*/
Nvoid GUI__CompactPixelIndices  (LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel);
Xvoid GUI__CompactPixelIndices  (unsigned long * pBuffer, int NumPixels, int BitsPerPixel);
Nvoid GUI__CompactPixelIndicesEx(LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel, tLCDDEV_Color2Index * pfColor2Index);
Xvoid GUI__CompactPixelIndicesEx(unsigned long * pBuffer, int NumPixels, int BitsPerPixel, tLCDDEV_Color2Index * pfColor2Index);
Nvoid GUI__Config(void);
NI32  GUI__CosHQ(I32 Ang1000);
Xsigned long  GUI__CosHQ(signed long Ang1000);
Nint  GUI__DivideRound     (int a, int b);
NI32  GUI__DivideRound32   (I32 a, I32 b);
Xsigned long  GUI__DivideRound32   (signed long a, signed long b);
Nvoid GUI__ExpandPixelIndices   (void * pBuffer, int NumPixels, int BitsPerPixel);
Nvoid GUI__ExpandPixelIndicesEx (void * pBuffer, int NumPixels, int BitsPerPixel, tLCDDEV_Index2Color * pfIndex2Color);
Nvoid GUI__memcpy(void * pDest, const void * pSrc, int NumBytes);
Nint  GUI__SetText(GUI_HMEM * phText, const char * s);
Xint  GUI__SetText(signed long * phText, const char * s);
NI32  GUI__SinHQ(I32 Ang1000);
Xsigned long  GUI__SinHQ(signed long Ang1000);
N
N/*********************************************************************
N*
N*       Get / Set Attributes
N*/
NGUI_COLOR GUI_GetBkColor     (void);
NGUI_COLOR GUI_GetColor       (void);
Nint       GUI_GetBkColorIndex(void);
Nint       GUI_GetColorIndex  (void);
NU8        GUI_GetPenSize     (void);
Xunsigned char        GUI_GetPenSize     (void);
NU8        GUI_GetPenShape    (void);
Xunsigned char        GUI_GetPenShape    (void);
NU8        GUI_GetLineStyle   (void);
Xunsigned char        GUI_GetLineStyle   (void);
N
Nvoid      GUI_SetBkColor   (GUI_COLOR);
Nvoid      GUI_SetColor     (GUI_COLOR);
Nvoid      GUI_SetBkColorIndex(int Index);
Nvoid      GUI_SetColorIndex(int Index);
N
NU8        GUI_SetPenSize   (U8 Size);
Xunsigned char        GUI_SetPenSize   (unsigned char Size);
NU8        GUI_SetPenShape  (U8 Shape);
Xunsigned char        GUI_SetPenShape  (unsigned char Shape);
NU8        GUI_SetLineStyle (U8 Style);
Xunsigned char        GUI_SetLineStyle (unsigned char Style);
N
N/* Get/Set Character used as decimal point (usually '.' or ',') */
Nchar      GUI_GetDecChar(void);
Nchar      GUI_SetDecChar(char c);
N
N/*********************************************************************
N*
N*       Color / Index related functions
N*/
Nint       GUI_Color2Index(GUI_COLOR color);
NGUI_COLOR GUI_Color2VisColor(GUI_COLOR color);
Nchar      GUI_ColorIsAvailable(GUI_COLOR color);
NGUI_COLOR GUI_Index2Color(int Index);
NU32       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
Xunsigned long       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
NU32       GUI_CalcVisColorError(GUI_COLOR color);
Xunsigned long       GUI_CalcVisColorError(GUI_COLOR color);
N
N/*********************************************************************
N*
N*       Logging (for debugging primarily)
N*/
Nvoid GUI_Log      (const char *s);
Nvoid GUI_Log1     (const char *s, int p0);
Nvoid GUI_Log2     (const char *s, int p0, int p1);
Nvoid GUI_Log3     (const char *s, int p0, int p1, int p2);
Nvoid GUI_Log4     (const char *s, int p0, int p1, int p2,int p3);
Nvoid GUI_Warn     (const char *s);
Nvoid GUI_Warn1    (const char *s, int p0);
Nvoid GUI_Warn2    (const char *s, int p0, int p1);
Nvoid GUI_Warn3    (const char *s, int p0, int p1, int p2);
Nvoid GUI_Warn4    (const char *s, int p0, int p1, int p2, int p3);
Nvoid GUI_ErrorOut (const char *s);
Nvoid GUI_ErrorOut1(const char *s, int p0);
Nvoid GUI_ErrorOut2(const char *s, int p0, int p1);
Nvoid GUI_ErrorOut3(const char *s, int p0, int p1, int p2);
Nvoid GUI_ErrorOut4(const char *s, int p0, int p1, int p2, int p3);
N
N/*********************************************************************
N*
N*       2d - GL
N*/
Nvoid GUI_Clear            (void);
Nvoid GUI_ClearRect        (int x0, int y0, int x1, int y1);
Nvoid GUI_ClearRectEx      (const GUI_RECT* pRect);
Nvoid GUI_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_DrawBitmap       (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0);
Xvoid GUI_DrawBitmap       (const GUI_BITMAP  * pBM, int x0, int y0);
Nvoid GUI_DrawBitmapMag    (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0, int XMul, int YMul);
Xvoid GUI_DrawBitmapMag    (const GUI_BITMAP  * pBM, int x0, int y0, int XMul, int YMul);
Nvoid GUI_DrawBitmapEx     (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Xvoid GUI_DrawBitmapEx     (const GUI_BITMAP  * pBM, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Nvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const U8 GUI_UNI_PTR * pData, const GUI_LOGPALETTE GUI_UNI_PTR * pPal);
Xvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const unsigned char  * pData, const GUI_LOGPALETTE  * pPal);
Nvoid GUI_DrawBitmapHWAlpha(const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0);
Xvoid GUI_DrawBitmapHWAlpha(const GUI_BITMAP  * pBM, int x0, int y0);
Nvoid GUI_DrawCircle       (int x0, int y0, int r);
Nvoid GUI_DrawEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_DrawGradientV    (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientH    (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGraph        (I16 *pay, int NumPoints, int x0, int y0);
Xvoid GUI_DrawGraph        (signed short *pay, int NumPoints, int x0, int y0);
Nvoid GUI_DrawGraphEx      (I16 *pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Xvoid GUI_DrawGraphEx      (signed short *pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Nvoid GUI_DrawHLine        (int y0, int x0, int x1);
Nvoid GUI_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawLineRel      (int dx, int dy);
Nvoid GUI_DrawLineTo       (int x, int y);
Nvoid GUI_DrawPie          (int x0, int y0, int r, int a0, int a1, int Type);
Nvoid GUI_DrawPixel        (int x, int y);
Nvoid GUI_DrawPoint        (int x, int y);
Nvoid GUI_DrawPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawPolyLine     (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawFocusRect    (const GUI_RECT *pRect, int Dist);
Nvoid GUI_DrawRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawRectEx       (const GUI_RECT *pRect);
Nvoid GUI_DrawRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_DrawVLine        (int x0, int y0, int y1);
Nvoid GUI_FillCircle       (int x0, int y0, int r);
Nvoid GUI_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_FillPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_FillRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_FillRectEx       (const GUI_RECT* pRect);
Nvoid GUI_FillRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_GetClientRect    (GUI_RECT* pRect);
Nvoid GUI_InvertRect       (int x0, int y0, int x1, int y1);
Nvoid GUI_MoveRel          (int dx, int dy);
Nvoid GUI_MoveTo           (int x, int y);
N
N/*********************************************************************
N*
N*       Graphic file support
N*/
Ntypedef int GUI_GET_DATA_FUNC(void * p, const U8 ** ppData, unsigned NumBytes, U32 Off);
Xtypedef int GUI_GET_DATA_FUNC(void * p, const unsigned char ** ppData, unsigned NumBytes, unsigned long Off);
N
N/*********************************************************************
N*
N*       GIF file support
N*/
Nint GUI_GIF_Draw           (const void * pGIF, U32 NumBytes,         int x0, int y0);
Xint GUI_GIF_Draw           (const void * pGIF, unsigned long NumBytes,         int x0, int y0);
Nint GUI_GIF_DrawEx         (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_GIF_DrawSub        (const void * pGIF, U32 NumBytes,         int x0, int y0, int Index);
Xint GUI_GIF_DrawSub        (const void * pGIF, unsigned long NumBytes,         int x0, int y0, int Index);
Nint GUI_GIF_DrawSubEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index);
Nint GUI_GIF_DrawSubScaled  (const void * pGIF, U32 NumBytes,         int x0, int y0, int Index, int Num, int Denom);
Xint GUI_GIF_DrawSubScaled  (const void * pGIF, unsigned long NumBytes,         int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_DrawSubScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_GetComment     (const void * pGIF, U32 NumBytes,         U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetComment     (const void * pGIF, unsigned long NumBytes,         unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetCommentEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetCommentEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetImageInfo   (const void * pGIF, U32 NumBytes,         GUI_GIF_IMAGE_INFO * pInfo, int Index);
Xint GUI_GIF_GetImageInfo   (const void * pGIF, unsigned long NumBytes,         GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetImageInfoEx (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetInfo        (const void * pGIF, U32 NumBytes,         GUI_GIF_INFO * pInfo);
Xint GUI_GIF_GetInfo        (const void * pGIF, unsigned long NumBytes,         GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetInfoEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetXSize       (const void * pGIF);
Nint GUI_GIF_GetXSizeEx     (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_GIF_GetYSize       (const void * pGIF);
Nint GUI_GIF_GetYSizeEx     (GUI_GET_DATA_FUNC * pfGetData, void * p);
N
N/*********************************************************************
N*
N*       BMP file support
N*/
Nint GUI_BMP_Draw        (const void * pFileData,                  int x0, int y0);
Nint GUI_BMP_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_BMP_DrawScaled  (const void * pFileData,                  int x0, int y0, int Num, int Denom);
Nint GUI_BMP_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint GUI_BMP_GetXSize    (const void * pFileData);
Nint GUI_BMP_GetXSizeEx  (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_BMP_GetYSize    (const void * pFileData);
Nint GUI_BMP_GetYSizeEx  (GUI_GET_DATA_FUNC * pfGetData, void * p);
N
N/*********************************************************************
N*
N*       PNG file support
N*/
Nint GUI_PNG_Draw      (const void * pFileData, int DataSize, int x0, int y0);
Nint GUI_PNG_DrawEx    (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_PNG_GetXSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetXSizeEx(GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_PNG_GetYSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetYSizeEx(GUI_GET_DATA_FUNC * pfGetData, void * p);
N
N/*********************************************************************
N*
N*       JPEG file support
N*/
Ntypedef struct {
N  int XSize;
N  int YSize;
N} GUI_JPEG_INFO;
N
N#if (GUI_SELECT_JPEG == 1)
X#if (0 == 1)
S
S#define GUI_JPEG_Draw(        pFileData, DataSize, x0, y0)             GUI_JPEG1_Draw        (pFileData, DataSize, x0, y0)            
S#define GUI_JPEG_DrawScaled(  pFileData, DataSize, x0, y0, Num, Denom) GUI_JPEG1_DrawScaled  (pFileData, DataSize, x0, y0, Num, Denom)
S#define GUI_JPEG_GetInfo(     pFileData, DataSize, pInfo)              GUI_JPEG1_GetInfo     (pFileData, DataSize, pInfo)             
S#define GUI_JPEG_DrawEx(      pfGetData, p, x0, y0)                    GUI_JPEG1_DrawEx      (pfGetData, p, x0, y0)                   
S#define GUI_JPEG_DrawScaledEx(pfGetData, p, x0, y0, Num, Denom)        GUI_JPEG1_DrawScaledEx(pfGetData, p, x0, y0, Num, Denom)       
S#define GUI_JPEG_GetInfoEx(   pfGetData, p, pInfo)                     GUI_JPEG1_GetInfoEx   (pfGetData, p, pInfo)                    
S
N#else
N
Nint GUI_JPEG_Draw        (const void * pFileData, int DataSize,    int x0, int y0);
Nint GUI_JPEG_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_JPEG_DrawScaled  (const void * pFileData, int DataSize,    int x0, int y0, int Num, int Denom);
Nint GUI_JPEG_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint GUI_JPEG_GetInfo     (const void * pFileData, int DataSize,    GUI_JPEG_INFO* pInfo);
Nint GUI_JPEG_GetInfoEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_JPEG_INFO * pInfo);
N
N#endif
N
Nint GUI_JPEG1_Draw        (const void * pFileData, int DataSize,    int x0, int y0);
Nint GUI_JPEG1_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_JPEG1_DrawScaled  (const void * pFileData, int DataSize,    int x0, int y0, int Num, int Denom);
Nint GUI_JPEG1_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint GUI_JPEG1_GetInfo     (const void * pFileData, int DataSize,    GUI_JPEG_INFO * pContext);
Nint GUI_JPEG1_GetInfoEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_JPEG_INFO * pContext);
N
N/*********************************************************************
N*
N*       Cursor routines
N*/
Ntypedef struct {
N  const GUI_UNI_PTR GUI_BITMAP * pBitmap;
X  const  GUI_BITMAP * pBitmap;
N  int xHot, yHot;
N} GUI_CURSOR;
N
N#if GUI_SUPPORT_CURSOR
X#if ((1) | (1))
N  int                            GUI_CURSOR_GetState     (void);
N  void                           GUI_CURSOR_Hide         (void);
N  void                           GUI_CURSOR_SetXor       (const GUI_BITMAP * pBM, int x, int y);
N  void                           GUI_CURSOR_SetPosition  (int x, int y);
N  const GUI_CURSOR GUI_UNI_PTR * GUI_CURSOR_Select       (const GUI_CURSOR GUI_UNI_PTR * pCursor);
X  const GUI_CURSOR  * GUI_CURSOR_Select       (const GUI_CURSOR  * pCursor);
N  void                           GUI_CURSOR_Show         (void);
N  const GUI_CURSOR GUI_UNI_PTR * GUI_CURSOR_SelectEx     (const GUI_CURSOR GUI_UNI_PTR * pCursor, int Layer);
X  const GUI_CURSOR  * GUI_CURSOR_SelectEx     (const GUI_CURSOR  * pCursor, int Layer);
N  void                           GUI_CURSOR_HideEx       (int Layer);
N  void                           GUI_CURSOR_ShowEx       (int Layer);
N  int                            GUI_CURSOR_GetStateEx   (int Layer);
N  void                           GUI_CURSOR_SetPositionEx(int xNewPos, int yNewPos, int Layer);
N  void                           GUI_CURSOR_GetCursorRect(GUI_RECT * pRect);
N  void                           GUI_CURSOR_GetCursorRectEx(GUI_RECT * pRect, int Layer);
N  void                           GUI_CURSOR_SetPixelIndexEx(int x, int y, int Index, int Layer);
N  void                           GUI_CURSOR_XorPixelIndexEx(int x, int y, int Layer);
N#else
S  #define GUI_CURSOR_Show()
S  #define GUI_CURSOR_Clear();
N#endif
N
N/*********************************************************************
N*
N*       Sprite support
N*/
N#define GUI_SPRITE_CF_STAYONTOP (1 << 0)
N#define GUI_SPRITE_CF_SHOW      (1 << 1)
N
NGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y, int Layer, U16 Flags); /* Not to be documented, only used by cursor modul */
XGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP  * pBM, int x, int y, int Layer, unsigned short Flags);  
NGUI_HSPRITE GUI_SPRITE_Create              (const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y);
XGUI_HSPRITE GUI_SPRITE_Create              (const GUI_BITMAP  * pBM, int x, int y);
NGUI_HSPRITE GUI_SPRITE_CreateEx            (const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y, int Layer);
XGUI_HSPRITE GUI_SPRITE_CreateEx            (const GUI_BITMAP  * pBM, int x, int y, int Layer);
Nvoid        GUI_SPRITE_Delete              (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_GetState            (GUI_HSPRITE hSprite);
Nvoid        GUI_SPRITE_Hide                (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_SetBitmap           (GUI_HSPRITE hSprite, const GUI_BITMAP GUI_UNI_PTR * pBM);
Xint         GUI_SPRITE_SetBitmap           (GUI_HSPRITE hSprite, const GUI_BITMAP  * pBM);
Nint         GUI_SPRITE_SetBitmapAndPosition(GUI_HSPRITE hSprite, const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y);
Xint         GUI_SPRITE_SetBitmapAndPosition(GUI_HSPRITE hSprite, const GUI_BITMAP  * pBM, int x, int y);
Nvoid        GUI_SPRITE_SetPosition         (GUI_HSPRITE hSprite, int x, int y);
Nvoid        GUI_SPRITE_Show                (GUI_HSPRITE hSprite);
N
N/*********************************************************************
N*
N*       Cursors and their bitmaps
N*/
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Xextern const GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Xextern const GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Xextern const GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Xextern const GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Xextern const GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Xextern const GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
Xextern const GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
N
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowS, GUI_BitmapArrowSI;
Xextern const GUI_BITMAP GUI_BitmapArrowS, GUI_BitmapArrowSI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowM, GUI_BitmapArrowMI;
Xextern const GUI_BITMAP GUI_BitmapArrowM, GUI_BitmapArrowMI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowL, GUI_BitmapArrowLI;
Xextern const GUI_BITMAP GUI_BitmapArrowL, GUI_BitmapArrowLI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossS, GUI_BitmapCrossSI;
Xextern const GUI_BITMAP GUI_BitmapCrossS, GUI_BitmapCrossSI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossM, GUI_BitmapCrossMI;
Xextern const GUI_BITMAP GUI_BitmapCrossM, GUI_BitmapCrossMI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossL, GUI_BitmapCrossLI;
Xextern const GUI_BITMAP GUI_BitmapCrossL, GUI_BitmapCrossLI;
N
N/*********************************************************************
N*
N*       Wrap modes
N*/
Ntypedef enum { GUI_WRAPMODE_NONE, GUI_WRAPMODE_WORD, GUI_WRAPMODE_CHAR } GUI_WRAPMODE;
N
N/*********************************************************************
N*
N*       Text related routines
N*/
Nvoid  GUI_DispCEOL             (void);
Nvoid  GUI_DispChar             (U16 c);
Xvoid  GUI_DispChar             (unsigned short c);
Nvoid  GUI_DispCharAt           (U16 c, I16P x, I16P y);
Xvoid  GUI_DispCharAt           (unsigned short c, signed short x, signed short y);
Nvoid  GUI_DispChars            (U16 c, int Cnt);
Xvoid  GUI_DispChars            (unsigned short c, int Cnt);
Nvoid  GUI_DispNextLine         (void);
Nvoid  GUI_DispString           (const char GUI_UNI_PTR * s);
Xvoid  GUI_DispString           (const char  * s);
Nvoid  GUI_DispStringAt         (const char GUI_UNI_PTR * s, int x, int y);
Xvoid  GUI_DispStringAt         (const char  * s, int x, int y);
Nvoid  GUI_DispStringAtCEOL     (const char GUI_UNI_PTR * s, int x, int y);
Xvoid  GUI_DispStringAtCEOL     (const char  * s, int x, int y);
Nvoid  GUI_DispStringHCenterAt  (const char GUI_UNI_PTR * s, int x, int y);
Xvoid  GUI_DispStringHCenterAt  (const char  * s, int x, int y);
Nvoid  GUI__DispStringInRect    (const char GUI_UNI_PTR * s, GUI_RECT * pRect, int TextAlign, int MaxNumChars);
Xvoid  GUI__DispStringInRect    (const char  * s, GUI_RECT * pRect, int TextAlign, int MaxNumChars);
Nvoid  GUI_DispStringInRect     (const char GUI_UNI_PTR * s, GUI_RECT * pRect, int TextAlign);
Xvoid  GUI_DispStringInRect     (const char  * s, GUI_RECT * pRect, int TextAlign);
N#if GUI_SUPPORT_ROTATION
X#if 1
N  void  GUI_DispStringInRectEx (const char GUI_UNI_PTR * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const GUI_ROTATION * pLCD_Api);
X  void  GUI_DispStringInRectEx (const char  * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const tLCD_APIList * pLCD_Api);
N#endif
Nvoid  GUI_DispStringInRectMax  (const char GUI_UNI_PTR * s, GUI_RECT * pRect, int TextAlign, int MaxLen); /* Not to be doc. */
Xvoid  GUI_DispStringInRectMax  (const char  * s, GUI_RECT * pRect, int TextAlign, int MaxLen);  
Nvoid  GUI_DispStringInRectWrap (const char GUI_UNI_PTR * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode); /* Not to be doc. */
Xvoid  GUI_DispStringInRectWrap (const char  * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode);  
Nvoid  GUI_DispStringLen        (const char GUI_UNI_PTR * s, int Len);
Xvoid  GUI_DispStringLen        (const char  * s, int Len);
Nvoid  GUI_GetTextExtend        (GUI_RECT* pRect, const char GUI_UNI_PTR * s, int Len);
Xvoid  GUI_GetTextExtend        (GUI_RECT* pRect, const char  * s, int Len);
Nint   GUI_GetYAdjust           (void);
Nint   GUI_GetDispPosX          (void);
Nint   GUI_GetDispPosY          (void);
Nconst GUI_FONT GUI_UNI_PTR * GUI_GetFont(void);
Xconst GUI_FONT  * GUI_GetFont(void);
Nint   GUI_GetCharDistX(U16 c);
Xint   GUI_GetCharDistX(unsigned short c);
Nint   GUI_GetStringDistX       (const char GUI_UNI_PTR * s);
Xint   GUI_GetStringDistX       (const char  * s);
NGUI_DRAWMODE GUI_GetDrawMode   (void);
Nint   GUI_GetFontDistY         (void);
Nint   GUI_GetFontSizeY         (void);
Nvoid  GUI_GetFontInfo          (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi);
Xvoid  GUI_GetFontInfo          (const GUI_FONT  * pFont, GUI_FONTINFO * pfi);
Nvoid  GUI_GetOrg               (int * px, int * py);
Nint   GUI_GetYSizeOfFont       (const GUI_FONT GUI_UNI_PTR * pFont);
Xint   GUI_GetYSizeOfFont       (const GUI_FONT  * pFont);
Nint   GUI_GetYDistOfFont       (const GUI_FONT GUI_UNI_PTR * pFont);
Xint   GUI_GetYDistOfFont       (const GUI_FONT  * pFont);
Nint   GUI_GetTextAlign         (void);
Nint   GUI_GetTextMode          (void);
Nchar  GUI_IsInFont             (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xchar  GUI_IsInFont             (const GUI_FONT  * pFont, unsigned short c);
Nint   GUI_SetTextAlign         (int Align);
Nint   GUI_SetTextMode          (int Mode);
Nchar  GUI_SetTextStyle         (char Style);
Nint   GUI_SetLBorder           (int x);
Nvoid  GUI_SetOrg               (int x, int y);
Nconst GUI_FONT GUI_UNI_PTR * GUI_SetFont(const GUI_FONT GUI_UNI_PTR * pNewFont);
Xconst GUI_FONT  * GUI_SetFont(const GUI_FONT  * pNewFont);
Nchar  GUI_GotoXY               (int x, int y);
Nchar  GUI_GotoX                (int x);
Nchar  GUI_GotoY                (int y);
Nint   GUI_WrapGetNumLines      (const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode);
Xint   GUI_WrapGetNumLines      (const char  * pText, int xSize, GUI_WRAPMODE WrapMode);
N
Nint   GUI_GetLeadingBlankCols (U16 c); /* Currently not implemented in V5! */
Xint   GUI_GetLeadingBlankCols (unsigned short c);  
Nint   GUI_GetTrailingBlankCols(U16 c); /* Currently not implemented in V5! */
Xint   GUI_GetTrailingBlankCols(unsigned short c);  
N
N/*********************************************************************
N*
N*       System independent fonts (SIF)
N*/
Nvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const GUI_SIF_TYPE * pFontType);
Xvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const tGUI_SIF_APIList * pFontType);
Nvoid GUI_SIF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       External binary fonts (XBF)
N*/
Nint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const GUI_XBF_TYPE * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Xint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const tGUI_XBF_APIList * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid GUI_XBF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
Nint  GUI_TTF_CreateFont   (GUI_FONT * pFont, GUI_TTF_CS * pCS);
Nvoid GUI_TTF_DestroyCache (void);
Nvoid GUI_TTF_Done         (void);
Nint  GUI_TTF_GetFamilyName(GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nint  GUI_TTF_GetStyleName (GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nvoid GUI_TTF_SetCacheSize (unsigned MaxFaces, unsigned MaxSizes, U32 MaxBytes);
Xvoid GUI_TTF_SetCacheSize (unsigned MaxFaces, unsigned MaxSizes, unsigned long MaxBytes);
N
N/*********************************************************************
N*
N*       Unicode support
N*/
Nint   GUI_UC_ConvertUC2UTF8   (const U16 GUI_UNI_PTR * s, int Len, char * pBuffer, int BufferSize);
Xint   GUI_UC_ConvertUC2UTF8   (const unsigned short  * s, int Len, char * pBuffer, int BufferSize);
Nint   GUI_UC_ConvertUTF82UC   (const char GUI_UNI_PTR * s, int Len, U16 * pBuffer, int BufferSize);
Xint   GUI_UC_ConvertUTF82UC   (const char  * s, int Len, unsigned short * pBuffer, int BufferSize);
Nint   GUI_UC_Encode           (char* s, U16 Char);
Xint   GUI_UC_Encode           (char* s, unsigned short Char);
Nint   GUI_UC_GetCharSize      (const char GUI_UNI_PTR * s);
Xint   GUI_UC_GetCharSize      (const char  * s);
NU16   GUI_UC_GetCharCode      (const char GUI_UNI_PTR * s);
Xunsigned short   GUI_UC_GetCharCode      (const char  * s);
Nvoid  GUI_UC_SetEncodeNone    (void);
Nvoid  GUI_UC_SetEncodeUTF8    (void);
N
Nvoid GUI_UC_DispString(const U16 GUI_UNI_PTR *s);
Xvoid GUI_UC_DispString(const unsigned short  *s);
Nvoid GUI_UC2DB (U16 Code, U8* pOut);
Xvoid GUI_UC2DB (unsigned short Code, unsigned char* pOut);
NU16  GUI_DB2UC (U8 Byte0, U8 Byte1);
Xunsigned short  GUI_DB2UC (unsigned char Byte0, unsigned char Byte1);
N
N/*********************************************************************
N*
N*       Drawing of binary, decimal and hexadecimal values
N*/
Nvoid GUI_DispBin  (U32  v, U8 Len);
Xvoid GUI_DispBin  (unsigned long  v, unsigned char Len);
Nvoid GUI_DispBinAt(U32  v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispBinAt(unsigned long  v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDec  (I32 v, U8 Len);
Xvoid GUI_DispDec  (signed long v, unsigned char Len);
Nvoid GUI_DispDecAt (I32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispDecAt (signed long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDecMin(I32 v);
Xvoid GUI_DispDecMin(signed long v);
Nvoid GUI_DispDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispDecShift(signed long v, unsigned char Len, unsigned char Shift);
Nvoid GUI_DispDecSpace(I32 v, U8 MaxDigits);
Xvoid GUI_DispDecSpace(signed long v, unsigned char MaxDigits);
Nvoid GUI_DispHex  (U32 v, U8 Len);
Xvoid GUI_DispHex  (unsigned long v, unsigned char Len);
Nvoid GUI_DispHexAt(U32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispHexAt(unsigned long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispSDec(I32 v, U8 Len);
Xvoid GUI_DispSDec(signed long v, unsigned char Len);
Nvoid GUI_DispSDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispSDecShift(signed long v, unsigned char Len, unsigned char Shift);
N
N/*********************************************************************
N*
N*       Drawing of floating point values
N*/
Nvoid GUI_DispFloat    (float v, char Len);
Nvoid GUI_DispFloatFix (float v, char Len, char Fract);
Nvoid GUI_DispFloatMin (float v, char Fract);
Nvoid GUI_DispSFloatFix(float v, char Len, char Fract);
Nvoid GUI_DispSFloatMin(float v, char Fract);
N
N/*********************************************************************
N*
N*       Dynamic memory management
N*/
N#if !defined(GUI_ALLOC_ALLOC)
X#if !0L
N  /* diagnostics */
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void);
X  signed long GUI_ALLOC_GetNumFreeBlocks(void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes (void);
X  signed long GUI_ALLOC_GetNumFreeBytes (void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void);
X  signed long GUI_ALLOC_GetNumUsedBlocks(void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes (void);
X  signed long GUI_ALLOC_GetNumUsedBytes (void);
N#else
S  #define GUI_ALLOC_GetNumFreeBlocks() 0
S  #define GUI_ALLOC_GetNumFreeBytes()  0
S  #define GUI_ALLOC_GetNumUsedBlocks() 0
S  #define GUI_ALLOC_GetNumUsedBytes()  0
N#endif
N
NGUI_HMEM           GUI_ALLOC_AllocInit     (const void * pInitData, GUI_ALLOC_DATATYPE Size);
Xsigned long           GUI_ALLOC_AllocInit     (const void * pInitData, signed long Size);
NGUI_HMEM           GUI_ALLOC_AllocNoInit   (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocNoInit   (signed long size);
NGUI_HMEM           GUI_ALLOC_AllocZero     (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocZero     (signed long size);
Nvoid               GUI_ALLOC_AssignMemory  (void * p, U32 NumBytes);
Xvoid               GUI_ALLOC_AssignMemory  (void * p, unsigned long NumBytes);
Nvoid               GUI_ALLOC_Free          (GUI_HMEM  hMem);
Xvoid               GUI_ALLOC_Free          (signed long  hMem);
Nvoid               GUI_ALLOC_FreeFixedBlock(void * p);
Nvoid               GUI_ALLOC_FreePtrArray  (GUI_HMEM * pArray, int NumElems);
Xvoid               GUI_ALLOC_FreePtrArray  (signed long * pArray, int NumElems);
Nvoid               GUI_ALLOC_FreePtr       (GUI_HMEM * phMem);
Xvoid               GUI_ALLOC_FreePtr       (signed long * phMem);
Nvoid *             GUI_ALLOC_GetFixedBlock (GUI_ALLOC_DATATYPE Size);
Xvoid *             GUI_ALLOC_GetFixedBlock (signed long Size);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize    (void);
Xsigned long GUI_ALLOC_GetMaxSize    (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetSize       (GUI_HMEM  hMem);
Xsigned long GUI_ALLOC_GetSize       (signed long  hMem);
Nvoid *             GUI_ALLOC_h2p           (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_h2p           (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_p2h           (void * p);
Xsigned long           GUI_ALLOC_p2h           (void * p);
Nvoid               GUI_ALLOC_Init          (void);
Nvoid               GUI_ALLOC_Lock          (void);
Nvoid *             GUI_ALLOC_LockH         (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_LockH         (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_Realloc       (GUI_HMEM hOld, int NewSize);
Xsigned long           GUI_ALLOC_Realloc       (signed long hOld, int NewSize);
NGUI_ALLOC_DATATYPE GUI_ALLOC_RequestSize   (void);
Xsigned long GUI_ALLOC_RequestSize   (void);
Nvoid               GUI_ALLOC_SetAvBlockSize(U32 BlockSize);
Xvoid               GUI_ALLOC_SetAvBlockSize(unsigned long BlockSize);
Nvoid               GUI_ALLOC_Unlock        (void);
Nvoid *             GUI_ALLOC_UnlockH       (void);
N
N/*********************************************************************
N*
N*       Memory devices: GUI_MEMDEV
N*/
N#define GUI_MEMDEV_HASTRANS       0
N#define GUI_MEMDEV_NOTRANS    (1<<0)
N
Ntypedef GUI_HMEM GUI_MEMDEV_Handle;
Xtypedef signed long GUI_MEMDEV_Handle;
Ntypedef void GUI_CALLBACK_VOID_P(void* p);
N
Ntypedef struct {
N  GUI_RECT rView, rPrev;
N  char FirstCall;
N} GUI_AUTODEV;
N
Ntypedef struct {
N  char DrawFixed;
N  char IsMeasurement;
N} GUI_AUTODEV_INFO;
N
Nint  GUI_MEMDEV_CreateAuto(GUI_AUTODEV * pAutoDev);
Nvoid GUI_MEMDEV_DeleteAuto(GUI_AUTODEV * pAutoDev);
Nint  GUI_MEMDEV_DrawAuto  (GUI_AUTODEV * pAutoDev, GUI_AUTODEV_INFO * pAutoDevInfo, GUI_CALLBACK_VOID_P * pfDraw, void * pData);
N
N/* Create a memory device which is compatible to the selected LCD */
NGUI_MEMDEV_Handle GUI_MEMDEV_Create     (int x0, int y0, int XSize, int YSize);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateEx   (int x0, int y0, int XSize, int YSize, int Flags);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed(int x0, int y0, 
N                                         int xsize, int ysize, int Flags,
N                                         const GUI_DEVICE_API     * pDeviceAPI,
N                                         const LCD_API_COLOR_CONV * pColorConvAPI);
Nvoid GUI_MEMDEV_Clear         (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyFromLCD   (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyFromLCDAA (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCD     (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCDAA   (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCDAt   (GUI_MEMDEV_Handle hMem, int x, int y);
Nint  GUI_MEMDEV_CompareWithLCD(GUI_MEMDEV_Handle hMem, int*px, int*py, int *pExp, int*pAct);
Nvoid GUI_MEMDEV_Delete        (GUI_MEMDEV_Handle MemDev);
Nvoid GUI_MEMDEV_DrawPerspectiveX(GUI_MEMDEV_Handle hMem, int x, int y, int h0, int h1, int dx, int dy);
Nint  GUI_MEMDEV_GetXPos       (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetXSize      (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetYPos       (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetYSize      (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_MarkDirty     (GUI_MEMDEV_Handle hMem, int x0, int y0, int x1, int y1);
Nvoid GUI_MEMDEV_ReduceYSize   (GUI_MEMDEV_Handle hMem, int YSize);
Nvoid GUI_MEMDEV_Rotate        (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateHQ      (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
NGUI_MEMDEV_Handle GUI_MEMDEV_Select (GUI_MEMDEV_Handle hMem);  /* Select (activate) a particular memory device. */
Nvoid  GUI_MEMDEV_SetOrg        (GUI_MEMDEV_Handle hMem, int x0, int y0);
Nvoid  GUI_MEMDEV_WriteAt       (GUI_MEMDEV_Handle hMem, int x, int y);
Nvoid  GUI_MEMDEV_Write         (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_WriteAlphaAt  (GUI_MEMDEV_Handle hMem, int Alpha, int x, int y);
Nvoid  GUI_MEMDEV_WriteAlpha    (GUI_MEMDEV_Handle hMem, int Alpha);
Nvoid  GUI_MEMDEV_WriteExAt     (GUI_MEMDEV_Handle hMem, int x, int y, int xMag, int yMag, int Alpha);
Nvoid  GUI_MEMDEV_WriteEx       (GUI_MEMDEV_Handle hMem, int xMag, int yMag, int Alpha);
Nint   GUI_MEMDEV_Draw          (GUI_RECT * pRect, GUI_CALLBACK_VOID_P * pfDraw, void * pData, int MemSize, int Flags);
Nint   GUI_MEMDEV_DrawStatic    (GUI_RECT * pRect, GUI_CALLBACK_VOID_P * pfDraw, void * pData, GUI_MEMDEV_Handle * phDst, int Flags);
Nvoid* GUI_MEMDEV_GetDataPtr    (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_SetColorConv  (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
Nint   GUI_MEMDEV_GetBitsPerPixel(GUI_MEMDEV_Handle hMemDev);
N
Nvoid     GUI_SelectLCD(void);
N
N/*********************************************************************
N*
N*       Alpha blending
N*/
Ntypedef struct {
N  U32 UserAlpha;
X  unsigned long UserAlpha;
N} GUI_ALPHA_STATE;
N
N#define GUI_MAKE_ALPHA(Alpha, Color) ((U32)(((U32)Alpha << 24) | Color))
N
Nunsigned GUI_EnableAlpha     (unsigned OnOff);
NU32      GUI_RestoreUserAlpha(GUI_ALPHA_STATE * pAlphaState);
Xunsigned long      GUI_RestoreUserAlpha(GUI_ALPHA_STATE * pAlphaState);
Nunsigned GUI_SetAlpha        (U8 Alpha);
Xunsigned GUI_SetAlpha        (unsigned char Alpha);
NU32      GUI_SetUserAlpha    (GUI_ALPHA_STATE * pAlphaState, U32 UserAlpha);
Xunsigned long      GUI_SetUserAlpha    (GUI_ALPHA_STATE * pAlphaState, unsigned long UserAlpha);
N
N/*********************************************************************
N*
N*       Multi layer support
N*/
Nunsigned GUI_SelectLayer(unsigned Index);
N
Nint  GUI_SetLayerPosEx  (unsigned Index, int xPos, int yPos);
Nint  GUI_SetLayerSizeEx (unsigned Index, int xSize, int ySize);
Nint  GUI_SetLayerVisEx  (unsigned Index, int OnOff);
Nint  GUI_SetLayerAlphaEx(unsigned Index, int Alpha);
Nvoid GUI_GetLayerPosEx  (unsigned Index, int * pxPos, int * pyPos);
N
Nvoid     GUI_AssignCursorLayer(unsigned Index, unsigned CursorLayer);
Nunsigned GUI_GetCursorLayer   (unsigned Index);
N
N/*********************************************************************
N*
N*       Display orientation
N*/
N/*********************************************************************
N*
N*       GUI_ORIENTATION_API
N*/
Ntypedef struct {
N  void     (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void     (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char  * pData, int Diff, const unsigned long * pTrans);
N  void     (* pfDrawHLine    )(GUI_DEVICE * pDevice, int x0, int y0,  int x1);
N  void     (* pfDrawVLine    )(GUI_DEVICE * pDevice, int x , int y0,  int y1);
N  void     (* pfFillRect     )(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1);
N  unsigned (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
N  void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
N  void     (* pfXorPixel     )(GUI_DEVICE * pDevice, int x, int y);
N  int      BytesPerPixel;
N} GUI_ORIENTATION_API;
N
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C0;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C8;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C16;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C32;
N
N#define GUI_ORIENTATION_C0  &GUI_OrientationAPI_C0
N#define GUI_ORIENTATION_C8  &GUI_OrientationAPI_C8
N#define GUI_ORIENTATION_C16 &GUI_OrientationAPI_C16
N#define GUI_ORIENTATION_C32 &GUI_OrientationAPI_C32
N
Nint GUI_SetOrientation        (int Orientation);
Nint GUI_SetOrientationEx      (int Orientation, int LayerIndex);
Nint GUI_SetOrientationExCached(int Orientation, int LayerIndex, const GUI_ORIENTATION_API * pAPI);
N
N/*********************************************************************
N*
N*       Measure device: GUI_MEASDEV
N*/
Ntypedef GUI_HMEM GUI_MEASDEV_Handle;
Xtypedef signed long GUI_MEASDEV_Handle;
N
NGUI_MEASDEV_Handle GUI_MEASDEV_Create (void);
Nvoid               GUI_MEASDEV_Delete (GUI_MEASDEV_Handle hMemDev);
Nvoid               GUI_MEASDEV_Select (GUI_MEASDEV_Handle hMem);
Nvoid               GUI_MEASDEV_GetRect(GUI_MEASDEV_Handle hMem, GUI_RECT *pRect);
Nvoid               GUI_MEASDEV_ClearRect(GUI_MEASDEV_Handle hMem);
N
N/*********************************************************************
N*
N*       Polygon helpers
N*/
Nvoid GUI_RotatePolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, float Angle);
Nvoid GUI_MagnifyPolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, int Mag);
Nvoid GUI_EnlargePolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, int Len);
N
N/*********************************************************************
N*
N*       Streamed bitmaps
N*/
N#define GUI_BITMAPSTREAM_GET_BUFFER     1
N#define GUI_BITMAPSTREAM_RELEASE_BUFFER 2
N#define GUI_BITMAPSTREAM_MODIFY_PALETTE 3
N
N#define DECLARE_CREATE_FROM_STREAM(ID) int GUI_CreateBitmapFromStream##ID(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
NDECLARE_CREATE_FROM_STREAM(IDX)
Xint GUI_CreateBitmapFromStreamIDX(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE4)
Xint GUI_CreateBitmapFromStreamRLE4(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE8)
Xint GUI_CreateBitmapFromStreamRLE8(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(565)
Xint GUI_CreateBitmapFromStream565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M565)
Xint GUI_CreateBitmapFromStreamM565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(555)
Xint GUI_CreateBitmapFromStream555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M555)
Xint GUI_CreateBitmapFromStreamM555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE16)
Xint GUI_CreateBitmapFromStreamRLE16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLEM16)
Xint GUI_CreateBitmapFromStreamRLEM16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(24)
Xint GUI_CreateBitmapFromStream24(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(Alpha)
Xint GUI_CreateBitmapFromStreamAlpha(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
Nint  GUI_CreateBitmapFromStream  (GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
Nvoid GUI_DrawStreamedBitmap      (const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapEx    (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nvoid GUI_GetStreamedBitmapInfo   (const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nint  GUI_GetStreamedBitmapInfoEx (GUI_GET_DATA_FUNC * pfGetData, const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nvoid GUI_SetStreamedBitmapHook   (GUI_BITMAPSTREAM_CALLBACK pfStreamedBitmapHook);
N
N/*********************************************************************
N*
N*       BMP-export
N*/
Ntypedef void GUI_CALLBACK_VOID_U8_P(U8 Data, void * p);
Xtypedef void GUI_CALLBACK_VOID_U8_P(unsigned char Data, void * p);
N
Nvoid GUI_BMP_SerializeEx(GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p);
Nvoid GUI_BMP_Serialize  (GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
N
N/*********************************************************************
N*
N*       Time / execution related routines
N*/
Nvoid GUI_Delay  (int Period);
Nint  GUI_GetTime(void);
Nint  GUI_Exec(void);         /* Execute all jobs ... Return 0 if nothing was done. */
Nint  GUI_Exec1(void);        /* Execute one job  ... Return 0 if nothing was done. */
N
N/*********************************************************************
N*
N*       MessageBox
N*/
Nint     GUI_MessageBox   (const char * sMessage, const char * sCaption, int Flags);
N#define GUI_MESSAGEBOX_CF_MOVEABLE (1 << 0)
N#define GUI_MESSAGEBOX_CF_MODAL    (1 << 1)
N
N#define GUI_MB_OK                20
N#define GUI_MB_WARNING           21
N
N/*********************************************************************
N*
N*       GUI_TIMER module
N*/
Ntypedef struct {
N  GUI_TIMER_TIME Time;
X  int Time;
N  U32            Context;
X  unsigned long            Context;
N} GUI_TIMER_MESSAGE;
N
Ntypedef GUI_HMEM GUI_TIMER_HANDLE;
Xtypedef signed long GUI_TIMER_HANDLE;
Ntypedef void GUI_TIMER_CALLBACK(/*const*/ GUI_TIMER_MESSAGE* pTM);
N
NGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK* cb, int Time,  U32 Context, int Flags);
XGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK* cb, int Time,  unsigned long Context, int Flags);
Nvoid             GUI_TIMER_Delete   (GUI_TIMER_HANDLE hObj);
N
N/* Methods changing properties */
Nvoid GUI_TIMER_SetPeriod (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid GUI_TIMER_SetPeriod (GUI_TIMER_HANDLE hObj, int Period);
Nvoid GUI_TIMER_SetTime   (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid GUI_TIMER_SetTime   (GUI_TIMER_HANDLE hObj, int Period);
Nvoid GUI_TIMER_SetDelay  (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Delay);
Xvoid GUI_TIMER_SetDelay  (GUI_TIMER_HANDLE hObj, int Delay);
Nvoid GUI_TIMER_Restart   (GUI_TIMER_HANDLE hObj);
Nint  GUI_TIMER_Exec(void);
N
N/*********************************************************************
N*
N*       Anti Aliasing
N*/
Nvoid GUI_AA_DisableHiRes     (void);
Nvoid GUI_AA_EnableHiRes      (void);
Nint  GUI_AA_GetFactor        (void);
Nvoid GUI_AA_SetFactor        (int Factor);
Nvoid GUI_AA_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_AA_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_AA_DrawPolyOutline  (const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y);
Nvoid GUI_AA_DrawPolyOutlineEx(const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y, GUI_POINT * pBuffer);
Nvoid GUI_AA_DrawRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_AA_FillCircle       (int x0, int y0, int r);
Nvoid GUI_AA_FillPolygon      (GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_AA_FillRoundedRect  (int x0, int y0, int x1, int y1, int r);
N
N/*********************************************************************
N*
N*       Keyboard
N*/
N/* Message layer */
Nvoid GUI_StoreKeyMsg(int Key, int Pressed);
Nvoid GUI_SendKeyMsg (int Key, int Pressed);
Nint  GUI_PollKeyMsg(void);
N
N/* Application layer */
Nint  GUI_GetKey(void);
Nint  GUI_WaitKey(void);
Nvoid GUI_StoreKey(int c);
Nvoid GUI_ClearKeyBuffer(void);
N
N/*********************************************************************
N*
N*       Task syncronisation (depends on configuration)
N*/
Nvoid GUI_WaitEvent(void);
N
N/*********************************************************************
N*
N*       Joystick, generic
N*/
Nvoid GUI_JOYSTICK_StoreState(const GUI_PID_STATE * pState);
N
N/*********************************************************************
N*
N*       PID  (Pointer input device ... mouse/touch) 
N*/
Nvoid GUI_PID_StoreState(const GUI_PID_STATE *pState);
Nint  GUI_PID_GetState  (      GUI_PID_STATE *pState);
N
N/*********************************************************************
N*
N*       Mouse, generic
N*/
Nint  GUI_MOUSE_GetState  (      GUI_PID_STATE *pState);
Nvoid GUI_MOUSE_StoreState(const GUI_PID_STATE *pState);
N
N/*********************************************************************
N*
N*       TOUCH screen, generic
N*/
Nint  GUI_TOUCH_GetState     (GUI_PID_STATE *pState);
Nvoid GUI_TOUCH_GetUnstable  (int* px, int* py);  /* for diagnostics only */
Nvoid GUI_TOUCH_SetLayer     (int Layer);
Nvoid GUI_TOUCH_StoreState   (int x, int y);
Nvoid GUI_TOUCH_StoreStateEx (const GUI_PID_STATE *pState);
Nvoid GUI_TOUCH_StoreUnstable(int x, int y);
N
N/*********************************************************************
N*
N*       Mouse, PS2 driver
N*/
Nvoid GUI_MOUSE_DRIVER_PS2_Init(void);               /* optional */
Nvoid GUI_MOUSE_DRIVER_PS2_OnRx(unsigned char Data);
N
N/*********************************************************************
N*
N*       TOUCH screen, analog driver
N*/
Nvoid GUI_TOUCH_Exec                 (void);
Nint  GUI_TOUCH_Calibrate            (int Coord, int Log0, int Log1, int Phys0, int Phys1);
Nvoid GUI_TOUCH_SetDefaultCalibration(void);
Nint  GUI_TOUCH_GetxPhys             (void);    /* for diagnostics only */
Nint  GUI_TOUCH_GetyPhys             (void);    /* for diagnostics only */
Nvoid GUI_TOUCH_GetCalData           (int Coord, int* pMin,int* pMax);
Nvoid GUI_TOUCH_SetOrientation       (unsigned Orientation);
Nvoid GUI_TOUCH_SetOrientationPhys   (unsigned Orientation);
N
N/*********************************************************************
N*
N*       TOUCH: imports
N*
N* Please note: The following functions are required by the module.
N* They need to be part of your application software (or rather, part
N* of the hardware-layer of your software).
N*/
Nvoid GUI_TOUCH_X_ActivateX(void);
Nvoid GUI_TOUCH_X_ActivateY(void);
Nvoid GUI_TOUCH_X_Disable  (void);
Nint  GUI_TOUCH_X_MeasureX (void);
Nint  GUI_TOUCH_X_MeasureY (void);
N
N/*********************************************************************
N*
N*       GUI_X_
N*
N* Externals, to be defined by application
N*
N* The externals defined below should be defined by the
N* application. They are per default contained in the module
N* GUI_X.c.
N* Note that a lot if not all of these are not required in most target
N* systems.
N* For this module, samples are available for configurations
N* with or without operating system.
N*/
N
N//
N// Configuration
N//
Nvoid GUI_X_Config(void);
Nvoid GUI_X_Init(void);
N
N//
N// ExecIdle - called if nothing else is left to do
N//
Nvoid GUI_X_ExecIdle(void);
N
N//
N// Timing routines
N//
Nint  GUI_X_GetTime(void);
Nvoid GUI_X_Delay(int Period);
N
N//
N// Multitask routines - required only if multitasking is used (#define GUI_OS 1)
N//
Nvoid GUI_X_Unlock(void);
Nvoid GUI_X_Lock(void);
NU32  GUI_X_GetTaskId(void);
Xunsigned long  GUI_X_GetTaskId(void);
Nvoid GUI_X_InitOS(void);
N
N//
N// Event driving (optional with multitasking)
N//
Nvoid GUI_X_WaitEvent(void);
Nvoid GUI_X_WaitEventTimed(int Period);
Nvoid GUI_X_SignalEvent(void);
N
N//
N// Recording (logs/warnings and errors) - required only for higher levels
N//
Nvoid GUI_X_Log(const char *s);
Nvoid GUI_X_Warn(const char *s);
Nvoid GUI_X_ErrorOut(const char *s); 
N
N/*********************************************************************
N*
N*       Constants for fonts and bitmaps
N*/
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods8888;
N
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods24;
N
N#define GUI_COMPRESS_RLE4 0
N#define GUI_COMPRESS_RLE8 0
N
N#define GUI_DRAW_RLE4    &GUI_BitmapMethodsRLE4   /* Method table ! */
N#define GUI_DRAW_RLE8    &GUI_BitmapMethodsRLE8   /* Method table ! */
N#define GUI_DRAW_RLE16   &GUI_BitmapMethodsRLE16  /* Method table ! */
N#define GUI_DRAW_RLEM16  &GUI_BitmapMethodsRLEM16 /* Method table ! */
N#define GUI_DRAW_BMP555  &GUI_BitmapMethods555    /* Method table ! */
N#define GUI_DRAW_BMPM555 &GUI_BitmapMethodsM555   /* Method table ! */
N#define GUI_DRAW_BMP565  &GUI_BitmapMethods565    /* Method table ! */
N#define GUI_DRAW_BMPM565 &GUI_BitmapMethodsM565   /* Method table ! */
N#define GUI_DRAW_BMP888  &GUI_BitmapMethods888    /* Method table ! */
N#define GUI_DRAW_BMPM888 &GUI_BitmapMethodsM888   /* Method table ! */
N#define GUI_DRAW_BMP8888 &GUI_BitmapMethods8888   /* Method table ! */
N#define GUI_DRAW_BMP24   &GUI_BitmapMethods24     /* Method table ! */
N
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Ext;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Frm;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2_EXT;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4_EXT;
N
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Frm;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA2_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA4_Ext;
N
N/*********************************************************************
N*
N*       GUI_KEY_...
N*
N* These ID values are basically meant to be used with widgets
N* Note that we have chosen the values to be close to existing
N* "standards", so do not change them unless forced to.
N*
N*/
N#define GUI_KEY_BACKSPACE         8         /* ASCII: BACKSPACE Crtl-H */
N#define GUI_KEY_TAB               9         /* ASCII: TAB       Crtl-I */
N#define GUI_KEY_BACKTAB           10
N#define GUI_KEY_ENTER             13        /* ASCII: ENTER     Crtl-M */
N#define GUI_KEY_LEFT              16
N#define GUI_KEY_UP                17
N#define GUI_KEY_RIGHT             18
N#define GUI_KEY_DOWN              19
N#define GUI_KEY_HOME              23
N#define GUI_KEY_END               24
N#define GUI_KEY_SHIFT             25
N#define GUI_KEY_CONTROL           26
N#define GUI_KEY_ESCAPE            27        /* ASCII: ESCAPE    0x1b   */
N#define GUI_KEY_INSERT            29
N#define GUI_KEY_DELETE            30
N#define GUI_KEY_SPACE             32
N#define GUI_KEY_PGUP              33
N#define GUI_KEY_PGDOWN            34
N
N#define GUI_KEY_F1                40
N#define GUI_KEY_F2                41
N
N/*********************************************************************
N*
N*       Dialog item IDs
N*
N*  The IDs below are arbitrary values. They just have to be unique
N*  within the dialog.
N*
N*  If you use your own Ids, we recommend to use values above GUI_ID_USER.
N*/
N#define GUI_ID_OK                1
N#define GUI_ID_CANCEL            2
N#define GUI_ID_YES               3
N#define GUI_ID_NO                4
N#define GUI_ID_CLOSE             5
N#define GUI_ID_HELP              6
N#define GUI_ID_MAXIMIZE          7
N#define GUI_ID_MINIMIZE          8
N
N#define GUI_ID_VSCROLL  0xFE
N#define GUI_ID_HSCROLL  0xFF
N
N#define GUI_ID_EDIT0    0x100
N#define GUI_ID_EDIT1    0x101
N#define GUI_ID_EDIT2    0x102
N#define GUI_ID_EDIT3    0x103
N#define GUI_ID_EDIT4    0x104
N#define GUI_ID_EDIT5    0x105
N#define GUI_ID_EDIT6    0x106
N#define GUI_ID_EDIT7    0x107
N#define GUI_ID_EDIT8    0x108
N#define GUI_ID_EDIT9    0x109
N
N#define GUI_ID_LISTBOX0 0x110
N#define GUI_ID_LISTBOX1 0x111
N#define GUI_ID_LISTBOX2 0x112
N#define GUI_ID_LISTBOX3 0x113
N#define GUI_ID_LISTBOX4 0x114
N#define GUI_ID_LISTBOX5 0x115
N#define GUI_ID_LISTBOX6 0x116
N#define GUI_ID_LISTBOX7 0x117
N#define GUI_ID_LISTBOX8 0x118
N#define GUI_ID_LISTBOX9 0x119
N
N#define GUI_ID_CHECK0   0x120
N#define GUI_ID_CHECK1   0x121
N#define GUI_ID_CHECK2   0x122
N#define GUI_ID_CHECK3   0x123
N#define GUI_ID_CHECK4   0x124
N#define GUI_ID_CHECK5   0x125
N#define GUI_ID_CHECK6   0x126
N#define GUI_ID_CHECK7   0x127
N#define GUI_ID_CHECK8   0x128
N#define GUI_ID_CHECK9   0x129
N
N#define GUI_ID_SLIDER0  0x130
N#define GUI_ID_SLIDER1  0x131
N#define GUI_ID_SLIDER2  0x132
N#define GUI_ID_SLIDER3  0x133
N#define GUI_ID_SLIDER4  0x134
N#define GUI_ID_SLIDER5  0x135
N#define GUI_ID_SLIDER6  0x136
N#define GUI_ID_SLIDER7  0x137
N#define GUI_ID_SLIDER8  0x138
N#define GUI_ID_SLIDER9  0x139
N
N#define GUI_ID_SCROLLBAR0 0x140
N#define GUI_ID_SCROLLBAR1 0x141
N#define GUI_ID_SCROLLBAR2 0x142
N#define GUI_ID_SCROLLBAR3 0x142
N
N#define GUI_ID_RADIO0 0x150
N#define GUI_ID_RADIO1 0x151
N#define GUI_ID_RADIO2 0x152
N#define GUI_ID_RADIO3 0x153
N#define GUI_ID_RADIO4 0x154
N#define GUI_ID_RADIO5 0x155
N#define GUI_ID_RADIO6 0x156
N#define GUI_ID_RADIO7 0x157
N
N#define GUI_ID_TEXT0  0x160
N#define GUI_ID_TEXT1  0x161
N#define GUI_ID_TEXT2  0x162
N#define GUI_ID_TEXT3  0x163
N#define GUI_ID_TEXT4  0x164
N#define GUI_ID_TEXT5  0x165
N#define GUI_ID_TEXT6  0x166
N#define GUI_ID_TEXT7  0x167
N#define GUI_ID_TEXT8  0x168
N#define GUI_ID_TEXT9  0x169
N
N#define GUI_ID_BUTTON0 0x170
N#define GUI_ID_BUTTON1 0x171
N#define GUI_ID_BUTTON2 0x172
N#define GUI_ID_BUTTON3 0x173
N#define GUI_ID_BUTTON4 0x174
N#define GUI_ID_BUTTON5 0x175
N#define GUI_ID_BUTTON6 0x176
N#define GUI_ID_BUTTON7 0x177
N#define GUI_ID_BUTTON8 0x178
N#define GUI_ID_BUTTON9 0x179
N
N#define GUI_ID_DROPDOWN0  0x180
N#define GUI_ID_DROPDOWN1  0x181
N#define GUI_ID_DROPDOWN2  0x182
N#define GUI_ID_DROPDOWN3  0x183
N
N#define GUI_ID_MULTIEDIT0 0x190
N#define GUI_ID_MULTIEDIT1 0x191
N#define GUI_ID_MULTIEDIT2 0x192
N#define GUI_ID_MULTIEDIT3 0x193
N
N#define GUI_ID_LISTVIEW0  0x200
N#define GUI_ID_LISTVIEW1  0x201
N#define GUI_ID_LISTVIEW2  0x202
N#define GUI_ID_LISTVIEW3  0x203
N
N#define GUI_ID_PROGBAR0   0x210
N#define GUI_ID_PROGBAR1   0x211
N#define GUI_ID_PROGBAR2   0x212
N#define GUI_ID_PROGBAR3   0x213
N
N#define GUI_ID_GRAPH0 0x220
N#define GUI_ID_GRAPH1 0x221
N#define GUI_ID_GRAPH2 0x222
N#define GUI_ID_GRAPH3 0x223
N
N#define GUI_ID_MULTIPAGE0 0x230
N#define GUI_ID_MULTIPAGE1 0x231
N#define GUI_ID_MULTIPAGE2 0x232
N#define GUI_ID_MULTIPAGE3 0x233
N
N#define GUI_ID_TREEVIEW0 0x240
N#define GUI_ID_TREEVIEW1 0x241
N#define GUI_ID_TREEVIEW2 0x242
N#define GUI_ID_TREEVIEW3 0x243
N
N#define GUI_ID_ICONVIEW0 0x250
N#define GUI_ID_ICONVIEW1 0x251
N#define GUI_ID_ICONVIEW2 0x252
N#define GUI_ID_ICONVIEW3 0x253
N
N#define GUI_ID_LISTWHEEL0 0x260
N#define GUI_ID_LISTWHEEL1 0x261
N#define GUI_ID_LISTWHEEL2 0x262
N#define GUI_ID_LISTWHEEL3 0x263
N
N#define GUI_ID_USER     0x800
N
N/*********************************************************************
N*
N*       Mouse buttons
N*/
N#define GUI_LBUTTON (1 << 0) /* Left button */
N#define GUI_RBUTTON (1 << 1) /* Right button */
N#define GUI_MBUTTON (1 << 2) /* Middle button */
N#define GUI_DBUTTON (1 << 7) /* Double-click button */
N
N/*********************************************************************
N*
N*       Text styles
N*/
N#define GUI_TS_NORMAL           (0)
N#define GUI_TS_UNDERLINE        (1 << 0)
N#define GUI_TS_STRIKETHRU       (1 << 1)
N#define GUI_TS_OVERLINE         (1 << 2)
N
N/*********************************************************************
N*
N*       Line styles
N*/
N#define GUI_LS_SOLID        (0)
N#define GUI_LS_DASH         (1)
N#define GUI_LS_DOT          (2)
N#define GUI_LS_DASHDOT      (3)
N#define GUI_LS_DASHDOTDOT   (4)
N
N/*********************************************************************
N*
N*       Pen shapes
N*/
N#define GUI_PS_ROUND        (0)
N#define GUI_PS_FLAT         (1)
N#define GUI_PS_SQUARE       (2)
N
N/*********************************************************************
N*
N*       Standard colors
N*/
N#define GUI_BLUE          0x00FF0000
N#define GUI_GREEN         0x0000FF00
N#define GUI_RED           0x000000FF
N#define GUI_CYAN          0x00FFFF00
N#define GUI_MAGENTA       0x00FF00FF
N#define GUI_YELLOW        0x0000FFFF
N#define GUI_LIGHTBLUE     0x00FF8080
N#define GUI_LIGHTGREEN    0x0080FF80
N#define GUI_LIGHTRED      0x008080FF
N#define GUI_LIGHTCYAN     0x00FFFF80
N#define GUI_LIGHTMAGENTA  0x00FF80FF
N#define GUI_LIGHTYELLOW   0x0080FFFF
N#define GUI_DARKBLUE      0x00800000
N#define GUI_DARKGREEN     0x00008000
N#define GUI_DARKRED       0x00000080
N#define GUI_DARKCYAN      0x00808000
N#define GUI_DARKMAGENTA   0x00800080
N#define GUI_DARKYELLOW    0x00008080
N#define GUI_WHITE         0x00FFFFFF
N#define GUI_LIGHTGRAY     0x00D3D3D3
N#define GUI_GRAY          0x00808080
N#define GUI_DARKGRAY      0x00404040
N#define GUI_BLACK         0x00000000
N#define GUI_BROWN         0x002A2AA5
N#define GUI_TRANSPARENT   0xFF000000
N
N#define GUI_INVALID_COLOR 0xFFFFFFF      /* Invalid color - more than 24 bits */
N
N/*********************************************************************
N*
N*       Coordinates used in touch driver
N*/
N#define GUI_COORD_X 0
N#define GUI_COORD_Y 1
N
N/*********************************************************************
N*
N*       Addresses of standard fonts
N*/
N//
N// Proportional fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Xextern const GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Xextern const GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Xextern const GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Xextern const GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Xextern const GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Xextern const GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Xextern const GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Xextern const GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Xextern const GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Xextern const GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Xextern const GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Xextern const GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Xextern const GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Xextern const GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
Xextern const GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
N
N//
N// Proportional fonts, framed
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20F_ASCII;
Xextern const GUI_FONT GUI_Font20F_ASCII;
N
N//
N// Monospaced
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font4x6;
Xextern const GUI_FONT GUI_Font4x6;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Xextern const GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Xextern const GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Xextern const GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Xextern const GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x10_ASCII;
Xextern const GUI_FONT GUI_Font8x10_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x12_ASCII;
Xextern const GUI_FONT GUI_Font8x12_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Xextern const GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Xextern const GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Xextern const GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Xextern const GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
Xextern const GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
N
N//
N// Digits
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD24x32;
Xextern const GUI_FONT GUI_FontD24x32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD32;
Xextern const GUI_FONT GUI_FontD32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD36x48;
Xextern const GUI_FONT GUI_FontD36x48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48;
Xextern const GUI_FONT GUI_FontD48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48x64;
Xextern const GUI_FONT GUI_FontD48x64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD64;
Xextern const GUI_FONT GUI_FontD64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD60x80;
Xextern const GUI_FONT GUI_FontD60x80;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD80;
Xextern const GUI_FONT GUI_FontD80;
N
N//
N// Comic fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Xextern const GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
Xextern const GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
N
N/*********************************************************************
N*
N*       Macros to be used
N*/
N//
N// Proportional fonts
N//
N#define GUI_FONT_8_ASCII        &GUI_Font8_ASCII
N#define GUI_FONT_8_1            &GUI_Font8_1
N#define GUI_FONT_10S_ASCII      &GUI_Font10S_ASCII
N#define GUI_FONT_10S_1          &GUI_Font10S_1
N#define GUI_FONT_10_ASCII       &GUI_Font10_ASCII
N#define GUI_FONT_10_1           &GUI_Font10_1
N#define GUI_FONT_13_ASCII       &GUI_Font13_ASCII
N#define GUI_FONT_13_1           &GUI_Font13_1
N#define GUI_FONT_13B_ASCII      &GUI_Font13B_ASCII
N#define GUI_FONT_13B_1          &GUI_Font13B_1
N#define GUI_FONT_13H_ASCII      &GUI_Font13H_ASCII
N#define GUI_FONT_13H_1          &GUI_Font13H_1
N#define GUI_FONT_13HB_ASCII     &GUI_Font13HB_ASCII
N#define GUI_FONT_13HB_1         &GUI_Font13HB_1
N#define GUI_FONT_16_ASCII       &GUI_Font16_ASCII
N#define GUI_FONT_16_1           &GUI_Font16_1
N#define GUI_FONT_16_HK          &GUI_Font16_HK
N#define GUI_FONT_16_1HK         &GUI_Font16_1HK
N#define GUI_FONT_16_ASCII       &GUI_Font16_ASCII
N#define GUI_FONT_16_1           &GUI_Font16_1
N#define GUI_FONT_16_HK          &GUI_Font16_HK
N#define GUI_FONT_16_1HK         &GUI_Font16_1HK
N#define GUI_FONT_16B_ASCII      &GUI_Font16B_ASCII
N#define GUI_FONT_16B_1          &GUI_Font16B_1
N#define GUI_FONT_20_ASCII       &GUI_Font20_ASCII
N#define GUI_FONT_20_1           &GUI_Font20_1
N#define GUI_FONT_20B_ASCII      &GUI_Font20B_ASCII
N#define GUI_FONT_20B_1          &GUI_Font20B_1
N#define GUI_FONT_24_ASCII       &GUI_Font24_ASCII
N#define GUI_FONT_24_1           &GUI_Font24_1
N#define GUI_FONT_24B_ASCII      &GUI_Font24B_ASCII
N#define GUI_FONT_24B_1          &GUI_Font24B_1
N#define GUI_FONT_32_ASCII       &GUI_Font32_ASCII
N#define GUI_FONT_32_1           &GUI_Font32_1
N#define GUI_FONT_32B_ASCII      &GUI_Font32B_ASCII
N#define GUI_FONT_32B_1          &GUI_Font32B_1
N
N//
N// Proportional fonts, framed
N//
N#define GUI_FONT_20F_ASCII      &GUI_Font20F_ASCII
N
N//
N// Monospaced
N//
N#define GUI_FONT_4X6            &GUI_Font4x6
N#define GUI_FONT_6X8            &GUI_Font6x8
N#define GUI_FONT_6X8_ASCII      &GUI_Font6x8_ASCII
N#define GUI_FONT_6X8_1          &GUI_Font6x8_1
N#define GUI_FONT_6X9            &GUI_Font6x9
N#define GUI_FONT_8X8            &GUI_Font8x8
N#define GUI_FONT_8X8_ASCII      &GUI_Font8x8_ASCII
N#define GUI_FONT_8X8_1          &GUI_Font8x8_1
N#define GUI_FONT_8X9            &GUI_Font8x9
N#define GUI_FONT_8X10_ASCII     &GUI_Font8x10_ASCII
N#define GUI_FONT_8X12_ASCII     &GUI_Font8x12_ASCII
N#define GUI_FONT_8X13_ASCII     &GUI_Font8x13_ASCII
N#define GUI_FONT_8X13_1         &GUI_Font8x13_1
N#define GUI_FONT_8X15B_ASCII    &GUI_Font8x15B_ASCII
N#define GUI_FONT_8X15B_1        &GUI_Font8x15B_1
N#define GUI_FONT_8X16           &GUI_Font8x16
N#define GUI_FONT_8X17           &GUI_Font8x17
N#define GUI_FONT_8X18           &GUI_Font8x18
N#define GUI_FONT_8X16X1X2       &GUI_Font8x16x1x2
N#define GUI_FONT_8X16X2X2       &GUI_Font8x16x2x2
N#define GUI_FONT_8X16X3X3       &GUI_Font8x16x3x3
N#define GUI_FONT_8X16_ASCII     &GUI_Font8x16_ASCII
N#define GUI_FONT_8X16_1         &GUI_Font8x16_1
N
N//
N// Digits
N//
N#define GUI_FONT_D24X32         &GUI_FontD24x32
N#define GUI_FONT_D32            &GUI_FontD32
N#define GUI_FONT_D36X48         &GUI_FontD36x48
N#define GUI_FONT_D48            &GUI_FontD48
N#define GUI_FONT_D48X64         &GUI_FontD48x64
N#define GUI_FONT_D64            &GUI_FontD64
N#define GUI_FONT_D60X80         &GUI_FontD60x80
N#define GUI_FONT_D80            &GUI_FontD80
N
N//
N// Comic fonts
N//
N#define GUI_FONT_COMIC18B_ASCII &GUI_FontComic18B_ASCII
N#define GUI_FONT_COMIC18B_1     &GUI_FontComic18B_1
N#define GUI_FONT_COMIC24B_ASCII &GUI_FontComic24B_ASCII
N#define GUI_FONT_COMIC24B_1     &GUI_FontComic24B_1
N
N/*********************************************************************
N*
N*       Text and drawing modes
N*
N* These defines come in two flavors: the long version (.._DRAWMODE_..)
N* and the short ones (.._DM_..). They are identical, feel free to use
N* which ever one you like best.
N*/
N#define GUI_DRAWMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_DRAWMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_DRAWMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_DRAWMODE_REV     LCD_DRAWMODE_REV
N#define GUI_DM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_DM_XOR           LCD_DRAWMODE_XOR
N#define GUI_DM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_DM_REV           LCD_DRAWMODE_REV
N
N#define GUI_TEXTMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_TEXTMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_TEXTMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_TEXTMODE_REV     LCD_DRAWMODE_REV
N#define GUI_TM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_TM_XOR           LCD_DRAWMODE_XOR
N#define GUI_TM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_TM_REV           LCD_DRAWMODE_REV
N
N/* Text alignment flags, horizontal */
N#define GUI_TA_HORIZONTAL  (3<<0)
N#define GUI_TA_LEFT        (0<<0)
N#define GUI_TA_RIGHT	     (1<<0)
N#define GUI_TA_CENTER	     (2<<0)
N#define GUI_TA_HCENTER	   GUI_TA_CENTER  /* easier to remember :-)  */
N
N/* Text alignment flags, vertical */
N#define GUI_TA_VERTICAL   (3<<2)
N#define GUI_TA_TOP	      (0<<2)
N#define GUI_TA_BOTTOM	    (1<<2)
N#define GUI_TA_BASELINE   (2<<2)
N#define GUI_TA_VCENTER    (3<<2)
N
N/* General orientation flags */
N#define GUI_MIRROR_X (1 << 0)
N#define GUI_MIRROR_Y (1 << 1)
N#define GUI_SWAP_XY  (1 << 2)
N
N/*********************************************************************
N*
N*       Min/Max coordinates
N*
N* Define minimum and maximum coordinates in x and y
N*/
N#define GUI_XMIN -4095
N#define GUI_XMAX  4095
N#define GUI_YMIN -4095
N#define GUI_YMAX  4095
N
N/*********************************************************************
N*
N*       Defines for constants
N*/
N#define	________	0x0
N#define	_______X	0x1
N#define	______X_	0x2
N#define	______XX	0x3
N#define	_____X__	0x4
N#define	_____X_X	0x5
N#define	_____XX_	0x6
N#define	_____XXX	0x7
N#define	____X___	0x8
N#define	____X__X	0x9
N#define	____X_X_	0xa
N#define	____X_XX	0xb
N#define	____XX__	0xc
N#define	____XX_X	0xd
N#define	____XXX_	0xe
N#define	____XXXX	0xf
N#define	___X____	0x10
N#define	___X___X	0x11
N#define	___X__X_	0x12
N#define	___X__XX	0x13
N#define	___X_X__	0x14
N#define	___X_X_X	0x15
N#define	___X_XX_	0x16
N#define	___X_XXX	0x17
N#define	___XX___	0x18
N#define	___XX__X	0x19
N#define	___XX_X_	0x1a
N#define	___XX_XX	0x1b
N#define	___XXX__	0x1c
N#define	___XXX_X	0x1d
N#define	___XXXX_	0x1e
N#define	___XXXXX	0x1f
N#define	__X_____	0x20
N#define	__X____X	0x21
N#define	__X___X_	0x22
N#define	__X___XX	0x23
N#define	__X__X__	0x24
N#define	__X__X_X	0x25
N#define	__X__XX_	0x26
N#define	__X__XXX	0x27
N#define	__X_X___	0x28
N#define	__X_X__X	0x29
N#define	__X_X_X_	0x2a
N#define	__X_X_XX	0x2b
N#define	__X_XX__	0x2c
N#define	__X_XX_X	0x2d
N#define	__X_XXX_	0x2e
N#define	__X_XXXX	0x2f
N#define	__XX____	0x30
N#define	__XX___X	0x31
N#define	__XX__X_	0x32
N#define	__XX__XX	0x33
N#define	__XX_X__	0x34
N#define	__XX_X_X	0x35
N#define	__XX_XX_	0x36
N#define	__XX_XXX	0x37
N#define	__XXX___	0x38
N#define	__XXX__X	0x39
N#define	__XXX_X_	0x3a
N#define	__XXX_XX	0x3b
N#define	__XXXX__	0x3c
N#define	__XXXX_X	0x3d
N#define	__XXXXX_	0x3e
N#define	__XXXXXX	0x3f
N#define	_X______	0x40
N#define	_X_____X	0x41
N#define	_X____X_	0x42
N#define	_X____XX	0x43
N#define	_X___X__	0x44
N#define	_X___X_X	0x45
N#define	_X___XX_	0x46
N#define	_X___XXX	0x47
N#define	_X__X___	0x48
N#define	_X__X__X	0x49
N#define	_X__X_X_	0x4a
N#define	_X__X_XX	0x4b
N#define	_X__XX__	0x4c
N#define	_X__XX_X	0x4d
N#define	_X__XXX_	0x4e
N#define	_X__XXXX	0x4f
N#define	_X_X____	0x50
N#define	_X_X___X	0x51
N#define	_X_X__X_	0x52
N#define	_X_X__XX	0x53
N#define	_X_X_X__	0x54
N#define	_X_X_X_X	0x55
N#define	_X_X_XX_	0x56
N#define	_X_X_XXX	0x57
N#define	_X_XX___	0x58
N#define	_X_XX__X	0x59
N#define	_X_XX_X_	0x5a
N#define	_X_XX_XX	0x5b
N#define	_X_XXX__	0x5c
N#define	_X_XXX_X	0x5d
N#define	_X_XXXX_	0x5e
N#define	_X_XXXXX	0x5f
N#define	_XX_____	0x60
N#define	_XX____X	0x61
N#define	_XX___X_	0x62
N#define	_XX___XX	0x63
N#define	_XX__X__	0x64
N#define	_XX__X_X	0x65
N#define	_XX__XX_	0x66
N#define	_XX__XXX	0x67
N#define	_XX_X___	0x68
N#define	_XX_X__X	0x69
N#define	_XX_X_X_	0x6a
N#define	_XX_X_XX	0x6b
N#define	_XX_XX__	0x6c
N#define	_XX_XX_X	0x6d
N#define	_XX_XXX_	0x6e
N#define	_XX_XXXX	0x6f
N#define	_XXX____	0x70
N#define	_XXX___X	0x71
N#define	_XXX__X_	0x72
N#define	_XXX__XX	0x73
N#define	_XXX_X__	0x74
N#define	_XXX_X_X	0x75
N#define	_XXX_XX_	0x76
N#define	_XXX_XXX	0x77
N#define	_XXXX___	0x78
N#define	_XXXX__X	0x79
N#define	_XXXX_X_	0x7a
N#define	_XXXX_XX	0x7b
N#define	_XXXXX__	0x7c
N#define	_XXXXX_X	0x7d
N#define	_XXXXXX_	0x7e
N#define	_XXXXXXX	0x7f
N#define	X_______	0x80
N#define	X______X	0x81
N#define	X_____X_	0x82
N#define	X_____XX	0x83
N#define	X____X__	0x84
N#define	X____X_X	0x85
N#define	X____XX_	0x86
N#define	X____XXX	0x87
N#define	X___X___	0x88
N#define	X___X__X	0x89
N#define	X___X_X_	0x8a
N#define	X___X_XX	0x8b
N#define	X___XX__	0x8c
N#define	X___XX_X	0x8d
N#define	X___XXX_	0x8e
N#define	X___XXXX	0x8f
N#define	X__X____	0x90
N#define	X__X___X	0x91
N#define	X__X__X_	0x92
N#define	X__X__XX	0x93
N#define	X__X_X__	0x94
N#define	X__X_X_X	0x95
N#define	X__X_XX_	0x96
N#define	X__X_XXX	0x97
N#define	X__XX___	0x98
N#define	X__XX__X	0x99
N#define	X__XX_X_	0x9a
N#define X__XX_XX	0x9b
N#define X__XXX__	0x9c
N#define X__XXX_X	0x9d
N#define	X__XXXX_	0x9e
N#define	X__XXXXX	0x9f
N#define	X_X_____	0xa0
N#define	X_X____X	0xa1
N#define	X_X___X_	0xa2
N#define	X_X___XX	0xa3
N#define	X_X__X__	0xa4
N#define	X_X__X_X	0xa5
N#define	X_X__XX_	0xa6
N#define	X_X__XXX	0xa7
N#define	X_X_X___	0xa8
N#define	X_X_X__X	0xa9
N#define	X_X_X_X_	0xaa
N#define	X_X_X_XX	0xab
N#define	X_X_XX__	0xac
N#define	X_X_XX_X	0xad
N#define	X_X_XXX_	0xae
N#define	X_X_XXXX	0xaf
N#define	X_XX____	0xb0
N#define X_XX___X	0xb1
N#define	X_XX__X_	0xb2
N#define	X_XX__XX	0xb3
N#define	X_XX_X__	0xb4
N#define	X_XX_X_X	0xb5
N#define	X_XX_XX_	0xb6
N#define	X_XX_XXX	0xb7
N#define	X_XXX___	0xb8
N#define	X_XXX__X	0xb9
N#define	X_XXX_X_	0xba
N#define	X_XXX_XX	0xbb
N#define	X_XXXX__	0xbc
N#define	X_XXXX_X	0xbd
N#define	X_XXXXX_	0xbe
N#define	X_XXXXXX	0xbf
N#define	XX______	0xc0
N#define	XX_____X	0xc1
N#define	XX____X_	0xc2
N#define	XX____XX	0xc3
N#define	XX___X__	0xc4
N#define	XX___X_X	0xc5
N#define	XX___XX_	0xc6
N#define	XX___XXX	0xc7
N#define	XX__X___	0xc8
N#define	XX__X__X	0xc9
N#define	XX__X_X_	0xca
N#define	XX__X_XX	0xcb
N#define	XX__XX__	0xcc
N#define	XX__XX_X	0xcd
N#define	XX__XXX_	0xce
N#define XX__XXXX	0xcf
N#define	XX_X____	0xd0
N#define	XX_X___X	0xd1
N#define	XX_X__X_	0xd2
N#define	XX_X__XX	0xd3
N#define	XX_X_X__	0xd4
N#define	XX_X_X_X	0xd5
N#define	XX_X_XX_	0xd6
N#define	XX_X_XXX	0xd7
N#define	XX_XX___	0xd8
N#define	XX_XX__X	0xd9
N#define	XX_XX_X_	0xda
N#define	XX_XX_XX	0xdb
N#define	XX_XXX__	0xdc
N#define	XX_XXX_X	0xdd
N#define	XX_XXXX_	0xde
N#define	XX_XXXXX	0xdf
N#define	XXX_____	0xe0
N#define	XXX____X	0xe1
N#define	XXX___X_	0xe2
N#define	XXX___XX	0xe3
N#define	XXX__X__	0xe4
N#define	XXX__X_X	0xe5
N#define	XXX__XX_	0xe6
N#define	XXX__XXX	0xe7
N#define	XXX_X___	0xe8
N#define	XXX_X__X	0xe9
N#define	XXX_X_X_	0xea
N#define	XXX_X_XX	0xeb
N#define	XXX_XX__	0xec
N#define	XXX_XX_X	0xed
N#define	XXX_XXX_	0xee
N#define	XXX_XXXX	0xef
N#define	XXXX____	0xf0
N#define	XXXX___X	0xf1
N#define	XXXX__X_	0xf2
N#define	XXXX__XX	0xf3
N#define	XXXX_X__	0xf4
N#define	XXXX_X_X	0xf5
N#define	XXXX_XX_	0xf6
N#define	XXXX_XXX	0xf7
N#define	XXXXX___	0xf8
N#define	XXXXX__X	0xf9
N#define	XXXXX_X_	0xfa
N#define	XXXXX_XX	0xfb
N#define	XXXXXX__	0xfc
N#define	XXXXXX_X	0xfd
N#define	XXXXXXX_	0xfe
N#define	XXXXXXXX	0xff
N
N/*********************************************************************
N*
N*       Compatibility with older versions
N*/
N#define GUI_DispString_UC  GUI_UC_DispString
N#define TOUCH_X_ActivateX  GUI_TOUCH_X_ActivateX
N#define TOUCH_X_ActivateY  GUI_TOUCH_X_ActivateY
N#define TOUCH_X_Disable    GUI_TOUCH_X_Disable
N#define TOUCH_X_MeasureX   GUI_TOUCH_X_MeasureX
N#define TOUCH_X_MeasureY   GUI_TOUCH_X_MeasureY
N#define GUI_SelLayer       GUI_SelectLayer
N#if defined(__cplusplus)
X#if 0L
S}
N#endif 
N
N#endif   /* ifdef GUI_H */
N
N/*************************** End of file ****************************/
L 21 "Setup\BSP.c" 2
N#include "GUIDRV_Lin.h"
L 1 "GUI\GUIDRV_Lin.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUIDRV_Lin.h
NPurpose     : Interface definition for GUIDRV_Lin driver
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GUIDRV_LIN_H
N#define GUIDRV_LIN_H
N
N/*********************************************************************
N*
N*       Display drivers
N*/
N//
N// Addresses
N//
Nextern const GUI_DEVICE_API GUIDRV_Win_API;
N
Nextern const GUI_DEVICE_API GUIDRV_Lin_1_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OY_1_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OX_1_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OXY_1_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OS_1_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSY_1_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSX_1_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSXY_1_API;
N
Nextern const GUI_DEVICE_API GUIDRV_Lin_2_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OY_2_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OX_2_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OXY_2_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OS_2_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSY_2_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSX_2_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSXY_2_API;
N
Nextern const GUI_DEVICE_API GUIDRV_Lin_4_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OY_4_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OX_4_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OXY_4_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OS_4_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSY_4_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSX_4_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSXY_4_API;
N
Nextern const GUI_DEVICE_API GUIDRV_Lin_8_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OY_8_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OX_8_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OXY_8_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OS_8_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSY_8_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSX_8_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSXY_8_API;
N
Nextern const GUI_DEVICE_API GUIDRV_Lin_16_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OY_16_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OX_16_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OXY_16_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OS_16_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSY_16_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSX_16_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSXY_16_API;
N
Nextern const GUI_DEVICE_API GUIDRV_Lin_24_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OY_24_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OX_24_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OXY_24_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OS_24_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSY_24_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSX_24_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSXY_24_API;
N
Nextern const GUI_DEVICE_API GUIDRV_Lin_32_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OY_32_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OX_32_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OXY_32_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OS_32_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSY_32_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSX_32_API;
Nextern const GUI_DEVICE_API GUIDRV_Lin_OSXY_32_API;
N
N//
N// Macros to be used in configuration files
N//
N#if defined(WIN32) && !defined(LCD_SIMCONTROLLER)
X#if 0L && !0L
S
S  #define GUIDRV_LIN_1       &GUIDRV_Win_API
S  #define GUIDRV_LIN_OY_1    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OX_1    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OXY_1   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OS_1    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSY_1   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSX_1   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSXY_1  &GUIDRV_Win_API
S
S  #define GUIDRV_LIN_2       &GUIDRV_Win_API
S  #define GUIDRV_LIN_OY_2    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OX_2    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OXY_2   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OS_2    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSY_2   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSX_2   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSXY_2  &GUIDRV_Win_API
S
S  #define GUIDRV_LIN_4       &GUIDRV_Win_API
S  #define GUIDRV_LIN_OY_4    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OX_4    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OXY_4   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OS_4    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSY_4   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSX_4   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSXY_4  &GUIDRV_Win_API
S
S  #define GUIDRV_LIN_8       &GUIDRV_Win_API
S  #define GUIDRV_LIN_OY_8    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OX_8    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OXY_8   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OS_8    &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSY_8   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSX_8   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSXY_8  &GUIDRV_Win_API
S
S  #define GUIDRV_LIN_16      &GUIDRV_Win_API
S  #define GUIDRV_LIN_OY_16   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OX_16   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OXY_16  &GUIDRV_Win_API
S  #define GUIDRV_LIN_OS_16   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSY_16  &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSX_16  &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSXY_16 &GUIDRV_Win_API
S
S  #define GUIDRV_LIN_24      &GUIDRV_Win_API
S  #define GUIDRV_LIN_OY_24   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OX_24   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OXY_24  &GUIDRV_Win_API
S  #define GUIDRV_LIN_OS_24   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSY_24  &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSX_24  &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSXY_24 &GUIDRV_Win_API
S
S  #define GUIDRV_LIN_32      &GUIDRV_Win_API
S  #define GUIDRV_LIN_OY_32   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OX_32   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OXY_32  &GUIDRV_Win_API
S  #define GUIDRV_LIN_OS_32   &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSY_32  &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSX_32  &GUIDRV_Win_API
S  #define GUIDRV_LIN_OSXY_32 &GUIDRV_Win_API
S
N#else
N
N  #define GUIDRV_LIN_1       &GUIDRV_Lin_1_API
N  #define GUIDRV_LIN_OY_1    &GUIDRV_Lin_OY_1_API
N  #define GUIDRV_LIN_OX_1    &GUIDRV_Lin_OX_1_API
N  #define GUIDRV_LIN_OXY_1   &GUIDRV_Lin_OXY_1_API
N  #define GUIDRV_LIN_OS_1    &GUIDRV_Lin_OS_1_API
N  #define GUIDRV_LIN_OSY_1   &GUIDRV_Lin_OSY_1_API
N  #define GUIDRV_LIN_OSX_1   &GUIDRV_Lin_OSX_1_API
N  #define GUIDRV_LIN_OSXY_1  &GUIDRV_Lin_OSXY_1_API
N
N  #define GUIDRV_LIN_2       &GUIDRV_Lin_2_API
N  #define GUIDRV_LIN_OY_2    &GUIDRV_Lin_OY_2_API
N  #define GUIDRV_LIN_OX_2    &GUIDRV_Lin_OX_2_API
N  #define GUIDRV_LIN_OXY_2   &GUIDRV_Lin_OXY_2_API
N  #define GUIDRV_LIN_OS_2    &GUIDRV_Lin_OS_2_API
N  #define GUIDRV_LIN_OSY_2   &GUIDRV_Lin_OSY_2_API
N  #define GUIDRV_LIN_OSX_2   &GUIDRV_Lin_OSX_2_API
N  #define GUIDRV_LIN_OSXY_2  &GUIDRV_Lin_OSXY_2_API
N
N  #define GUIDRV_LIN_4       &GUIDRV_Lin_4_API
N  #define GUIDRV_LIN_OY_4    &GUIDRV_Lin_OY_4_API
N  #define GUIDRV_LIN_OX_4    &GUIDRV_Lin_OX_4_API
N  #define GUIDRV_LIN_OXY_4   &GUIDRV_Lin_OXY_4_API
N  #define GUIDRV_LIN_OS_4    &GUIDRV_Lin_OS_4_API
N  #define GUIDRV_LIN_OSY_4   &GUIDRV_Lin_OSY_4_API
N  #define GUIDRV_LIN_OSX_4   &GUIDRV_Lin_OSX_4_API
N  #define GUIDRV_LIN_OSXY_4  &GUIDRV_Lin_OSXY_4_API
N
N  #define GUIDRV_LIN_8       &GUIDRV_Lin_8_API
N  #define GUIDRV_LIN_OY_8    &GUIDRV_Lin_OY_8_API
N  #define GUIDRV_LIN_OX_8    &GUIDRV_Lin_OX_8_API
N  #define GUIDRV_LIN_OXY_8   &GUIDRV_Lin_OXY_8_API
N  #define GUIDRV_LIN_OS_8    &GUIDRV_Lin_OS_8_API
N  #define GUIDRV_LIN_OSY_8   &GUIDRV_Lin_OSY_8_API
N  #define GUIDRV_LIN_OSX_8   &GUIDRV_Lin_OSX_8_API
N  #define GUIDRV_LIN_OSXY_8  &GUIDRV_Lin_OSXY_8_API
N
N  #define GUIDRV_LIN_16      &GUIDRV_Lin_16_API
N  #define GUIDRV_LIN_OY_16   &GUIDRV_Lin_OY_16_API
N  #define GUIDRV_LIN_OX_16   &GUIDRV_Lin_OX_16_API
N  #define GUIDRV_LIN_OXY_16  &GUIDRV_Lin_OXY_16_API
N  #define GUIDRV_LIN_OS_16   &GUIDRV_Lin_OS_16_API
N  #define GUIDRV_LIN_OSY_16  &GUIDRV_Lin_OSY_16_API
N  #define GUIDRV_LIN_OSX_16  &GUIDRV_Lin_OSX_16_API
N  #define GUIDRV_LIN_OSXY_16 &GUIDRV_Lin_OSXY_16_API
N
N  #define GUIDRV_LIN_24      &GUIDRV_Lin_24_API
N  #define GUIDRV_LIN_OY_24   &GUIDRV_Lin_OY_24_API
N  #define GUIDRV_LIN_OX_24   &GUIDRV_Lin_OX_24_API
N  #define GUIDRV_LIN_OXY_24  &GUIDRV_Lin_OXY_24_API
N  #define GUIDRV_LIN_OS_24   &GUIDRV_Lin_OS_24_API
N  #define GUIDRV_LIN_OSY_24  &GUIDRV_Lin_OSY_24_API
N  #define GUIDRV_LIN_OSX_24  &GUIDRV_Lin_OSX_24_API
N  #define GUIDRV_LIN_OSXY_24 &GUIDRV_Lin_OSXY_24_API
N
N  #define GUIDRV_LIN_32      &GUIDRV_Lin_32_API
N  #define GUIDRV_LIN_OY_32   &GUIDRV_Lin_OY_32_API
N  #define GUIDRV_LIN_OX_32   &GUIDRV_Lin_OX_32_API
N  #define GUIDRV_LIN_OXY_32  &GUIDRV_Lin_OXY_32_API
N  #define GUIDRV_LIN_OS_32   &GUIDRV_Lin_OS_32_API
N  #define GUIDRV_LIN_OSY_32  &GUIDRV_Lin_OSY_32_API
N  #define GUIDRV_LIN_OSX_32  &GUIDRV_Lin_OSX_32_API
N  #define GUIDRV_LIN_OSXY_32 &GUIDRV_Lin_OSXY_32_API
N
N#endif
N
N#endif
N
N/*************************** End of file ****************************/
L 22 "Setup\BSP.c" 2
N#include "I2CPCA9532.h"
L 1 "Setup\I2CPCA9532.h" 1
N/*********************************************************************
N*               SEGGER MICROCONTROLLER SYSTEME GmbH                  *
N*       Solutions for real time microcontroller applications         *
N**********************************************************************
N*                                                                    *
N*       (C) 2006   SEGGER Microcontroller Systeme GmbH               *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : I2CPCA9532.h
NPurpose : I2C PCA9532 header
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N         void I2CPCA9532_Init     (void);
Nunsigned char I2CPCA9532_WriteRead(unsigned char * pData, unsigned short NumBytesToWrite, unsigned char * pBuf, unsigned short NumBytesToRead);
L 23 "Setup\BSP.c" 2
N#include "LCDConf.h"
L 1 "Config\LCDConf.h" 1
N#ifndef LCDCONF_H
N#define LCDCONF_H
N
N#endif /* LCDCONF_H */
L 24 "Setup\BSP.c" 2
N
N/*********************************************************************
N*
N*       Configuration
N*
N**********************************************************************
N*/
N#define TOUCHTIMERINTERVAL     (10)  // Interval in ms
N
N/*********************************************************************
N*
N*       Layer configuration (to be modified)
N*
N**********************************************************************
N*/
N//
N// Physical display size
N//
N#define XSIZE_PHYS                320
N#define YSIZE_PHYS                240
N
N//
N// Virtual display size
N//
N#define VXSIZE_PHYS               (2 * XSIZE_PHYS)
N#define VYSIZE_PHYS               YSIZE_PHYS
N
N//
N// Color conversion
N//
N#define COLOR_CONVERSION          GUICC_565
N
N//
N// Display driver
N//
N#define DISPLAY_DRIVER            GUIDRV_Lin_OSX_16_API
N
N//
N// Pixel width in bytes
N//
N#define PIXEL_WIDTH               2
N
N//
N// Touch controller values
N//
N#define TOUCH_AD_TOP              (184)
N#define TOUCH_AD_BOTTOM           (3894)
N#define TOUCH_AD_LEFT             (154)
N#define TOUCH_AD_RIGHT            (3834)
N
N//
N// Video RAM address
N//
N#define VRAM_ADDR             ((U32)&_aVRAM[0])
N
N//
N// Video RAM
N//
Nstatic U32 _aVRAM[(VXSIZE_PHYS * VYSIZE_PHYS / (4 / PIXEL_WIDTH)) + 8];
Xstatic unsigned long _aVRAM[((2 * 320) * 240 / (4 / 2)) + 8];
N
N/*********************************************************************
N*
N*       Configuration checking
N*
N**********************************************************************
N*/
N#ifndef   VXSIZE_PHYS
S  #define VXSIZE_PHYS XSIZE_PHYS
N#endif
N#ifndef   VYSIZE_PHYS
S  #define VYSIZE_PHYS YSIZE_PHYS
N#endif
N#ifndef   VRAM_ADDR
S  #define VRAM_ADDR 0
N#endif
N
N#ifndef   XSIZE_PHYS
S  #error Physical X size of display is not defined!
N#endif
N#ifndef   YSIZE_PHYS
S  #error Physical Y size of display is not defined!
N#endif
N#ifndef   COLOR_CONVERSION
S  #error Color conversion not defined!
N#endif
N#ifndef   DISPLAY_DRIVER
S  #error No display driver defined!
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N
N#define INT_INDEX_MAC                (21)
N
N/* LED states */
N#define LED_SET                      (0)
N#define LED_CLR                      (1)
N#define LED_TOGGLE                   (2)
N
N/****** Addresses of sfrs and peripheral identifiers ****************/
N#define PINSEL_BASE_ADDR             (0xE002C000)
N#define PINMODE_BASE_ADDR            (0xE002C040)
N#define FIO_BASE_ADDR                (0x3FFFC000)
N#define PWM1_BASE_ADDR               (0xE0018000)
N#define SPI0_BASE_ADDR               (0xE0020000)
N#define IO_BASE_ADDR                 (0xE0028000)
N#define LCDC_BASE_ADDR               (0xFFE10000)
N
N/****** SFRs and identifiers used for SPI initialization ************/
N#define SPI_BASE_ADDR                (0xE0020000)
N#define SPI_S0SPCR                   (*(volatile U32*) SPI_BASE_ADDR)
N#define SPI_S0SPSR                   (*(volatile U32*) (SPI_BASE_ADDR + 0x04))
N#define SPI_S0SPDR                   (*(volatile U32*) (SPI_BASE_ADDR + 0x08))
N#define SPI_S0SPCCR                  (*(volatile U32*) (SPI_BASE_ADDR + 0x0C))
N
N#define CS_PIN                       (1 << 20)  //P0.20
N
N/****** SFRs and identifiers used for LED demo **********************/
N#define PINSEL0                      (*(volatile U32 *)(PINSEL_BASE_ADDR + 0x0000))
N#define PINSEL1                      (*(volatile U32 *)(PINSEL_BASE_ADDR + 0x0004))
N#define PINSEL2                      (*(volatile U32 *)(PINSEL_BASE_ADDR + 0x0008))
N#define PINSEL3                      (*(volatile U32 *)(PINSEL_BASE_ADDR + 0x000C))
N#define PINSEL4                      (*(volatile U32 *)(PINSEL_BASE_ADDR + 0x0010))
N#define PINSEL9                      (*(volatile U32 *)(PINSEL_BASE_ADDR + 0x0024))
N#define PINSEL10                     (*(volatile U32 *)(PINSEL_BASE_ADDR + 0x0028))
N#define PINSEL11                     (*(volatile U32 *)(PINSEL_BASE_ADDR + 0x002C))
N
N#define PINMODE0                     (*(volatile U32 *)(PINMODE_BASE_ADDR + 0x0000))
N#define PINMODE1                     (*(volatile U32 *)(PINMODE_BASE_ADDR + 0x0004))
N#define PINMODE3                     (*(volatile U32 *)(PINMODE_BASE_ADDR + 0x000C))
N#define PINMODE4                     (*(volatile U32 *)(PINMODE_BASE_ADDR + 0x0010))
N#define PINMODE9                     (*(volatile U32 *)(PINMODE_BASE_ADDR + 0x0024))
N
N
N#define FIO2DIR                      (*(volatile U32 *)(FIO_BASE_ADDR    + 0x0040))
N#define FIO2PIN                      (*(volatile U32 *)(FIO_BASE_ADDR    + 0x0054))
N#define FIO2SET                      (*(volatile U32 *)(FIO_BASE_ADDR    + 0x0058))
N
N#define PWM1TCR                      (*(volatile U32 *)(PWM1_BASE_ADDR   + 0x0004))
N#define PWM1PR                       (*(volatile U32 *)(PWM1_BASE_ADDR   + 0x000C))
N#define PWM1MCR                      (*(volatile U32 *)(PWM1_BASE_ADDR   + 0x0014))
N#define PWM1MR0                      (*(volatile U32 *)(PWM1_BASE_ADDR   + 0x0018))
N#define PWM1MR1                      (*(volatile U32 *)(PWM1_BASE_ADDR   + 0x001C))
N#define PWM1PCR                      (*(volatile U32 *)(PWM1_BASE_ADDR   + 0x004C))
N#define PWM1LER                      (*(volatile U32 *)(PWM1_BASE_ADDR   + 0x0050))
N
N#define S0SPCR                       (*(volatile U32 *)(SPI0_BASE_ADDR   + 0x0000))
N#define S0SPSR                       (*(volatile U32 *)(SPI0_BASE_ADDR   + 0x0004))
N#define S0SPDR                       (*(volatile U32 *)(SPI0_BASE_ADDR   + 0x0008))
N#define S0SPCCR                      (*(volatile U32 *)(SPI0_BASE_ADDR   + 0x000C))
N
N#define IO0SET                       (*(volatile U32 *)(IO_BASE_ADDR     + 0x0004))
N#define IO0DIR                       (*(volatile U32 *)(IO_BASE_ADDR     + 0x0008))
N#define IO0CLR                       (*(volatile U32 *)(IO_BASE_ADDR     + 0x000C))
N
N#define LCD_CFG                      (*(volatile U32 *)(0xE01FC1B8))
N
N#define LCD_TIMH                     (*(volatile U32 *)(LCDC_BASE_ADDR   + 0x0000))
N#define LCD_TIMV                     (*(volatile U32 *)(LCDC_BASE_ADDR   + 0x0004))
N#define LCD_POL                      (*(volatile U32 *)(LCDC_BASE_ADDR   + 0x0008))
N#define LCD_LE                       (*(volatile U32 *)(LCDC_BASE_ADDR   + 0x000C))
N#define LCD_UPBASE                   (*(volatile U32 *)(LCDC_BASE_ADDR   + 0x0010))
N#define LCD_CTRL                     (*(volatile U32 *)(LCDC_BASE_ADDR   + 0x0018))
N#define LCD_INTMSK                   (*(volatile U32 *)(LCDC_BASE_ADDR   + 0x001C))
N
N
N#define LCD_PAL_ADDR                                             (LCDC_BASE_ADDR   + 0x0200)
N
N#define MAC_MODULEID                 (*(volatile U32 *)(0xFFE00FFC))  // MAC ID register
N
N
N
N//
N// System Control Block(SCB) modules include Memory Accelerator Module,
N// Phase Locked Loop, VPB divider, Power Control, External Interrupt,
N// Reset, and Code Security/Debugging
N//
N#define SCB_BASE_ADDR	0xE01FC000
N/* Power Control */
N#define PCON                         (*(volatile U32 *)(SCB_BASE_ADDR + 0x0C0))
N#define PCONP                        (*(volatile U32 *)(0xE01FC0C4))
N
N//
N// On LPC23xx, the names are USBClkCtrl and USBClkSt; on LPC24xx, the names are
N// OTG_CLK_CTRL and OTG_CLK_STAT respectively.
N//
N#define USBOTG_CLK_BASE_ADDR	0xFFE0CFF0
N#define OTG_CLK_CTRL                 (*(volatile U32 *)(USBOTG_CLK_BASE_ADDR + 0x04))
N#define OTG_CLK_STAT                 (*(volatile U32 *)(USBOTG_CLK_BASE_ADDR + 0x08))
N
N#define EXTINT                       (*(volatile U32 *)(0xE01FC140))
N#define EXTMODE                      (*(volatile U32 *)(0xE01FC148))
N
N#define INT_INDEX_USB  22
N
N/*	register PCONP */
N#define PCUSB 	                      ((U32)1<<31) /* USB interface power/clock 0 */
N
N/* USB PIN selection masks */
N
N/*** PINSEL0 ***/
N#define PS0_P012_USB_PPWR2      (1 << 24)    /*Port Power enable signal for USB port 2. */
N#define PS0_P013_USB_UP_LED2    (1 << 26)    /* USB port 2 GoodLink LED indicator.
N                                                It is LOW when device is configured (non-control endpoints enabled).
N                                                It is HIGH when the device is not configured or during global suspend.
N                                           */
N#define PS0_P014_USB_HSTEN2     (1 << 28)    /* Host Enabled status for USB port 2.*/
N#define PS0_P014_USB_CONN2      (2 << 28)    /* USB device SoftConnect control for USB port 2.*/
N
N/*** PINSEL1 ***/
N#define PS1_P029_USB_DP1        (1 << 26)         /* USB port 1 bidirectional D+ line. */
N#define PS1_P030_USB_DM1        (1 << 28)         /* USB port 1 bidirectional D-line, USB DM2 has an own pin! */
N#define PS1_P031_USB_DP2        (1 << 30)         /* USB port 2 bidirectional D+ Line*/
N
N/*** PINSEL3 ***/
N#define PS3_P118_USB_UP_LED1    (1 <<  4)       /* USB port 1 GoodLink LED indicator. It is LOW when device is configured (non-control endpoints enabled).*/
N#define PS3_P119_USB_TX_E1      (1 <<  6)     /* Transmit Enable signal for USB port 1 (OTG transceiver). */
N#define PS3_P119_USB_PPWR1      (2 <<  6)     /* Port Power enable signal for USB port 1. */
N/***** OTG TRANCEIVER and Port 1 Power Overcurrent ****/
N#define PS3_P120_USB_TX_DP1     (1 <<  8)           /* D+ transmit data for USB port 1 (OTG transceiver). */
N#define PS3_P121_USB_TX_DM1     (1 << 10)          /* D- transmit data for USB port 1 (OTG transceiver).*/
N#define PS3_P122_USB_RCV1       (1 << 12)            /* Differential receive data for USB port 1 (OTG transceiver). */
N#define PS3_P122_USB_PWRD1      (2 << 12)            /* Power Status for USB port 1 (host power switch). */
N#define PS3_P123_USB_RX_DP1     (1 << 14)          /* D+ receive data for USB port 1 (OTG transceiver). */
N#define PS3_P124_USB_RX_DM1     (1 << 16)          /*D- receive data for USB port 1 (OTG transceiver).*/
N#define PS3_P125_USB_LS1        (1 << 18)           /* Low-speed status for USB port 1 (OTG transceiver). */
N#define PS3_P125_USB_HSTEN1     (2 << 18)           /* Low-speed status for USB port 1 (OTG transceiver). */
N#define PS3_P126_USB_SSPND1     (1 << 20)           /*USB port 1 Bus Suspend status (OTG transceiver). */
N#define PS3_P127_USB_INT1       (1 << 22)            /* USB port 1 OTG ATX interrupt (OTG transceiver). */
N#define PS3_P127_USB_OVRCR1     (2 << 22)           /* USB port 1 Over-Current status. */
N#define PS3_P128_USB_SCL1       (1 << 24)            /* USB port 1 Over-Current status. */
N#define PS3_P129_USB_SDA1       (1 << 26)            /* USB port 1 I2C serial data (OTG transceiver). */
N/***** Port 2 Power Overcurrent ****/
N#define PS3_P130_USB_PWRD2      (1 << 28)      /* Power Status for USB port 2. */
N#define PS3_P130_USB_VBUS       (2 << 28)      /* Indicates the presence of USB bus power. */
N#define PS3_P131_USB_OVECR2     (1 << 30)      /* Over-Current status for USB port 2. */
N
N//
N// USB clock control
N// USBClkCtrl reg. OTG clock control register,
N// also referred as OTG clock control register!!!	
N//
N#define USB_HOST_CLK_EN	(1<<0)
N#define USB_DEV_CLK_EN	(1<<1)
N#define USB_I2C_CLK_EN	(1<<2)
N#define USB_OTG_CLK_EN	(1<<3)
N#define USB_AHB_CLK_EN	(1<<4)
N
N
N/* PIN mode register values */
N
N#define PIN_MODE_PULL_UP   0
N#define PIN_MODE_NO_PULLS  2
N#define PIN_MODE_PULL_DOWN 3
N#define PIN_MODE_MASK      3
N
N#define PINMODE_GET_0_TO_15(PIN_NUMBER,PIN_MODE)     ((PIN_MODE) << PIN_NUMBER)
N#define PINMODE_GET_16_TO_31(PIN_NUMBER,PIN_MODE)    ((PIN_MODE) << (PIN_NUMBER-16))
N
N
N/*********************************************************************
N*
N*       Static data
N*
N**********************************************************************
N*/
Nstatic OS_TIMER _TouchTimer;
Nstatic U32      _VRAMAddr;
Xstatic unsigned long      _VRAMAddr;
N
N/*********************************************************************
N*
N*       Static functions
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       _Delay()
N*/
Nstatic void _Delay(int ms) {
N  volatile int i;
N
N  for (i = 0; i < (50 * ms); i++) {}  // Delay of x * 1ms
N}
N
N/*********************************************************************
N*
N*       _SetLEDState()
N*/
Nstatic void _SetLEDState(unsigned char LED, unsigned char State) {
N  U8  acCommandString[2] = {0x08, 0x00};
X  unsigned char  acCommandString[2] = {0x08, 0x00};
N  U8  Reg;
X  unsigned char  Reg;
N
N  if (LED > 7) {
N    return;
N  }
N  //
N  // Adjust address if LED >= 5
N  //
N  if (LED >= 4) {
N    acCommandString[0] = 0x09;
N  }
N  //
N  // Read current register value
N  //
N  OS_IncDI();
X  { { if (!(((OS_Counters . Cnt . DI & 0xf0) == 0))) OS_Error((153)); }; __disable_irq(); OS_Counters . Cnt . DI++; };
N  I2CPCA9532_WriteRead(acCommandString, 1, &Reg, 1);
N  OS_DecRI();
X  { { if (!(((OS_Counters . Cnt . DI & 0xf0) == 0))) OS_Error((153)); }; if (--OS_Counters . Cnt . DI==0) __enable_irq(); };
N  //
N  // Set new LED state
N  //
N  if (LED >= 4) {
N    LED -= 4;  // Address was already corrected above
N  }
N  if (State == LED_SET) {
X  if (State == (0)) {
N    Reg |= (1 << (LED * 2)); //0x01;
N  } else if (State == LED_TOGGLE) {
X  } else if (State == (2)) {
N    if (Reg & (1 << (LED * 2))) {
N      Reg &= ~(1 << (LED * 2));
N    } else {
N      Reg |= (1 << (LED * 2));
N    }
N  } else {
N    Reg &= ~(1 << (LED * 2));
N  }
N  acCommandString[1] = Reg;
N  OS_IncDI();
X  { { if (!(((OS_Counters . Cnt . DI & 0xf0) == 0))) OS_Error((153)); }; __disable_irq(); OS_Counters . Cnt . DI++; };
N  I2CPCA9532_WriteRead(acCommandString, sizeof(acCommandString), 0, 0);
N  OS_DecRI();
X  { { if (!(((OS_Counters . Cnt . DI & 0xf0) == 0))) OS_Error((153)); }; if (--OS_Counters . Cnt . DI==0) __enable_irq(); };
N}
N/*********************************************************************
N*
N*       _LCD_HW_Init()
N*/
Nstatic void _LCD_HW_Init(void) {
N  PCONP   |= (1 << 20);   // Enable peripheral clock for LCDC
X  (*(volatile unsigned long *)(0xE01FC0C4))   |= (1 << 20);   
N  //
N  // Turn on LCD power
N  //
N  FIO2DIR |= (1 << 0);
X  (*(volatile unsigned long *)((0x3FFFC000) + 0x0040)) |= (1 << 0);
N  FIO2SET  = (1 << 0);
X  (*(volatile unsigned long *)((0x3FFFC000) + 0x0058))  = (1 << 0);
N
N  //
N  // Set P1.18 as PWM output
N  //
N  PINSEL3 &= ~(0x3 << 4);  // Clear P1[18]
X  (*(volatile unsigned long *)((0xE002C000) + 0x000C)) &= ~(0x3 << 4);  
N  PINSEL3 |= (1 << 5);     // PWM1[1]
X  (*(volatile unsigned long *)((0xE002C000) + 0x000C)) |= (1 << 5);     
N  PWM1PR  = 0x00;          // No prescaling
X  (*(volatile unsigned long *)((0xE0018000) + 0x000C))  = 0x00;          
N  PWM1MCR = (1 << 1);      // Reset counter if MR0 match
X  (*(volatile unsigned long *)((0xE0018000) + 0x0014)) = (1 << 1);      
N  PWM1MR0 = 0x3000;        // Period time equal about 5 ms
X  (*(volatile unsigned long *)((0xE0018000) + 0x0018)) = 0x3000;        
N  PWM1MR1 = 0x00;
X  (*(volatile unsigned long *)((0xE0018000) + 0x001C)) = 0x00;
N  PWM1LER = 0
X  (*(volatile unsigned long *)((0xE0018000) + 0x0050)) = 0
N            | (1 << 0)     // Latch MR0
N            | (1 << 1)     // Latch MR1
N            ;
N  PWM1PCR = (1 << 9);      // Enable PWMENA1
X  (*(volatile unsigned long *)((0xE0018000) + 0x004C)) = (1 << 9);      
N  PWM1TCR = 0
X  (*(volatile unsigned long *)((0xE0018000) + 0x0004)) = 0
N            | (1 << 0)     // Enable counter
N            | (1 << 3)     // Enable PWM
N            ;
N  //
N  // Init SPI0
N  //
N  PINSEL0 |= (0x3uL << 30);   // SCK
X  (*(volatile unsigned long *)((0xE002C000) + 0x0000)) |= (0x3uL << 30);   
N  PINSEL1 |= (0
X  (*(volatile unsigned long *)((0xE002C000) + 0x0004)) |= (0
N              | (0x3 << 2)  // SSEL
N              | (0x3 << 4)  // MOSI
N             );
N  IO0DIR  |= (0
X  (*(volatile unsigned long *)((0xE0028000) + 0x0008))  |= (0
N              | (1 << 16)
N              | (1 << 19)
N             );
N  IO0SET   =  0
X  (*(volatile unsigned long *)((0xE0028000) + 0x0004))   =  0
N              | (1 << 16)
N              | (1 << 19)
N              ;
N  S0SPCCR  =  0xC;          // SPI0 clock counter setting
X  (*(volatile unsigned long *)((0xE0020000) + 0x000C))  =  0xC;          
N  S0SPCR   =  0
X  (*(volatile unsigned long *)((0xE0020000) + 0x0000))   =  0
N              | (1 << 3)    // Clock phase control, data is sampled on second clock edge of SCK
N              | (1 << 4)    // CPOL, SCK is active low
N              | (1 << 5)    // MSTR, SPI operates in master mode
N              ;
N  PINSEL10 = 0x00;
X  (*(volatile unsigned long *)((0xE002C000) + 0x0028)) = 0x00;
N  PINSEL0  = (PINSEL0 & 0xFFF000FF)
X  (*(volatile unsigned long *)((0xE002C000) + 0x0000))  = ((*(volatile unsigned long *)((0xE002C000) + 0x0000)) & 0xFFF000FF)
N             | (1 <<  8)    // I2SRX_CLK  / LCDVD[0]
N             | (1 << 10)    // I2SRX_WS   / LCDVD[1]
N             | (1 << 12)    // I2SRX_SDA  / LCDVD[8]
N             | (1 << 14)    // I2STX_CLK  / LCDVD[9]
N             | (1 << 16)    // I2STX_WS   / LCDVD[16]
N             | (1 << 18)    // I2STX_SDA  / LCDVD[17]
N             ;
N  PINSEL3  = (PINSEL3 & 0xF00000FF)
X  (*(volatile unsigned long *)((0xE002C000) + 0x000C))  = ((*(volatile unsigned long *)((0xE002C000) + 0x000C)) & 0xF00000FF)
N             | (1 <<  8)    // USB_TX_DP1 / LCDVD[6]  / LCDVD[10]
N             | (1 << 10)    // USB_TX_DM1 / LCDVD[7]  / LCDVD[11]
N             | (1 << 12)    // USB_RCV1   / LCDVD[8]  / LCDVD[12]
N             | (1 << 14)    // USB_RX_DP1 / LCDVD[9]  / LCDVD[13]
N             | (1 << 16)    // USB_RX_DM1 / LCDVD[10] / LCDVD[14]
N             | (1 << 18)    // USB_LS1    / LCDVD[11] / LCDVD[15]
N             | (1 << 20)    // USB_SSPND1 / LCDVD[12] / LCDVD[20]
N             | (1 << 22)    // USB_INT1   / LCDVD[13] / LCDVD[21]
N             | (1 << 24)    // USB_SCL1   / LCDVD[14] / LCDVD[22]
N             | (1 << 26)    // USB_SDA1   / LCDVD[15] / LCDVD[23]
N             ;
N  PINSEL4  = (PINSEL4 & 0xF0300000)
X  (*(volatile unsigned long *)((0xE002C000) + 0x0010))  = ((*(volatile unsigned long *)((0xE002C000) + 0x0010)) & 0xF0300000)
N             | (0x3 <<  0)  // TRACECLK   / LCDPWR
N             | (0x3 <<  2)  // PIPESTAT0  / LCDLE
N             | (0x3 <<  4)  // PIPESTAT1  / LCDDCLK
N             | (0x3 <<  6)  // PIPESTAT2  / LCDFP
N             | (0x3 <<  8)  // TRACESYNC  / LCDENAB   / LCDM
N             | (0x3 << 10)  // TRACEPKT0  / LCDLP
N             | (0x3 << 12)  // TRACEPKT1  / LCDVD[0]  / LCDVD[4]
N             | (0x3 << 14)  // TRACEPKT2  / LCDVD[1]  / LCDVD[5]
N             | (0x3 << 16)  // TRACEPKT3  / LCDVD[2]  / LCDVD[6]
N             | (0x3 << 18)  // EXTIN0     / LCDVD[3]  / LCDVD[7]
N             | (1   << 22)  // EINT1      / LCDCLKIN
N             | (1   << 24)  // EINT2      / LCDVD[4]  / LCDVD[3]  / LCDVD[8]  / LCDVD[18]
N             | (1   << 24)  // EINT3      / LCDVD[5]  / LCDVD[9]  / LCDVD[19]
N             ;
N  PINSEL9  = (PINSEL9 & 0xF0FFFFFF)
X  (*(volatile unsigned long *)((0xE002C000) + 0x0024))  = ((*(volatile unsigned long *)((0xE002C000) + 0x0024)) & 0xF0FFFFFF)
N             | (1 << 25)    // MAT2[0]    / LCDVD[6]  / LCDVD[10] / LCDVD[2]
N             | (1 << 27)    // MAT2[1]    / LCDVD[7]  / LCDVD[11] / LCDVD[3]
N             ;
N  PINSEL11 = 0
X  (*(volatile unsigned long *)((0xE002C000) + 0x002C)) = 0
N             | (1   << 0)   // Enable LCD port
N             | (0x3 << 2)   // LCD Mode: TFT 16-bit (1:5:5:5 mode)
N             ;
N}
N
N/*********************************************************************
N*
N*       _LCD_SetBacklight()
N*/
Nstatic void _LCD_SetBacklight(unsigned char Percent) {
N  PWM1MR1 = ((unsigned long)0x3000 * (unsigned long)(100 - Percent)) / (unsigned long)100;
X  (*(volatile unsigned long *)((0xE0018000) + 0x001C)) = ((unsigned long)0x3000 * (unsigned long)(100 - Percent)) / (unsigned long)100;
N  PWM1LER = (1 << 1);
X  (*(volatile unsigned long *)((0xE0018000) + 0x0050)) = (1 << 1);
N}
N
N/*********************************************************************
N*
N*       _LCD_Ctrl_Init()
N*/
Nstatic void _LCD_Ctrl_Init(void) {
N  unsigned long* pPal = 0;
N  unsigned char  i;
N
N  LCD_CTRL &= 0xFFFFFFFE;  // Disable the display
X  (*(volatile unsigned long *)((0xFFE10000) + 0x0018)) &= 0xFFFFFFFE;  
N
N  // ppl value to set = ppl / 16 -1 (2:7)
N  // hsw value to set = hsw - 1     (8:15)
N  // hfp value to set = hfp - 1     (16:23)
N  // hbp value to set = hbp - 1     (24:31)
N  LCD_TIMH   = 0
X  (*(volatile unsigned long *)((0xFFE10000) + 0x0000))   = 0
N               | (((240 / 16) - 1) <<  2)  // (Pixels per line / 16) - 1
N               | (( 2 - 1)         <<  8)  // Horizontal synchronization pulse width - 1
N               | ((10 - 1)         << 16)  // Horizontal front porch - 1
N               | ((28 - 1)         << 24)  // Horizontal back porch  - 1
N               ;
N  LCD_TIMV   = 0
X  (*(volatile unsigned long *)((0xFFE10000) + 0x0004))   = 0
N               | ((320 - 1)        <<  0)  // Lines per panel - 1
N               | ((  2 - 1)        << 10)  // Vertical synchronization pulse width - 1
N               | ((  2 - 1)        << 16)  // Vertical front porch
N               | ((  3 - 1)        << 24)  // Vertical back porch
N               ;
N  LCD_POL    = 0
X  (*(volatile unsigned long *)((0xFFE10000) + 0x0008))    = 0
N               | (( 13 - 2) <<  0)  // Lower five bits of panel clock divisor
N               |         (1 << 11)  // Invert vertical synchronization
N               |         (1 << 12)  // Invert horizontal synchronization
N               |         (1 << 13)  // Invert panel clock
N               | ((240 - 1) << 16)  // Clocks per line = (Pixels per line / 1) - 1
N               ;
N  LCD_LE     = 0x00;                // skip line end control
X  (*(volatile unsigned long *)((0xFFE10000) + 0x000C))     = 0x00;                
N  LCD_INTMSK = 0;                   // Disable interrupts
X  (*(volatile unsigned long *)((0xFFE10000) + 0x001C)) = 0;                   
N  LCD_CTRL   = 0
X  (*(volatile unsigned long *)((0xFFE10000) + 0x0018))   = 0
N               | (0x06 << 1)        // 16 bits per pixel
N               | (   1 << 5)        // TFT
N               ;
N  //
N  // Clear palette
N  //
N  pPal = (unsigned long*)LCD_PAL_ADDR;
X  pPal = (unsigned long*)((0xFFE10000) + 0x0200);
N  for (i = 0; i < 128; i++) {
N    *pPal++ = 0;
N  }
N  LCD_CFG = 0x00;  // 0 = Divide by 1
X  (*(volatile unsigned long *)(0xE01FC1B8)) = 0x00;  
N  _Delay(20);
N}
N
N/*********************************************************************
N*
N*       _SPI_Send()
N*/
Nstatic void _SPI_Send(unsigned char Data) {
N  unsigned long Failsafe = 0;
N
N  S0SPDR = Data;
X  (*(volatile unsigned long *)((0xE0020000) + 0x0008)) = Data;
N  while (((S0SPSR & 0x80) == 0) && (Failsafe < 5000)) {  // while (SPI Transfer active)
X  while ((((*(volatile unsigned long *)((0xE0020000) + 0x0004)) & 0x80) == 0) && (Failsafe < 5000)) {  
N    Failsafe++;
N  }
N  if (Failsafe >= 5000) {
N    S0SPCCR = 0x08;  // SPI0 clock counter setting
X    (*(volatile unsigned long *)((0xE0020000) + 0x000C)) = 0x08;  
N    S0SPCR  = 0
X    (*(volatile unsigned long *)((0xE0020000) + 0x0000))  = 0
N             | (1 << 3)  // Clock phase control, data is sampled on second clock edge of SCK
N             | (1 << 4)  // CPOL, SCK is active low
N             | (1 << 5)  // MSTR, SPI operates in master mode
N             ;
N  }
N}
N
N/*********************************************************************
N*
N*       _LCD_WriteToReg()
N*/
Nstatic void _LCD_WriteToReg(unsigned short Addr, unsigned short Data) {
N  IO0CLR = (1 << 19);  // RESET_RS
X  (*(volatile unsigned long *)((0xE0028000) + 0x000C)) = (1 << 19);  
N  IO0CLR = (1 << 16);  // ACTIVATE_CS
X  (*(volatile unsigned long *)((0xE0028000) + 0x000C)) = (1 << 16);  
N  _SPI_Send(0);
N  _SPI_Send(Addr);
N  IO0SET = (1 << 16);  // DEACTIVATE_CS
X  (*(volatile unsigned long *)((0xE0028000) + 0x0004)) = (1 << 16);  
N  IO0SET = (1 << 19);  // SET_RS
X  (*(volatile unsigned long *)((0xE0028000) + 0x0004)) = (1 << 19);  
N  IO0CLR = (1 << 16);  // ACTIVATE_CS
X  (*(volatile unsigned long *)((0xE0028000) + 0x000C)) = (1 << 16);  
N  _SPI_Send(Data >> 8);
N  _SPI_Send(Data & 0xFF);
N  IO0SET = (1 << 16);  // DEACTIVATE_CS
X  (*(volatile unsigned long *)((0xE0028000) + 0x0004)) = (1 << 16);  
N  IO0CLR = (1 << 19);  // RESET_RS
X  (*(volatile unsigned long *)((0xE0028000) + 0x000C)) = (1 << 19);  
N  IO0CLR = (1 << 16);  // ACTIVATE_CS
X  (*(volatile unsigned long *)((0xE0028000) + 0x000C)) = (1 << 16);  
N  _SPI_Send(0);
N  _SPI_Send(0x22);
N  IO0SET = (1 << 16);  // DEACTIVATE_CS
X  (*(volatile unsigned long *)((0xE0028000) + 0x0004)) = (1 << 16);  
N}
N
N/*********************************************************************
N*
N*       _LCD_DisplayInit()
N*/
Nstatic void _LCD_DisplayInit(void) {
N  _LCD_WriteToReg(0x00,0x0001);
N  _Delay(20);
N  _LCD_WriteToReg(0x03,0xA2A4);
N  _LCD_WriteToReg(0x0C,0x0004);
N  _LCD_WriteToReg(0x0D,0x0308);
N  _LCD_WriteToReg(0x0E,0x3000);
N  _Delay(50);
N  _LCD_WriteToReg(0x1E,0x00AF);
N  _LCD_WriteToReg(0x01,0x2B3F);
N  _LCD_WriteToReg(0x02,0x0600);
N  _LCD_WriteToReg(0x10,0x0000);
N  _LCD_WriteToReg(0x07,0x0233);
N  _LCD_WriteToReg(0x0B,0x0039);
N  _LCD_WriteToReg(0x0F,0x0000);
N  _Delay(50);
N  _LCD_WriteToReg(0x30,0x0707);
N  _LCD_WriteToReg(0x31,0x0204);
N  _LCD_WriteToReg(0x32,0x0204);
N  _LCD_WriteToReg(0x33,0x0502);
N  _LCD_WriteToReg(0x34,0x0507);
N  _LCD_WriteToReg(0x35,0x0204);
N  _LCD_WriteToReg(0x36,0x0204);
N  _LCD_WriteToReg(0x37,0x0502);
N  _LCD_WriteToReg(0x3A,0x0302);
N  _LCD_WriteToReg(0x3B,0x0302);
N
N  _LCD_WriteToReg(0x23,0x0000);
N  _LCD_WriteToReg(0x24,0x0000);
N
N  _LCD_WriteToReg(0x48,0x0000);
N  _LCD_WriteToReg(0x49,0x013F);
N  _LCD_WriteToReg(0x4A,0x0000);
N  _LCD_WriteToReg(0x4B,0x0000);
N
N  _LCD_WriteToReg(0x41,0x0000);
N  _LCD_WriteToReg(0x42,0x0000);
N
N  _LCD_WriteToReg(0x44,0xEF00);
N  _LCD_WriteToReg(0x45,0x0000);
N  _LCD_WriteToReg(0x46,0x013F);
N  _Delay(50);
N  _LCD_WriteToReg(0x44,0xEF00);
N  _LCD_WriteToReg(0x45,0x0000);
N  _LCD_WriteToReg(0x4E,0x0000);
N  _LCD_WriteToReg(0x4F,0x0000);
N  _LCD_WriteToReg(0x46,0x013F);
N}
N
N/*********************************************************************
N*
N*       _LCD_TurnOn()
N*/
Nstatic void _LCD_TurnOn(void) {
N  LCD_CTRL |= (0
X  (*(volatile unsigned long *)((0xFFE10000) + 0x0018)) |= (0
N               | (1 <<  0)  // Enable LCD
N               | (1 << 11)  // Power On
N              );
N  _Delay(50);
N  _LCD_DisplayInit();
N  _LCD_SetBacklight(100);
N}
N
N/*********************************************************************
N*
N*       _ExecTouch()
N*/
Nstatic void _ExecTouch(void) {
N    GUI_TOUCH_Exec();
N    OS_RetriggerTimer(&_TouchTimer);
N}
N
N/*********************************************************************
N*
N*       _TouchInit()
N*/
Nstatic void _TouchInit(void) {
N  PINSEL0     |= 0xc0000000;
X  (*(volatile unsigned long *)((0xE002C000) + 0x0000))     |= 0xc0000000;
N  PINSEL1     |= 0x0000003c;
X  (*(volatile unsigned long *)((0xE002C000) + 0x0004))     |= 0x0000003c;
N  IO0DIR      |= CS_PIN;
X  (*(volatile unsigned long *)((0xE0028000) + 0x0008))      |= (1 << 20);
N  IO0SET       = CS_PIN;
X  (*(volatile unsigned long *)((0xE0028000) + 0x0004))       = (1 << 20);
N  SPI_S0SPCCR  = 57;
X  (*(volatile unsigned long*) ((0xE0020000) + 0x0C))  = 57;
N  SPI_S0SPCR   = 0x38;
X  (*(volatile unsigned long*) (0xE0020000))   = 0x38;
N}
N
N/*********************************************************************
N*
N*       _Align
N*/
Nstatic void * _Align(void * pMem, U32 NumBytes) {
Xstatic void * _Align(void * pMem, unsigned long NumBytes) {
N U32 Addr;
X unsigned long Addr;
N Addr = (U32)pMem;
X Addr = (unsigned long)pMem;
N NumBytes -= 1;
N Addr += NumBytes;
N Addr &= ~NumBytes;
N return (void*)Addr;
N}
N
N/*********************************************************************
N*
N*       _SetDisplayOrigin()
N*/
Nstatic void _SetDisplayOrigin(int x, int y) {
N  //
N  // Set start address for display data and enable LCD controller
N  //
N  LCD_UPBASE  = (unsigned long) _VRAMAddr + (y * XSIZE_PHYS * PIXEL_WIDTH);   // Needs to be set, before LCDC is enabled
X  (*(volatile unsigned long *)((0xFFE10000) + 0x0010))  = (unsigned long) _VRAMAddr + (y * 320 * 2);   
N}
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       BSP_ETH_Init()
N*/
Nvoid BSP_ETH_Init(unsigned Unit) {
N
N  /*------------------------------------------------------------------------------
N  * write to PINSEL2/3 to select the PHY functions on P1[17:0]
N  *-----------------------------------------------------------------------------*/
N  /* P1.6, ENET-TX_CLK, has to be set for EMAC to address a BUG in
N  the rev"xx-X" or "xx-Y" silicon(see errata). On the new rev.(xxAY, released
N  on 06/22/2007), P1.6 should NOT be set. */
N  if (MAC_MODULEID == 0x39022000) {  // Older chip ?
X  if ((*(volatile unsigned long *)(0xFFE00FFC)) == 0x39022000) {  
N    PINSEL2 = 0x50151105;            // selects P1[0,1,4,6,8,9,10,14,15]
X    (*(volatile unsigned long *)((0xE002C000) + 0x0008)) = 0x50151105;            
N  } else {
N    PINSEL2 = 0x50150105;            // selects P1[0,1,4,8,9,10,14,15]
X    (*(volatile unsigned long *)((0xE002C000) + 0x0008)) = 0x50150105;            
N  }
N  PINSEL3 = (PINSEL3 & ~0x0000000f) | 0x5;
X  (*(volatile unsigned long *)((0xE002C000) + 0x000C)) = ((*(volatile unsigned long *)((0xE002C000) + 0x000C)) & ~0x0000000f) | 0x5;
N}
N
N/*********************************************************************
N*
N*       BSP_ETH_InstallISR()
N*/
Nvoid BSP_ETH_InstallISR(void (*pfISR)(void)) {
N  OS_ARM_InstallISRHandler(INT_INDEX_MAC, pfISR);     // Timer/counter interrupt vector.
X  OS_ARM_InstallISRHandler((21), pfISR);     
N  OS_ARM_EnableISR(INT_INDEX_MAC);                    // Enable timer/counter 0 interrupt.
X  OS_ARM_EnableISR((21));                    
N  OS_ARM_ISRSetPrio(INT_INDEX_MAC, 15);               // lowest priority
X  OS_ARM_ISRSetPrio((21), 15);               
N}
N
N/*********************************************************************
N*
N*       BSP_Init()
N*/
Nvoid BSP_Init(void) {
N  //
N  // Init I2C
N  //
N  I2CPCA9532_Init();
N}
N
N/*********************************************************************
N*
N*       LED switching routines
N*/
Nvoid BSP_SetLED(int Index) {
N  _SetLEDState(Index, LED_SET);
X  _SetLEDState(Index, (0));
N}
N
Nvoid BSP_ClrLED(int Index) {
N  _SetLEDState(Index, LED_CLR);
X  _SetLEDState(Index, (1));
N}
N
Nvoid BSP_ToggleLED(int Index) {
N  _SetLEDState(Index, LED_TOGGLE);
X  _SetLEDState(Index, (2));
N}
N
N/*********************************************************************
N*
N*       _InitLCDController
N*
N* Function description:
N*   Initializes the display controller
N*/
Nstatic void _InitLCDController(unsigned LayerIndex) {
N  U32 TouchOrientation;
X  unsigned long TouchOrientation;
N
N  //
N  // Calibrate touch
N  //
N  TouchOrientation = (GUI_MIRROR_X * LCD_GetMirrorXEx(0)) |
X  TouchOrientation = ((1 << 0) * LCD_GetMirrorXEx(0)) |
N                     (GUI_MIRROR_Y * LCD_GetMirrorYEx(0)) |
X                     ((1 << 1) * LCD_GetMirrorYEx(0)) |
N                     (GUI_SWAP_XY  * LCD_GetSwapXYEx (0)) ;
X                     ((1 << 2)  * LCD_GetSwapXYEx (0)) ;
N  GUI_TOUCH_SetOrientation(TouchOrientation);
N  GUI_TOUCH_Calibrate(GUI_COORD_X, 0, 240, TOUCH_AD_TOP , TOUCH_AD_BOTTOM);  // x axis
X  GUI_TOUCH_Calibrate(0, 0, 240, (184) , (3894));  
N  GUI_TOUCH_Calibrate(GUI_COORD_Y, 0, 320, TOUCH_AD_LEFT, TOUCH_AD_RIGHT);   // y axis
X  GUI_TOUCH_Calibrate(1, 0, 320, (154), (3834));   
N  //
N  // LCD Init
N  //
N  _VRAMAddr = (U32)_Align((void *)VRAM_ADDR, 8);
X  _VRAMAddr = (unsigned long)_Align((void *)((unsigned long)&_aVRAM[0]), 8);
N  _LCD_HW_Init();
N  _LCD_SetBacklight(0);
N  _LCD_Ctrl_Init();
N  LCD_UPBASE = _VRAMAddr;
X  (*(volatile unsigned long *)((0xFFE10000) + 0x0010)) = _VRAMAddr;
N  _LCD_TurnOn();
N  //
N  // Setup LCD touch
N  //
N  _TouchInit();
N  OS_CREATETIMER(&_TouchTimer, _ExecTouch, TOUCHTIMERINTERVAL);
X  OS_CreateTimer(&_TouchTimer,_ExecTouch,(10)); OS_StartTimer(&_TouchTimer);;
N}
N
N/*********************************************************************
N*
N*       LCD_X_DisplayDriver
N*
N* Purpose:
N*   This function is called by the display driver for several purposes.
N*   To support the according task the routine needs to be adapted to
N*   the display controller. Please note that the commands marked with
N*   'optional' are not cogently required and should only be adapted if
N*   the display controller supports these features.
N*
N* Parameter:
N*   LayerIndex - Index of layer to be configured
N*   Cmd        - Please refer to the details in the switch statement below
N*   pData      - Pointer to a LCD_X_DATA structure
N*/
Nint LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData) {
N  LCD_X_SETORG_INFO * pSetOrg;
N
N  switch (Cmd) {
N  //
N  // Required
N  //
N  case LCD_X_INITCONTROLLER:
X  case 0x01:
N    //
N    // Called during the initialization process in order to set up the
N    // display controller and put it into operation. If the display
N    // controller is not initialized by any external routine this needs
N    // to be adapted by the customer...
N    //
N    _InitLCDController(LayerIndex);
N    break;
N  case LCD_X_SETORG:
X  case 0x03:
N    //
N    // Required for setting the display origin which is passed in the 'xPos' and 'yPos' element of p
N    //
N    pSetOrg = (LCD_X_SETORG_INFO *)pData;
N    _SetDisplayOrigin(pSetOrg->xPos, pSetOrg->yPos);
N  }
N  return 0;
N}
N
N/*********************************************************************
N*
N*       LCD_X_Config
N*
N* Purpose:
N*   Called during the initialization process in order to set up the
N*   display driver configuration.
N*
N*/
Nvoid LCD_X_Config(void) {
N  _VRAMAddr = (U32)_Align((void *)VRAM_ADDR, 8);
X  _VRAMAddr = (unsigned long)_Align((void *)((unsigned long)&_aVRAM[0]), 8);
N  //
N  // Set display driver and color conversion for 1st layer
N  //
N  GUI_DEVICE_CreateAndLink(&DISPLAY_DRIVER, COLOR_CONVERSION, 0, 0);
X  GUI_DEVICE_CreateAndLink(&GUIDRV_Lin_OSX_16_API, &LCD_API_ColorConv_565, 0, 0);
N  //
N  // Display driver configuration, required for Lin-driver
N  //
N  LCD_SetSizeEx    (0, XSIZE_PHYS,   YSIZE_PHYS);
X  LCD_SetSizeEx    (0, 320,   240);
N  LCD_SetVSizeEx   (0, VXSIZE_PHYS,  VYSIZE_PHYS);
X  LCD_SetVSizeEx   (0, (2 * 320),  240);
N  LCD_SetVRAMAddrEx(0, (void *)_VRAMAddr);
N  //
N  // Set user palette data (only required if no fixed palette is used)
N  //
N  #if defined(PALETTE)
X  #if 0L
S    LCD_SetLUTEx(0, PALETTE);
N  #endif
N}
N
N/*********************************************************************
N*
N*       BSP_USBH_InstallISR
N*/
Nvoid BSP_USBH_InstallISR(void (*pfISR)(void)) {
N  OS_ARM_InstallISRHandler(INT_INDEX_USB, pfISR);     // Timer/counter interrupt vector.
X  OS_ARM_InstallISRHandler(22, pfISR);     
N  OS_ARM_EnableISR(INT_INDEX_USB);                    // Enable timer/counter 0 interrupt.
X  OS_ARM_EnableISR(22);                    
N  OS_ARM_ISRSetPrio(INT_INDEX_USB, 2);               // lowest priority
X  OS_ARM_ISRSetPrio(22, 2);               
N}
N
N/*********************************************************************
N*
N*       BSP_USBH_Init
N*
N*   Function description
N*     Initialize the USB host part of the USB module
N*     The pins are shown configured:
N*       PINSEL0
N*         P0.12 /USB_PPWR2
N*         P0.13 USP_UP_LED2
N*         P0.14 /USB_HSTEN2  /USB_CONN
N*       PINSEL1
N*         P0.29 USB_D+1
N*         P0.30 USB_D-1
N*         P0.31 USB_D+2
N*       PINSEL3
N*         P1.18 USB_UP_LED1
N*         P1.19 USB_TX_E1 /USB_PPWR1
N*         P1.20 USB_TX_DP1
N*         P1.21 USB_TX_DM1
N*         P1.22 USB_RCV1
N*         P1.23 USB_RX_DP1
N*         P1.24 USB_RX_DM1
N*         P1.25 USB_LS1 /USB_HSTEN1
N*         P1.26 /USB_SSPND1
N*         P1.27 /USB_INT1 /USB_OVRCRT1
N*         P1.28 USB_SCL1
N*         P1.29 USB_SDA1
N*         P1.30 USB_PWRD2 VBUS
N*         P1.31 /USB_OVRCR2
N*
N*/
Nvoid BSP_USBH_Init(void) {
N  //
N  // power the USB block
N  //
N  PCONP |= PCUSB;
X  (*(volatile unsigned long *)(0xE01FC0C4)) |= ((unsigned long)1<<31);
N  //
N  // Enable USB host and USB OTG clock
N  //
N  OTG_CLK_CTRL  |= USB_HOST_CLK_EN | USB_OTG_CLK_EN | USB_AHB_CLK_EN;
X  (*(volatile unsigned long *)(0xFFE0CFF0 + 0x04))  |= (1<<0) | (1<<3) | (1<<4);
N  while( (OTG_CLK_STAT & (USB_HOST_CLK_EN | USB_OTG_CLK_EN | USB_AHB_CLK_EN)) != (USB_HOST_CLK_EN | USB_OTG_CLK_EN | USB_AHB_CLK_EN));
X  while( ((*(volatile unsigned long *)(0xFFE0CFF0 + 0x08)) & ((1<<0) | (1<<3) | (1<<4))) != ((1<<0) | (1<<3) | (1<<4)));
N	//
N  // Configure the pins for port1 OTG
N	// The USB device is connected to port 1 	
N	// port2 Host port
N	// P0.12    = USB-2:PORT_PWRn
N	// P0.13    = USB-2:LEDn
N	// P0.13    = USB-2:HostEN2 enable the 15k pull downs, static +5V
N	// P0.15 = GPIO
N  //
N	PINSEL0 |= PS0_P012_USB_PPWR2 | PS0_P013_USB_UP_LED2;
X	(*(volatile unsigned long *)((0xE002C000) + 0x0000)) |= (1 << 24) | (1 << 26);
N	//
N  // if P0.14 does not correct switch disable P0.14 function
N  //  configure P014 as GPIO Output */
N	IO0DIR |= (1 << 14); /* P0.14 is an output */
X	(*(volatile unsigned long *)((0xE0028000) + 0x0008)) |= (1 << 14);  
N	IO0CLR  = (1 << 14); /* P0.14 is 0, enabling the pull-downs */
X	(*(volatile unsigned long *)((0xE0028000) + 0x000C))  = (1 << 14);  
N	//		
N	// P0.29 = USB1:D+
N  // P0.30 = USB1:D-
N  // P0.31 = USB2:D+
N  //
N	PINSEL1 |= PS1_P029_USB_DP1 | PS1_P030_USB_DM1 | PS1_P031_USB_DP2;
X	(*(volatile unsigned long *)((0xE002C000) + 0x0004)) |= (1 << 26) | (1 << 28) | (1 << 30);
N	PINSEL3 |= PS3_P118_USB_UP_LED1 // P1.18 = USBOTG:LEDn
X	(*(volatile unsigned long *)((0xE002C000) + 0x000C)) |= (1 << 4) 
N          |  PS3_P130_USB_PWRD2		// P1.30 = USB2:POWEREDn
X          |  (1 << 28)		
N          |  PS3_P131_USB_OVECR2;	// P1.31 = USB2:OVR_CRNTn
X          |  (1 << 30);	
N
N  /* In all configurations,
N     disable the pull ups on P1.27 (OTG interrupt input)
N     and P1.30 (Host Port 2 Power status)
N  */
N  PINMODE3 &=~ (PINMODE_GET_16_TO_31(27,PIN_MODE_MASK)
X  (*(volatile unsigned long *)((0xE002C040) + 0x000C)) &=~ (((3) << (27-16))
N						   | PINMODE_GET_16_TO_31(30,PIN_MODE_MASK) );
X						   | ((3) << (30-16)) );
N  PINMODE3 |= PINMODE_GET_16_TO_31(27,PIN_MODE_NO_PULLS)
X  (*(volatile unsigned long *)((0xE002C040) + 0x000C)) |= ((2) << (27-16))
N  					  | PINMODE_GET_16_TO_31(30,PIN_MODE_NO_PULLS);
X  					  | ((2) << (30-16));
N}
N
N
N/*************************** End of file ****************************/
