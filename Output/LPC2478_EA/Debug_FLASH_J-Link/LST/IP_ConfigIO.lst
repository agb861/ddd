L 1 "Config\IP_ConfigIO.c"
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : IP_ConfigIO.c
NPurpose     : I/O Configuration routines for TCP/IP
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#include <stdio.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030076
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 19 "Config\IP_ConfigIO.c" 2
N#include "IP.h"
L 1 "IP\IP.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : IP.h
NPurpose     : API of the TCP/IP stack
N---------------------------END-OF-HEADER------------------------------
N*/
N/* Additional Copyrights: */
N/* Copyright  2000 By InterNiche Technologies Inc. All rights reserved */
N/* Portions Copyright 1990,1993 by NetPort Software. */
N/* Portions Copyright 1986 by Carnegie Mellon */
N/* Portions Copyright 1983 by the Massachusetts Institute of Technology */
N
N#ifndef _IP_H_
N#define _IP_H_
N
N#include "Global.h"
L 1 "GUI\Global.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : GLOBAL.h
NPurpose : Global types etc.
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GLOBAL_H            // Guard against multiple inclusion
N#define GLOBAL_H
N
N/*********************************************************************
N*
N*       Macros
N*
N**********************************************************************
N*/
N#define U8    unsigned char
N#define U16   unsigned short
N#define U32   unsigned long
N#define I8    signed char
N#define I16   signed short
N#define I32   signed long
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 27 "IP\IP.h" 2
N#include "IP_ConfDefaults.h"
L 1 "IP\IP_ConfDefaults.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : IP_ConfDefaults.h
NPurpose :
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef IP_CONFDEFAULTS_H
N#define IP_CONFDEFAULTS_H
N
N#include "IP_Conf.h"
L 1 "Setup\IP_Conf.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef _IP_CONF_H_
N#define _IP_CONF_H_ 1
N
N//
N// IAR ARM compiler related macros
N//
N#ifdef __ICCARM__
S  #if ((__TID__ >> 4) & 0x0F) < 6   // For any ARM CPU core < v7, we will use optimized routines
S    #include "Util.h"
S    #define IP_MEMCPY(pDest, pSrc, NumBytes) ARM_memcpy(pDest, pSrc, NumBytes)    // Speed optimization: Our memcpy is much faster!
S    U16 ARM_IP_cksum(void * ptr, unsigned NumHWords);
S    #define IP_CKSUM(p, NumItems) ARM_IP_cksum((p), (NumItems))
S  #endif
S  #define IP_IS_BIG_ENDIAN (1 - __LITTLE_ENDIAN__)
N#endif
N
N//
N// Change endianess if required, default is IP_IS_BIG_ENDIAN == 0
N//
N//#define IP_IS_BIG_ENDIAN    1
N//#define IP_MEMCPY(pDest, pSrc, NumBytes) UTIL_memcpy(pDest, pSrc, NumBytes)    // Speed optimization: Our memcpy is much faster!
N
N#ifdef DEBUG
N  #if DEBUG
X  #if 1
N    #define IP_DEBUG        2   // Debug level: 1: Support "Panic" checks, 2: Support warn & log
N  #endif
N#endif
N
N#endif     // Avoid multiple inclusion
N
N
L 22 "IP\IP_ConfDefaults.h" 2
N
N
N#ifndef   IP_DEBUG
S  #define IP_DEBUG                  (0)
N#endif
N
N#ifndef   IP_MEMCPY
N  #define IP_MEMCPY  memcpy
N#endif
N
N#ifndef   IP_MEMSET
N  #define IP_MEMSET  memset
N#endif
N
N#ifndef   IP_MEMMOVE
N  #define IP_MEMMOVE memmove
N#endif
N
N#ifndef   IP_MEMCMP
N  #define IP_MEMCMP  memcmp
N#endif
N
N#ifndef   IP_CKSUM
N  #define IP_CKSUM(p, NumHWords) IP_cksum(p, NumHWords)
N#endif
N
N#ifndef   IP_OPTIMIZE
N  #define IP_OPTIMIZE
N#endif
N
N#ifndef   IP_IS_BIG_ENDIAN
N  #define IP_IS_BIG_ENDIAN 0      // Little endian is default
N#endif
N
N
N
N#ifndef   IP_INCLUDE_STAT         // Allow override in IP_Conf.h
N  #if IP_DEBUG > 0
X  #if 2 > 0
N    #define IP_INCLUDE_STAT 1     // Can be set to 0 to disable statistics for extremly small release builds
N  #else
S    #define IP_INCLUDE_STAT 0
N  #endif
N#endif
N
N#ifndef IP_DEBUG_Q                // Allow override in IP_Conf.h
N  #if IP_DEBUG
X  #if 2
N    #define IP_DEBUG_Q 1
N  #else
S    #define IP_DEBUG_Q 0
N  #endif
N#endif
N//
N// TCP retransmission range defaults
N//
N#ifndef   IP_TCP_RETRANS_MIN
N  #define IP_TCP_RETRANS_MIN   200   // Min. delay for retransmit. Real delay is computed, this minimum applies only if computed delay is shorter.
N#endif
N
N#ifndef   IP_TCP_RETRANS_MAX
N  #define IP_TCP_RETRANS_MAX  5000   // Max. delay for retransmit. Real delay is computed, this maximum applies only if computed delay is longer.
N#endif
N
N//
N// TCP keep-alive defaults
N//
N#ifndef IP_TCP_KEEPALIVE_INIT
N  #define  IP_TCP_KEEPALIVE_INIT     20000       // Initial connect keep alive, 20 sec.
N#endif
N
N#ifndef IP_TCP_KEEPALIVE_IDLE
N  #define  IP_TCP_KEEPALIVE_IDLE     60000       // Default time before probing
N#endif
N
N#ifndef IP_TCP_KEEPALIVE_PERIOD
N  #define  IP_TCP_KEEPALIVE_PERIOD   10000       // Default probe interval
N#endif
N
N#ifndef IP_TCP_KEEPALIVE_MAX_REPS
N  #define  IP_TCP_KEEPALIVE_MAX_REPS     8       // Max probes before drop
N#endif
N
N#ifndef IP_TCP_MSL
N  #define  IP_TCP_MSL                 2000       // Max segment lifetime
N#endif
N
N
N#define IP_TCP_DACK_PERIOD    10   // Time base for delayed acknowledges
N#define IP_TCP_SLOW_PERIOD    10
N
N
N#define INCLUDE_ARP          1   // Include Ethernet ARP ?
N#define INCLUDE_ICMP         1   // Include ICMP || ping only
N#define INCLUDE_TCP          1
N#define INCLUDE_UDP          1
N#define TCP_ZEROCOPY         1  // Enable zero-copy Socket extension
N#define TCP_TIMESTAMP        1  // Are we using RFC-1323 TCP timestamp feature to compute RTT ?
N#ifndef   IP_SUPPORT_MULTICAST
N  #define IP_SUPPORT_MULTICAST  0   // Experimental
N#endif
N
N#ifndef IP_MAX_DNS_SERVERS
N  #define IP_MAX_DNS_SERVERS  2
N#endif
N
N#ifndef IP_PANIC
N  #if   IP_DEBUG
X  #if   2
N    #define IP_PANIC(s)     IP_Panic(s)
N  #else
S    #define IP_PANIC(s)
N  #endif
N#endif
N
N#ifndef   IP_SUPPORT_LOG
N  #if   IP_DEBUG > 1
X  #if   2 > 1
N    #define IP_SUPPORT_LOG  1
N  #else
S    #define IP_SUPPORT_LOG  0
N  #endif
N#endif
N
N#ifndef   IP_SUPPORT_WARN
N  #if   IP_DEBUG > 1
X  #if   2 > 1
N    #define IP_SUPPORT_WARN  1
N  #else
S    #define IP_SUPPORT_WARN  0
N  #endif
N#endif
N
N
N
N#if   IP_INCLUDE_STAT
X#if   1
N  #define IP_STAT_DEC(Cnt)     (Cnt)--
N  #define IP_STAT_INC(Cnt)     (Cnt)++
N  #define IP_STAT_ADD(Cnt, v) { Cnt += v; }
N#else
S  #define IP_STAT_DEC(Cnt)
S  #define IP_STAT_INC(Cnt)
S  #define IP_STAT_ADD(Cnt, v)
N#endif
N
N#define TPS        1000    /* cticks per second */
N
N#define IP_TTL        64 /* define IP hop count for this port */
N#define IP_TCP_DELAY_ACK_DEFAULT 200       // [ms]
N
N#define DO_DELAY_ACKS  (1)   // Defining enables delayed acks
N//#define TCP_SACK       (1)
N#define TCP_WIN_SCALE  (0)     // We do not want to use it per default, since it requires a sufficiently big buffer in the hardware.
N#define IP_PTR_OP_IS_ATOMIC       (1)
N
N#define IP_MAX_IFACES       1  /* max ifaces to support at one time */
N
N#endif // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
N
N
N
L 28 "IP\IP.h" 2
N#include "IP_socket.h"
L 1 "IP\IP_socket.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : IP_socket.h
NPurpose :
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N/* Additional Copyrights: */
N/* Copyright 1997 - 2000 By InterNiche Technologies Inc. All rights reserved */
N/* Copyright (c) 1982, 1986 Regents of the University of California.
N* All rights reserved.
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N* 1. Redistributions of source code must retain the above copyright
N*    notice, this list of conditions and the following disclaimer.
N* 2. Redistributions in binary form must reproduce the above copyright
N*    notice, this list of conditions and the following disclaimer in the
N*    documentation and/or other materials provided with the distribution.
N* 3. [rescinded 22 July 1999]
N* 4. Neither the name of the University nor the names of its contributors
N*    may be used to endorse or promote products derived from this software
N*    without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
N* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N* ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
N* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N* SUCH DAMAGE.
N*/
N
N
N
N#ifndef SOCKET_H                         // Avoid multiple inclusion
N#define  SOCKET_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*
N * Address families, for socket() call and "domain" variables.
N */
N
N#define  AF_INET     2     /* internetwork: UDP, TCP, etc. */
N#define  AF_INET6    3     /* IPv6 */
N#define  PF_INET6    AF_INET6
N
N
N/* IPPROTO_... definitions, from BSD <netinet/in.h> */
N#define     IPPROTO_IP     0  /* added for IP multicasting changes */
N#define     IPPROTO_IGMP   2  /* added for IP multicasting changes */
N#define     IPPROTO_TCP    6
N#define     IPPROTO_UDP    17
N#define     IPPROTO_RAW    255
N
N
N
N/* BSD sockets errors */
N
N#define     ENOBUFS        1
N#define     ETIMEDOUT      2
N#define     EISCONN        3
N#define     EOPNOTSUPP     4
N#define     ECONNABORTED   5
N#define     EWOULDBLOCK    6
N#define     ECONNREFUSED   7
N#define     ECONNRESET     8
N#define     ENOTCONN       9
N#define     EALREADY       10
N#define     EINVAL         11
N#define     EMSGSIZE       12
N#define     EPIPE          13
N#define     EDESTADDRREQ   14
N#define     ESHUTDOWN      15
N#define     ENOPROTOOPT    16
N#define     EHAVEOOB       17
N#define     ENOMEM         18
N#define     EADDRNOTAVAIL  19
N#define     EADDRINUSE     20
N#define     EAFNOSUPPORT   21
N#define     EINPROGRESS    22
N#define     ELOWER         23    /* lower layer (IP) error */
N#define     ENOTSOCK       24    /* Includes sockets which closed while blocked */
N#define     EIEIO 27 /* bad input/output on Old Macdonald's farm :-) */
N#define     ETOOMANYREFS   28    // Multicast only
N#define     EFAULT         29
N#define     ENETUNREACH    30
N
N
N
N
N
N
N
N
N
N/*
N * Types
N */
N#define     SOCK_STREAM    1     /* stream socket */
N#define     SOCK_DGRAM     2     /* datagram socket */
N#define     SOCK_RAW       3     /* raw-protocol interface */
N#define     SOCK_RDM       4     /* reliably-delivered message */
N#define     SOCK_SEQPACKET 5     /* sequenced packet stream */
N
N/*
N * Option flags per-socket.
N */
N#define     SO_DEBUG       0x00001     /* turn on debugging info recording */
N#define     SO_ACCEPTCONN  0x00002     /* socket has had listen() */
N#define     SO_REUSEADDR   0x00004     /* allow local address reuse */
N#define     SO_KEEPALIVE   0x00008     /* keep connections alive */
N#define     SO_DONTROUTE   0x00010     /* just use interface addresses */
N#define     SO_BROADCAST   0x00020     /* permit sending of broadcast msgs */
N#define     SO_USELOOPBACK 0x00040     /* bypass hardware when possible */
N#define     SO_LINGER      0x00080     /* linger on close if data present */
N#define     SO_OOBINLINE   0x00100     /* leave received OOB data in line */
N#define     SO_TCPSACK     0x00200     /* Allow TCP SACK (Selective acknowledgment) */
N#define     SO_WINSCALE    0x00400     /* Set scaling window option */
N#define     SO_TIMESTAMP   0x00800     /* Set TCP timestamp option */
N#define     SO_BIGCWND     0x01000     /* Large initial TCP Congenstion window */
N#define     SO_HDRINCL     0x02000     /* user access to IP hdr for SOCK_RAW */
N#define     SO_NOSLOWSTART 0x04000     /* suppress slowstart on this socket */
N#define     SO_FULLMSS     0x08000     /* force packets to all be MAX size */
N
N/* for compatability with second-rate stacks: */
N#define SO_EXPEDITE     SO_NOSLOWSTART
N#define SO_THROUGHPUT   SO_FULLMSS
N
N/*
N * Additional options, not kept in so_options.
N */
N#define  SO_SNDBUF      0x1001      /* send buffer size */
N#define  SO_RCVBUF      0x1002      /* receive buffer size */
N#define  SO_SNDLOWAT    0x1003      /* send low-water mark */
N#define  SO_RCVLOWAT    0x1004      /* receive low-water mark */
N#define  SO_SNDTIMEO    0x1005      /* send timeout */
N#define  SO_RCVTIMEO    0x1006      /* receive timeout */
N#define  SO_ERROR       0x1007      /* get error status and clear */
N#define  SO_TYPE        0x1008      /* get socket type */
N#define  SO_HOPCNT      0x1009      /* Hop count to get to dst   */
N#define  SO_MAXMSG      0x1010      /* get TCP_MSS (max segment size) */
N
N/* ...And some netport additions to setsockopt: */
N#define  SO_RXDATA      0x1011      /* get count of bytes in sb_rcv */
N#define  SO_TXDATA      0x1012      /* get count of bytes in sb_snd */
N#define  SO_MYADDR      0x1013      /* return my IP address */
N#define  SO_NBIO        0x1014      /* set socket into NON-blocking mode */
N#define  SO_BIO         0x1015      /* set socket into blocking mode */
N#define  SO_NONBLOCK    0x1016      /* set/get blocking mode via optval param */
N#define  SO_CALLBACK    0x1017      /* set/get zero_copy callback routine */
N
N/*
N * TCP User-settable options (used with setsockopt).
N * TCP-specific socket options use the 0x2000 number space.
N */
N
N#define  TCP_ACKDELAYTIME 0x2001    /* Set time for delayed acks */
N#define  TCP_NOACKDELAY   0x2002    /* suppress delayed ACKs */
N#define  TCP_MAXSEG       0x2003    /* set maximum segment size */
N#define  TCP_NODELAY      0x2004    /* Disable Nagle Algorithm */
N
N
N/*
N * Structure used for manipulating linger option.
N */
Nstruct   linger {
N   int   l_onoff;    /* option on/off */
N   int   l_linger;   /* linger time */
N};
N
N
N/*
N * Structure used by kernel to store most
N * addresses.
N */
Nstruct sockaddr {
N   U16     sa_family;     /* address family */
X   unsigned short     sa_family;      
N   char     sa_data[14];      /* up to 14 bytes of direct address */
N};
N
N
N/* Berkeley style "Internet address" */
N
Nstruct in_addr {
N   U32  s_addr;
X   unsigned long  s_addr;
N};
N
N#define  INADDR_ANY     0L
N
N/* Berkeley style "Socket address" */
Nstruct sockaddr_in {
N  U16      sin_family;
X  unsigned short      sin_family;
N  U16      sin_port;
X  unsigned short      sin_port;
N  struct   in_addr  sin_addr;
N  char     sin_zero[8];
N};
N
N
N
N
N/*
N * Structure used by kernel to pass protocol
N * information in raw sockets.
N */
Nstruct sockproto {
N   U16     sp_family;     /* address family */
X   unsigned short     sp_family;      
N   U16     sp_protocol;   /* protocol */
X   unsigned short     sp_protocol;    
N};
N
N/* Support for Large initial congestion window */
N#ifdef TCP_BIGCWND
Sextern   int      use_default_cwnd;    /* Flag to use this on all sockets */
Sextern   U32   default_cwnd;        /* initial cwnd value to use */
N#endif   /* TCP_BIGCWND */
N
N/*
N * Protocol families, same as address families for now.
N */
N#define  PF_UNSPEC   AF_UNSPEC
N#define  PF_UNIX     AF_UNIX
N#define  PF_INET     AF_INET
N#define  PF_IMPLINK  AF_IMPLINK
N#define  PF_PUP      AF_PUP
N#define  PF_CHAOS    AF_CHAOS
N#define  PF_NS       AF_NS
N#define  PF_NBS      AF_NBS
N#define  PF_ECMA     AF_ECMA
N#define  PF_DATAKIT  AF_DATAKIT
N#define  PF_CCITT    AF_CCITT
N#define  PF_SNA      AF_SNA
N#define  PF_DECnet   AF_DECnet
N#define  PF_DLI      AF_DLI
N#define  PF_LAT      AF_LAT
N#define  PF_HYLINK   AF_HYLINK
N#define  PF_APPLETALK   AF_APPLETALK
N
N
N/*
N * Maximum queue length specifiable by listen.
N */
N#define     SOMAXCONN   5
N
N#define     MSG_PEEK       0x2      /* peek at incoming message */
N#define     MSG_DONTROUTE  0x4      /* send without using routing tables */
N#define     MSG_NEWPIPE    0x8      /* New pipe for recvfrom call   */
N#define     MSG_EOR        0x10     /* data completes record */
N#define     MSG_DONTWAIT   0x20     /* this message should be nonblocking */
N
N/* utility functions defined in misclib\parseip.c */
Nint inet46_addr(char *str, struct sockaddr *address);
N
Nlong  t_socket (int, int, int);
Nint   t_bind (long, struct sockaddr *, int);
Nint   t_listen (long, int);
Nlong  t_accept (long, struct sockaddr *, int *);
Nint   t_connect (long, struct sockaddr *, int);
Nint   t_getpeername (long, struct sockaddr *, int * addrlen);
Nint   t_getsockname (long, struct sockaddr *, int * addrlen);
Nint   t_setsockopt (long sock, int level, int op, void * data, int dlen);
Nint   t_getsockopt (long sock, int level, int op, void * data, int dlen);
Nint   t_recv (long, char *, int, int);
Nint   t_send (long, const char *, int, int);
Nint   t_recvfrom (long s, char * buf, int len, int flags, struct sockaddr *, int*);
Nint   t_sendto (long s, const char * buf, int len, int flags, struct sockaddr *, int);
Nint   t_shutdown (long, int);
Nint   t_socketclose (long);
Nint   t_errno(long s);
N
Nchar * so_perror(int);  /* return an error string for a socket error */
N
N//
N// Map plain BSD socket routine names to Interniche t_" names.
N//
N#define  socket(x,y,z)           t_socket(x,y,z)
N#define  bind(s,a,l)             t_bind(s,a,l)
N#define  connect(s,a,l)          t_connect(s,a,l)
N#define  listen(s,c)             t_listen(s,c)
N#define  send(s, b, l, f)        t_send(s, b, l, f)
N#define  recv(s, b, l, f)        t_recv(s, b, l, f)
N#define  accept(s,a,l)           t_accept(s, a, l)
N#define  sendto(s,b,l,f,a,x)     t_sendto(s,b,l,f,a,x)
N#define  recvfrom(s,b,l,f,a,x)   t_recvfrom(s,b,l,f,a,x)
N#define  socketclose(s)          t_socketclose(s)
N#define  closesocket(s)          t_socketclose(s)
N#define  setsockopt(s,l,o,d,x)   t_setsockopt(s,l,o,d,x)
N#define  getsockopt(s,l,o,d,x)   t_getsockopt(s,l,o,d,x)
N#define  shutdown(s,how)         t_shutdown(s,how)
N#define  select(i,o,e,tv)        t_select(i,o,e,tv)
N#define  getpeername(s,a,al)     t_getpeername(s,a,al)
N#define  getsockname(s,a,al)     t_getsockname(s,a,al)
N
Nstruct hostent *  gethostbyname (char * name);
N
N
N
N#define  SOCKTYPE    long     /* preferred generic socket type */
N
N#define  SYS_SOCKETNULL -1    /* error return from sys_socket. */
N#define  INVALID_SOCKET -1    /* WINsock-ish synonym for SYS_SOCKETNULL */
N#define  SOCKET_ERROR   -1    /* error return from send(), sendto(), et.al. */
N#define  SOL_SOCKET     -1    /* compatability parm for set/get sockopt */
N
N#define  SO_SELECT      1  /* support select() call */
N
N
N#ifdef SO_SELECT
N/* define the size of the sockets arrays passed to select(). On UNIX
N * and winsock this is usually 64, but most embedded systems don't
N * need more than 1 or 2, and can't always afford to waste the space.
N * NOTE: These determine the size of set_fd structs, which are often
N */
N#ifndef FD_SETSIZE   /* let h_h files override */
N#define  FD_SETSIZE     12
N#endif   /* FD_SETSIZE */
N#endif   /* SO_SELECT */
N
N
N
N
N/* the definitions to support the select() function. These are about
N * as UNIX-like as we can make 'em on embedded code. They are also
N * fairly compatable with WinSock's select() definitions.
N */
N
Ntypedef struct IP_FD_SET   /* the select socket array manager */
N{
N   unsigned fd_count;               /* how many are SET? */
N   long     fd_array[FD_SETSIZE];   /* an array of SOCKETs */
X   long     fd_array[12];    
N} IP_fd_set;
N
N/* our select call - note the traditional "width" parameter is absent */
Nint t_select(IP_fd_set * in, IP_fd_set * out, IP_fd_set * ev, long tmo_seconds);
N
N//
N// Select-related functions are calls (not macros) to save space
N//
Nvoid  IP_FD_CLR  (long so, IP_fd_set * set);
Nvoid  IP_FD_SET  (long so, IP_fd_set * set);
Nint   IP_FD_ISSET(long so, IP_fd_set * set);
N// and one actual macro:
N#define  IP_FD_ZERO(set)   (((IP_fd_set *)(set))->fd_count=0)
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* SOCKET_H */
N
N/* end of file socket.h */
N
N
L 29 "IP\IP.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#define IP_VERSION   15601   // Format: Mmmrr. Example: 10201 is 1.02a
N
N/*********************************************************************
N*
N*       IP_MTYPE
N*
N*  Ids to distinguish different message types
N*/
N#define IP_MTYPE_INIT         (1UL << 0)
N#define IP_MTYPE_CORE         (1UL << 1)
N#define IP_MTYPE_ALLOC        (1UL << 2)
N#define IP_MTYPE_DRIVER       (1UL << 3)
N#define IP_MTYPE_ARP          (1UL << 4)
N#define IP_MTYPE_IP           (1UL << 5)
N
N#define IP_MTYPE_TCP_CLOSE    (1UL << 6)
N#define IP_MTYPE_TCP_OPEN     (1UL << 7)
N#define IP_MTYPE_TCP_IN       (1UL << 8)
N#define IP_MTYPE_TCP_OUT      (1UL << 9)
N#define IP_MTYPE_TCP_RTT      (1UL << 10)
N#define IP_MTYPE_TCP_RXWIN    (1UL << 11)
N#define IP_MTYPE_TCP          (IP_MTYPE_TCP_OPEN | IP_MTYPE_TCP_CLOSE | IP_MTYPE_TCP_IN | IP_MTYPE_TCP_OUT | IP_MTYPE_TCP_RTT)
N
N#define IP_MTYPE_UDP_IN       (1UL << 12)
N#define IP_MTYPE_UDP_OUT      (1UL << 13)
N#define IP_MTYPE_UDP          (IP_MTYPE_UDP_IN | IP_MTYPE_UDP_OUT)
N
N#define IP_MTYPE_LINK_CHANGE  (1UL << 14)
N#define IP_MTYPE_DHCP         (1UL << 17)
N#define IP_MTYPE_DHCP_EXT     (1UL << 18)
N
N#define IP_MTYPE_APPLICATION  (1UL << 19)
N
N
N#define IP_MTYPE_ICMP         (1UL << 20)
N#define IP_MTYPE_NET_IN       (1UL << 21)
N#define IP_MTYPE_NET_OUT      (1UL << 22)
N
N#define IP_MTYPE_DNS          (1UL << 24)
N
N#define IP_MTYPE_SOCKET_STATE (1UL << 26)
N#define IP_MTYPE_SOCKET_READ  (1UL << 27)
N#define IP_MTYPE_SOCKET_WRITE (1UL << 28)
N#define IP_MTYPE_SOCKET       (IP_MTYPE_SOCKET_STATE | IP_MTYPE_SOCKET_READ | IP_MTYPE_SOCKET_WRITE)
N#define IP_MTYPE_DNSC         (1UL << 29)
N
Nvoid IP_Logf_Application(const char * sFormat, ...);
Nvoid IP_Warnf_Application(const char * sFormat, ...);
N
N/*********************************************************************
N*
N*       IP_ERR_
N*
N*  Ids to distinguish different message types
N*
N* Stack generic error codes: generally full success is 0,
N* definite errors are negative numbers, and indeterminate conditions
N* are positive numbers. These may be changed if they conflict with
N* defines in the target system.
N* If you have to change
N* these values, be sure to recompile ALL NetPort sources.
N*/
N
N/* programming errors */
N#define IP_ERR_PARAM      -10 /* bad parameter */
N#define IP_ERR_LOGIC      -11 /* sequence of events that shouldn't happen */
N#define IP_ERR_NOCIPHER   -12 /* No corresponding cipher found for the cipher id */
N
N/* system errors */
N#define IP_ERR_NOMEM      -20 /* malloc or calloc failed */
N#define IP_ERR_NOBUFFER   -21 /* ran out of free packets */
N#define IP_ERR_RESOURCE   -22 /* ran out of other queue-able resource */
N#define SEND_DROPPED IP_ERR_RESOURCE /* full queue or similar lack of resource */
N#define IP_ERR_BAD_STATE  -23 /* TCP layer error */
N#define IP_ERR_TIMEOUT    -24 /* TCP layer error */
N
N#define IP_ERR_NOFILE     -25 /* expected file was missing */
N#define IP_ERR_FILEIO     -26 /* file IO error */
N
N/* net errors */
N#define IP_ERR_SENDERR    -30 /* send to net failed at low layer */
N#define IP_ERR_NOARPREP   -31 /* no ARP for a given host */
N#define IP_ERR_BAD_HEADER -32 /* bad header at upper layer (for upcalls) */
N#define IP_ERR_NO_ROUTE   -33 /* can't find a reasonable next IP hop */
N#define IP_ERR_NO_IFACE   -34 /* can't find a reasonable interface */
N#define IP_ERR_HARDWARE   -35 /* detected hardware failure */
N
N/* conditions that are not really fatal OR success: */
N#define IP_ERR_SEND_PENDING 1 /* packet queued pending an ARP reply */
N#define IP_ERR_NOT_MINE     2 /* packet was not of interest (upcall reply) */
N
N
N
N/*********************************************************************
N*
N*  Convert little/big endian - these should be efficient,
N*  inline code or MACROs
N*/
N#if IP_IS_BIG_ENDIAN
X#if 0
S  #define htonl(l) (l)
S  #define htons(s) (s)
S  #define IP_HTONL_FAST(l) (l)
N#else
N  #define htonl(l) IP_SwapU32(l)
N  #define htons(s) ((U16)((U16)(s) >> 8) | (U16)((U16)(s) << 8))   /* Amazingly, some compilers really need all these U16 casts: */
N//  #define htons(s) (((s) >> 8) | (U16)((s) << 8))
N  #define IP_HTONL_FAST(v) (                      \
N      (((U32)((v) << 0)  >> 24) << 0) | \
N      (((U32)((v) << 8)  >> 24) << 8) | \
N      (((U32)((v) << 16) >> 24) << 16) | \
N      (((U32)((v) << 24) >> 24) << 24))
X  #define IP_HTONL_FAST(v) (                            (((U32)((v) << 0)  >> 24) << 0) |       (((U32)((v) << 8)  >> 24) << 8) |       (((U32)((v) << 16) >> 24) << 16) |       (((U32)((v) << 24) >> 24) << 24))
N#endif
N
N#define ntohl(l) htonl(l)
N#define ntohs(s) htons(s)
N
N
NU32 IP_SwapU32(U32 v);
Xunsigned long IP_SwapU32(unsigned long v);
N
N
N/*********************************************************************
N*
N*  IP_OS_
N*/
Nvoid IP_OS_Delay(unsigned ms);
Nvoid IP_OS_DisableInterrupt(void);
Nvoid IP_OS_EnableInterrupt(void);
Nvoid IP_OS_Init(void);
Nvoid IP_OS_Unlock(void);
Nvoid IP_OS_AssertLock(void);
Nvoid IP_OS_Lock  (void);
NU32  IP_OS_GetTime32(void);
Xunsigned long  IP_OS_GetTime32(void);
N// Wait and signal for Net task
Nvoid IP_OS_WaitNetEvent  (unsigned ms);
Nvoid IP_OS_SignalNetEvent(void);
N// Wait and signal for the optional Rx task
Nvoid IP_OS_WaitRxEvent  (void);
Nvoid IP_OS_SignalRxEvent(void);
N// Wait and signal for application tasks
Nvoid IP_OS_WaitItem      (void * pWaitItem);
Nvoid IP_OS_WaitItemTimed (void * pWaitItem, unsigned Timeout);
Nvoid IP_OS_SignalItem(void * pWaitItem);
Nvoid IP_OS_AddTickHook(void (* pfHook)(void));
N
N
N/*********************************************************************
N*
N*       IP_PACKET
N*
N* INCOMING: Incoming packets are always front-aligned in the
N* pBuffer field. The pData pointer is set to pBuffer by the
N* receiver and advanced by each layer of the stack before
N* upcalling the next; ie the ethernet driver bumps the prot field
N* by 14 and decrements plen by 14. PACKETs are pk_alloc()ed by
N* the receiving net layer and pk_free()ed by the transport layer
N* or application when it's finished with them. OUTGOING:
N* Protocols install data into pBuffer with a front pad big enough
N* to accomadate the biggest likely protocol headers, ususally
N* about 62 bytes (14 ether + 24 IP + 24 TCP, where IP & TCP each
N* have option fields.) prot plen are set for this data, and the
N* protocol headers are prepended as the packet goes down the
N* stack. pBuffer is not used in this case except for overflow
N* checks. PACKETs are pk_alloc()ed by the sending protocol and
N* freed by the lower layer level that dispatches them, usually
N* net link layer driver. They can be held by ARP for several
N* seconds while awaiting arp replys on initial sends to a new IP
N* host, and the ARP code will free them when a reply comes in or
N* times out.
N*/
Ntypedef   U32 ip_addr;
Xtypedef   unsigned long ip_addr;
N
Ntypedef struct IP_PACKET {
N  struct IP_PACKET * pNext;
N  struct net       * pNet;          // The interface (net) it came in on
N  char             * pBuffer;       // Beginning of raw buffer
N  char             * pData;         // Beginning of protocol/data. This is always >= pBuffer.
N  ip_addr          fhost;           // IP address asociated with packet
N  U16              NumBytes;        // Number of bytes in buffer
X  unsigned short              NumBytes;        
N  U16              BufferSize;      // Length of raw buffer */
X  unsigned short              BufferSize;      
N  U16              UseCnt;          // Use count, for cloning buffer
X  unsigned short              UseCnt;          
N} IP_PACKET;
N
Ntypedef struct IP_PHY_CONTEXT IP_PHY_CONTEXT;
N
Ntypedef struct {
N  unsigned (*pfRead)         (IP_PHY_CONTEXT* pContext, unsigned RegIndex);
N  void     (*pfWrite)        (IP_PHY_CONTEXT* pContext, unsigned RegIndex, unsigned  val);
N} IP_PHY_ACCESS;
N
Nstruct IP_PHY_CONTEXT {
N  const IP_PHY_ACCESS * pAccess;
N  void * pContext;   // Context needed for low level functions
N  U8   Addr;
X  unsigned char   Addr;
N  U8   UseRMII;      // 0: MII, 1: RMII
X  unsigned char   UseRMII;      
N  U16  Anar;         // Value written to ANAR (Auto-negotiation Advertisement register)
X  unsigned short  Anar;         
N  U16  Bmcr;         // Value written to BMCR (basic mode control register)
X  unsigned short  Bmcr;         
N};
N
Ntypedef struct {
N  int   (*pfInit)         (IP_PHY_CONTEXT * pContext);
N  void  (*pfGetLinkState) (IP_PHY_CONTEXT * pContext, U32 * pDuplex, U32 * pSpeed);
X  void  (*pfGetLinkState) (IP_PHY_CONTEXT * pContext, unsigned long * pDuplex, unsigned long * pSpeed);
N} IP_PHY_DRIVER;
N
Nextern const IP_PHY_DRIVER IP_PHY_Generic;
N
Ntypedef struct {
N  int   (*pfInit)         (unsigned Unit);
N  int   (*pfSendPacket)   (unsigned Unit);
N  int   (*pfGetPacketSize)(unsigned Unit);                                   // Return the number of bytes in next packet, <= 0 if there is no more packet.
N  int   (*pfReadPacket)   (unsigned Unit, U8 * pDest, unsigned NumBytes);    // Read (if pDest is valid) and discard packet.
X  int   (*pfReadPacket)   (unsigned Unit, unsigned char * pDest, unsigned NumBytes);    
N  void  (*pfTimer)        (unsigned Unit);                                   // Routine is called periodically
N  int   (*pfControl)      (unsigned Unit, int Cmd, void * p);                // Various control functions
N} IP_HW_DRIVER;
N
N
Ntypedef struct {
N  unsigned NumAddr;
N  const U8 * pHWAddr;                // Hardware addresses
X  const unsigned char * pHWAddr;                
N} IP_NI_CMD_SET_FILTER_DATA;
N
N
N
N/*********************************************************************
N*
N*       Drivers commands
N*/
N#define IP_NI_CMD_SET_FILTER          0   // Set filter. Can handle multiple MAC-addresses.
N#define IP_NI_CMD_CLR_BPRESSURE       1   // Clear back-pressure
N#define IP_NI_CMD_SET_BPRESSURE       2   // Set back-pressure, to avoid receiving more data until the current data is handled
N#define IP_NI_CMD_GET_CAPS            3   // Retrieves the capabilites, which are a logical-or combination of the IP_NI_CAPS below
N#define IP_NI_CMD_SET_PHY_ADDR        4   // Allows settings the PHY address
N#define IP_NI_CMD_SET_PHY_MODE        5   // Allows settings the PHY in a specific mode (duplex, speed)
N#define IP_NI_CMD_POLL                6   // Poll MAC (typically once per ms) in cases where MAC does not trigger an interrupt.
N#define IP_NI_CMD_GET_MAC_ADDR        7   // Retrieve the MAC address from the MAC. This is used for hardware which stores the MAC addr. in an attached EEPROM.
N#define IP_NI_CMD_DISABLE             8   // Disable the network interface (MAC unit + PHY)
N#define IP_NI_CMD_ENABLE              9   // Enable the network interface (MAC unit + PHY)
N#define IP_NI_CMD_SET_TX_BUFFER_SIZE 10   // Allows setting the size of the Tx buffer.
N
N
N/*********************************************************************
N*
N*       Drivers capabilities
N*/
N#define IP_NI_CAPS_WRITE_IP_CHKSUM     (1 << 0)    // Driver capable of inserting the IP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_WRITE_UDP_CHKSUM    (1 << 1)    // Driver capable of inserting the UDP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_WRITE_TCP_CHKSUM    (1 << 2)    // Driver capable of inserting the TCP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_WRITE_ICMP_CHKSUM   (1 << 3)    // Driver capable of inserting the ICMP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_CHECK_IP_CHKSUM     (1 << 4)    // Driver capable of computing and comparing the IP-checksum of an incoming packet ?
N#define IP_NI_CAPS_CHECK_UDP_CHKSUM    (1 << 5)    // Driver capable of computing and comparing the UDP-checksum of an incoming packet ?
N#define IP_NI_CAPS_CHECK_TCP_CHKSUM    (1 << 6)    // Driver capable of computing and comparing the TCP-checksum of an incoming packet ?
N#define IP_NI_CAPS_CHECK_ICMP_CHKSUM   (1 << 7)    // Driver capable of computing and comparing the ICMP-checksum of an incoming packet ?
N
N
Nvoid IP_NI_ClrBPressure  (unsigned Unit);
Nvoid IP_NI_SetBPressure  (unsigned Unit);
N
N/*********************************************************************
N*
N*       Drivers supplied by SEGGER.
N*
N*  Other drivers can always be added or developped by end user.
N*/
Nextern const IP_HW_DRIVER IP_Driver_AT32AP7000;
Nextern const IP_HW_DRIVER IP_Driver_AT91RM9200;
Nextern const IP_HW_DRIVER IP_Driver_CAP9;
Nextern const IP_HW_DRIVER IP_Driver_DM9000;
Nextern const IP_HW_DRIVER IP_Driver_LAN9115;
Nextern const IP_HW_DRIVER IP_Driver_LPC17xx;
Nextern const IP_HW_DRIVER IP_Driver_LPC24xx;
Nextern const IP_HW_DRIVER IP_Driver_LPC32xx;
Nextern const IP_HW_DRIVER IP_Driver_SAM7X;
Nextern const IP_HW_DRIVER IP_Driver_SAM9260;
Nextern const IP_HW_DRIVER IP_Driver_SAM9263;
Nextern const IP_HW_DRIVER IP_Driver_SAM9XE;
Nextern const IP_HW_DRIVER IP_Driver_STR912;
Nextern const IP_HW_DRIVER IP_Driver_NIOSII_MaCo;
Nextern const IP_HW_DRIVER IP_Driver_GMACII;
Nextern const IP_HW_DRIVER IP_Driver_MCF5329;
Nextern const IP_HW_DRIVER IP_Driver_MCF5223x;
Nextern const IP_HW_DRIVER IP_Driver_H8S2472;
Nextern const IP_HW_DRIVER IP_Driver_LAN9118;
Nextern const IP_HW_DRIVER IP_Driver_LAN91C111;
Nextern const IP_HW_DRIVER IP_Driver_LM3S6965;
Nextern const IP_HW_DRIVER IP_Driver_LM3S9B90;
Nextern const IP_HW_DRIVER IP_Driver_SH7670;
N
Nvoid IP_NI_AT32AP7000_ConfigNumRxBuffers(U16 NumRxBuffers);
Xvoid IP_NI_AT32AP7000_ConfigNumRxBuffers(unsigned short NumRxBuffers);
Nvoid IP_NI_AT91RM9200_ConfigNumRxBuffers(U16 NumRxBuffers);
Xvoid IP_NI_AT91RM9200_ConfigNumRxBuffers(unsigned short NumRxBuffers);
Nvoid IP_NI_SAM7X_ConfigNumRxBuffers     (U16 NumRxBuffers);
Xvoid IP_NI_SAM7X_ConfigNumRxBuffers     (unsigned short NumRxBuffers);
Nvoid IP_NI_SAM9260_ConfigNumRxBuffers   (U16 NumRxBuffers);
Xvoid IP_NI_SAM9260_ConfigNumRxBuffers   (unsigned short NumRxBuffers);
Nvoid IP_NI_SAM9263_ConfigNumRxBuffers   (U16 NumRxBuffers);
Xvoid IP_NI_SAM9263_ConfigNumRxBuffers   (unsigned short NumRxBuffers);
Nvoid IP_NI_SAM9XE_ConfigNumRxBuffers    (U16 NumRxBuffers);
Xvoid IP_NI_SAM9XE_ConfigNumRxBuffers    (unsigned short NumRxBuffers);
Nvoid IP_NI_CAP9_ConfigNumRxBuffers      (U16 NumRxBuffers);
Xvoid IP_NI_CAP9_ConfigNumRxBuffers      (unsigned short NumRxBuffers);
N
Ntypedef struct IP_NI_DM9000_ACCESS  IP_NI_DM9000_ACCESS;
Ntypedef struct DM9000_INST DM9000_INST;
N
Nstruct DM9000_INST {
N  U8 *  pHardware;
X  unsigned char *  pHardware;
N  U8 *  pValue;
X  unsigned char *  pValue;
N  U8    BusWidth;    // 8, 16 or 32 bits
X  unsigned char    BusWidth;    
N  IP_NI_DM9000_ACCESS* pAccess;
N};
N
Nstruct IP_NI_DM9000_ACCESS {
N  void (*pf_WriteReg8)    (DM9000_INST * pInst, unsigned RegIndex,  unsigned  val);
N  U16  (*pf_ReadReg8)     (DM9000_INST * pInst, unsigned RegIndex);
X  unsigned short  (*pf_ReadReg8)     (DM9000_INST * pInst, unsigned RegIndex);
N  void (*pf_ReadData)     (DM9000_INST * pInst, U8*   pDest, U32 NumBytes);
X  void (*pf_ReadData)     (DM9000_INST * pInst, unsigned char*   pDest, unsigned long NumBytes);
N  void (*pf_WriteData)    (DM9000_INST * pInst, void* pPacket, U32 NumBytes);
X  void (*pf_WriteData)    (DM9000_INST * pInst, void* pPacket, unsigned long NumBytes);
N};
N
Nvoid IP_NI_DM9000_ISR_Handler (unsigned Unit);
Nvoid IP_NI_DM9000_ConfigAddr  (unsigned Unit, void* pBase, void* pValue);
Nvoid IP_NI_DM9000_ConfigAccess(unsigned Unit, IP_NI_DM9000_ACCESS * pAccess);
N
Nvoid IP_NI_LAN91C111_ISR_Handler(unsigned Unit);
Nvoid IP_NI_LAN91C111_ConfigAddr (unsigned Unit, void* pBase);
N
Nvoid IP_NI_LAN9115_ISR_Handler   (unsigned Unit);
Nvoid IP_NI_LAN9115_ConfigBaseAddr(unsigned Unit, void* pBase);
N
Nvoid IP_NI_NIOSII_MaCo_ConfigNumRxBuffers(unsigned Unit, U16 NumRxBuffers);
Xvoid IP_NI_NIOSII_MaCo_ConfigNumRxBuffers(unsigned Unit, unsigned short NumRxBuffers);
Nvoid IP_NI_NIOSII_MaCo_ConfigBaseAddr    (unsigned Unit, void* pBase, unsigned IrqNumber);
N
Nvoid IP_NI_GMACII_ConfigBaseAddr(unsigned Unit, void* pBase, unsigned IrqNumber);
N
N/*********************************************************************
N*
N*       PHY configuration
N*/
N#define IP_PHY_MODE_MII  0
N#define IP_PHY_MODE_RMII 1
N
N#define IP_PHY_ADDR_ANY       0xFF                          // IP_PHY_ADDR_ANY is used as PHY addr to initiate automatic scan for PHY
N#define IP_PHY_ADDR_INTERNAL  0xFE                          // IP_PHY_ADDR_INTERNAL is used as PHY addr to select internal PHY
N
Nvoid IP_NI_ConfigPHYAddr (unsigned Unit, U8 Addr);          // Configure PHY Addr (5-bit)
Xvoid IP_NI_ConfigPHYAddr (unsigned Unit, unsigned char Addr);          
Nvoid IP_NI_ConfigPHYMode (unsigned Unit, U8 Mode);          // Configure PHY Mode: 0: MII, 1: RMII
Xvoid IP_NI_ConfigPHYMode (unsigned Unit, unsigned char Mode);          
Nvoid IP_NI_ConfigPoll    (unsigned Unit);
Nvoid IP_NI_SetError      (unsigned Unit);
Nint  IP_NI_SetTxBufferSize(unsigned Unit, unsigned NumBytes);
N
N
N/*********************************************************************
N*
N*       IP stack tasks
N*/
Nvoid IP_Task(void);
Nvoid IP_RxTask(void);
Nvoid IP_ShellServer(void);
N
N
Ntypedef int (IP_RX_HOOK)(IP_PACKET * pPacket);
N
N/*********************************************************************
N*
N*       Core functions
N*/
Nvoid IP_AddBuffers                (int NumBuffers, int BytesPerBuffer);
Nvoid IP_AddEtherInterface         (const IP_HW_DRIVER *pDriver);
Nvoid IP_AllowBackPressure         (char v);
Nvoid IP_AssignMemory              (U32 * pMem, U32 NumBytes);
Xvoid IP_AssignMemory              (unsigned long * pMem, unsigned long NumBytes);
Nvoid IP_ConfTCPSpace              (unsigned SendSpace, unsigned RecvSpace);  // Set window sizes
Nvoid IP_Exec                      (void);
Nvoid IP_GetAddrMask               (U8 IFace, U32 * pAddr, U32 * pMask);
Xvoid IP_GetAddrMask               (unsigned char IFace, unsigned long * pAddr, unsigned long * pMask);
Nint  IP_GetCurrentLinkSpeed       (void);
NU32  IP_GetGWAddr                 (U8 IFace);
Xunsigned long  IP_GetGWAddr                 (unsigned char IFace);
Nvoid IP_GetHWAddr                 (U8 IFace, U8 * pDest, unsigned Len);
Xvoid IP_GetHWAddr                 (unsigned char IFace, unsigned char * pDest, unsigned Len);
NU32  IP_GetIPAddr                 (U8 IFace);
Xunsigned long  IP_GetIPAddr                 (unsigned char IFace);
Nconst char * IP_GetIPPacketInfo   (IP_PACKET * pPacket);
Nint  IP_GetVersion                (void);                   // Format: Mmmrr. Sample 10201 is 1.02a
Nvoid IP_ICMP_SetRxHook            (IP_RX_HOOK * pfRxHook);
Nint  IP_IFaceIsReady              (void);
Nvoid IP_Init                      (void);
Nint  IP_NI_GetCaps                (unsigned Unit);
Nint  IP_NI_LoadHWAddr             (unsigned Unit);
Nvoid IP_Panic                     (const char * sError);
Nvoid IP_SetAddrMask               (U32 Addr, U32 Mask);
Xvoid IP_SetAddrMask               (unsigned long Addr, unsigned long Mask);
Nint  IP_SetCurrentLinkState       (U32 Duplex, U32 Speed);  // Called from driver
Xint  IP_SetCurrentLinkState       (unsigned long Duplex, unsigned long Speed);  
Nvoid IP_SetDefaultTTL             (int v);
Nvoid IP_SetGWAddr                 (U8 IFace, U32 GWAddr);
Xvoid IP_SetGWAddr                 (unsigned char IFace, unsigned long GWAddr);
Nvoid IP_SetHWAddr                 (const U8 * pHWAddr);
Xvoid IP_SetHWAddr                 (const unsigned char * pHWAddr);
Nvoid IP_SetMTU                    (U8 IFace, U32 Mtu);
Xvoid IP_SetMTU                    (unsigned char IFace, unsigned long Mtu);
Nint  IP_SendPacket                (unsigned IFace, void * pData, int NumBytes);
Nint  IP_SendPing                  (ip_addr, char* pData, unsigned NumBytes, U16 SeqNo);
Xint  IP_SendPing                  (ip_addr, char* pData, unsigned NumBytes, unsigned short SeqNo);
Nvoid IP_SetRxHook                 (IP_RX_HOOK * pfRxHook);
Nvoid IP_SOCKET_SetDefaultOptions  (U16 v);
Xvoid IP_SOCKET_SetDefaultOptions  (unsigned short v);
Nvoid IP_SOCKET_SetLimit           (unsigned Limit);
Nvoid IP_TCP_Set2MSLDelay          (unsigned v);
Nvoid IP_TCP_SetConnKeepaliveOpt   (U32 Init, U32 Idle, U32 Period, U32 Cnt);
Xvoid IP_TCP_SetConnKeepaliveOpt   (unsigned long Init, unsigned long Idle, unsigned long Period, unsigned long Cnt);
Nvoid IP_TCP_SetRetransDelayRange  (unsigned RetransDelayMin, unsigned RetransDelayMax);
Nvoid IP_X_Config                  (void);
N
N/*********************************************************************
N*
N*       Log/Warn functions
N*/
Nvoid IP_Log           (const char * s);
Nvoid IP_Warn          (const char * s);
Nvoid IP_SetLogFilter  (U32 FilterMask);
Xvoid IP_SetLogFilter  (unsigned long FilterMask);
Nvoid IP_SetWarnFilter (U32 FilterMask);
Xvoid IP_SetWarnFilter (unsigned long FilterMask);
Nvoid IP_AddLogFilter  (U32 FilterMask);
Xvoid IP_AddLogFilter  (unsigned long FilterMask);
Nvoid IP_AddWarnFilter (U32 FilterMask);
Xvoid IP_AddWarnFilter (unsigned long FilterMask);
N
N
N/*********************************************************************
N*
N*       DNS (Domain name system)
N*
N*  Name resolution
N*/
N// Description of data base entry for a single host.
Nstruct hostent {
N  char *  h_name;        // Official name of host.
N  char ** h_aliases;     // Alias list.
N  int     h_addrtype;    // Host address type.
N  int     h_length;      // Length of address.
N  char ** h_addr_list;   // List of addresses from name server.
N#define h_addr h_addr_list[0] /* Address, for backward compatibility.  */
N#ifdef DNS_CLIENT_UPDT
S  // Extra variables passed in to Dynamic DNS updates.
S  char *  h_z_name;      // IN- zone name for UPDATE packet.
S  ip_addr h_add_ipaddr;  // IN- add this ip address for host name in zone.
S  U32     h_ttl;         // IN- time-to-live field for UPDATE packet.
N#endif
N};
N
N
Nstruct hostent * gethostbyname (char * name);
Nint              IP_ResolveHost(char * host, ip_addr *   address,  int   flags);
Nvoid             IP_DNS_SetServer (U32 DNSServerAddr);
Xvoid             IP_DNS_SetServer (unsigned long DNSServerAddr);
NU32              IP_DNS_GetServer (void);
Xunsigned long              IP_DNS_GetServer (void);
Nint              IP_DNS_SetServerEx (U8 IFace, U8 DNSServer, const U8 * pDNSAddr, int AddrLen);
Xint              IP_DNS_SetServerEx (unsigned char IFace, unsigned char DNSServer, const unsigned char * pDNSAddr, int AddrLen);
Nvoid             IP_DNS_GetServerEx (U8 IFace, U8 DNSServer, U8 * pDNSAddr, int * pAddrLen);
Xvoid             IP_DNS_GetServerEx (unsigned char IFace, unsigned char DNSServer, unsigned char * pDNSAddr, int * pAddrLen);
Nchar           * IP_ParseIPAddr(ip_addr * ipout,  unsigned *  sbits, char *   stringin);
Nvoid             IP_DNSC_SetMaxTTL(U32 TTL);
Xvoid             IP_DNSC_SetMaxTTL(unsigned long TTL);
N
N
N/*********************************************************************
N*
N*       Utility functions
N*
N* RS: Maybe we should move them into a UTIL module some time ? (We can keep macros here for compatibility)
N*/
NI32  IP_BringInBounds(I32 v, I32 Min, I32 Max);
Xsigned long  IP_BringInBounds(signed long v, signed long Min, signed long Max);
NU32  IP_LoadU32BE(const U8 * pData);
Xunsigned long  IP_LoadU32BE(const unsigned char * pData);
NU32  IP_LoadU32LE(const U8 * pData);
Xunsigned long  IP_LoadU32LE(const unsigned char * pData);
NU32  IP_LoadU32TE(const U8 * pData);
Xunsigned long  IP_LoadU32TE(const unsigned char * pData);
NU32  IP_LoadU16BE(const U8 * pData);
Xunsigned long  IP_LoadU16BE(const unsigned char * pData);
NU32  IP_LoadU16LE(const U8 * pData);
Xunsigned long  IP_LoadU16LE(const unsigned char * pData);
Nvoid IP_StoreU32BE(U8 * p, U32 v);
Xvoid IP_StoreU32BE(unsigned char * p, unsigned long v);
Nvoid IP_StoreU32LE(U8 * p, U32 v);
Xvoid IP_StoreU32LE(unsigned char * p, unsigned long v);
N
Nchar IP_tolower(char c);
Nchar IP_isalpha(char c);
Nchar IP_isalnum(char c);
Nint  IP_PrintIPAddr(char * pDest, U32 IPAddr, int BufferSize);
Xint  IP_PrintIPAddr(char * pDest, unsigned long IPAddr, int BufferSize);
N
N
N
N/*********************************************************************
N*
N*       UDP
N*/
Ntypedef  struct udp_conn * UDPCONN;
Ntypedef  U32 IP_ADDR;
Xtypedef  unsigned long IP_ADDR;
N
N#define IP_RX_ERROR        -1
N#define IP_OK               0
N#define IP_OK_KEEP_PACKET   1
N
Ntypedef UDPCONN IP_UDP_CONN;
N
NIP_UDP_CONN IP_UDP_Open(IP_ADDR IPAddr, U16 fport, U16 lport, int(*)(IP_PACKET *, void * pContext) , void * pContext);
XIP_UDP_CONN IP_UDP_Open(IP_ADDR IPAddr, unsigned short fport, unsigned short lport, int(*)(IP_PACKET *, void * pContext) , void * pContext);
Nvoid        IP_UDP_Close(IP_UDP_CONN);
NIP_PACKET * IP_UDP_Alloc(int NumBytes);
Nint         IP_UDP_Send       (int IFace, IP_ADDR FHost, U16 fport, U16 lport, IP_PACKET * pPacket);
Xint         IP_UDP_Send       (int IFace, IP_ADDR FHost, unsigned short fport, unsigned short lport, IP_PACKET * pPacket);
Nint         IP_UDP_SendAndFree(int IFace, IP_ADDR FHost, U16 fport, U16 lport, IP_PACKET * pPacket);
Xint         IP_UDP_SendAndFree(int IFace, IP_ADDR FHost, unsigned short fport, unsigned short lport, IP_PACKET * pPacket);
Nvoid        IP_UDP_Free       (IP_PACKET * pPacket);
NU16         IP_UDP_FindFreePort(void);
Xunsigned short         IP_UDP_FindFreePort(void);
NU16         IP_UDP_GetLPort  (const IP_PACKET *pPacket);
Xunsigned short         IP_UDP_GetLPort  (const IP_PACKET *pPacket);
Nvoid *      IP_UDP_GetDataPtr(const IP_PACKET *pPacket);
Nvoid        IP_UDP_GetSrcAddr(const IP_PACKET *pPacket, void * pSrcAddr, int AddrLen);
N
Nvoid        IP_UDP_EnableRxChecksum(void);
Nvoid        IP_UDP_DisableRxChecksum(void);
Nvoid        IP_UDP_EnableTxChecksum(void);
Nvoid        IP_UDP_DisableTxChecksum(void);
N
N
N/*********************************************************************
N*
N*       TCP Zero copy
N*/
NIP_PACKET * IP_TCP_Alloc      (int datasize);
Nvoid        IP_TCP_Free       (        IP_PACKET * pPacket);
Nint         IP_TCP_Send       (long s, IP_PACKET * pPacket);
Nint         IP_TCP_SendAndFree(long s, IP_PACKET * pPacket);
N
N/*********************************************************************
N*
N*       IP_DHCPC_...
N*
N*  DHCP (Dynamic host configuration protocol) functions.
N*/
Nvoid     IP_DHCPC_Activate   (int IFIndex, const char *sHost, const char *sDomain, const char *sVendor);
Nunsigned IP_DHCPC_GetState   (int IFIndex);
Nvoid     IP_DHCPC_Halt       (int IFIndex);
Nvoid     IP_DHCPC_SetCallback(int IFIndex, int (*routine)(int,int) );
Nvoid     IP_DHCPC_SetClientId(int IFIndex, const char *sClientId);
N
N
N/*********************************************************************
N*
N*       IP_Show_...
N*
N*  Text output functions informing about the state of various components of the software
N*/
Nint IP_ShowARP       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowICMP      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowTCP       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowBSDConn   (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowBSDSend   (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowBSDRcv    (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowMBuf      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowMBufList  (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowSocketList(void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowStat      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowUDP       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowUDPSockets(void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowDHCPClient(void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowDNS       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowDNS1      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
N
N
Ntypedef struct {
N  long Socket;
N  char * pBuffer;
N  int BufferSize;
N} IP_SENDF_CONTEXT;
N
Nvoid IP_Sendf(void * pContext, const char * sFormat, ...);
N
N/*********************************************************************
N*
N*       IP_CONNECTION information
N*
N*/
N
N#define IP_CONNECTION_TYPE_TCP 1
N
Ntypedef void * IP_CONNECTION_HANDLE;
Ntypedef struct {
N  void * pSock;
N  long hSock;
N  U32  ForeignAddr;
X  unsigned long  ForeignAddr;
N  U32  LocalAddr;
X  unsigned long  LocalAddr;
N  U16  ForeignPort;
X  unsigned short  ForeignPort;
N  U16  LocalPort;
X  unsigned short  LocalPort;
N  U8   Type;
X  unsigned char   Type;
N  U8   TcpState;
X  unsigned char   TcpState;
N  U16  TcpMtu;
X  unsigned short  TcpMtu;
N  U16  TcpMss;
X  unsigned short  TcpMss;
N  U32  TcpRetransDelay;
X  unsigned long  TcpRetransDelay;
N  U32  TcpIdleTime;
X  unsigned long  TcpIdleTime;
N  U32  RxWindowCur;
X  unsigned long  RxWindowCur;
N  U32  RxWindowMax;
X  unsigned long  RxWindowMax;
N  U32  TxWindow;
X  unsigned long  TxWindow;
N} IP_CONNECTION;
N
Nint IP_INFO_GetConnectionList(IP_CONNECTION_HANDLE *pDest, int MaxItems);
Nint IP_INFO_GetConnectionInfo(IP_CONNECTION_HANDLE h, IP_CONNECTION * p);
Nconst char * IP_INFO_ConnectionType2String(U8 Type);
Xconst char * IP_INFO_ConnectionType2String(unsigned char Type);
Nconst char * IP_INFO_ConnectionState2String(U8 State);
Xconst char * IP_INFO_ConnectionState2String(unsigned char State);
N
N#if defined(__cplusplus)
X#if 0L
S  }              // Make sure we have C-declarations in C++ programs
N#endif
N
N#endif   // Avoid multiple inclusion
N
N
N
L 20 "Config\IP_ConfigIO.c" 2
N#include "RTOS.h"
L 1 "OS\RTOS.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : RTOS.h
NPurpose : include file for embOS,
N          to be included in every C-module accessing embOS-routines
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef RTOS_H_INCLUDED        /* Avoid multiple inclusion          */
N#define RTOS_H_INCLUDED
N
N/*********************************************************************
N*
N*       Chip specifics for ARM7TDMI / ARM9TDMI and KEIL ARM MDK
N*
N**********************************************************************
N*/
N
N#include <string.h>                            /* req. for memset.h */
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 30 "OS\RTOS.h" 2
N
N/*********************************************************************
N*
N*     Specifics for ARM cores and KEIL-MDK compiler
N*
N**********************************************************************
N*/
N
N#define OS_PORT_REVISION          (1)                // Port specific revision
N#define OS_PTR_OP_IS_ATOMIC       (1)
N#define OS_GetTime()              (OS_Time)
N#define OS_GetTime32()            (OS_Time)
N#define OS_I32                    int
N#define OS_SIZEOF_INT             (4)                // Size of integer in bytes
N#define OS_BIG_ENDIAN             (0)                
N#define OS_SUPPORT_SYSSTACK_INFO  (1)                // Option to supply more info  to viewer
N#define OS_SUPPORT_OS_ALLOC       (1)                // Define whether OS_Alloc is supported
N#define OS_SP_ADJUST              (0)
N#define OS_EnterIntStack()                           // Int stack is automatically used by ARM
N#define OS_LeaveIntStack()                           // Int stack is automatically used by ARM
N
N/*****  Core specific configuration *********************************/
N
N#define OS_SUPPORT_INTSTACK_INFO            (1)      // Option to supply more info  to viewer
N#define OS_SWITCH_FROM_INT_MODIFIES_STACK   (1)
N#define OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY (0)
N#define OS_SUPPORT_INT_PRIORITY             (0)              // No selectable interrupt priorities with ARM
N
N/*****  End of configuration settings *******************************/
N
N#ifdef __TARGET_ARCH_4T
N  #define OS_CPU "ARM4/KEIL_MDK"
N#else
S  #define OS_CPU "ARM5/KEIL_MDK"
N#endif
N
N#define OS_DI() __disable_irq()    /* We use the default intrinsic function */
N#define OS_EI() __enable_irq()     /* We use the default intrinsic function */
N
N
N/* Option to get Stack pointer information  */
N#define OS_INIT_STACK_INFO()
N
N/*********************************************************************
N*
N*       Port specific (non OS generic) functions
N*/
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N  typedef void    OS_ISR_HANDLER(void);
N  void            OS_irq_handler(void);     /* Declare function to make sure it is arm pcs */
N  void            OS_IRQ_SERVICE(void);     /* embOS int handler in RTOSVect.asm  */
N  void            OS_USER_irq_func(void);   /* User interrupt handler from UserIrq.c */
N  OS_ISR_HANDLER* OS_ARM_InstallISRHandler (int ISRIndex, OS_ISR_HANDLER* pFunc);
N  void            OS_ARM_EnableISR         (int ISRIndex);
N  void            OS_ARM_DisableISR        (int ISRIndex);
N  int             OS_ARM_ISRSetPrio        (int ISRIndex, int Prio);
N  void            OS_ARM_AssignISRSource   (int ISRIndex, int Source);
N  void            OS_ARM_EnableISRSource   (int SourceIndex);
N  void            OS_ARM_DisableISRSource  (int SourceIndex);
N  void            OS_StartTask             (void);
N  void            OS_InitPLL               (void);
N
N/*********************************************************************
N*
N*       Core specific implementation
N*/
N
N/****** Support for ARM VFP *****************************************/
N  
Nextern const struct OS_EXTEND_TASK_CONTEXT OS_VFP_ExtendContext;
N
N/****** Support for ARM MMU and caches ******************************/
N
Nvoid OS_ARM_ICACHE_Enable(void);
Nvoid OS_ARM_DCACHE_Enable(void);
Nvoid OS_ARM_DCACHE_CleanRange     (void* p, unsigned int NumBytes);
Nvoid OS_ARM_DCACHE_InvalidateRange(void* p, unsigned int NumBytes);
Nvoid OS_ARM_CACHE_Sync(void);
N
Nvoid OS_ARM_MMU_Enable(unsigned int* pTranslationTable);
Nvoid OS_ARM_MMU_InitTT(unsigned int* pTranslationTable);
Nvoid OS_ARM_MMU_AddTTEntries(unsigned int* pTranslationTable, unsigned int CacheMode, unsigned int VIndex, unsigned int PIndex, unsigned int NumEntries);
N
Nvoid OS_ARM720_CACHE_Enable(void);
Nvoid OS_ARM720_CACHE_CleanRange(void* p, unsigned int NumBytes);
Nvoid OS_ARM720_CACHE_InvalidateRange(void* p, unsigned int NumBytes);
N
Nvoid OS_ARM720_MMU_Enable(unsigned int* pTranslationTable);
Nvoid OS_ARM720_MMU_InitTT(unsigned int* pTranslationTable);
Nvoid OS_ARM720_MMU_AddTTEntries(unsigned int* pTranslationTable, unsigned int CacheMode, unsigned int VIndex, unsigned int PIndex, unsigned int NumEntries);
N
N#define OS_ARM_CACHEMODE_NC_NB    ((0 << 3) | (0 << 2))
N#define OS_ARM_CACHEMODE_C_NB     ((1 << 3) | (0 << 2))
N#define OS_ARM_CACHEMODE_NC_B     ((0 << 3) | (1 << 2))
N#define OS_ARM_CACHEMODE_C_B      ((1 << 3) | (1 << 2))
N#define OS_ARM_CACHEMODE_ILLEGAL  (0x01)
N
N#ifdef __cplusplus
S  } 
N#endif
N
N/*********************************************************************
N*
N*     Port specific revision
N*/
N
N/*********************************************************************
N*
N*       Check configuration
N*
N**********************************************************************
N
NThis is required in order to automatically create the correct identifiers
Nin order to be able to autoamitcally remap the identifiers.
N
N*/
N
N#ifdef __thumb
N  #define OS_CPUMODE_PREFIX "T"
N#else
S  #define OS_CPUMODE_PREFIX "A"
N#endif
N
N#ifdef __TARGET_ARCH_4T
N  #define OS_CPU_PREFIX "4"
N#else
S  #define OS_CPU_PREFIX "5"
N#endif
N
N#ifdef __BIG_ENDIAN
S  #define OS_ENDIAN_PREFIX "B"
N#else
N  #define OS_ENDIAN_PREFIX "L"
N#endif
N
N#define OS_MODEL OS_CPUMODE_PREFIX OS_CPU_PREFIX OS_ENDIAN_PREFIX
N
N
N/****** End of chip / compiler specific part ************************/
N
N/*********************************************************************
N*
N*       Generic portion of the OS starts here
N*
N**********************************************************************
NThis file (original name OS_RAW.h) is part of RTOS.h, the include
Nfile for the OS.
N*/
N
N#if (!defined(OS_LIBMODE_XR) && !defined(OS_LIBMODE_R)  &&   \
N     !defined(OS_LIBMODE_S)  && !defined(OS_LIBMODE_SP) &&   \
N     !defined(OS_LIBMODE_D)  && !defined(OS_LIBMODE_DP) &&   \
N     !defined(OS_LIBMODE_DT))
X#if (!0L && !0L  &&        !0L  && !0L &&        !0L  && !0L &&        !0L)
N#include "OS_Config.h"
L 1 "Config\OS_Config.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef OS_CONFIG_H                     /* Avoid multiple inclusion */
N#define OS_CONFIG_H
N
N/*********************************************************************
N*
N*       Configuration for RTOS build and UART
N*
N*  One of the following builds needs to be selected for both DEBUG and Release builds:
N*
N*  OS_LIBMODE_XR    Extremly small release build without Round robin
N*  OS_LIBMODE_R     Release build
N*  OS_LIBMODE_S     Release build with stack check
N*  OS_LIBMODE_SP    Release build with stack check and profiling
N*  OS_LIBMODE_D     Debug build
N*  OS_LIBMODE_DP    Debug build with profiling
N*  OS_LIBMODE_DT    Debug build with trace
N*/
N
N#ifndef   DEBUG
S  #define DEBUG 0
N#endif
N
N#if DEBUG
X#if 1
N  #define OS_LIBMODE_DP
N#else
S  #define OS_LIBMODE_R
S  #define OS_VIEW_ENABLE   0
N#endif
N
N#endif                                  /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 187 "OS\RTOS.h" 2
N#endif
N
N#define OS_VERSION_GENERIC (36004)      /*   Generic version 3.60d  */
N
N#ifndef   OS_PORT_REVISION
S  #define OS_PORT_REVISION 0
N#endif
N
N#define OS_VERSION OS_VERSION_GENERIC + (OS_PORT_REVISION * 25)
N
N/*********************************************************************
N*
N*       Defines for library types
N*
N**********************************************************************
N*/
N
N/* If library type is not selected yet (on project level,
N   for example), then select DP by default
N*/
N#if (!defined(OS_LIBMODE_XR) && !defined(OS_LIBMODE_R)  &&   \
N     !defined(OS_LIBMODE_S)  && !defined(OS_LIBMODE_SP) &&   \
N     !defined(OS_LIBMODE_D)  && !defined(OS_LIBMODE_DP) &&   \
N     !defined(OS_LIBMODE_DT))
X#if (!0L && !0L  &&        !0L  && !0L &&        !0L  && !1L &&        !0L)
S#define OS_LIBMODE_DP
N#endif
N
N#if defined(OS_LIBMODE_XR)                                   // Extremely small release - without Round robin support
X#if 0L                                   
S  #define OS_CHECKSTACK       0
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_RR_SUPPORTED     0
S  #define OS_TRACKNAME        0
S  #define OS_SUPPORT_SAVE_RESTORE_HOOK 0
S  #define OS_CreateTask   OS_CreateTask_XR
S  #define OS_CreateTaskEx OS_CreateTaskEx_XR
S  #define OS_LIBMODE "XR"
S#elif defined(OS_LIBMODE_R)                                  // Release build
X#elif 0L                                  
S  #define OS_CHECKSTACK       0
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_R
S  #define OS_CreateTaskEx OS_CreateTaskEx_R
S  #define OS_LIBMODE "R"
S#elif defined(OS_LIBMODE_S)                                  // Release build with stack check
X#elif 0L                                  
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_S
S  #define OS_CreateTaskEx OS_CreateTaskEx_S
S  #define OS_LIBMODE "S"
S#elif defined(OS_LIBMODE_SP)                                 // Release build with stack check and profiling
X#elif 0L                                 
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            0
S  #define OS_PROFILE          1
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_SP
S  #define OS_CreateTaskEx OS_CreateTaskEx_SP
S  #define OS_LIBMODE "SP"
S#elif defined(OS_LIBMODE_D)                                  // Debug build
X#elif 0L                                  
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            1
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_D
S  #define OS_CreateTaskEx OS_CreateTaskEx_D
S  #define OS_LIBMODE "D"
N#elif defined(OS_LIBMODE_DP)                                  // Debug build with profiling
X#elif 1L                                  
N  #define OS_CHECKSTACK       1
N  #define OS_PROFILE          1
N  #define OS_DEBUG            1
N  #define OS_SUPPORT_TICKSTEP 1
N  #define OS_TRACE            0
N  #define OS_CreateTask   OS_CreateTask_DP
N  #define OS_CreateTaskEx OS_CreateTaskEx_DP
N  #define OS_LIBMODE "DP"
N#elif defined(OS_LIBMODE_DT)                                  // Debug build with profiling and trace
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            1
S  #define OS_PROFILE          1
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            1
S  #define OS_CreateTask   OS_CreateTask_DT
S  #define OS_CreateTaskEx OS_CreateTaskEx_DT
S  #define OS_LIBMODE "DT"
S#else
S  #error Please define library type used !
N#endif
N
N/*********************************************************************
N*
N*       OS compile time switches
N*
N**********************************************************************
N
NThese compile time switches can be modified when recompiling
Nthe library. Usually, the values are in OSCHIP.H, which is then
Nmerged with OS_RAW.H to form RTOS.H.
NIf the values are not defined in OSCHIP.H, the default values
Nbelow are used.
N*/
N
N/* Make it possible to place const data in RAM via
N   define and therefore via command line. This is required
N   for some smaller CPUs in small memory models
N   It is defined to be "const" by default, but can be defined to nothing
N   by simply adding a -DOS_CONST_DATA on the commandline
N*/
N
N#ifndef   OS_CONST_DATA
N  #define OS_CONST_DATA const  /* Default      */
N#else
S  #undef  OS_CONST_DATA
S  #define OS_CONST_DATA        /* define blank */
N#endif
N
N#ifndef   OS_INTERWORK
N  #define OS_INTERWORK
N#endif
N
N#ifndef   OS_SCHEDULER_ACTIVATED_BY_EXCEPTION
N  #define OS_SCHEDULER_ACTIVATED_BY_EXCEPTION   (0)
N#endif
N
N#ifndef   OS_STACK_ADR
N  #define OS_STACK_ADR OS_U32
N#endif
N
N#ifndef   OS_MODEL
S  #define OS_MODEL ""
N#endif
N
N#ifndef   OS_MEMSET
N  #define OS_MEMSET(a,v,s) memset(a,v,s)
N#endif
N
N#ifndef   OS_MEMCPY
N  #define OS_MEMCPY(dest,src,cnt) memcpy(dest,src,cnt)
N#endif
N
N#ifndef   OS_STRLEN
N  #define OS_STRLEN(s) strlen(s)
N#endif
N
N#ifndef   OS_DUMMY_STATEMENT
N  #define OS_DUMMY_STATEMENT()
N#endif
N
N#ifndef   OS_USEPARA
N  #define OS_USEPARA(para) para=para
N#endif
N
N#ifndef   OS_SUPPORT_TICKSTEP
S  #define OS_SUPPORT_TICKSTEP 0
N#endif
N
N#ifndef   OS_TRACKNAME
N  #define OS_TRACKNAME (1)
N#endif
N
N#ifndef   OS_TRACE
S  #define OS_TRACE (0)
N#endif
N
N#ifndef   OS_SUPPORT_SAVE_RESTORE_HOOK
N  #define OS_SUPPORT_SAVE_RESTORE_HOOK  (1)
N#endif
N
N#ifndef   OS_RR_SUPPORTED
N  #define OS_RR_SUPPORTED (1)
N#endif
N
N#ifndef   OS_STACK_AT_BOTTOM
N  #define OS_STACK_AT_BOTTOM (0)
N#endif
N
N/*  Settings for NON-ANSI compiler syntax
N    The default behaviour complies with IAR.
N*/
N#ifndef   OS_COMPILER_LOCATION_LEFT
N  #define OS_COMPILER_LOCATION_LEFT 1  /* (req. for IAR) */
N#endif
N
N#ifndef   OS_COMPILER_STORAGE_MODIFIER_LEFT
N  #define OS_COMPILER_STORAGE_MODIFIER_LEFT 1  /* default for all except KEIL */
N#endif
N
N#define OS_LINK_MAILBOXES (OS_DEBUG)
N
N#ifndef   OS_CHECK
N  #define OS_CHECK 0
N#endif
N
N#ifndef   OS_ALIGN_PTR
N  #define OS_ALIGN_PTR (1)
N#endif
N
N#ifndef   OS_ALIGN_INT
N  #define OS_ALIGN_INT (1)
N#endif
N
N#ifndef   OS_PTR_TO_VALUE
N  #define OS_PTR_TO_VALUE(p) (p)
N#endif
N
N#ifndef   OS_IDLE
N  #define OS_IDLE() OS_Idle()
N#endif
N
N#ifndef   OS_PTR_OP_IS_ATOMIC
S  #define OS_PTR_OP_IS_ATOMIC   (0)         // Helps to minimize code size and execution time. Some code is not required if setting pointers is an atomic operation (32 bit CPUs or 16 bit CPUs in near model)
N#endif
N
N#ifndef   OS_SUSPEND_TASK_ON_TERMINATE      // Sets the task state of a terminated task to "suspended". Primarily used in the OS simulation, because the windows scheduler might re-activate a suspended task
N  #define OS_SUSPEND_TASK_ON_TERMINATE (0)
N#endif
N
N#ifndef   OS_INIT_EXPLICITLY
N  #define OS_INIT_EXPLICITLY  (0)           // If enabled, OS_InitKern() initializes Non-Zero globals. Required only for faulty compiler (or startup-code) which do not perform proper init of globals during startup.
N#endif
N
N#ifndef   OS_TASK_LIST_HAS_PPREV
N  #define OS_TASK_LIST_HAS_PPREV   OS_RR_SUPPORTED
N#else
S  #if (OS_TASK_LIST_HAS_PPREV == 0) && OS_RR_SUPPORTED
S    #error  "Invalid combination of config switches"
S  #endif
N#endif
N
N#ifndef   OS_SUPPORT_CALL_ISR
N  #define OS_SUPPORT_CALL_ISR (1)
N#endif
N
N#ifndef   OS_PREPARE_STACKPOINTER
N  #define OS_PREPARE_STACKPOINTER()
N#endif
N
N#ifndef   OS_SUPPORT_POWER
N  #define OS_SUPPORT_POWER (1)
N#endif
N
N#ifndef   OS_POWER_NUM_COUNTERS
N  #define OS_POWER_NUM_COUNTERS (5)
N#endif
N
N/*********************************************************************
N*
N*       Check Compile time switches
N*
N**********************************************************************
N*/
N
N#ifndef OS_SIZEOF_INT
S  #error "Please define OS_SIZEOF_INT (OSChip.h)"
N#endif
N#ifndef OS_BIG_ENDIAN
S  #error "Please define OS_BIG_ENDIAN (OSChip.h)"
N#endif
N
N#if (OS_STACK_AT_BOTTOM != 0) && (OS_STACK_AT_BOTTOM != 1)
X#if ((0) != 0) && ((0) != 1)
S  /*
S  *  Only 0 or 1 is allowed, because OS_STACK_AT_BOTTOM is used for calculations!
S  */
S  #error "OS_STACK_AT_BOTTOM has to be defined to 0 or 1"
N#endif
N
N/*********************************************************************
N*
N*       Basic type defines
N*
N**********************************************************************
N*/
N
N#ifndef   OS_I8
N  #define OS_I8 signed char
N#endif
N
N#ifndef   OS_U8
N  #define OS_U8 unsigned char
N#endif
N
N#ifndef   OS_I16
N  #define OS_I16 signed short
N#endif
N
N#ifndef   OS_U16
N  #define OS_U16 unsigned short
N#endif
N
N#ifndef   OS_I32
S  #define OS_I32 long
N#endif
N
N#ifndef   OS_U32
N  #define OS_U32 unsigned OS_I32
N#endif
N
N/* Defines a true integer. This type is guaranteed
N   a) to have at least 8 bits,
N   b) to compile and execute best on the target CPU
N   It will normally be the same as an int, but on most
N   8-bit CPUs it will be replaced by a character because
N   the CPU can deal with 8 bits more efficient than with
N   16 bit integers.
N   Use with care !
N*/
N#ifndef   OS_INT
N  #define OS_INT       int
N#endif
N
N#ifndef   OS_UINT
N  #define OS_UINT      unsigned OS_INT
N#endif
N
N#ifndef   OS_TIME
N  #define OS_TIME      int
N#endif
N
N
N/*********************************************************************
N*
N*       Error codes
N*
N**********************************************************************
N*/
N
N/* User 0..99  ***********************************/
N
N/* Port 100..119 *********************************/
N#define OS_ERR_ISR_INDEX                      (100)
N#define OS_ERR_ISR_VECTOR                     (101)
N#define OS_ERR_ISR_PRIO                       (102)
N
N/* OS generic ************************************/
N/* stack overflow or invalid stack */
N#define OS_ERR_STACK                          (120)
N
N/* Counting semaphore overflow */
N#define OS_ERR_CSEMA_OVERFLOW                 (121)
N
N/* Power management module */
N#define OS_ERR_POWER_OVER                     (122)
N#define OS_ERR_POWER_UNDER                    (123)
N#define OS_ERR_POWER_INDEX                    (124)
N
N
N/* invalid or non-initialized data structures */
N#define OS_ERR_INV_TASK                       (128)
N#define OS_ERR_INV_TIMER                      (129)
N#define OS_ERR_INV_MAILBOX                    (130)
N#define OS_ERR_INV_CSEMA                      (132)
N#define OS_ERR_INV_RSEMA                      (133)
N
N/* Using GetMail1 or PutMail1 or GetMailCond1 or PutMailCond1 on
N   a non-1 byte mailbox  */
N#define OS_ERR_MAILBOX_NOT1                   (135)
N
N/* Waitable objects deleted with waiting tasks or occupied by task */
N#define OS_ERR_MAILBOX_DELETE                 (136)
N#define OS_ERR_CSEMA_DELETE                   (137)
N#define OS_ERR_RSEMA_DELETE                   (138)
N
N/* internal errors, please contact SEGGER Microcontrollersysteme */
N#define OS_ERR_MAILBOX_NOT_IN_LIST            (140)
N#define OS_ERR_TASKLIST_CORRUPT               (142)
N
N/* not matching routine calls or macro usage */
N#define OS_ERR_UNUSE_BEFORE_USE               (150)
N#define OS_ERR_LEAVEREGION_BEFORE_ENTERREGION (151)
N#define OS_ERR_LEAVEINT                       (152)
N#define OS_ERR_DICNT                          (153)
N#define OS_ERR_INTERRUPT_DISABLED             (154)
N#define OS_ERR_TASK_ENDS_WITHOUT_TERMINATE    (155)
N#define OS_ERR_RESOURCE_OWNER                 (156)
N
N#define OS_ERR_ILLEGAL_IN_ISR                 (160)  /* not a legal system call during interrupt */
N#define OS_ERR_ILLEGAL_IN_TIMER               (161)  /* not a legal system call during timer */
N#define OS_ERR_ILLEGAL_OUT_ISR                (162)  /* not a legal system call outside interrupt */
N#define OS_ERR_NOT_IN_ISR                     (163)  /* OS_EnterInterrupt() has been called, but CPU is not in ISR state */
N#define OS_ERR_IN_ISR                         (164)  /* OS_EnterInterrupt() has not been called, but CPU is in ISR state */
N
N#define OS_ERR_INIT_NOT_CALLED                (165)  /* OS_InitKern() was not called */
N
N/* Double used data structures */
N#define OS_ERR_2USE_TASK                      (170)
N#define OS_ERR_2USE_TIMER                     (171)
N#define OS_ERR_2USE_MAILBOX                   (172)
N#define OS_ERR_2USE_BSEMA                     (173)
N#define OS_ERR_2USE_CSEMA                     (174)
N#define OS_ERR_2USE_RSEMA                     (175)
N#define OS_ERR_2USE_MEMF                      (176)
N
N/* Communication errors (OSCOM) */
N#define OS_ERR_NESTED_RX_INT                  (180)
N
N/* Fixed block memory pool  */
N#define OS_ERR_MEMF_INV                       (190)
N#define OS_ERR_MEMF_INV_PTR                   (191)
N#define OS_ERR_MEMF_PTR_FREE                  (192)
N#define OS_ERR_MEMF_RELEASE                   (193)
N#define OS_ERR_POOLADDR                       (194)
N#define OS_ERR_BLOCKSIZE                      (195)
N
N/* Task suspend / resume errors */
N#define OS_ERR_SUSPEND_TOO_OFTEN              (200)
N#define OS_ERR_RESUME_BEFORE_SUSPEND          (201)
N
N/* Other task related errors */
N#define OS_ERR_TASK_PRIORITY                  (202)
N
N/* Event object */
N#define OS_ERR_EVENT_INVALID                  (210)
N#define OS_ERR_2USE_EVENTOBJ                  (211)
N#define OS_ERR_EVENT_DELETE                   (212)
N
N/* Waitlist (checked build) */
N#define OS_ERR_WAITLIST_RING                  (220)
N#define OS_ERR_WAITLIST_PREV                  (221)
N#define OS_ERR_WAITLIST_NEXT                  (222)
N
N/* Other potential problems discovered in checked build */
N#define OS_ERR_NOT_IN_REGION                  (225)
N
N/* Cache related */
N#define OS_ERR_NON_ALIGNED_INVALIDATE         (230)
N
N/* OS special build, or internal */
N#define OS_ERR_TRIAL_LIMIT                    (254)
N
N/*********************************************************************
N*
N*       Trace identifier
N*
N**********************************************************************
N
NIdentifier from 0 to 99 are reserved for the OS
NEven when not all of those are currently used,
Nthey may be defined in the future
N
N*/
N
N#define OS_TRACE_ID_DEACTIVATE      (1)
N#define OS_TRACE_ID_ACTIVATE        (2)
N#define OS_TRACE_ID_TIMERCALLBACK   (3)
N
N/* Task group */
N#define OS_TRACE_ID_DELAY           (10)
N#define OS_TRACE_ID_DELAYUNTIL      (11)
N#define OS_TRACE_ID_SETPRIORITY     (12)
N#define OS_TRACE_ID_WAKETASK        (13)
N#define OS_TRACE_ID_CREATETASK      (14)
N#define OS_TRACE_ID_TERMINATETASK   (15)
N#define OS_TRACE_ID_SUSPENDTASK     (16)
N#define OS_TRACE_ID_RESUMETASK      (17)
N#define OS_TRACE_ID_CREATETASK_EX   (18)
N#define OS_TRACE_ID_YIELD           (19)
N
N/* Event group */
N#define OS_TRACE_ID_WAITEVENT       (20)
N#define OS_TRACE_ID_WAITEVENT_TIMED (21)
N#define OS_TRACE_ID_SIGNALEVENT     (22)
N#define OS_TRACE_ID_CLEAREVENTS     (23)
N
N/* Mailbox group  */
N#define OS_TRACE_ID_CREATEMB        (30)
N#define OS_TRACE_ID_CLEARMB         (31)
N#define OS_TRACE_ID_DELETEMB        (32)
N#define OS_TRACE_ID_PUTMAIL         (33)
N#define OS_TRACE_ID_GETMAIL         (34)
N#define OS_TRACE_ID_PUTMAILCOND     (35)
N#define OS_TRACE_ID_GETMAILCOND     (36)
N#define OS_TRACE_ID_PUTMAIL_TIMED   (37)
N#define OS_TRACE_ID_GETMAIL_TIMED   (38)
N#define OS_TRACE_ID_WAITMAIL        (39)
N
N#define OS_TRACE_ID_PUTMAIL1        (40)
N#define OS_TRACE_ID_GETMAIL1        (41)
N#define OS_TRACE_ID_PUTMAILCOND1    (42)
N#define OS_TRACE_ID_GETMAILCOND1    (43)
N#define OS_TRACE_ID_PUTMAIL_TIMED1  (44)
N#define OS_TRACE_ID_GETMAIL_TIMED1  (45)
N
N#define OS_TRACE_ID_PUTMAIL_F       (46)
N#define OS_TRACE_ID_PUTMAIL_F1      (47)
N#define OS_TRACE_ID_PUTMAIL_FCOND   (48)
N#define OS_TRACE_ID_PUTMAIL_FCOND1  (49)
N
N/* Resource group */
N#define OS_TRACE_ID_CREATERSEMA     (50)
N#define OS_TRACE_ID_USE             (51)
N#define OS_TRACE_ID_UNUSE           (52)
N#define OS_TRACE_ID_REQUEST         (53)
N#define OS_TRACE_ID_GETSEMAVALUE    (54)
N#define OS_TRACE_ID_DELETE_RSEMA    (55)
N
N/* Counting Semaphore group */
N#define OS_TRACE_ID_CREATECSEMA     (60)
N#define OS_TRACE_ID_DELETECSEMA     (61)
N#define OS_TRACE_ID_SIGNALCSEMA     (62)
N#define OS_TRACE_ID_WAITCSEMA       (63)
N#define OS_TRACE_ID_WAITCSEMATIMED  (64)
N#define OS_TRACE_ID_SIGNALCSEMA_MAX (65)
N#define OS_TRACE_ID_SET_CSEMAVALUE  (66)
N#define OS_TRACE_ID_CSEMAREQUEST    (67)
N
N/* Timer group    */
N#define OS_TRACE_ID_CREATETIMER     (70)
N#define OS_TRACE_ID_DELETETIMER     (71)
N#define OS_TRACE_ID_STARTTIMER      (72)
N#define OS_TRACE_ID_STOPTIMER       (73)
N#define OS_TRACE_ID_RETRIGGERTIMER  (74)
N#define OS_TRACE_ID_SETTIMERPERIOD  (75)
N#define OS_TRACE_ID_CREATETIMER_EX  (76)
N
N/* Heap type memory management  */
N#define OS_TRACE_ID_MALLOC          (80)
N#define OS_TRACE_ID_FREE            (81)
N#define OS_TRACE_ID_REALLOC         (82)
N
N/* Fixed block type memory management  */
N#define OS_TRACE_ID_MEMF_CREATE     (90)
N#define OS_TRACE_ID_MEMF_DELETE     (91)
N#define OS_TRACE_ID_MEMF_ALLOC      (92)
N
N
N/*********************************************************************
N*
N*       Assertions
N*
N**********************************************************************
N
N  Assertions are used to generate code in the debug version
N  of the OS in order catch programming faults like
N  bad pointers or uninitialized data structures
N*/
N
N#if OS_DEBUG
X#if 1
N  #define OS_ASSERT(Exp, ErrCode) { if (!(Exp)) OS_Error(ErrCode); }
N#else
S  #define OS_ASSERT(Exp, ErrCode)
N#endif
N
N#define OS_ASSERT_INT()           OS_ASSERT((OS_InInt != 0),          OS_ERR_ILLEGAL_OUT_ISR)
N#define OS_ASSERT_NOINT()         OS_ASSERT((OS_InInt == 0),          OS_ERR_ILLEGAL_IN_ISR)
N#define OS_ASSERT_NOTIMER()       OS_ASSERT((OS_InTimer == 0),        OS_ERR_ILLEGAL_IN_TIMER)
N#define OS_ASSERT_DICnt()         OS_ASSERT(((OS_DICnt & 0xf0) == 0), OS_ERR_DICNT)
N#define OS_ASSERT_INIT_CALLED()   OS_ASSERT((OS_InitCalled != 0),     OS_ERR_INIT_NOT_CALLED)
N
N/*********************************************************************
N*
N*       Memory attributes
N*
N**********************************************************************
N*/
N
N#ifndef OS_STACKPTR
N  #define OS_STACKPTR
N#endif
N
N#ifndef OS_SADDR
N  #ifdef SADDR
S    #define OS_SADDR SADDR
N  #else
N    #define OS_SADDR
N  #endif
N#endif
N
N/* pointer modifier for data items */
N#ifndef OS_DATAPTR
N  #define OS_DATAPTR
N#endif
N
N#ifndef OS_RSEMAPTR
N  #define OS_RSEMAPTR
N#endif
N
N#ifndef   OS_CSEMAPTR
N  #define OS_CSEMAPTR
N#endif
N
N#ifndef   OS_MBPTR
N  #define OS_MBPTR
N#endif
N
N#ifndef   OS_TCBPTR
N  #define OS_TCBPTR
N#endif
N
N#ifndef   OS_TIMERPTR
N  #define OS_TIMERPTR
N#endif
N
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N/*********************************************************************
N*
N*       Data structures
N*
N**********************************************************************
N*/
N
Ntypedef struct OS_TASK         OS_TASK;
Ntypedef struct OS_WAIT_LIST    OS_WAIT_LIST;
Ntypedef struct OS_WAIT_OBJ     OS_WAIT_OBJ;
Ntypedef struct OS_WAIT_OBJ_EX  OS_WAIT_OBJ_EX;
Ntypedef struct OS_REGS         OS_REGS;
N
Ntypedef void voidRoutine(void);
Ntypedef void OS_RX_CALLBACK(OS_U8 Data);
Xtypedef void OS_RX_CALLBACK(unsigned char Data);
Ntypedef void OS_TIMERROUTINE(void);
Ntypedef void OS_TIMER_EX_ROUTINE(void *);
Ntypedef void OS_ON_TERMINATE_FUNC(OS_TASK *);
N
Ntypedef void OS_TICK_HOOK_ROUTINE(void);
N
N/**********************************************************************
N*
N*       OS_WAIT_OBJ
N*       OS_WAIT_LIST
N*       OS_WAIT_OBJ_EX
N*/
Nstruct OS_WAIT_OBJ {
N  OS_WAIT_LIST * pWaitList;
N};
N
Nstruct OS_WAIT_OBJ_EX {
N  OS_WAIT_OBJ WaitObj;
N  int v;
N};
N
Nstruct OS_WAIT_LIST {
N  OS_WAIT_LIST * pNext;    /* Needs to be first element ! */
N  OS_WAIT_LIST * pPrev;
N  OS_WAIT_OBJ  * pWaitObj;
N  OS_TASK      * pTask;
N};
N
N
N/**********************************************************************
N*
N*       OS_EXTEND_TASK_CONTEXT
N*
N*  This structure is used to define a save and restore function for
N*  extension of the task context.
N*  A pointer to this structure is part of the task control block
N*  It is initialized by OS_ExtendTaskContext();
N*/
Ntypedef struct OS_EXTEND_TASK_CONTEXT {
N  void (*pfSave)   (      void * pStack);
N  void (*pfRestore)(const void * pStack);
N} OS_EXTEND_TASK_CONTEXT;
N
N
N/**********************************************************************
N*
N*       OS_TASK
N*
N*  This structure (referred to as "task control block" or TCB) holds all relevant information
N*  about a single task. Note that some elements are optional, depending on the compile time
N*  options, especially the type of build
N*/
Nstruct OS_TASK {
N  //
N  // Elements required for all builds
N  //
N  // Start of assembly relevant section. Do not move these elements
N  OS_TASK * pNext;                        // Points to the TCB of the next task in the list (with equal or lower priority). Needs to be first element !
N  OS_REGS OS_STACKPTR * pStack;           // Typically contains the stack pointer if the task is suspended.                 Needs to be second element !
X  OS_REGS  * pStack;           
N  // End of assembly relevant section
N  OS_WAIT_LIST * pWaitList;               // Points to a waitable object if task is suspended.
N  OS_TIME        Timeout;
X  int        Timeout;
N  OS_U8          Priority;
X  unsigned char          Priority;
N  OS_U8          Stat;
X  unsigned char          Stat;
N  OS_U8          Events;                  // Event storage
X  unsigned char          Events;                  
N  OS_U8          EventMask;               // Event mask
X  unsigned char          EventMask;               
N  //
N  // PPrev is required only in builds with doubly-linked task lists
N  //
N  #if OS_TASK_LIST_HAS_PPREV
X  #if (1)
N    OS_TASK      * pPrev;                   //
N  #endif
N  //
N  // Elements required with "Track-name" functionality only. Typically available in all builds, but can be disabled at compile time
N  //
N  #if OS_TRACKNAME
X  #if (1)
N    const char * Name;
N  #endif
N  //
N  // Elements required with "Stack-check" functionality only. Available in stack-check and debug builds.
N  //
N  #if OS_CHECKSTACK
X  #if 1
N    OS_UINT  StackSize;            // Stack size in bytes. Not required for functionality, just for analysis
X    unsigned int  StackSize;            
N    OS_U8 OS_STACKPTR* pStackBot;  // First byte of stack. Not required for functionality, just for analysis
X    unsigned char * pStackBot;  
N  #endif
N  //
N  // Elements required with profiling or debug builds
N  //
N  #if (OS_PROFILE || OS_DEBUG)
X  #if (1 || 1)
N    OS_U32 NumActivations;         // Counts how many times task has been activated
X    unsigned int NumActivations;         
N    OS_U32 NumPreemptions;         // Counts how many times task has been preempted
X    unsigned int NumPreemptions;         
N  #endif
N  //
N  // Elements required with profiling builds
N  //
N  #if OS_PROFILE
X  #if 1
N    OS_U32 ExecTotal;              // Time spent executing
X    unsigned int ExecTotal;              
N    OS_U32 ExecLast;               // Time spent executing (Reference)
X    unsigned int ExecLast;               
N    OS_U32 Load;                   // Profiling builds only:
X    unsigned int Load;                   
N  #endif
N  //
N  // Elements required with Round-robin functionality only. Typically available in all builds, but can be disabled at compile time
N  //
N  #if OS_RR_SUPPORTED
X  #if (1)
N    OS_U8  TimeSliceRem;
X    unsigned char  TimeSliceRem;
N    OS_U8  TimeSliceReload;
X    unsigned char  TimeSliceReload;
N  #endif
N  //
N  // Optional Save & Restore hook support (usually only for bigger CPUs)
N  //
N  #if OS_SUPPORT_SAVE_RESTORE_HOOK
X  #if (1)
N    const OS_EXTEND_TASK_CONTEXT * pExtendContext;
N  #endif
N  //
N  // Elements required with debug builds
N  //
N  #if OS_DEBUG
X  #if 1
N    char Id;                       // Debug builds only: Id of this control block.
N  #endif
N  //
N  // Allow port specific extension to the task control block. Not used in most ports
N  //
N  #ifdef OS_TCB_CPU_EX
S    OS_TCB_CPU_EX
N  #endif
N};
N
N/**********************************************************************
N*
N*       OS_TIMER
N*/
Ntypedef struct OS_timer OS_TIMER;
Nstruct OS_timer {
N  OS_TIMER * pNext;
N  voidRoutine* Hook;
N  OS_TIME Time;
X  int Time;
N  OS_TIME Period;
X  int Period;
N  char    Active;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_TIMER_EX
N*/
Ntypedef struct {
N  OS_TIMER Timer;
N  OS_TIMER_EX_ROUTINE * pfUser;
N  void * pData;
N} OS_TIMER_EX;
N
N/**********************************************************************
N*
N*       OS_TICK_HOOK
N*/
Ntypedef struct OS_TICK_HOOK OS_TICK_HOOK;
Nstruct OS_TICK_HOOK {
N  OS_TICK_HOOK*          pNext;
N  OS_TICK_HOOK_ROUTINE * pfUser;
N};
N
N/**********************************************************************
N*
N*       OS_RSEMA
N*/
Ntypedef struct OS_RSEMA OS_RSEMA;
Nstruct OS_RSEMA {
N  OS_WAIT_OBJ WaitObj;
N  OS_TASK * pTask;                /* Owner */
N  OS_U8 UseCnt;
X  unsigned char UseCnt;
N  OS_RSEMA * pNext;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_CSEMA
N*/
Ntypedef struct OS_CSEMA OS_CSEMA;
Nstruct OS_CSEMA {
N  OS_WAIT_OBJ WaitObj;
N  OS_UINT Cnt;
X  unsigned int Cnt;
N#if OS_DEBUG
X#if 1
N  OS_CSEMA * pNext;
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_MAILBOX
N*/
Ntypedef struct OS_MAILBOX OS_MAILBOX;
Nstruct OS_MAILBOX {
N  OS_WAIT_OBJ WaitObj;
N#if OS_LINK_MAILBOXES
X#if (1)
N  OS_MAILBOX * pNext;
N#endif
N  char *pData;
N  OS_UINT nofMsg;
X  unsigned int nofMsg;
N  OS_UINT maxMsg;
X  unsigned int maxMsg;
N  OS_UINT iRd;
X  unsigned int iRd;
N  OS_U8  sizeofMsg;
X  unsigned char  sizeofMsg;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_Q
N*/
Ntypedef struct OS_Q OS_Q;
Nstruct OS_Q {
N  OS_WAIT_OBJ WaitObj;
N  OS_Q*    pNext;          /* ptr to next queue (for debugging / monitoring) */
N  OS_U8*   pData;
X  unsigned char*   pData;
N  OS_UINT  Size;
X  unsigned int  Size;
N  OS_UINT  MsgCnt;
X  unsigned int  MsgCnt;
N  OS_UINT  offFirst;
X  unsigned int  offFirst;
N  OS_UINT  offLast;
X  unsigned int  offLast;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_MEMF
N*/
N#ifndef   OS_MEMF_MAX_ITEMS
N  #define OS_MEMF_MAX_ITEMS 20
N#endif
N
N#define OS_MEMF_SIZEOF_BLOCKCONTROL 0  /* sizeof(int) in future version for debugging */
N
Ntypedef struct OS_MEMF OS_MEMF;
Nstruct OS_MEMF {
N  OS_WAIT_OBJ WaitObj;
N  OS_MEMF* pNext;          /* ptr to next memory pool */
N  void*    pPool;
N  OS_U16   NumBlocks;
X  unsigned short   NumBlocks;
N  OS_U16   BlockSize;
X  unsigned short   BlockSize;
N  OS_U16   NumFreeBlocks;
X  unsigned short   NumFreeBlocks;
N  OS_U16   MaxUsed;
X  unsigned short   MaxUsed;
N  void*    pFree;
N  #if OS_DEBUG
X  #if 1
N    int  aiPurpose[OS_MEMF_MAX_ITEMS];
X    int  aiPurpose[20];
N    char Id;
N  #endif
N};
N
N/**********************************************************************
N*
N*       OS_EVENT
N*/
Ntypedef struct  OS_EVENT OS_EVENT;
N
Nstruct OS_EVENT {
N  OS_WAIT_OBJ WaitObj;
N  OS_U8       Signaled;
X  unsigned char       Signaled;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_TRACE_ENTRY
N*/
Ntypedef struct {
N  OS_U32  Time;
X  unsigned int  Time;
N  void    *pCurrentTask;
N  void    *p;
N  OS_U32  v;
X  unsigned int  v;
N  OS_U8   iRout;
X  unsigned char   iRout;
N} OS_TRACE_ENTRY;
N
N
N/*********************************************************************
N*
N*       Globals
N*
N**********************************************************************
N*/
N
N/*
N    Handle DEFinition (storage is actually allocted) versus DEClaration
N    (reference) of RTOS variables depending upon who includes this header file.
N*/
N#ifdef __OSGLOBAL_C__
S  #define OS_EXTERN        /* Declare variables if included by RTOSKERN.C */
S  #define OS_EXTERN_INIT(Var, Val) Var=Val
N#else
N  #define OS_EXTERN extern /* Define variables if included by anyone else */
N  #define OS_EXTERN_INIT(Var, Val) Var
N#endif
N
N/*****  Mark start of memory pragma area ****************************/
N
N/* Some compilers can not deal with memory attributes and need pragmas */
N#if defined(__ghs_zda)
X#if 0L
S  #pragma ghs startzda
N#endif
N
N/********************************************************************/
N
Ntypedef union {
N  int Dummy;            // Make sure a full integer (32 bit on 32 bit CPUs) is used.
N  struct {
N    OS_U8 Region;
X    unsigned char Region;
N    OS_U8 DI;
X    unsigned char DI;
N  } Cnt;
N} OS_COUNTERS;
N
N
N#if OS_COMPILER_STORAGE_MODIFIER_LEFT  /* default */
X#if 1   
N  OS_EXTERN OS_SADDR  volatile OS_I32 OS_Time;
X  extern   volatile int OS_Time;
N  OS_EXTERN OS_SADDR  OS_TIME         OS_EXTERN_INIT(OS_TimeDex, 16384);
X  extern   int         OS_TimeDex;
N  OS_EXTERN OS_SADDR  OS_COUNTERS OS_Counters;
X  extern   OS_COUNTERS OS_Counters;
N
N  OS_EXTERN OS_SADDR  OS_U8  OS_EXTERN_INIT(OS_IntMSInc, 1);
X  extern   unsigned char  OS_IntMSInc;
N  OS_EXTERN OS_SADDR  OS_U8  OS_Pending;
X  extern   unsigned char  OS_Pending;
N  OS_EXTERN OS_SADDR  volatile OS_U8  OS_Status;
X  extern   volatile unsigned char  OS_Status;
N
N  #if OS_RR_SUPPORTED
X  #if (1)
N    OS_EXTERN OS_SADDR  OS_U8  OS_TimeSlice;
X    extern   unsigned char  OS_TimeSlice;
N    OS_EXTERN OS_SADDR  OS_U8  OS_TimeSliceAtStart;
X    extern   unsigned char  OS_TimeSliceAtStart;
N  #endif
N  #if OS_SUPPORT_TICKSTEP
X  #if 1
N    OS_EXTERN OS_SADDR  volatile OS_U8   OS_TickStep;
X    extern   volatile unsigned char   OS_TickStep;
N    OS_EXTERN OS_SADDR  volatile int     OS_TickStepTime;
X    extern   volatile int     OS_TickStepTime;
N  #endif
N  OS_EXTERN OS_SADDR        OS_UINT OS_TicksPerMS;
X  extern         unsigned int OS_TicksPerMS;
N  OS_EXTERN OS_SADDR        int     OS_IntTicksInc;
X  extern         int     OS_IntTicksInc;
N  #if OS_PROFILE
X  #if 1
N    OS_EXTERN OS_SADDR OS_U32 OS_TS_ExecStart;
X    extern  unsigned int OS_TS_ExecStart;
N    OS_EXTERN OS_SADDR OS_U8  ProfilingOn;
X    extern  unsigned char  ProfilingOn;
N  #endif
N  #if OS_DEBUG
X  #if 1
N    OS_EXTERN OS_SADDR OS_U8 OS_InInt;
X    extern  unsigned char OS_InInt;
N    OS_EXTERN OS_SADDR OS_U8 OS_InTimer;
X    extern  unsigned char OS_InTimer;
N    OS_EXTERN OS_SADDR OS_U8 OS_InitCalled;
X    extern  unsigned char OS_InitCalled;
N  #endif
N
N  #if OS_SUPPORT_POWER
X  #if (1)
N    OS_EXTERN OS_SADDR OS_U8 OS_POWER_Levels[OS_POWER_NUM_COUNTERS];
X    extern  unsigned char OS_POWER_Levels[(5)];
N  #endif
N
N  /*** Pointers ***
N    Unfortunately there is no real standard on how to define/declare
N    pointers properly with extended memory attributes. There are
N    currently 2 different standards, which we both support.
N  */
N  #if OS_COMPILER_LOCATION_LEFT
X  #if 1
N    OS_EXTERN OS_SADDR  OS_TASK      * OS_pTask;             /* linked list of all Tasks */
X    extern   OS_TASK      * OS_pTask;              
N    OS_EXTERN OS_SADDR  OS_TASK      * OS_pCurrentTask;      /* pointer to current Task */
X    extern   OS_TASK      * OS_pCurrentTask;       
N    OS_EXTERN OS_SADDR  OS_TASK volatile * volatile OS_pActiveTask;
X    extern   OS_TASK volatile * volatile OS_pActiveTask;
N    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pTimer;            /* linked list of all active Timers */
X    extern   OS_TIMER     * OS_pTimer;             
N    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pCurrentTimer;     /* Actual expired timer which called callback */
X    extern   OS_TIMER     * OS_pCurrentTimer;      
N    OS_EXTERN OS_SADDR OS_RSEMA      * OS_pRSema;
X    extern  OS_RSEMA      * OS_pRSema;
N    #if OS_LINK_MAILBOXES
X    #if (1)
N      OS_EXTERN OS_SADDR OS_MAILBOX  * OS_pMailbox;
X      extern  OS_MAILBOX  * OS_pMailbox;
N    #endif
N    #if OS_DEBUG
X    #if 1
N      OS_EXTERN OS_SADDR OS_CSEMA    * OS_pCSema;
X      extern  OS_CSEMA    * OS_pCSema;
N    #endif
N    OS_EXTERN   OS_SADDR OS_MEMF      * OS_pMEMF;            /* linked list of all fixed size memory pools */
X    extern    OS_MEMF      * OS_pMEMF;             
N    OS_EXTERN   OS_SADDR OS_TICK_HOOK * OS_pTickHook;        /* linked list of all tick hook functions */
X    extern    OS_TICK_HOOK * OS_pTickHook;         
N  #else
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pTask;          /* linked list of all Tasks */
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pCurrentTask;   /* pointer to current Task */
S    OS_EXTERN OS_TASK    volatile * OS_SADDR volatile OS_pActiveTask;
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pTimer;         /* linked list of all active Timers */
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pCurrentTimer;  /* Actual expired timer which called callback */
S    OS_EXTERN OS_RSEMA            * OS_SADDR OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_MAILBOX        * OS_SADDR OS_pMailbox;
S    #endif
S
S    #if OS_DEBUG
S      OS_EXTERN  OS_CSEMA         * OS_SADDR OS_pCSema;
S    #endif
S    OS_EXTERN OS_MEMF             * OS_SADDR OS_pMEMF;          /* linked list of all fixed size memory pools */
S    OS_EXTERN OS_TICK_HOOK        * OS_SADDR OS_pTickHook;      /* linked list of all tick hook functions */
N  #endif
N
N#else  /*  OS_COMPILER_STORAGE_MODIFIER_LEFT == 0, needed for Keil 166 */
S  OS_EXTERN volatile OS_I32 OS_SADDR OS_Time;
S  OS_EXTERN OS_TIME         OS_SADDR OS_EXTERN_INIT(OS_TimeDex, 16384);
S  OS_EXTERN OS_COUNTERS OS_SADDR OS_Counters;
S
S  OS_EXTERN OS_U8 OS_SADDR OS_EXTERN_INIT(OS_IntMSInc, 1);
S  OS_EXTERN OS_U8 OS_SADDR OS_Pending;
S  OS_EXTERN volatile OS_U8 OS_SADDR OS_Status;
S  #if OS_RR_SUPPORTED
S    OS_EXTERN OS_U8 OS_SADDR OS_TimeSlice;
S    OS_EXTERN OS_U8 OS_SADDR OS_TimeSliceAtStart;
S  #endif
S  #if OS_SUPPORT_TICKSTEP
S    OS_EXTERN volatile OS_U8 OS_SADDR OS_TickStep;
S    OS_EXTERN volatile int   OS_SADDR OS_TickStepTime;
S  #endif
S  OS_EXTERN OS_UINT OS_SADDR OS_TicksPerMS;
S  OS_EXTERN int     OS_SADDR OS_IntTicksInc;
S  #if OS_PROFILE
S    OS_EXTERN OS_U32 OS_SADDR OS_TS_ExecStart;
S    OS_EXTERN OS_U8  OS_SADDR ProfilingOn;
S  #endif
S  #if OS_DEBUG
S    OS_EXTERN OS_U8 OS_SADDR OS_InInt;
S    OS_EXTERN OS_U8 OS_SADDR OS_InTimer;
S    OS_EXTERN OS_U8 OS_SADDR OS_InitCalled;
S  #endif
S
S  #if OS_SUPPORT_POWER
S    OS_EXTERN OS_U8 OS_SADDR OS_POWER_Levels[OS_POWER_NUM_COUNTERS];
S  #endif
S
S  /*** Pointers ***
S    Unfortunately there is no real standard on how to define/declare
S    pointers properly with extended memory attributes. There are
S    currently 2 different standards, which we both support.
S  */
S  #if OS_COMPILER_LOCATION_LEFT
S    OS_EXTERN OS_SADDR  OS_TASK      * OS_pTask;             /* linked list of all Tasks */
S    OS_EXTERN OS_SADDR  OS_TASK      * OS_pCurrentTask;      /* pointer to current Task */
S    OS_EXTERN OS_SADDR  OS_TASK volatile * volatile OS_pActiveTask;
S    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pTimer;            /* linked list of all active Timers */
S    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pCurrentTimer;     /* Actual expired timer which called callback */
S    OS_EXTERN OS_SADDR OS_RSEMA      * OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_SADDR OS_MAILBOX  * OS_pMailbox;
S    #endif
S    #if OS_DEBUG
S      OS_EXTERN OS_SADDR OS_CSEMA    * OS_pCSema;
S    #endif
S      OS_EXTERN OS_SADDR OS_MEMF      * OS_pMEMF;            /* linked list of all fixed size memory pools */
S      OS_EXTERN OS_SADDR OS_TICK_HOOK * OS_pTickHook;        /* linked list of all tick hook functions */
S
S  #else
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pTask;          /* linked list of all Tasks */
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pCurrentTask;   /* pointer to current Task */
S    OS_EXTERN OS_TASK    volatile * volatile OS_SADDR OS_pActiveTask;
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pTimer;         /* linked list of all active Timers */
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pCurrentTimer;  /* Actual expired timer which called callback */
S    OS_EXTERN OS_RSEMA            * OS_SADDR OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_MAILBOX        * OS_SADDR OS_pMailbox;
S    #endif
S    #if OS_DEBUG
S      OS_EXTERN OS_CSEMA          * OS_SADDR OS_pCSema;
S    #endif
S
S    OS_EXTERN OS_MEMF             * OS_SADDR OS_pMEMF;          /* linked list of all fixed size memory pools */
S    OS_EXTERN OS_TICK_HOOK        * OS_SADDR OS_pTickHook;      /* linked list of all tick hook functions */
S  #endif
S
N#endif  /*  OS_COMPILER_STORAGE_MODIFIER_LEFT  */
N
N/***** Mark end of memory pragma area *******************************/
N#if defined(__ghs_zda)
X#if 0L
S  #pragma ghs endzda
N#endif
N
N/********************************************************************/
N
N#define OS_RegionCnt OS_Counters.Cnt.Region
N#define OS_DICnt     OS_Counters.Cnt.DI
N
N/*********************************************************************
N*
N*       OS_CREATETASK macro
N*       OS_CREATETASK_EX macro
N*/
N#if OS_RR_SUPPORTED
X#if (1)
N  #define CTPARA_TIMESLICE ,2
N#else
S  #define CTPARA_TIMESLICE
N#endif
N
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack) \
N  OS_CreateTask (pTask,                                      \
N                  Name,                                      \
N                  Priority,                                  \
N                  Hook,                                      \
N                  (void OS_STACKPTR*)pStack,                 \
N                  sizeof(pStack)                             \
N                  CTPARA_TIMESLICE                           \
N               )
X  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack)   OS_CreateTask (pTask,                                                        Name,                                                        Priority,                                                    Hook,                                                        (void OS_STACKPTR*)pStack,                                   sizeof(pStack)                                               CTPARA_TIMESLICE                                          )
N#else
S  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack) \
S  OS_CreateTask (pTask,                                      \
S                  Priority,                                  \
S                  Hook,                                      \
S                  (void OS_STACKPTR*)pStack,                 \
S                  sizeof(pStack)                             \
S                  CTPARA_TIMESLICE                           \
S               )
X  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack)   OS_CreateTask (pTask,                                                        Priority,                                                    Hook,                                                        (void OS_STACKPTR*)pStack,                                   sizeof(pStack)                                               CTPARA_TIMESLICE                                          )
N#endif
N
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext) \
N  OS_CreateTaskEx  (pTask,                                                \
N                    Name,                                                 \
N                    Priority,                                             \
N                    Hook,                                                 \
N                    (void OS_STACKPTR*)pStack,                            \
N                    sizeof(pStack)                                        \
N                    CTPARA_TIMESLICE,                                     \
N                    pContext                                              \
N               )
X  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext)   OS_CreateTaskEx  (pTask,                                                                    Name,                                                                     Priority,                                                                 Hook,                                                                     (void OS_STACKPTR*)pStack,                                                sizeof(pStack)                                                            CTPARA_TIMESLICE,                                                         pContext                                                             )
N#else
S  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext) \
S  OS_CreateTaskEx  (pTask,                                                \
S                    Priority,                                             \
S                    Hook,                                                 \
S                    (void OS_STACKPTR*)pStack,                            \
S                    sizeof(pStack)                                        \
S                    CTPARA_TIMESLICE,                                     \
S                    pContext                                              \
S               )
X  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext)   OS_CreateTaskEx  (pTask,                                                                    Priority,                                                                 Hook,                                                                     (void OS_STACKPTR*)pStack,                                                sizeof(pStack)                                                            CTPARA_TIMESLICE,                                                         pContext                                                             )
N#endif
N
N/*********************************************************************
N*
N*       OS_CreateTask
N*       OS_CreateTaskEx
N*/
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATE_TASK_PARA_NAME      const char*Name,
N#else
S  #define OS_CREATE_TASK_PARA_NAME
N#endif
N
N#if OS_RR_SUPPORTED
X#if (1)
N  #define OS_CREATE_TASK_PARA_TS   ,OS_UINT TimeSlice
N#else
S  #define OS_CREATE_TASK_PARA_TS
N#endif
N
Nvoid OS_CreateTask  ( OS_TASK * pTask,
Xvoid OS_CreateTask_DP  ( OS_TASK * pTask,
N                      OS_CREATE_TASK_PARA_NAME
X                      const char*Name,
N                      OS_U8 Priority,
X                      unsigned char Priority,
N                      void (*pRoutine)(void),
N                      void OS_STACKPTR *pStack,
X                      void  *pStack,
N                      OS_UINT StackSize
X                      unsigned int StackSize
N                      OS_CREATE_TASK_PARA_TS
X                      ,unsigned int TimeSlice
N        );
Nvoid OS_CreateTaskEx  ( OS_TASK * pTask,
Xvoid OS_CreateTaskEx_DP  ( OS_TASK * pTask,
N                        OS_CREATE_TASK_PARA_NAME
X                        const char*Name,
N                        OS_U8 Priority,
X                        unsigned char Priority,
N                        void (*pRoutine)(void *),
N                        void OS_STACKPTR *pStack,
X                        void  *pStack,
N                        OS_UINT StackSize
X                        unsigned int StackSize
N                        OS_CREATE_TASK_PARA_TS,
X                        ,unsigned int TimeSlice,
N                        void * pContext
N        );
N#if OS_SUPPORT_SAVE_RESTORE_HOOK
X#if (1)
Nvoid OS_ExtendTaskContext(const OS_EXTEND_TASK_CONTEXT * pExtendContext);
N#endif
N/*********************************************************************
N*
N*       Task related routines
N*
N**********************************************************************
N*/
N
Nvoid  OS_Delay(OS_TIME ms);                /* OSKern.c              */
Xvoid  OS_Delay(int ms);                 
Nvoid  OS_DelayUntil(OS_TIME t);            /* OSKern.c              */
Xvoid  OS_DelayUntil(int t);             
NOS_U8 OS_GetSuspendCnt  (OS_TASK* pTask);  /* OS_GetSuspendCnt.c    */
Xunsigned char OS_GetSuspendCnt  (OS_TASK* pTask);   
Nvoid  OS_GetState       (OS_TASK* pTask);
Nchar  OS_IsTask         (OS_TASK* pTask);  /* OSIsTask.c            */
Nvoid  OS_Resume         (OS_TASK* pTask);  /* OS_Suspend.c          */
Nvoid  OS_SetTaskName    (OS_TASK * pTask, const char* s);
Nvoid  OS_SetPriority    (OS_TASK* pTask, OS_U8 Prio); /* OSSetP.c   */
Xvoid  OS_SetPriority    (OS_TASK* pTask, unsigned char Prio);  
Nvoid  OS_Suspend        (OS_TASK* pTask);  /* OS_Suspend.c          */
Nvoid  OS_Terminate      (OS_TASK* pTask);  /* OSTerm.c              */
Nvoid  OS_TerminateError (void);            /* OSTermE.c             */
Nvoid  OS_WakeTask       (OS_TASK* pTask);  /* OSWake.c              */
Nvoid  OS_Yield          (void);            /* OS_Yield              */
N
N#if OS_SUSPEND_TASK_ON_TERMINATE           /* Set task state of a terminated task to "suspended" */
X#if (0)            
S  #define OS_SUSPEND_TERMINATED_TASK(pTask) (pTask->Stat = 0x01)
N#else
N  #define OS_SUSPEND_TERMINATED_TASK(pTask)
N#endif
N
N/*********************************************************************
N*
N*       Info routines (OSInfo.c)
N*
N**********************************************************************
N*/
N
Nconst char* OS_GetCPU(void);
Nconst char* OS_GetLibMode(void);
Nconst char* OS_GetModel(void);
Nconst char* OS_GetLibName(void);
N
NOS_UINT OS_GetVersion(void);
Xunsigned int OS_GetVersion(void);
N#define OS_GetType() OS_GetLibMode()
N
N#define OS_TASKID OS_TASK *
N#define OS_GetTaskID() OS_pCurrentTask
N
N#define OS_GetpCurrentTask()    OS_pCurrentTask
N#define OS_GetpCurrentTimer()   OS_pCurrentTimer
N#define OS_GetpCurrentTimerEx() ((OS_TIMER_EX*)OS_pCurrentTimer)
N
N#if OS_TRACKNAME
X#if (1)
N  const char* OS_GetTaskName(OS_TASK *);
N#else
S  #define OS_GetTaskName(pt)  ("n/a")
N#endif
N
N#if OS_CHECKSTACK
X#if 1
N  void OS_CheckStack(void);              /* internal usage */
N  int  OS_GetStackSpace(OS_TASK * pTask);
N  int  OS_GetStackUsed (OS_TASK * pTask);
N  int  OS_GetStackSize (OS_TASK OS_TCBPTR * pTask);
X  int  OS_GetStackSize (OS_TASK  * pTask);
N  void OS_STACKPTR* OS_GetStackBase(OS_TASK OS_TCBPTR *pTask);
X  void * OS_GetStackBase(OS_TASK  *pTask);
N#else
S  #define OS_CheckStack()
S  #define OS_GetStackSpace(pt) 0
S  #define OS_GetStackUsed(pt)  0
S  #define OS_GetStackSize(pt)  0
S  #define OS_GetStackBase(pt)  0
N#endif
N
NOS_STACK_ADR OS_GetSysStackBase(void);  /* RTOS asm part */
Xunsigned int OS_GetSysStackBase(void);   
Nunsigned int OS_GetSysStackSize(void);  /* RTOS asm part */
NOS_STACK_ADR OS_GetIntStackBase(void);  /* RTOS asm part */
Xunsigned int OS_GetIntStackBase(void);   
Nunsigned int OS_GetIntStackSize(void);  /* RTOS asm part */
N
N#if OS_RR_SUPPORTED
X#if (1)
N  OS_U8 OS_SetTimeSlice(OS_TASK * pTask, OS_U8 TimeSlice);
X  unsigned char OS_SetTimeSlice(OS_TASK * pTask, unsigned char TimeSlice);
N  OS_U8 OS_GetTimeSliceRem(OS_TASK OS_TCBPTR * pTask);
X  unsigned char OS_GetTimeSliceRem(OS_TASK  * pTask);
N  #define OS_GetTimeSliceReload(pTask)  pTask->TimeSliceReload
N#else
S  #define OS_GetTimeSliceRem(pTask)     0
S  #define OS_GetTimeSliceReload(pTask)  0
N#endif
N
NOS_U8    OS_GetPriority(OS_TASK * pTask);  /* OS_GetPrio.c       */
Xunsigned char    OS_GetPriority(OS_TASK * pTask);   
N#define OS_GET_PRIORITY(pt) pt->Priority
N
Nint     OS_GetNumTasks(void);              /* OS_GetNumTasks.c   */
N
NOS_TASK* OS_TaskIndex2Ptr(int TaskIndex);  /* OS_TaskIndex2Ptr.c */
N
N#if OS_PROFILE >=1
X#if 1 >=1
N  OS_U32 OS_STAT_GetExecTime_Cycles (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetExecTime_Cycles (OS_TASK *pTask);   
N  int    OS_STAT_GetLoad            (OS_TASK *pTask);  /* OSStatGL.c */
N  void   OS_STAT_NotifyReadyStart   (OS_TASK *pTask);  /* OSStat.c   */
N  void   OS_STAT_Sample(void);                         /* OSStat.c   */
N#else
S  #define OS_STAT_NotifyExecEnd()
S  #define OS_STAT_GetExecTime_Cycles(pTask)   0
S  #define OS_STAT_GetLoad(pTask)              0
S  #define OS_STAT_Sample()
S  #define OS_STAT_SetClocksPerUnit(ClocksPerUnit)
S  #define OS_STAT_NOTIFYREADYSTART(pTask)
N#endif
N
N
N#if ((OS_PROFILE >= 1) || (OS_DEBUG > 0))  /* Also available in Debug build since V3.32b */
X#if ((1 >= 1) || (1 > 0))   
N  OS_U32 OS_STAT_GetNumActivations  (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetNumActivations  (OS_TASK *pTask);   
N  OS_U32 OS_STAT_GetNumPreemptions  (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetNumPreemptions  (OS_TASK *pTask);   
N#else
S  #define OS_STAT_GetNumActivations(pTask)    0
S  #define OS_STAT_GetNumPreemptions(pTask)    0
N#endif
N
N/*********************************************************************
N*
N*       Size info routines (OS_GetSize.c)
N*
N**********************************************************************
N*/
N
Nint OS_WAIT_OBJ_GetSize(void);
Nint OS_WAIT_OBJ_EX_GetSize(void);
Nint OS_WAIT_LIST_GetSize(void);
Nint OS_EXTEND_TASK_CONTEXT_GetSize(void);
Nint OS_TASK_GetSize(void);
Nint OS_REGS_GetSize(void);
Nint OS_TIMER_GetSize(void);
Nint OS_TIMER_EX_GetSize(void);
Nint OS_TICK_HOOK_GetSize(void);
Nint OS_RSEMA_GetSize(void);
Nint OS_CSEMA_GetSize(void);
Nint OS_MAILBOX_GetSize(void);
Nint OS_Q_GetSize(void);
Nint OS_MEMF_GetSize(void);
Nint OS_EVENT_GetSize(void);
Nint OS_TRACE_ENTRY_GetSize(void);
N
N/*********************************************************************
N*
N*       Critical regions (OsKern.c)
N*
N**********************************************************************
N*/
N
N#define OS_EnterRegion() {OS_RegionCnt++; }
Nvoid OS_LeaveRegion(void);
N
N/* Macro for OS_Leaveregion.
N   Main purposes:
N   - Used in OS-Kernel
N   - Offers the high speed variant (macro) instead of the function call
N*/
N
N#define OS_LEAVEREGION_STD()        \
N  if (--OS_RegionCnt == 0) {        \
N    OS_DI();                        \
N    if (OS_Pending) {               \
N      OS_RegionCnt = 1;             \
N      OS_Switch();                  \
N      OS_RegionCnt = 0;             \
N    }                               \
N    OS_RESTORE_I();                 \
N  }
X#define OS_LEAVEREGION_STD()          if (--OS_RegionCnt == 0) {            OS_DI();                            if (OS_Pending) {                     OS_RegionCnt = 1;                   OS_Switch();                        OS_RegionCnt = 0;                 }                                   OS_RESTORE_I();                   }
N
N#if OS_DEBUG
X#if 1
N #define OS_LEAVEREGION() \
N   if (!OS_RegionCnt) OS_Error(OS_ERR_LEAVEREGION_BEFORE_ENTERREGION); \
N   OS_LEAVEREGION_STD()
X #define OS_LEAVEREGION()    if (!OS_RegionCnt) OS_Error(OS_ERR_LEAVEREGION_BEFORE_ENTERREGION);    OS_LEAVEREGION_STD()
N#else
S  #define OS_LEAVEREGION()  OS_LEAVEREGION_STD()
N#endif
N
N/*********************************************************************
N*
N*       Interrupt save/disable/restore macros
N*
N**********************************************************************
N*/
N#define OS_IncDI()       { OS_ASSERT_DICnt(); OS_DI(); OS_DICnt++; }
N#define OS_DecRI()       { OS_ASSERT_DICnt(); if (--OS_DICnt==0) OS_EI(); }
N#define OS_RESTORE_I()   { OS_ASSERT_DICnt(); if (OS_DICnt==0)   OS_EI(); }
N
Nvoid OS_RestoreI(void);  /* OS_Kern.c */
N
N/*********************************************************************
N*
N*       ISR (Interrupt service routine) support
N*
N**********************************************************************
N*/
N
N#define RTOS_PPENDING           (1)     /*      Preemption  pending */
N#define RTOS_TSPENDING          (2)     /*      Task switch pending */
N#define RTOS_RRPENDING          (4)     /*      Round robin pending */
N
N
N#ifndef   OS_SUPPORT_INT_PRIORITY
S  #define OS_SUPPORT_INT_PRIORITY (1)
N#endif
N
N#if OS_SUPPORT_INT_PRIORITY
X#if (0)
S  #ifndef   OS_IPL_EI_DEFAULT
S    #error "Please define OS_IPL_EI_DEFAULT (OSChip.h)"
S  #endif
S
S  #ifndef   OS_IPL_DI_DEFAULT
S    #error "Please define OS_IPL_DI_DEFAULT (OSChip.h)"
S  #endif
S
S  #if OS_COMPILER_STORAGE_MODIFIER_LEFT
S    OS_EXTERN OS_SADDR unsigned int  OS_EXTERN_INIT(OS_Ipl_EI, OS_IPL_EI_DEFAULT);
S    OS_EXTERN OS_SADDR unsigned int  OS_EXTERN_INIT(OS_Ipl_DI, OS_IPL_DI_DEFAULT);
S  #else
S    OS_EXTERN unsigned int OS_SADDR  OS_EXTERN_INIT(OS_Ipl_EI, OS_IPL_EI_DEFAULT);
S    OS_EXTERN unsigned int OS_SADDR  OS_EXTERN_INIT(OS_Ipl_DI, OS_IPL_DI_DEFAULT);
S  #endif
N#endif
N
N#if OS_DEBUG
X#if 1
N  #define OS_MARK_IN_ISR()         {OS_InInt++;}
N  #define OS_MARK_OUTOF_ISR()      {if (!OS_InInt--) OS_Error(OS_ERR_LEAVEINT);}
N#else
S  #define OS_MARK_IN_ISR()
S  #define OS_MARK_OUTOF_ISR()
N#endif
N
N#if OS_SUPPORT_CALL_ISR            // Not allowed for some CPUs
X#if (1)            
Nvoid OS_CallISR        (void (*pRoutine)(void));
Nvoid OS_CallNestableISR(void (*pRoutine)(void));
N#endif
N
N#if (OS_SWITCH_FROM_INT_MODIFIES_STACK == 0) && (OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY != 0) && (OS_SCHEDULER_ACTIVATED_BY_EXCEPTION == 0)
X#if ((1) == 0) && ((0) != 0) && ((0) == 0)
S  //
S  // FOR CPUs without separate interrupt stack which do not disable interrupts on entry,
S  // OS_Enter- / Leave- Interrupt() is not defined.
S  // OS_CallISR() has to be used
S  //
N#else
N
N  #ifndef   OS_ENABLE_INTS_SAVE_IPL
N    #define OS_ENABLE_INTS_SAVE_IPL() OS_EI()
N  #endif
N
N  #ifndef   OS_RESTORE_IPL
N    #define OS_RESTORE_IPL()
N  #endif
N
N  #ifndef   OS_EI_ON_LEAVE
N    #define OS_EI_ON_LEAVE()        // Required for CPUs with do not restore DI-flag by RETI. Currently only CM3.
N  #endif
N
N  #if OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY
X  #if (0)
S    #define OS_DI_ON_ENTRY() OS_DI()
N  #else
N    #define OS_DI_ON_ENTRY()
N  #endif
N
N  #if OS_SWITCH_FROM_INT_MODIFIES_STACK
X  #if (1)
N    #define OS_HANDLE_REGION_CNT_ON_LI()                                          \
N      else {                                                                      \
N        OS_RegionCnt--;                                                           \
N      }
X    #define OS_HANDLE_REGION_CNT_ON_LI()                                                else {                                                                              OS_RegionCnt--;                                                                 }
N  #else
S    #define OS_HANDLE_REGION_CNT_ON_LI()                                          \
S      OS_RegionCnt--;
X    #define OS_HANDLE_REGION_CNT_ON_LI()                                                OS_RegionCnt--;
N  #endif
N
N
N  #define OS_SWITCH_FROM_INT_IF_REQUIRED()                                      \
N    if ((OS_RegionCnt == 1) && OS_Pending) {                                    \
N      OS_SwitchFromInt();                                                       \
N    }
X  #define OS_SWITCH_FROM_INT_IF_REQUIRED()                                          if ((OS_RegionCnt == 1) && OS_Pending) {                                          OS_SwitchFromInt();                                                           }
N
N  #define OS_EnterInterrupt() { \
N    OS_DI_ON_ENTRY();           \
N    OS_MARK_IN_ISR();           \
N    OS_RegionCnt++;             \
N    OS_DICnt++;                 \
N  }
X  #define OS_EnterInterrupt() {     OS_DI_ON_ENTRY();               OS_MARK_IN_ISR();               OS_RegionCnt++;                 OS_DICnt++;                   }
N
N  #define OS_LeaveInterrupt() {                                                 \
N    OS_MARK_OUTOF_ISR();                                                        \
N    OS_DICnt--; /* Must have been zero initially ! (We could put =0 instead) */ \
N    OS_SWITCH_FROM_INT_IF_REQUIRED()                                            \
N    OS_HANDLE_REGION_CNT_ON_LI();                                               \
N    OS_EI_ON_LEAVE();                                                           \
N  }
X  #define OS_LeaveInterrupt() {                                                     OS_MARK_OUTOF_ISR();                                                            OS_DICnt--;       OS_SWITCH_FROM_INT_IF_REQUIRED()                                                OS_HANDLE_REGION_CNT_ON_LI();                                                   OS_EI_ON_LEAVE();                                                             }
N
N  #define OS_LeaveInterruptNoSwitch() { \
N    OS_MARK_OUTOF_ISR();                \
N    OS_DICnt--;                         \
N    OS_RegionCnt--;                     \
N    OS_EI_ON_LEAVE();                   \
N  }
X  #define OS_LeaveInterruptNoSwitch() {     OS_MARK_OUTOF_ISR();                    OS_DICnt--;                             OS_RegionCnt--;                         OS_EI_ON_LEAVE();                     }
N
N  #define OS_EnterNestableInterrupt() { \
N    OS_MARK_IN_ISR();                   \
N    OS_RegionCnt++;                     \
N    OS_ENABLE_INTS_SAVE_IPL();          \
N  }
X  #define OS_EnterNestableInterrupt() {     OS_MARK_IN_ISR();                       OS_RegionCnt++;                         OS_ENABLE_INTS_SAVE_IPL();            }
N
N  #define OS_LeaveNestableInterrupt() {                                         \
N    OS_DI();                                                                    \
N    OS_MARK_OUTOF_ISR();                                                        \
N    OS_SWITCH_FROM_INT_IF_REQUIRED()                                            \
N    OS_HANDLE_REGION_CNT_ON_LI();                                               \
N    OS_RESTORE_IPL();                                                           \
N    OS_EI_ON_LEAVE();                                                           \
N  }
X  #define OS_LeaveNestableInterrupt() {                                             OS_DI();                                                                        OS_MARK_OUTOF_ISR();                                                            OS_SWITCH_FROM_INT_IF_REQUIRED()                                                OS_HANDLE_REGION_CNT_ON_LI();                                                   OS_RESTORE_IPL();                                                               OS_EI_ON_LEAVE();                                                             }
N
N  #define OS_LeaveNestableInterruptNoSwitch() { \
N    OS_DI();                                    \
N    OS_MARK_OUTOF_ISR();                        \
N    OS_RegionCnt--;                             \
N    OS_RESTORE_IPL();                           \
N    OS_EI_ON_LEAVE();                           \
N  }
X  #define OS_LeaveNestableInterruptNoSwitch() {     OS_DI();                                        OS_MARK_OUTOF_ISR();                            OS_RegionCnt--;                                 OS_RESTORE_IPL();                               OS_EI_ON_LEAVE();                             }
N#endif
N
N#ifndef OS_EnterIntStack
S  void OS__EnterIntStack(void);
S  #define OS_EnterIntStack() {OS_DI(); OS__EnterIntStack(); OS_RESTORE_I(); }
N#endif
N
N#ifndef OS_LeaveIntStack
S  void OS__LeaveIntStack(void);
S  #define OS_LeaveIntStack() {OS_DI(); OS__LeaveIntStack(); }
N#endif
N
Nvoid OS_SetFastIntPriorityLimit(OS_UINT Priority);
Xvoid OS_SetFastIntPriorityLimit(unsigned int Priority);
N
N/*********************************************************************
N*
N*       Resource semaphores
N*
N**********************************************************************
N*/
N
Nint      OS_Use             (OS_RSEMA * pRSema); /* OSRsem.c   */
Nvoid     OS_Unuse           (OS_RSEMA * pRSema); /* OSRsem.c   */
Nchar     OS_Request         (OS_RSEMA * pRSema); /* OSRsemRQ.c */
Nint      OS_GetSemaValue    (OS_RSEMA * pRSema); /* OSRSemGV.c */
NOS_TASK* OS_GetResourceOwner(OS_RSEMA * pRSema); /* OSRsemGO.c */
N
Nvoid     OS_CreateRSema     (OS_RSEMA * pRSema); /* OSRsem.c   */
Nvoid     OS_DeleteRSema     (OS_RSEMA * pRSema); /* OSDelRS.c  */
N
N#define  OS_CREATERSEMA(ps) OS_CreateRSema(ps)
N
N/*********************************************************************
N*
N*       Counting semaphores
N*
N**********************************************************************
N*/
N
Nvoid  OS_CreateCSema    (OS_CSEMA * pCSema, OS_UINT InitValue);  /* OSCSEM.c             */
Xvoid  OS_CreateCSema    (OS_CSEMA * pCSema, unsigned int InitValue);   
Nvoid  OS_DeleteCSema    (OS_CSEMA * pCSema);                     /* OSDELCS.c            */
Nint   OS_GetCSemaValue  (OS_CSEMA * pCSema);                     /* OSCSEMGV.c           */
NOS_U8 OS_SetCSemaValue  (OS_CSEMA * pCSema, OS_UINT value);      /* OS_SetCSemaValue.c   */
Xunsigned char OS_SetCSemaValue  (OS_CSEMA * pCSema, unsigned int value);       
Nvoid  OS_SignalCSema    (OS_CSEMA * pCSema);                     /* OSCSEM.c             */
Nvoid  OS_SignalCSemaMax (OS_CSEMA * pCSema, OS_UINT MaxValue);   /* OS_CSEMA_SignalMax.c */
Xvoid  OS_SignalCSemaMax (OS_CSEMA * pCSema, unsigned int MaxValue);    
Nvoid  OS_WaitCSema      (OS_CSEMA * pCSema);                     /* OSCSEM.c             */
Nint   OS_WaitCSemaTimed (OS_CSEMA * pCSema, OS_TIME TimeOut);    /* OSCSEMT.c            */
Xint   OS_WaitCSemaTimed (OS_CSEMA * pCSema, int TimeOut);     
Nchar  OS_CSemaRequest   (OS_CSEMA * pCSema);                     /* OSCSEMRQ.c           */
N
N#define OS_CREATECSEMA(ps) OS_CreateCSema(ps,0)
N
N/*********************************************************************
N*
N*       Mailboxes
N*
N**********************************************************************
N*/
N#define CREATEMB(MAILBOX, size, max, Buffer) OS_CreateMB(MAILBOX,size, max, Buffer);
Nvoid OS_CreateMB          (OS_MAILBOX * pMB, OS_U8 sizeofMsg, OS_UINT maxnofMsg, void* Buffer);    /* initialize mailbox */
Xvoid OS_CreateMB          (OS_MAILBOX * pMB, unsigned char sizeofMsg, unsigned int maxnofMsg, void* Buffer);     
Nvoid OS_ClearMB           (OS_MAILBOX * pMB);
Nvoid OS_PutMail           (OS_MAILBOX * pMB, void* pMail);
Nchar OS_PutMailCond       (OS_MAILBOX * pMB, void* pMail);
Nvoid OS_PutMailFront      (OS_MAILBOX * pMB, void* pMail);
Nchar OS_PutMailFrontCond  (OS_MAILBOX * pMB, void* pMail);
Nvoid OS_GetMail           (OS_MAILBOX * pMB, void* pDest);
Nchar OS_GetMailCond       (OS_MAILBOX * pMB, void* pDest);
Nvoid OS_PutMail1          (OS_MAILBOX * pMB, const char* pMail);
Nchar OS_PutMailCond1      (OS_MAILBOX * pMB, const char* pMail);
Nvoid OS_PutMailFront1     (OS_MAILBOX * pMB, const char* pMail);
Nchar OS_PutMailFrontCond1 (OS_MAILBOX * pMB, const char* pMail);
Nvoid OS_GetMail1          (OS_MAILBOX * pMB, char* pDest);
Nchar OS_GetMailCond1      (OS_MAILBOX * pMB, char* pDest);
Nchar OS_GetMailTimed      (OS_MAILBOX * pMB, void* pDest, OS_TIME Timeout);
Xchar OS_GetMailTimed      (OS_MAILBOX * pMB, void* pDest, int Timeout);
Nvoid OS_DeleteMB          (OS_MAILBOX * pMB);
Nvoid OS_WaitMail          (OS_MAILBOX * pMB);
N
N#if OS_DEBUG == 0
X#if 1 == 0
S  #define OS_GetMessageCnt(pMB) (*pMB).nofMsg
N#else
N  OS_UINT OS_GetMessageCnt(OS_MAILBOX * pMB);   /* get no. of available Messages */
X  unsigned int OS_GetMessageCnt(OS_MAILBOX * pMB);    
N#endif
N
N/*********************************************************************
N*
N*       Message Queues (OSQ.c)
N*
N**********************************************************************
N*/
N
Nvoid    OS_Q_Create       (OS_Q* pQ, void*pData, OS_UINT Size);
Xvoid    OS_Q_Create       (OS_Q* pQ, void*pData, unsigned int Size);
Nvoid    OS_Q_Clear        (OS_Q* pQ);                                /* OSQCL.c  */
Nint     OS_Q_GetMessageCnt(OS_Q* pQ);                                /* OSQGMC.c */
Nint     OS_Q_Put          (OS_Q* pQ, const void* pSrc, OS_UINT Size);
Xint     OS_Q_Put          (OS_Q* pQ, const void* pSrc, unsigned int Size);
Nint     OS_Q_GetPtr       (OS_Q* pQ, void**ppData);
Nint     OS_Q_GetPtrCond   (OS_Q* pQ, void**ppData);                  /* OSQGPC.c */
Nint     OS_Q_GetPtrTimed  (OS_Q* pQ, void**ppData, OS_TIME Timeout); /* OSQGPT.c */
Xint     OS_Q_GetPtrTimed  (OS_Q* pQ, void**ppData, int Timeout);  
Nvoid    OS_Q_Purge        (OS_Q* pQ);
N
N/*********************************************************************
N*
N*       Events
N*
N**********************************************************************
N*/
N
Nchar OS_ClearEvents          (OS_TASK * pTask);                 /* OSEVENCL.c  */
Nchar OS_GetEventsOccured     (OS_TASK * pTask);                 /* OSEVENGE.c  */
Nvoid OS_SignalEvent          (char Event, OS_TASK * pTask);     /* OSENENS.c   */
Nchar OS_WaitEvent            (char EventMask);                  /* OSEVENW.c   */
Nchar OS_WaitEventTimed       (char EventMask, OS_TIME TimeOut); /* OSEVENT.c   */
Xchar OS_WaitEventTimed       (char EventMask, int TimeOut);  
Nchar OS_WaitSingleEvent      (char EventMask);                  /* OSEVENWS.c  */
Nchar OS_WaitSingleEventTimed (char EventMask, OS_TIME TimeOut); /* OSEVENWST.c */
Xchar OS_WaitSingleEventTimed (char EventMask, int TimeOut);  
N
N/*********************************************************************
N*
N*       Timers(OSTIME.c)
N*
N**********************************************************************
N*/
N
N#ifdef OS_SIZEOF_INT
N  #if OS_SIZEOF_INT == 2
X  #if (4) == 2
S    #define OS_TIMER_MAX_TIME 0x7F00
N  #elif OS_SIZEOF_INT == 4
X  #elif (4) == 4
N    #define OS_TIMER_MAX_TIME 0x7FFFFF00
N  #else
S    #error "OS_SIZEOF_INT not correctly defined"
N  #endif
N#endif
N
Nvoid    OS_CreateTimer    (OS_TIMER * pTimer, OS_TIMERROUTINE* Callback, OS_TIME Timeout);
Xvoid    OS_CreateTimer    (OS_TIMER * pTimer, OS_TIMERROUTINE* Callback, int Timeout);
Nvoid    OS_RetriggerTimer (OS_TIMER * pTimer);
Nvoid    OS_StartTimer     (OS_TIMER * pTimer);
Nvoid    OS_StopTimer      (OS_TIMER * pTimer);
Nvoid    OS_DeleteTimer    (OS_TIMER * pTimer);                  /* OSTIMED.c  */
NOS_TIME OS_GetTimerPeriod (OS_TIMER * pTimer);                  /* OSTIMEGP.c */
Xint OS_GetTimerPeriod (OS_TIMER * pTimer);                   
NOS_U8   OS_GetTimerStatus (OS_TIMER * pTimer);                  /* OSTIMEGS.c */
Xunsigned char   OS_GetTimerStatus (OS_TIMER * pTimer);                   
NOS_TIME OS_GetTimerValue  (OS_TIMER * pTimer);                  /* OSTIMEGV.c */
Xint OS_GetTimerValue  (OS_TIMER * pTimer);                   
Nvoid    OS_SetTimerPeriod (OS_TIMER * pTimer, OS_TIME Period);  /* OSTIMES.c  */
Xvoid    OS_SetTimerPeriod (OS_TIMER * pTimer, int Period);   
N
N#define OS_CREATETIMER(pTimer,c,d)  \
N        OS_CreateTimer(pTimer,c,d); \
N        OS_StartTimer(pTimer);
X#define OS_CREATETIMER(pTimer,c,d)          OS_CreateTimer(pTimer,c,d);         OS_StartTimer(pTimer);
N
N/*********************************************************************
N*
N*       Extended timers (OSTIMERX.c)
N*
N**********************************************************************
N*/
Nvoid    OS_CreateTimerEx (OS_TIMER_EX * pTimerEx, OS_TIMER_EX_ROUTINE* Callback, OS_TIME Timeout, void * pData);
Xvoid    OS_CreateTimerEx (OS_TIMER_EX * pTimerEx, OS_TIMER_EX_ROUTINE* Callback, int Timeout, void * pData);
N
N#define OS_RetriggerTimerEx(pTimerEx)         OS_RetriggerTimer(&(pTimerEx)->Timer)
N#define OS_StartTimerEx(pTimerEx)             OS_StartTimer(&(pTimerEx)->Timer)
N#define OS_StopTimerEx(pTimerEx)              OS_StopTimer(&(pTimerEx)->Timer)
N#define OS_DeleteTimerEx(pTimerEx)            OS_DeleteTimer(&(pTimerEx)->Timer)
N#define OS_GetTimerPeriodEx(pTimerEx)         OS_GetTimerPeriod(&(pTimerEx)->Timer)
N#define OS_GetTimerStatusEx(pTimerEx)         OS_GetTimerStatus(&(pTimerEx)->Timer)
N#define OS_GetTimerValueEx(pTimerEx)          OS_GetTimerValue(&(pTimerEx)->Timer)
N#define OS_SetTimerPeriodEx(pTimerEx,Period)  OS_SetTimerPeriod(&(pTimerEx)->Timer, Period)
N
N#define OS_CREATETIMER_EX(pTimerEx,cb,Timeout,pData) \
N        OS_CreateTimerEx(pTimerEx,cb,Timeout,pData); \
N        OS_StartTimerEx(pTimerEx)
X#define OS_CREATETIMER_EX(pTimerEx,cb,Timeout,pData)         OS_CreateTimerEx(pTimerEx,cb,Timeout,pData);         OS_StartTimerEx(pTimerEx)
N
N/*********************************************************************
N*
N*       Heap type memory management (OS_Alloc.c)
N*
N**********************************************************************
N
N  This functions might not be implemented in all OS ports.
N  Therefore declaration depends on condition OS_SUPPORT_OS_ALLOC
N  which has to be defined in CPU specific part
N
N*/
N
N#if OS_SUPPORT_OS_ALLOC
X#if (1)
N  void* OS_malloc(unsigned int);
N  void  OS_free  (void* pMemBlock);
N  void* OS_realloc  (void* pMemBlock, unsigned NewSize);
N#endif
N
N/*********************************************************************
N*
N*       Fixed Block memory management
N*
N**********************************************************************
N*/
N
Nvoid  OS_MEMF_Create(OS_MEMF* pMEMF, void* pPool, OS_U16 NumBlocks, OS_U16 BlockSize);
Xvoid  OS_MEMF_Create(OS_MEMF* pMEMF, void* pPool, unsigned short NumBlocks, unsigned short BlockSize);
Nvoid  OS_MEMF_Delete(OS_MEMF* pMEMF);
Nvoid* OS_MEMF_Alloc(OS_MEMF* pMEMF, int Purpose);
Nvoid* OS_MEMF_AllocTimed(OS_MEMF* pMEMF, OS_TIME Timeout, int Purpose);
Xvoid* OS_MEMF_AllocTimed(OS_MEMF* pMEMF, int Timeout, int Purpose);
Nvoid* OS_MEMF_Request(OS_MEMF* pMEMF, int Purpose);
Nvoid  OS_MEMF_Release(OS_MEMF* pMEMF, void* pMemBlock);
Nvoid  OS_MEMF_FreeBlock(void* pMemBlock);
Nint   OS_MEMF_GetNumFreeBlocks(OS_MEMF* pMEMF);
Nchar  OS_MEMF_IsInPool(OS_MEMF* pMEMF, void* pMemBlock);
Nint   OS_MEMF_GetMaxUsed(OS_MEMF* pMEMF);
Nint   OS_MEMF_GetNumBlocks(OS_MEMF* pMEMF);
Nint   OS_MEMF_GetBlockSize(OS_MEMF* pMEMF);
N
N/*********************************************************************
N*
N*       Event object module
N*
N**********************************************************************
N*/
N
N/****** Simple OS_EVENT functions ************************************/
N
Nvoid  OS_EVENT_Create    (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Delete    (OS_EVENT* pEvent);
N
NOS_U8 OS_EVENT_Get       (OS_EVENT* pEvent);
Xunsigned char OS_EVENT_Get       (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Pulse     (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Reset     (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Set       (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Wait      (OS_EVENT* pEvent);
Nchar  OS_EVENT_WaitTimed (OS_EVENT* pEvent, OS_TIME Timeout);
Xchar  OS_EVENT_WaitTimed (OS_EVENT* pEvent, int Timeout);
N
N/*********************************************************************
N*
N*       Timing support (OSTiming.c)
N*
N**********************************************************************
N
N New in V3.04, but not yet documented to the end user. Great for
N run-time measurement.
N*/
N
N#define OS_TIMING OS_U32
Nvoid    OS_Timing_Start(OS_TIMING* pCycle);
Xvoid    OS_Timing_Start(unsigned int* pCycle);
Nvoid    OS_Timing_End(OS_TIMING* pCycle);
Xvoid    OS_Timing_End(unsigned int* pCycle);
NOS_U32  OS_Timing_Getus(OS_TIMING* pCycle);
Xunsigned int  OS_Timing_Getus(unsigned int* pCycle);
N#define OS_Timing_GetCycles(pPara) (*pPara)
N
N
N/*********************************************************************
N*
N*       OS Power control module OS_Power.c
N*
N**********************************************************************
N*/
N#if OS_SUPPORT_POWER
X#if (1)
N#define OS_POWER_LEVEL0  (0x0001)
N#define OS_POWER_LEVEL1  (0x0002)
N#define OS_POWER_LEVEL2  (0x0004)
N#define OS_POWER_LEVEL3  (0x0008)
N#define OS_POWER_LEVEL4  (0x0010)
N#define OS_POWER_LEVEL5  (0x0020)
N#define OS_POWER_LEVEL6  (0x0040)
N#define OS_POWER_LEVEL8  (0x0080)
N
Nvoid    OS_POWER_UsageInc(OS_UINT Level);
Xvoid    OS_POWER_UsageInc(unsigned int Level);
Nvoid    OS_POWER_UsageDec(OS_UINT Level);
Xvoid    OS_POWER_UsageDec(unsigned int Level);
NOS_UINT OS_POWER_GetMask(void);
Xunsigned int OS_POWER_GetMask(void);
N#endif
N
N/*********************************************************************
N*
N*       Advanced profiling support (Module OsKern.c)
N*
N**********************************************************************
N*/
N#if OS_PROFILE >= 1
X#if 1 >= 1
N  void OS_EnableProfiling(int Period);
N  #define OS_DisableProfiling() { OS_ProfilingOn=0; }
N#else
S  #define OS_EnableProfiling(Period);
S  #define OS_DisableProfiling()
N#endif
N
N/*********************************************************************
N*
N*       Configuration
N*
N**********************************************************************
N*/
N
N#define OS_CONFIG_FRACT(f, div)                    \
N  OS_TicksPerMS  = f/1000;                         \
N  OS_IntMSInc    = div*1000L/f;                    \
N  OS_IntTicksInc = div-(f/1000)*(div*1000L/f);
X#define OS_CONFIG_FRACT(f, div)                      OS_TicksPerMS  = f/1000;                           OS_IntMSInc    = div*1000L/f;                      OS_IntTicksInc = div-(f/1000)*(div*1000L/f);
N
N#define OS_CONFIG(f, div)     \
N  OS_IntMSInc    = div*1000L/f;
X#define OS_CONFIG(f, div)       OS_IntMSInc    = div*1000L/f;
N
N
N/*********************************************************************
N*
N*       Trace support (OSTrace.c)
N*
N**********************************************************************
N
NTrace support is enabled by defining OS_TRACE 1.
NThis is automatically done, when OS_LIBMODE_T is defined.
N
N*/
N
N#if OS_TRACE
X#if 0
S  /* Declare trace function prototypes */
S  void OS_TraceVoid (OS_U8 id);
S  void OS_TracePtr  (OS_U8 id, void* p);
S  void OS_TraceData (OS_U8 id, int v);
S  void OS_TraceDataPtr (OS_U8 id, int v, void*p);
S  void OS_TraceU32Ptr  (OS_U8 id, OS_U32 p0, void*p1);
S  void OS_TraceEnable(void);
S  void OS_TraceDisable(void);
S  void OS_TraceEnableAll(void);                              /* OSTrace1.c */
S  void OS_TraceDisableAll(void);                             /* OSTrace1.c */
S  void OS_TraceEnableId(OS_U8 id);                           /* OSTrace1.c */
S  void OS_TraceDisableId(OS_U8 id);                          /* OSTrace1.c */
S  void OS_TraceEnableFilterId(OS_U8 FilterIndex, OS_U8 id);  /* OSTrace1.c */
S  void OS_TraceDisableFilterId(OS_U8 FilterIndex, OS_U8 id); /* OSTrace1.c */
S
S  /* Trace function macros, used in API functions */
S  #define OS_TRACE_VOID(id)            OS_TraceVoid(id)
S  #define OS_TRACE_PTR(id, p)          OS_TracePtr(id, p)
S  #define OS_TRACE_DATA(id, v)         OS_TraceData(id, v)
S  #define OS_TRACE_DATA_PTR(id, v, p)  OS_TraceDataPtr(id, v, p)
S  #define OS_TRACE_U32_PTR(id, p0, p1) OS_TraceU32Ptr(id, p0, p1)
S
S  #define OS_TRACE_START()                    { OS_EnterRegion();                                }
S  #define OS_TRACE_START_VOID(id)             { OS_EnterRegion(); OS_TraceVoid(id);              }
S  #define OS_TRACE_START_PTR(id, p)           { OS_EnterRegion(); OS_TracePtr(id, p);            }
S  #define OS_TRACE_START_DATA(id, v)          { OS_EnterRegion(); OS_TraceData(id, v);           }
S  #define OS_TRACE_START_DATA_PTR(id, v, p)   { OS_EnterRegion(); OS_TraceDataPtr(id, v, p);     }
S  #define OS_TRACE_START_U32_PTR(id, p0, p1)  { OS_EnterRegion(); OS_TraceU32Ptr(id, u, p);      }
S  #define OS_TRACE_END()                      { OS_LeaveRegion();                                }
S
N#else
N  /* Replace trace functions by empty macros if trace is not enabled */
N  #define OS_TraceVoid(id)
N  #define OS_TracePtr(id, p)
N  #define OS_TraceData(id, v)
N  #define OS_TraceDataPtr(id, v, p)
N  #define OS_TraceU32Ptr(id, p0, p1)
N  #define OS_TraceEnable()
N  #define OS_TraceDisable()
N  #define OS_TraceEnableAll()
N  #define OS_TraceDisableAll()
N  #define OS_TraceEnableId(id)
N  #define OS_TraceDisableId(id)
N  #define OS_TraceEnableFilterId(FilterIndex, id)
N  #define OS_TraceDisableFilterId(FilterIndex, id)
N  /* Trace function macros, used in API functions. */
N  /* Expand to nothing if trace is disabled       */
N  #define OS_TRACE_VOID(id)
N  #define OS_TRACE_PTR(id, p)
N  #define OS_TRACE_DATA(id, v)
N  #define OS_TRACE_DATA_PTR(id, v, p)
N  #define OS_TRACE_U32_PTR(id, p0, p1)
N
N  #define OS_TRACE_START()
N  #define OS_TRACE_START_VOID(id)
N  #define OS_TRACE_START_PTR(id, p)
N  #define OS_TRACE_START_DATA(id, v)
N  #define OS_TRACE_START_DATA_PTR(id, v, p)
N  #define OS_TRACE_START_U32_PTR(id, p0, p1)
N  #define OS_TRACE_END()
N#endif
N
N/*********************************************************************
N*
N*        RTOSInit and misc.
N*
N**********************************************************************
N
NThe routines declared below are available on all targets.
N
N*/
N
N/* Routines in RTOSInit.c */
Nvoid   OS_InitHW(void);
Nvoid   OS_Idle(void);
NOS_U32 OS_ConvertCycles2us(OS_U32 Cycles);
Xunsigned int OS_ConvertCycles2us(unsigned int Cycles);
NOS_U32 OS_GetTime_Cycles(void);
Xunsigned int OS_GetTime_Cycles(void);
Nvoid   OS_COM_Init(void);
Nvoid   OS_COM_Send1(unsigned char c);
N
N/* Routines in OS_Error.c, delivered as source file */
Nvoid   OS_Error(int code);
N
NOS_INTERWORK void  OS_Start(void);                  /* RTOS ASM part   */
X void  OS_Start(void);                   
NOS_INTERWORK void  OS_Switch(void);                 /* RTOS ASM part   */
X void  OS_Switch(void);                  
NOS_INTERWORK int   OS_SwitchFromInt(void);          /* RTOS ASM part   */
X int   OS_SwitchFromInt(void);           
N
Nvoid  OS_InitKern(void);             /* OSKern.c        */
NOS_U8 OS_OnTx(void);                 /* OSComRxTx1.c, Returns 1 on last byte */
Xunsigned char OS_OnTx(void);                  
Nvoid  OS_OnRx(unsigned char c);      /* OSComRxTx1.c    */
Nvoid  OS_Send1(OS_U8 c);             /* not implemented */
Xvoid  OS_Send1(unsigned char c);              
Nvoid  OS_SendString(const char* s);  /* OSSend.c        */
NOS_RX_CALLBACK* OS_SetRxCallback(OS_RX_CALLBACK* cb);
NOS_U8 OS_EvaPacketEx(const OS_U8 * pSrc, OS_U16 SrcLen, OS_U8** pReturn);  /* OS_EvaPacketEx.c */
Xunsigned char OS_EvaPacketEx(const unsigned char * pSrc, unsigned short SrcLen, unsigned char** pReturn);   
N
Nvoid  OS_COM_ClearTxActive(void);    /* OSCom2.c */
N
N/*********************************************************************
N*
N*        RTOS misc. optional
N*
N**********************************************************************
N
NThe routines declared below are available on some targets
Nonly. (Because they do not make much sense on others)
N*/
N
N/* Timing routines. Their existance depends on the CPU. In general,
N  8-bit CPUs require both routines, where 16-bit CPUs require one
N  and 32-bit CPUs require none of these.
N*/
N#ifndef OS_GetTime
S  OS_TIME OS_GetTime(void);
N#endif
N#ifndef OS_GetTime32
S  #if (OS_SIZEOF_INT == 4)
S    #define OS_GetTime32() (OS_Time)
S  #else
S    OS_I32 OS_GetTime32(void);
S  #endif
N#endif
N
Nvoid OS__di(void);
Nvoid OS__ei(void);
Nvoid OS__SaveIPL(void);
Nvoid OS__RestIPL(void);
Nvoid OS_SIM_Init(void);
N
N/* Standard tick handler which increment OS time variable by one on each interrupt */
Nvoid OS_HandleTick(void);       /* New version of OS_TickHandler() without Enter- Leave-Interrupt    */
Nvoid OS_HandleTickDI(void);     /* OSTickDI.c */
N
N/* Non standard tick handler which increment the OS time variable by OS_IntMsInc once on each interrupt */
N/* One of these handler has to be used when OS_CONFIG() is used to set a tick increment unequal to 0    */
Nvoid OS_HandleTick_Ex(void);    /* OS_HandleTick_Ex.c */
Nvoid OS_HandleTickDI_Ex(void);  /* OSTickDI_Ex.c      */
N
Nvoid OS_AddTickHook(OS_TICK_HOOK* pHook, OS_TICK_HOOK_ROUTINE * pfUser);
Nvoid OS_RemoveTickHook(OS_TICK_HOOK* pHook);
N
N/* Routines for the PC-version running in native mode (non-windows) */
Nvoid OS_SetIntFreq(OS_UINT f);
Xvoid OS_SetIntFreq(unsigned int f);
Nvoid OS_Exit(int code);
Nvoid OS_UseDos(void);
Nvoid OS_UnuseDos(void);
Nint  OS_GetKey(void);
Nint  OS_WaitKey(void);
N
N/* Compatibility with manual */
N#define OS_CREATEMB          OS_CreateMB
N#define OS_GetUseCnt         OS_GetSemaValue
N#define OS_WaitCSema_Timed   OS_WaitCSemaTimed
N#define OS_WaitEvent_Timed   OS_WaitEventTimed
N
N/********************************************************************/
N
N#ifdef __cplusplus
S  }
N#endif
N
N#endif /* RTOS_H_INCLUDED */
N
N/*****  EOF  ********************************************************/
N
L 21 "Config\IP_ConfigIO.c" 2
N
N
N/*********************************************************************
N*
N*       Defines, configurable
N*
N*       This section is normaly the only section which requires changes.
N*       on most embedded systems
N*
N**********************************************************************
N*/
N#define USE_DCC        0
N#define SHOW_TIME      1
N#define SHOW_TASK      1
N
N#if USE_DCC
X#if 0
S#include "JLINKDCC.h"
N#endif
N
N/*********************************************************************
N*
N*       _puts
N*
N*  Function description
N*    Local (static) replacement for puts.
N*    The reason why puts is not used is that puts always appends a NL
N*    character, which screws up our formatting.
N*/
Nstatic void _puts(const char * s) {
N  char c;
N  for (;;) {
N   c = *s++;
N   if (c == 0) {
N     break;
N   }
N#if USE_DCC
X#if 0
S   JLINKDCC_SendChar(c);
N#else
N   putchar(c);
X   putc(c, (& __stdout));
N#endif
N  }
N}
N
N/*********************************************************************
N*
N*       _WriteUnsigned
N*/
Nstatic char * _WriteUnsigned(char * s, U32 v, int NumDigits) {
Xstatic char * _WriteUnsigned(char * s, unsigned long v, int NumDigits) {
N  unsigned Base;
N  unsigned Div;
N  U32 Digit;
X  unsigned long Digit;
N
N  Digit = 1;
N  Base  = 10;
N  //
N  // Count how many digits are required
N  //
N  while (((v / Digit) >= Base) | (NumDigits-- > 1)) {
N    Digit *= Base;
N  }
N  //
N  // Output digits
N  //
N  do {
N    Div = v / Digit;
N    v  -= Div * Digit;
N    *s++ = (char)('0' + Div);
N    Digit /= Base;
N  } while (Digit);
N  *s = 0;
N  return s;
N}
N
N/*********************************************************************
N*
N*       _ShowStamp
N*
N*  Function description
N*
N*/
Nstatic void _ShowStamp(void) {
N#if SHOW_TIME
X#if 1
N  {
N    I32 Time;
X    signed long Time;
N    char ac[20];
N    char * sBuffer = &ac[0];
N    Time = OS_GetTime32();
X    Time = (OS_Time);
N    sBuffer = _WriteUnsigned(sBuffer, Time / 1000, 0);
N    *sBuffer++ = ':';
N    sBuffer = _WriteUnsigned(sBuffer, Time % 1000, 3);
N    *sBuffer++ = ' ';
N    *sBuffer++ = 0;
N    _puts(ac);
N  }
N#endif
N
N#if SHOW_TASK
X#if 1
N  {
N    const char * s;
N    s = OS_GetTaskName(NULL);
X    s = OS_GetTaskName(0);
N    if (s) {
N      _puts(s);
N      _puts(" - ");
N    }
N  }
N#endif
N}
N
N
N/*********************************************************************
N*
N*       IP_Panic
N*
N*  Function description
N*    This function is called if the stack encounters a critical situation.
N*    In a release build, this function may not be linked in.
N*
N*/
Nvoid IP_Panic(const char * s) {
N  (void)s;
N  IP_OS_DisableInterrupt();
N#if IP_DEBUG > 1
X#if 2 > 1
N  _puts("*** Fatal error, System halted: ");
N  _puts(s);
N  _puts("\n");
N#endif
N  while (1);
N}
N
N
N
N/*********************************************************************
N*
N*       IP_Log
N*
N*  Function description
N*    This function is called by the stack in debug builds with log output.
N*    In a release build, this function may not be linked in.
N*
N*  Notes
N*    (1)  Interrupts and task switches
N*         printf() has a reentrance problem on  alot of systems if interrupts are not disabled.
N*                  which would scramble strings if printf() called from an ISR interrupts an other printf.
N*         In order to avoid this problem, interrupts are disabled.
N*
N*/
Nvoid IP_Log(const char * s) {
N
N  IP_OS_DisableInterrupt();
N  _ShowStamp();
N  _puts(s);
N  _puts("\n");
N  IP_OS_EnableInterrupt();
N}
N
N/*********************************************************************
N*
N*       IP_Warn
N*
N*  Function description
N*    This function is called by the stack in debug builds with log output.
N*    In a release build, this function may not be linked in.
N*
N*  Notes
N*    (1)  Interrupts and task switches
N*         See IP_Log()
N*/
Nvoid IP_Warn(const char * s) {
N  IP_OS_DisableInterrupt();
N  _ShowStamp();
N  _puts("*** Warning *** ");
N  _puts(s);
N  _puts("\n");
N  IP_OS_EnableInterrupt();
N}
N
N
N/*************************** End of file ****************************/
