L 1 "Config\USBH_ConfigIO.c"
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : USBH_ConfigIO.c
NPurpose     :
N---------------------------END-OF-HEADER------------------------------
N*/
N
N/*********************************************************************
N*
N*       #include Section
N*
N**********************************************************************
N*/
N#include <stdlib.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 25 "Config\USBH_ConfigIO.c" 2
N#include "USBH_Int.h"
L 1 "USBH\USBH_Int.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : USBH_Int.h
NPurpose     : Internals used accross different layers of the USB device stack
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef _USBH_INT_H_ // Avoid multiple/recursive inclusion
N
N#define _USBH_INT_H_
N
N#include <stdlib.h>  // for atoi(), exit()
N#include <string.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 24 "USBH\USBH_Int.h" 2
N#include <stdio.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030076
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 25 "USBH\USBH_Int.h" 2
N
N#include "Segger.h"
L 1 "Inc\Segger.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : SEGGER.h
NPurpose : Global types etc & general purpose utility functions
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef SEGGER_H            // Guard against multiple inclusion
N#define SEGGER_H
N
N#include "Global.h"         // Type definitions: U8, U16, U32, I8, I16, I32
L 1 "GUI\Global.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : GLOBAL.h
NPurpose : Global types etc.
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GLOBAL_H            // Guard against multiple inclusion
N#define GLOBAL_H
N
N/*********************************************************************
N*
N*       Macros
N*
N**********************************************************************
N*/
N#define U8    unsigned char
N#define U16   unsigned short
N#define U32   unsigned long
N#define I8    signed char
N#define I16   signed short
N#define I32   signed long
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 22 "Inc\Segger.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N
N/*********************************************************************
N*
N*       Function-like macros
N*
N**********************************************************************
N*/
N
N#define SEGGER_COUNTOF(a)          (sizeof(a)/sizeof(a[0]))
N#define SEGGER_MIN(a,b)            (((a) < (b)) ? (a) : (b))
N#define SEGGER_MAX(a,b)            (((a) > (b)) ? (a) : (b))
N
N/*********************************************************************
N*
N*       Utiliy functions
N*
N**********************************************************************
N*/
Nvoid SEGGER_ARM_memcpy(void * pDest, const void * pSrc, int NumBytes);
Nvoid SEGGER_memcpy    (void * pDest, const void * pSrc, int NumBytes);
Nvoid SEGGER_snprintf(char * pBuffer, int BufferSize, const char * sFormat, ...);
N
N#if defined(__cplusplus)
X#if 0L
S}                /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 27 "USBH\USBH_Int.h" 2
N#include "USBH.h"
L 1 "USBH\USBH.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : USBH.h
NPurpose     : API of the USB host stack
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef _USBH_H_
N#define _USBH_H_
N
N#include <stdarg.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N  typedef struct __va_list { void *__ap; } va_list;
N
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stdarg.h */
N
L 22 "USBH\USBH.h" 2
N#include "SEGGER.h"
N#include "USBH_ConfDefaults.h"
L 1 "USBH\USBH_ConfDefaults.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : USBH_ConfDefaults.h
NPurpose :
N--------------------------  END-OF-HEADER  ---------------------------
N*/
N
N#ifndef   USBH_CONFDEFAULTS_H
N#define   USBH_CONFDEFAULTS_H
N
N#include "USBH_Conf.h"
L 1 "Setup\USBH_Conf.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : USB_Conf.h
NPurpose : Config file. Modify to reflect your configuration
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef USBH_CONF_H      // Avoid multiple inclusion
N
N#define USBH_CONF_H
N
N#if defined(__cplusplus) // Make sure we have C-declarations in C++ programs
X#if 0L 
S  extern "C" {
N#endif
N
N#ifdef DEBUG
N#if DEBUG
X#if 1
N  #define USBH_DEBUG   2 // Debug level: 1: Support "Panic" checks, 2: Support warn & log
N#endif
N#endif
N
N
N// Make sure we have C-declarations in C++ programs
N#if defined(__cplusplus)
X#if 0L
S
S}
S
N#endif
N
N#endif // Avoid multiple inclusion
N
N/********************************* EOF ******************************/
L 22 "USBH\USBH_ConfDefaults.h" 2
N
N/*********************************************************************
N*
N*       Basic types
N*/
N#define     USBH_BOOL char
N
N#ifndef     FALSE
N  #define   FALSE        (1 == 0)
N#endif
N#ifndef     TRUE
N  #define   TRUE         (1 == 1)
N#endif
N#ifndef     USBH_DEBUG
S  #define   USBH_DEBUG   (0)
N#endif
N#ifndef     USBH_MEMCPY
N  #define   USBH_MEMCPY  memcpy
N#endif
N#ifndef     USBH_MEMSET
N  #define   USBH_MEMSET  memset
N#endif
N#ifndef     USBH_MEMMOVE
N  #define   USBH_MEMMOVE memmove
N#endif
N#ifndef     USBH_MEMCMP
N  #define   USBH_MEMCMP  memcmp
N#endif
N#ifndef     USBH_OPTIMIZE
N  #define   USBH_OPTIMIZE
N#endif
N#ifndef     USBH_IS_BIG_ENDIAN
N  #define   USBH_IS_BIG_ENDIAN 0      // Little endian is default
N#endif
N
N#ifndef     USBH_PANIC
N  #if       USBH_DEBUG
X  #if       2
N    #define USBH_PANIC(s) USBH_Panic(s)
N  #else
S    #define USBH_PANIC(s)
N  #endif
N#endif
N#ifndef     USBH_SUPPORT_LOG
N  #if       USBH_DEBUG > 1
X  #if       2 > 1
N    #define USBH_SUPPORT_LOG   1
N  #else
S    #define USBH_SUPPORT_LOG   0
N  #endif
N#endif
N#ifndef     USBH_SUPPORT_WARN
N  #if       USBH_DEBUG > 1
X  #if       2 > 1
N    #define USBH_SUPPORT_WARN  1
N  #else
S    #define USBH_SUPPORT_WARN  0
N  #endif
N#endif
N
N#ifndef    USBH_SUPPORT_ISO_TRANSFER
N  #define  USBH_SUPPORT_ISO_TRANSFER                     1
N#endif
N
N#define USBH_TRANSFER_BUFFER_ALIGNMENT                   1
N#define USBH_IS_VALID_TRANSFER_BUFFER_RANGE(    pBuffer) (TRUE)
N#define USBH_IS_VALID_TRANSFER_BUFFER_ALIGNMENT(pBuffer) (FALSE)
N#define USBH_IS_VALID_TRANSFER_MEM(             pBuffer) (USBH_IS_VALID_TRANSFER_BUFFER_RANGE(pBuffer) && USBH_IS_VALID_TRANSFER_BUFFER_ALIGNMENT(pBuffer) ? TRUE : FALSE)
N
N//#if HC_ISO_ENABLE && (HC_DEVICE_ISO_ENDPOINTS==0)
N//  #error error HC_DEVICE_ISO_ENDPOINTS
N//#endif
N
N#ifndef USBH_MSD_EP0_TIMEOUT
N  #define USBH_MSD_EP0_TIMEOUT 5000            // Specifies the default timeout, in milliseconds, to be used for synchronous operations on the control endpoint.
N#endif
N#ifndef USBH_MSD_READ_TIMEOUT
N  #define USBH_MSD_READ_TIMEOUT      3000 // Specifies the maximum time in milliseconds, for reading all bytes with the bulk read operation.
N#endif
N#ifndef USBH_MSD_WRITE_TIMEOUT
N  #define USBH_MSD_WRITE_TIMEOUT     1000 // Specifies the maximum time, in milliseconds, for writing all bytes with the bulk write operation.
N#endif
N// Must be a multiple of the maximum packet length for bulk data endpoints.
N// That are 64 bytes for a USB 1.1 device and 512 bytes for a USB 2.0 high speed device.
N#ifndef USBH_MSD_MAX_TRANSFER_SIZE
N  #define USBH_MSD_MAX_TRANSFER_SIZE (32 * 1024) // [bytes]
N#endif
N#ifndef USBH_MSD_DEFAULT_SECTOR_SIZE
N  #define USBH_MSD_DEFAULT_SECTOR_SIZE    512 // Specifies the default sector size in bytes to be used for reading and writing.
N#endif
N#ifndef USBH_MSD_MAX_DEVICES
N  #define USBH_MSD_MAX_DEVICES            1   // Maximum number of USB Mass Storage devices that are supported from the library. A lower value saves memory.
N#endif
N#ifndef USBH_MSD_MAX_LUNS_PER_DEVICE
N  #define USBH_MSD_MAX_LUNS_PER_DEVICE    2   // Maximum number of logical units per device that are supported from the library. A lower value saves memory.
N#endif
N
N#define DEFAULT_RESET_TIMEOUT        40  // The reset on the root hub is aborted after this time
N// The host controller waits this time after reset before the Set Address command is sent. Some devices require some time
N// before they can answer correctly. It is not required by the USB specification but Windows makes this gap with 80 ms.
N#define WAIT_AFTER_RESET            80
N// The bus driver waits this time before the next command is sent after Set Address. The device must answer to SetAddress on USB address 0 with the
N// handshake and than set the new address. This is a potential racing condition if this step is performed in the firmware.
N// Give the device this time to set the new address.
N#define WAIT_AFTER_SETADDRESS       30
N// If the device makes an error during USB reset and set address the enumeration process is repeated. The repeat count is defined by this define.
N// Possible errors are OverCurrent, remove during reset, no answer to SetAddress.
N#define RESET_RETRY_COUNTER         10
N#define DELAY_FOR_REENUM            1000 // Describes the time before a USB reset is restarted if the last try has failed.
N// The bus controller waits this time after a USB device connect event is detected
N// before a USB bus reset is applied to the device
N#define WAIT_AFTER_CONNECT          200
N// The default size of the buffer to get descriptors from the device. If the buffer is too small for the configuration descriptor,
N// a new buffer is dynamically allocated. The default size must be at least 256 bytes to read all possible string descriptors.
N#define DEFAULT_TRANSFERBUFFER_SIZE 256
N#define DEFAULT_SETUP_TIMEOUT       500  // Default timeout for all setup requests. After this time a not completed setup request is terminated.
N// If the enumeration of the device (get descriptors, set configuration) fails, it is repeated after a time gap of this value
N#define DEFAULT_RETRY_TIMEOUT       1000
N
N// In order to avoid warnings for undefined parameters
N#ifndef USBH_USE_PARA
N  #if defined(NC30) || defined(NC308)
X  #if 0L || 0L
S    #define USBH_USE_PARA(para)
N  #else
N    #define USBH_USE_PARA(para) para=para;
N  #endif
N#endif
N
N#endif
N
N/*************************** End of file ****************************/
L 24 "USBH\USBH.h" 2
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {                 // Make sure we have C-declarations in C++ programs
N#endif
N
N#define USBH_VERSION   10401 // Format: Mmmrr. Example: 10201 is 1.02a
N
Ntypedef struct USBH_HOST_CONTROLLER   USBH_HOST_CONTROLLER;
Ntypedef struct USB_DEVICE             USB_DEVICE;
Ntypedef struct USBH_OHCI_DEVICE       USBH_OHCI_DEVICE;
Ntypedef struct USBH_HUB_PORT          USBH_HUB_PORT;
Ntypedef struct USB_HUB                USB_HUB;
Ntypedef struct USBH_OHCI_DUMMY_INT_EP USBH_OHCI_DUMMY_INT_EP;
Ntypedef struct USB_INTERFACE          USB_INTERFACE;
N
N/*********************************************************************
N*
N*       USBH_MTYPE
N*
N*  IDs to distinguish different message types
N*
N**********************************************************************
N*/
N#define USBH_MTYPE_INIT          (1UL <<  0)
N#define USBH_MTYPE_CORE          (1UL <<  1)
N#define USBH_MTYPE_TIMER         (1UL <<  2)
N#define USBH_MTYPE_DRIVER        (1UL <<  3)
N#define USBH_MTYPE_MEM           (1UL <<  4)
N#define USBH_MTYPE_URB           (1UL <<  5)
N#define USBH_MTYPE_OHCI          (1UL <<  6)
N#define USBH_MTYPE_UBD           (1UL <<  7)
N#define USBH_MTYPE_PNP           (1UL <<  8)
N#define USBH_MTYPE_DEVICE        (1UL <<  9)
N#define USBH_MTYPE_EP            (1UL << 10)
N#define USBH_MTYPE_HUB           (1UL << 11)
N#define USBH_MTYPE_MSD           (1UL << 12)
N#define USBH_MTYPE_MSD_INTERN    (1UL << 13)
N#define USBH_MTYPE_MSD_PHYS      (1UL << 14)
N#define USBH_MTYPE_HID           (1UL << 15)
N#define USBH_MTYPE_PRINTER_CLASS (1UL << 16)
N#define USBH_MTYPE_APPLICATION   (1UL << 19)
N
Nvoid USBH_Logf_Application   (const char * sFormat, ...);
Nvoid USBH_Warnf_Application  (const char * sFormat, ...);
Nvoid USBH_sprintf_Application(      char * pBuffer, unsigned BufferSize, const char * sFormat, ...);
N
N/*********************************************************************
N*
N*       Log/Warn functions
N*
N**********************************************************************
N*/
Nvoid USBH_Log          (const char * s);
Nvoid USBH_Warn         (const char * s);
Nvoid USBH_SetLogFilter (U32 FilterMask);
Xvoid USBH_SetLogFilter (unsigned long FilterMask);
Nvoid USBH_SetWarnFilter(U32 FilterMask);
Xvoid USBH_SetWarnFilter(unsigned long FilterMask);
Nvoid USBH_AddLogFilter (U32 FilterMask);
Xvoid USBH_AddLogFilter (unsigned long FilterMask);
Nvoid USBH_AddWarnFilter(U32 FilterMask);
Xvoid USBH_AddWarnFilter(unsigned long FilterMask);
Nvoid USBH_Logf         (U32 Type,             const char * sFormat, ...);
Xvoid USBH_Logf         (unsigned long Type,             const char * sFormat, ...);
Nvoid USBH_Warnf        (U32 Type,             const char * sFormat, ...);
Xvoid USBH_Warnf        (unsigned long Type,             const char * sFormat, ...);
Nvoid USBH_PrintfSafe   (char       * pBuffer, const char * sFormat, int BufferSize, va_list * pParamList);
Nvoid USBH_Panic        (const char * sError);
N
N/*********************************************************************
N*
N*       USBH_OS_
N*
N**********************************************************************
N*/
Nvoid USBH_OS_Delay           (unsigned ms);
Nvoid USBH_OS_DisableInterrupt(void);
Nvoid USBH_OS_EnableInterrupt (void);
Nvoid USBH_OS_Init            (void);
Nvoid USBH_OS_Unlock          (void);
Nvoid USBH_OS_AssertLock      (void);
Nvoid USBH_OS_Lock            (void);
NU32  USBH_OS_GetTime32       (void);
Xunsigned long  USBH_OS_GetTime32       (void);
N
N// Lock / Unlock mutex / resource semaphore used for memory operations
Nvoid USBH_OS_LockSys       (void);
Nvoid USBH_OS_UnlockSys     (void);
N// Wait and signal for USBH Main Task
Nvoid USBH_OS_WaitNetEvent  (unsigned ms);
Nvoid USBH_OS_SignalNetEvent(void);
N// Wait and signal for USBH ISR Task
Nvoid USBH_OS_WaitISR       (void);
Nvoid USBH_OS_SignalISR     (void);
N
N/*********************************************************************
N*
N*       USBH_OS_ - Event objects
N*
N**********************************************************************
N*/
N#define USBH_OS_EVENT_SIGNALED 0
N
Ntypedef struct      USBH_OS_EVENT_OBJ     USBH_OS_EVENT_OBJ;
NUSBH_OS_EVENT_OBJ * USBH_OS_AllocEvent    (void);                       // Allocates and returns an event object.
Nvoid                USBH_OS_FreeEvent     (USBH_OS_EVENT_OBJ * pEvent); // Releases an object event.
Nvoid                USBH_OS_SetEvent      (USBH_OS_EVENT_OBJ * pEvent); // Sets the state of the specified event object to signaled.
Nvoid                USBH_OS_ResetEvent    (USBH_OS_EVENT_OBJ * pEvent); // Sets the state of the specified event object to none-signaled.
Nvoid                USBH_OS_WaitEvent     (USBH_OS_EVENT_OBJ * pEvent);
Nint                 USBH_OS_WaitEventTimed(USBH_OS_EVENT_OBJ * pEvent, U32 milliSeconds);
Xint                 USBH_OS_WaitEventTimed(USBH_OS_EVENT_OBJ * pEvent, unsigned long milliSeconds);
N
N// Wait and signal for application tasks
Nvoid USBH_OS_WaitItem     (void * pWaitItem);
Nvoid USBH_OS_WaitItemTimed(void * pWaitItem, unsigned Timeout);
Nvoid USBH_OS_SignalItem   (void * pWaitItem);
Nvoid USBH_OS_AddTickHook  (void(* pfHook)(void));
N
Nvoid USBH_Task                (void);
Nchar USBH_IsExpired           (I32 Time);
Xchar USBH_IsExpired           (signed long Time);
Nint  USBH_GetVersion          (void);
Nvoid USBH_Init                (void);
Nvoid USBH_X_Config            (void);
Nvoid USBH_AssignMemory        (U32 * pMem, U32 NumBytes);
Xvoid USBH_AssignMemory        (unsigned long * pMem, unsigned long NumBytes);
Nvoid USBH_AssignTransferMemory(U32 * pMem, U32 NumBytes);
Xvoid USBH_AssignTransferMemory(unsigned long * pMem, unsigned long NumBytes);
N
N// Direction types
N#define USB_IN_DIRECTION      0x80
N#define USB_OUT_DIRECTION     0x00
N
N// Request Type Direction
N#define USB_TO_DEVICE         0
N#define USB_TO_HOST           0x80
N
N// End Point types
N#define USB_EP_TYPE_CONTROL   0x00
N#define USB_EP_TYPE_ISO       0x01
N#define USB_EP_TYPE_BULK      0x02
N#define USB_EP_TYPE_INT       0x03
N
N// bcdUSB
N#define USB_1                 0x0110
N#define USB_2                 0x0210
N
N// USB descriptor types
N#define USB_DEVICE_DESCRIPTOR_TYPE                    0x01
N#define USB_CONFIGURATION_DESCRIPTOR_TYPE             0x02
N#define USB_STRING_DESCRIPTOR_TYPE                    0x03
N#define USB_INTERFACE_DESCRIPTOR_TYPE                 0x04
N#define USB_ENDPOINT_DESCRIPTOR_TYPE                  0x05
N#define USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE          0x06
N#define USB_OTHER_SPEED_CONFIGURATION_DESCRIPTOR_TYPE 0x07
N#define USB_INTERFACE_ASSOCIATION_TYPE                0x0B
N#define USB_HID_DESCRIPTOR_TYPE                       0x21
N#define USB_HID_DESCRIPTOR_TYPE_REPORT                0x22
N
N// Defines for Standard Configruation pDescriptor
N// bmAttributes
N#define USB_CONF_BUSPWR                               0x80 // Config. attribute: Bus powered
N#define USB_CONF_SELFPWR                              0x40 // Config. attribute: Self powered
N#define USB_CONF_REMOTE_WAKEUP                        0x20 // Config. attribute: Remote Wakeup
N
N// USB classes
N#define USB_DEVICE_CLASS_RESERVED                     0x00
N#define USB_DEVICE_CLASS_AUDIO                        0x01
N#define USB_DEVICE_CLASS_COMMUNICATIONS               0x02
N#define USB_DEVICE_CLASS_HUMAN_INTERFACE              0x03
N#define USB_DEVICE_CLASS_MONITOR                      0x04
N#define USB_DEVICE_CLASS_PHYSICAL_INTERFACE           0x05
N#define USB_DEVICE_CLASS_POWER                        0x06
N#define USB_DEVICE_CLASS_PRINTER                      0x07
N#define USB_DEVICE_CLASS_STORAGE                      0x08
N#define USB_DEVICE_CLASS_HUB                          0x09
N#define USB_DEVICE_CLASS_DATA                         0x0A
N#define USB_DEVICE_CLASS_VENDOR_SPECIFIC              0xFF
N
N// HID protocol and subclass definitions
N#define HID_DEVICE_BOOT_INTERFACE_SUBCLASS            0x01
N#define HID_DEVICE_KEYBOARD_PROTOCOL                  0x01
N#define HID_DEVICE_MOUSE_PROTOCOL                     0x02
N
N// USB endpoint types
N#define USB_ENDPOINT_TYPE_CONTROL                     0x00
N#define USB_ENDPOINT_TYPE_ISOCHRONOUS                 0x01
N#define USB_ENDPOINT_TYPE_BULK                        0x02
N#define USB_ENDPOINT_TYPE_INTERRUPT                   0x03
N
N// Setup Request Types
N#define USB_REQTYPE_MASK                              0x60 // Used to mask off request type
N#define USB_REQTYPE_STANDARD                          0x00 // Standard Request
N#define USB_REQTYPE_CLASS                             0x20 // Class Request
N#define USB_REQTYPE_VENDOR                            0x40 // Vendor Request
N#define USB_REQTYPE_RESERVED                          0x60 // Reserved or illegal request
N
N// Request Type Recipient
N#define USB_RECIPIENT_MASK                            0x1F // Bitsd D0..D4
N#define USB_DEVICE_RECIPIENT                          0
N#define USB_INTERFACE_RECIPIENT                       1
N#define USB_ENDPOINT_RECIPIENT                        2
N#define USB_OTHER_RECIPIENT                           3
N#define USB_RESERVED_RECIPIENT                        4
N
N// bRequest in USB Device Request
N// Standard Request Codes
N#define USB_REQ_GET_STATUS                            0x00
N#define USB_REQ_CLEAR_FEATURE                         0x01
N#define USB_REQ_SET_FEATURE                           0x03
N#define USB_REQ_SET_ADDRESS                           0x05
N#define USB_REQ_GET_DESCRIPTOR                        0x06
N#define USB_REQ_SET_DESCRIPTOR                        0x07
N#define USB_REQ_GET_CONFIGURATION                     0x08
N#define USB_REQ_SET_CONFIGURATION                     0x09
N#define USB_REQ_GET_INTERFACE                         0x0A
N#define USB_REQ_SET_INTERFACE                         0x0B
N#define USB_REQ_SYNCH_FRAME                           0x0C
N
N// GetStatus Requests Recipients and STATUS Codes
N#define USB_STATUS_DEVICE                             0x80 // Get Status: Device
N#define USB_STATUS_INTERFACE                          0x81 // Get Status: Interface
N#define USB_STATUS_ENDPOINT                           0x82 // Get Status: End Point
N#define USB_STATUS_SELF_POWERED                       0x01
N#define USB_STATUS_REMOTE_WAKEUP                      0x02
N#define USB_STATUS_ENDPOINT_HALT                      0x01
N#define USB_STATUS_LENGTH                             2 // 2 byte
N
N// Standard Feature Selectors
N#define USB_FEATURE_REMOTE_WAKEUP                     0x01
N#define USB_FEATURE_STALL                             0x00
N#define USB_FEATURE_TEST_MODE                         0x02
N
N// Common descriptor indexes
N#define USB_DESC_LENGTH_INDEX                         0
N#define USB_DESC_TYPE_INDEX                           1
N
Ntypedef struct USB_DEVICE_DESCRIPTOR { // Device descriptor
N  U8  bLength;
X  unsigned char  bLength;
N  U8  bDescriptorType;
X  unsigned char  bDescriptorType;
N  U16 bcdUSB;
X  unsigned short bcdUSB;
N  U8  bDeviceClass;
X  unsigned char  bDeviceClass;
N  U8  bDeviceSubClass;
X  unsigned char  bDeviceSubClass;
N  U8  bDeviceProtocol;
X  unsigned char  bDeviceProtocol;
N  U8  bMaxPacketSize0;
X  unsigned char  bMaxPacketSize0;
N  U16 idVendor;
X  unsigned short idVendor;
N  U16 idProduct;
X  unsigned short idProduct;
N  U16 bcdDevice;
X  unsigned short bcdDevice;
N  U8  iManufacturer;
X  unsigned char  iManufacturer;
N  U8  iProduct;
X  unsigned char  iProduct;
N  U8  iSerialNumber;
X  unsigned char  iSerialNumber;
N  U8  bNumConfigurations;
X  unsigned char  bNumConfigurations;
N} USB_DEVICE_DESCRIPTOR;
N
N#define USB_DEVICE_DESCRIPTOR_LENGTH                  (18)
N
Ntypedef struct USB_CONFIGURATION_DESCRIPTOR { // Configuration descriptor
N  U8  bLength;
X  unsigned char  bLength;
N  U8  bDescriptorType;
X  unsigned char  bDescriptorType;
N  U16 wTotalLength;
X  unsigned short wTotalLength;
N  U8  bNumInterfaces;
X  unsigned char  bNumInterfaces;
N  U8  bConfigurationValue;
X  unsigned char  bConfigurationValue;
N  U8  iConfiguration;
X  unsigned char  iConfiguration;
N  U8  bmAttributes;
X  unsigned char  bmAttributes;
N  U8  MaxPower;
X  unsigned char  MaxPower;
N} USB_CONFIGURATION_DESCRIPTOR;
N
N#define USB_CONFIGURATION_DESCRIPTOR_LENGTH             (9)
N#define USB_CONFIGURATION_DESCRIPTOR_BMATTRIBUTES_INDEX (7)
N#define USB_CONFIGURATION_DESCRIPTOR_WTOTALLENGTH_INDEX (2)
N#define USB_CONFIGURATION_DESCRIPTOR_POWER_INDEX        (8)
N
Ntypedef struct USB_INTERFACE_DESCRIPTOR { // Interface descriptor
N  U8 bLength;
X  unsigned char bLength;
N  U8 bDescriptorType;
X  unsigned char bDescriptorType;
N  U8 bInterfaceNumber;
X  unsigned char bInterfaceNumber;
N  U8 bAlternateSetting;
X  unsigned char bAlternateSetting;
N  U8 bNumEndpoints;
X  unsigned char bNumEndpoints;
N  U8 bInterfaceClass;
X  unsigned char bInterfaceClass;
N  U8 bInterfaceSubClass;
X  unsigned char bInterfaceSubClass;
N  U8 bInterfaceProtocol;
X  unsigned char bInterfaceProtocol;
N  U8 iInterface;
X  unsigned char iInterface;
N} USB_INTERFACE_DESCRIPTOR;
N
N#define USB_INTERFACE_DESCRIPTOR_LENGTH               (9)
N#define USB_INTERFACE_DESC_NUMBER_OFS                 2
N#define USB_INTERFACE_DESC_CLASS_OFS                  5
N#define USB_INTERFACE_DESC_SUBCLASS_OFS               6
N#define USB_INTERFACE_DESC_PROTOCOL_OFS               7
N
Ntypedef struct USB_ENDPOINT_DESCRIPTOR { // Endpoint descriptor
N  U8  bLength;
X  unsigned char  bLength;
N  U8  bDescriptorType;
X  unsigned char  bDescriptorType;
N  U8  bEndpointAddress;
X  unsigned char  bEndpointAddress;
N  U8  bmAttributes;
X  unsigned char  bmAttributes;
N  U16 wMaxPacketSize;
X  unsigned short wMaxPacketSize;
N  U8  bInterval;
X  unsigned char  bInterval;
N} USB_ENDPOINT_DESCRIPTOR;
N
N#define USB_ENDPOINT_DESCRIPTOR_LENGTH                (7)
N#define USB_EP_DESC_ADDRESS_OFS                       2
N#define USB_EP_DESC_ATTRIB_OFS                        3
N#define USB_EP_DESC_PACKET_SIZE_OFS                   4
N#define USB_EP_DESC_INTERVAL_OFS                      6
N#define USB_EP_DESC_ATTRIB_MASK                       0x03
N#define USB_EP_DESC_DIR_MASK                          0x80
N
Ntypedef struct USB_STRING_DESCRIPTOR { // String descriptor
N  U8  bLength;
X  unsigned char  bLength;
N  U8  bDescriptorType;
X  unsigned char  bDescriptorType;
N  U16 bString[1];                        // Variable size
X  unsigned short bString[1];                        
N} USB_STRING_DESCRIPTOR;
N
N#define USB_STRING_HEADER_LENGTH                      2
N#define USB_LANGUAGE_DESC_LENGTH                      (4)
N#define USB_LANGUAGE_ID                               (0x0409)
N
Ntypedef struct USB_DEVICE_QUALIFIER_DESCRIPTOR { // Device qualifier descriptor
N  U8  bLength;
X  unsigned char  bLength;
N  U8  bDescriptorType;
X  unsigned char  bDescriptorType;
N  U16 bcdUSB;
X  unsigned short bcdUSB;
N  U8  bDeviceClass;
X  unsigned char  bDeviceClass;
N  U8  bDeviceSubClass;
X  unsigned char  bDeviceSubClass;
N  U8  bDeviceProtocol;
X  unsigned char  bDeviceProtocol;
N  U8  bMaxPacketSize0;
X  unsigned char  bMaxPacketSize0;
N  U8  bNumConfigurations;
X  unsigned char  bNumConfigurations;
N  U8  bReserved;
X  unsigned char  bReserved;
N} USB_DEVICE_QUALIFIER_DESCRIPTOR;
N
N#define USB_DEVICE_QUALIFIER_DESCRIPTOR_LENGTH        (10)
N
Ntypedef struct USB_INTERFACE_ASSOCIATION_DESCRIPTOR { // Interface association descriptor
N  U8 bLength;
X  unsigned char bLength;
N  U8 bDescriptorType;
X  unsigned char bDescriptorType;
N  U8 bFirstInterface;
X  unsigned char bFirstInterface;
N  U8 bInterfaceCount;
X  unsigned char bInterfaceCount;
N  U8 bFunctionClass;
X  unsigned char bFunctionClass;
N  U8 bFunctionSubClass;
X  unsigned char bFunctionSubClass;
N  U8 bFunctionProtocol;
X  unsigned char bFunctionProtocol;
N  U8 iFunction;
X  unsigned char iFunction;
N} USB_INTERFACE_ASSOCIATION_DESCRIPTOR;
N
Ntypedef struct USB_COMMON_DESCRIPTOR { // Common descriptor header
N  U8 bLength;
X  unsigned char bLength;
N  U8 bDescriptorType;
X  unsigned char bDescriptorType;
N} USB_COMMON_DESCRIPTOR;
N
Ntypedef struct USB_SETUP_PACKET { // CS Endpoint
N  U8  Type;
X  unsigned char  Type;
N  U8  Request;
X  unsigned char  Request;
N  U16 Value;
X  unsigned short Value;
N  U16 Index;
X  unsigned short Index;
N  U16 Length;
X  unsigned short Length;
N} USBH_SETUP_PACKET;
N
N#define USB_SETUP_PACKET_LEN                          8
N#define USB_SETUP_TYPE_INDEX                          0
N#define USB_SETUP_LENGTH_INDEX_LSB                    6
N#define USB_SETUP_LENGTH_INDEX_MSB                    7
N
N/*********************************************************************
N*
N*       pHub Device Class (HDC) *
N*
N**********************************************************************
N*/
N
N// HDC specific descriptor types
N#define CDC_CS_INTERFACE_DESCRIPTOR_TYPE              0x24
N#define CDC_CS_ENDPOINT_DESCRIPTOR_TYPE               0x25
N
N// HDC Port Type Recipient. All other are device recipients!
N#define HDC_PORT_RECIPIENT USB_OTHER_RECIPIENT
N
N// pHub class descriptor
N#define HDC_MAX_HUB_DESCRIPTOR_LENGTH                 71
N#define USB_HUB_DESCRIPTOR_TYPE                       0x29
N
N// Class specific hub  descriptor
N#define HDC_DESC_PORT_NUMBER_OFS                      2
N#define HDC_DESC_CHARACTERISTICS_LOW_OFS              3
N#define HDC_DESC_CHARACTERISTICS_HIGH_OFS             4
N#define HDC_DESC_POWER_GOOD_TIME_OFS                  5
N#define HDC_DESC_MAX_CUURENT_OFS                      6
N#define HDC_DESC_DEVICE_REMOVABLE_OFS                 7
N#define HDC_DESC_POWER_SWITCH_MASK                    0x3
N#define HDC_DESC_ALL_POWER_SWITCH_VALUE               0x0
N#define HDC_DESC_SINGLE_POWER_SWITCH_VALUE            0x1
N#define HDC_DESC_COMPOUND_DEVICE_MASK                 0x4
N#define HDC_DESC_OVERCURRENT_MASK                     0x18
N#define HDC_DESC_OVERCURRENT_GLOBAL_VAL               0x0
N#define HDC_DESC_OVERCURRENT_SELECTIVE_VAL            0x08
N#define HDC_DESC_NO_OVERCURRENT_MASK                  0x10
N#define HDC_DESC_SUPPORT_INIDCATOR_MASK               0x80
N
N// pHub status request length
N#define HCD_GET_STATUS_LENGTH                         4
N#define HDC_DESC_MIN_LENGTH                           8
N
N// bRequest in USB Class Request
N// HDC Standard Request Codes
N#define HDC_REQTYPE_GET_STATUS                        0
N#define HDC_REQTYPE_CLEAR_FEATRUE                     1
N// RESERVED (used in previous specifications for GET_STATE)
N#define HDC_REQTYPE_GET_STATUS_OLD                    2
N#define HDC_REQTYPE_SET_FEATRUE                       3
N// RESERVED 4 and 5
N#define HDC_REQTYPE_GET_DESCRIPTOR                    6
N#define HDC_REQTYPE_SET_DESCRIPTOR                    7
N#define HDC_REQTYPE_CLEAR_TT_BUFFER                   8
N#define HDC_REQTYPE_RESET_TT                          9
N#define HDC_REQTYPE_GET_TT_STATE                      10
N#define HDC_REQTYPE_STOP_TT                           11
N
N// pHub class hub feature selectors
N// pHub change bits
N#define HDC_SELECTOR_C_HUB_LOCAL_POWER                0
N#define HDC_SELECTOR_C_HUB_OVER_CURRENT               1
N
N// pHub class port feature selectors
N// Port Selectors
N#define HDC_SELECTOR_PORT_CONNECTION                  0
N#define HDC_SELECTOR_PORT_ENABLE                      1
N#define HDC_SELECTOR_PORT_SUSPEND                     2
N#define HDC_SELECTOR_PORT_OVER_CURREWNT               3
N#define HDC_SELECTOR_PORT_RESET                       4
N#define HDC_SELECTOR_PORT_POWER                       8
N#define HDC_SELECTOR_PORT_LOW_SPEED                   9
N
N// Port change bits
N#define HDC_SELECTOR_C_PORT_CONNECTION                16
N#define HDC_SELECTOR_C_PORT_ENABLE                    17
N#define HDC_SELECTOR_C_PORT_SUSPEND                   18
N#define HDC_SELECTOR_C_PORT_OVER_CURRENT              19
N#define HDC_SELECTOR_C_PORT_RESET                     20
N
N// Port Selectors
N#define HDC_SELECTOR_PORT_TEST                        21
N#define HDC_SELECTOR_PORT_INDICATOR                   22
N#define HDC_GET_SELECTOR_MASK(Selector)               (((U32)0x0001)<<(Selector))
N
N// Port status bits
N#define PORT_STATUS_CONNECT                           0x00000001
N#define PORT_STATUS_ENABLED                           0x00000002
N#define PORT_STATUS_SUSPEND                           0x00000004
N#define PORT_STATUS_OVER_CURRENT                      0x00000008
N#define PORT_STATUS_RESET                             0x00000010
N#define PORT_STATUS_POWER                             0x00000100
N#define PORT_STATUS_LOW_SPEED                         0x00000200
N#define PORT_STATUS_HIGH_SPEED                        0x00000400
N#define PORT_C_ALL_MASK                               0x001F0000UL
N#define PORT_C_STATUS_CONNECT                         0x00010000UL
N#define PORT_C_STATUS_ENABLE                          0x00020000UL
N#define PORT_C_STATUS_SUSPEND                         0x00040000UL
N#define PORT_C_STATUS_OVER_CURRENT                    0x00080000UL
N#define PORT_C_STATUS_RESET                           0x00100000UL
N
N// pHub status bits
N#define HUB_STATUS_LOCAL_POWER                        0x00000001
N#define HUB_STATUS_OVER_CURRENT                       0x00000002
N#define HUB_STATUS_C_LOCAL_POWER                      0x00010000UL
N#define HUB_STATUS_C_OVER_CURRENT                     0x00020000UL
N
Ntypedef unsigned int USBH_STATUS;
N// Status Codes
N#define USBH_STATUS_SUCCESS                            0x0000
N
N// Host controller error codes
N#define USBH_STATUS_CRC                                0x0001
N#define USBH_STATUS_BITSTUFFING                        0x0002
N#define USBH_STATUS_DATATOGGLE                         0x0003
N#define USBH_STATUS_STALL                              0x0004
N#define USBH_STATUS_NOTRESPONDING                      0x0005
N#define USBH_STATUS_PID_CHECK                          0x0006
N#define USBH_STATUS_UNEXPECTED_PID                     0x0007
N#define USBH_STATUS_DATA_OVERRUN                       0x0008
N#define USBH_STATUS_DATA_UNDERRUN                      0x0009
N#define USBH_STATUS_BUFFER_OVERRUN                     0x000C
N#define USBH_STATUS_BUFFER_UNDERRUN                    0x000D
N#define USBH_STATUS_NOT_ACCESSED                       0x000F
N
N// EHCI error codes
N#define USBH_STATUS_BUFFER                             0x00010
N#define USBH_STATUS_BABBLE                             0x00011
N#define USBH_STATUS_XACT                               0x00012
N
N#define USBH_STATUS_CHANNEL_HALTED                     0x00020
N#define USBH_STATUS_CHANNEL_NAK                        0x00021
N
N// Maximum error code for an hardware error number
N#define USBH_STATUS_MAX_HARDWARE_ERROR                 0x00FF
N
N// Bus driver error codes
N#define USBH_STATUS_ERROR                              0x0101
N#define USBH_STATUS_BUFFER_OVERFLOW                    0x0102
N#define USBH_STATUS_INVALID_PARAM                      0x0103
N#define USBH_STATUS_PENDING                            0x0104
N#define USBH_STATUS_DEVICE_REMOVED                     0x0105
N#define USBH_STATUS_CANCELED                           0x0106
N
N// The endpoint, interface or device has pending requests and the operation requires no pending requests
N#define USBH_STATUS_BUSY                               0x0109
N
N// Returned on an invalid descriptor
N#define USBH_STATUS_INVALID_DESCRIPTOR                 0x0110
N
N// The endpoint has been halted. This error is reported by the USB host controller driver layer.
N// A pipe will be halted when a data transmission error (CRC, bit stuff, DATA toggle) occurs.
N#define USBH_STATUS_ENDPOINT_HALTED                    0x0111
N#define USBH_STATUS_TIMEOUT                            0x0112
N#define USBH_STATUS_PORT                               0x0113
N
N// The following additional error codes are used from the USB Mass Storage Class Driver.
N#define USBH_STATUS_LENGTH                             (0x0200)
N#define USBH_STATUS_COMMAND_FAILED                     (0x0202)
N#define USBH_STATUS_INTERFACE_PROTOCOL                 (0x0203)
N#define USBH_STATUS_INTERFACE_SUB_CLASS                (0x0204)
N#define USBH_STATUS_SENSE_STOP                         (0x0205)
N#define USBH_STATUS_SENSE_REPEAT                       (0x0206)
N#define USBH_STATUS_WRITE_PROTECT                      (0x0207)
N
N// System errors
N#define USBH_STATUS_INVALID_ALIGNMENT                  0x1007
N#define USBH_STATUS_MEMORY                             0x1008
N#define USBH_STATUS_RESOURCES                          0x1009
N#define USBH_STATUS_DEMO                               0x2000
N
N// URBs HcFlags allowed values
N#define URB_CANCEL_PENDING_MASK                       0x01 // Pending URB must be canceled
N
N// pHub initialization state machine
Ntypedef enum {
N  USBH_SUBSTATE_IDLE,                                     // Idle, if an URB is completed or if no URb is submitted and an Timeout occurrs!
N  USBH_SUBSTATE_TIMER,                                    // USBH_URB_SubStateWait on success
N  USBH_SUBSTATE_TIMERURB,                                 // USBH_URB_SubStateSubmitRequest on success
N  USBH_SUBSTATE_TIMEOUT_PENDING_URB                       // On Timeout and pending URB
N} USBH_SUBSTATE_STATE;
N
Ntypedef void USBH_SUBSTATE_FUNC(void *context); // Is only called on an Timeout.
N
N// @doc
N// @module USBH_DLIST <en-> Double Linked List |
N// The module USBH_DLIST provides an implementation of a double linked list.
N// The USBH_DLIST structure and the related macros may be used for general purpose.
N
N/*********************************************************************
N*
N*       Public part (interface)
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       Private part (implementation)
N*
N**********************************************************************
N*/
N
N
N// Double linked list structure. Can be used as either a list head, or as link words.
N
N// @struct USBH_DLIST |
N//   The USBH_DLIST structure is the link element of the double linked list. It is used as either a list head, or as link entry.
N// @field  struct tDLIST * | Flink |
N//   Pointer to the successor (forward link).
N// @field  struct tDLIST * | pPrev |
N//   Pointer to the predecessor (backward link).
N// @comm By means of such elements any structures may be handled as a double linked list. The USBH_DLIST structure is to be inserted
N//   into the structure which is to be handled. A pointer to the original structure can be obtained by means of the macro <f STRUCT_BASE_POINTER>.
Ntypedef struct USBH_DLIST USBH_DLIST;
Nstruct USBH_DLIST {
N  USBH_DLIST * pNext;
N  USBH_DLIST * pPrev;
N};
N
N
N#define HCM_ASSERT_ITEMHEADER_ADDRESS(pPool,Itemheader)                          \
N        USBH_ASSERT(    (void*) (Itemheader) >= (void*)(pPool)->pItemHeaderStartAddr \
N                  && (void*) (Itemheader) <= (void*)(pPool)->pItemHeaderEndAddr)
X#define HCM_ASSERT_ITEMHEADER_ADDRESS(pPool,Itemheader)                                  USBH_ASSERT(    (void*) (Itemheader) >= (void*)(pPool)->pItemHeaderStartAddr                   && (void*) (Itemheader) <= (void*)(pPool)->pItemHeaderEndAddr)
N
N#define HCM_PHY_ADDR_IN_POOL(pPool, PhyAddr)                                     \
N        (    (PhyAddr) >= (pPool) ->ContiguousMemoryPhyAddr                      \
N          && (PhyAddr) <= (pPool) ->EndContiguousMemoryPhyAddr)
X#define HCM_PHY_ADDR_IN_POOL(pPool, PhyAddr)                                             (    (PhyAddr) >= (pPool) ->ContiguousMemoryPhyAddr                                && (PhyAddr) <= (pPool) ->EndContiguousMemoryPhyAddr)
N
N#define HCM_ASSERT_PHY_MEMORY(pPool,PhyAddr) USBH_ASSERT(HCM_PHY_ADDR_IN_POOL((pPool), (PhyAddr))
N
N//
N// Generic pool handling
N//
N#define HcmPoolEmpty(pPool) ((pPool)->pHead == NULL) // Returns true if pool is empty
N
N#if (USBH_DEBUG > 1)                            // Get an item from pool / MUST ONLY be called if pool is NOT empty!
X#if (2 > 1)                            
N  #define HcmPoolGet(pPool, Item) {    \
N    (Item)       = (pPool)->pHead;      \
N    (pPool)->RefCount++;               \
N    (pPool)->pHead = (Item)->Link.Next; \
N  }
X  #define HcmPoolGet(pPool, Item) {        (Item)       = (pPool)->pHead;          (pPool)->RefCount++;                   (pPool)->pHead = (Item)->Link.Next;   }
N#else
S  #define HcmPoolGet(pPool, Item) {    \
S    (Item)       = (pPool)->pHead;      \
S    (pPool)->pHead = (Item)->Link.Next; \
S  }
X  #define HcmPoolGet(pPool, Item) {        (Item)       = (pPool)->pHead;          (pPool)->pHead = (Item)->Link.Next;   }
N#endif
N
N#if (USBH_DEBUG > 1)                              // Put an item into pool / implements a LIFO scheme
X#if (2 > 1)                              
N  #define HcmPoolPut(pPool, Item)      {   \
N    (Item)->Link.Next = (pPool)->pHead;  \
N    USBH_ASSERT((pPool)->RefCount != 0); \
N    (pPool)->RefCount--;                 \
N    (pPool)->pHead      = (Item);        \
N  }
X  #define HcmPoolPut(pPool, Item)      {       (Item)->Link.Next = (pPool)->pHead;      USBH_ASSERT((pPool)->RefCount != 0);     (pPool)->RefCount--;                     (pPool)->pHead      = (Item);          }
N#else
S  #define HcmPoolPut(pPool, Item) {     \
S    (Item)->Link.Next = (pPool)->pHead; \
S    (pPool)->pHead      = (Item);       \
S  }
X  #define HcmPoolPut(pPool, Item) {         (Item)->Link.Next = (pPool)->pHead;     (pPool)->pHead      = (Item);         }
N#endif
N
N// With USBH_HCM_ITEM_HEADER begins every pool item allocated in virtual memory. The user can extend this pool header by the
N// parameter SizeOfExtension in the function  Hcm_AllocPool.
Ntypedef struct USBH_HCM_ITEM_HEADER {
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32                 Magic;
X  unsigned long                 Magic;
N#endif
N  // link element, used to create chains
N  union {
N    struct USBH_HCM_ITEM_HEADER * Next;
N    USBH_DLIST                    ListEntry;
N  } Link;
N  volatile U32           PhyAddr;            // Physical start address of associated contiguous memory
X  volatile unsigned long           PhyAddr;            
N  struct USBH_HCM_POOL * pOwningPool;         // Pointer to pool the descriptor was allocated from
N} USBH_HCM_ITEM_HEADER;
N
Ntypedef struct USBH_HCM_POOL {
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32 Magic;
X  unsigned long Magic;
N#endif
N  U32               ContiguousMemoryPhyAddr;
X  unsigned long               ContiguousMemoryPhyAddr;
N  void            * pItemHeaderStartAddr;      // Start address of not contiguous memory, used to release the memory
N  USBH_HCM_ITEM_HEADER * pHead;                     // Pointer to first buffer, pHead==NULL if pool is empty
N
N  // Additional fields used for calculations
N  U32               NumberOfItems;            // Number of items should be grater than zero
X  unsigned long               NumberOfItems;            
N  U32               SizeOfItem;               // Size in bytes of item in contiguous non paged physical memory
X  unsigned long               SizeOfItem;               
N  U32               SizeOfExtension;          // Size in bytes of an item in not contiguous memory
X  unsigned long               SizeOfExtension;          
N
N  // Only for debug
N  void            * pItemHeaderEndAddr;
N  U32               EndContiguousMemoryPhyAddr;
X  unsigned long               EndContiguousMemoryPhyAddr;
N  U32               RefCount;                 // GetItem and PutItem validation ref.counter*/
X  unsigned long               RefCount;                 
N} USBH_HCM_POOL;
N
N// Get USBH_HCM_ITEM_HEADER pointer from pointer to embedded USBH_DLIST ListEntry
N
N// Get pointer to extra space allocated after USBH_HCM_ITEM_HEADER
N#define HCM_ITEM_HEADER_EXTRA_SPACE(ItemHeaderPtr) ((void*)((ItemHeaderPtr) + 1))
N
N// Get USBH_HCM_ITEM_HEADER pointer from pointer to extra space
N// lint -emacro((740),HCM_ITEM_HEADER_FROM_EXTRA_SPACE)
N#define HCM_ITEM_HEADER_FROM_EXTRA_SPACE(pes) (((USBH_HCM_ITEM_HEADER *)(void *)(pes)) - 1)
N
NUSBH_STATUS            USBH_HCM_AllocPool         (USBH_HCM_POOL        * Pool,    U32 NumberOfItems, U32 SizeOfPhysItem, U32 SizeOfExtension, U32 Alignment);
XUSBH_STATUS            USBH_HCM_AllocPool         (USBH_HCM_POOL        * Pool,    unsigned long NumberOfItems, unsigned long SizeOfPhysItem, unsigned long SizeOfExtension, unsigned long Alignment);
Nvoid                   USBH_HCM_FreePool          (USBH_HCM_POOL        * MemPool);
NUSBH_HCM_ITEM_HEADER * USBH_HCM_GetItem           (USBH_HCM_POOL        * MemPool);
NUSBH_HCM_ITEM_HEADER * USBH_HCM_GetItemFromPhyAddr(USBH_HCM_POOL        * MemPool, U32 PhyAddr);
XUSBH_HCM_ITEM_HEADER * USBH_HCM_GetItemFromPhyAddr(USBH_HCM_POOL        * MemPool, unsigned long PhyAddr);
Nvoid                   USBH_HCM_PutItem           (USBH_HCM_ITEM_HEADER * Item);
Nvoid                   USBH_HCM_FillPhyMemory     (USBH_HCM_ITEM_HEADER * Item,    U8 Val);
Xvoid                   USBH_HCM_FillPhyMemory     (USBH_HCM_ITEM_HEADER * Item,    unsigned char Val);
NU32                    USBH_HCM_IsPhysAddrInPool  (USBH_HCM_POOL        * MemPool, U32 PhyAddr);
Xunsigned long                    USBH_HCM_IsPhysAddrInPool  (USBH_HCM_POOL        * MemPool, unsigned long PhyAddr);
N
N// The following defines must not be changed!
N#define OH_DEV_MAX_TRANSFER_DESC      (9)                           // default value: 7 (reserved for enumeration)
N#define OH_DEV_ENUMERATION_CONTROL_EP 7                             // +1=dummy endpoint
N#define USBH_OHCI_MAX_BULK_EP            (USBH_Global.Config.NumBulkEndpoints + 1) // +1=dummy endpoint
N#define USBH_OHCI_MAX_CONTROL_EP         (USBH_Global.Config.NumUSBDevices + OH_DEV_ENUMERATION_CONTROL_EP + 1)
N#define USBH_OHCI_MAX_INT_EP             (USBH_Global.Config.NumIntEndpoints)
N#define USBH_OHCI_MAX_ISO_EP             (USBH_Global.Config.NumIsoEndpoints)
N
N
N
N#define OH_DEV_MAX_ISO_TD             (USBH_OHCI_MAX_ISO_EP * OH_DEV_MAX_TRANSFER_DESC)                         // Maximum number of ISO pEp host controller TD's
N#define OH_DEV_MAX_BULK_TD            (USBH_OHCI_MAX_BULK_EP * OH_DEV_MAX_TRANSFER_DESC)                              // Maximum number of BULK pEp host controller TD's
N#define OH_DEV_MAX_INT_TD             (USBH_OHCI_MAX_INT_EP * OH_DEV_MAX_TRANSFER_DESC)                   // Maximum number of INTERRUPT pEp host controller TD's*, dummy endpoint have not transfer descriptors !!!
N#define OH_DEV_MAX_CONTROL_TD         (USBH_OHCI_MAX_CONTROL_EP + (USBH_OHCI_MAX_CONTROL_EP * OH_DEV_MAX_TRANSFER_DESC)) // Maximum number of CONTROL pEp host controller TD's
N
N#define OH_TOTAL_GTD                  (OH_DEV_MAX_BULK_TD + OH_DEV_MAX_CONTROL_TD)                                 // Number transfer and endpoint descriptors.
N#define OH_TOTAL_ED                   (USBH_OHCI_MAX_ISO_EP + USBH_OHCI_MAX_INT_EP + USBH_OHCI_MAX_BULK_EP + USBH_OHCI_MAX_CONTROL_EP + OHD_DUMMY_INT_NUMBER)
N
N#define OH_MAX_ED_SIZE                (OH_ED_SIZE + OH_ED_ALIGNMENT)
N#define OH_MAX_TD_SIZE                (OH_GTD_SIZE + OH_GTD_ALIGNMENT)
N
N// HCCA
N#define OH_HCCA_LENGTH         256
N#define OH_HCCA_ALIGNMENT      256
N#define OH_HCCA_MAX_SIZE       (OH_HCCA_LENGTH+OH_HCCA_ALIGNMENT)
N
N// This defines includes also the setup buffer for all control endpoint and the additional transfer buffer in the host driver.
N// It does not include any from user allocated physical buffer
N#define OH_OHCI_MEMORY_SIZE           ((OH_MAX_ED_SIZE*OH_TOTAL_ED) + (OH_TOTAL_GTD*OH_MAX_TD_SIZE) + OH_HCCA_MAX_SIZE + (OH_DEV_MAX_CONTROL_TD*8))
N
N// OHD_BULK_INT_EP AbortMask values
N#define EP_ABORT_MASK                 0x0001UL // 1. Endpoint is skipped and an timer with an Timeout of about two frames is started
N#define EP_ABORT_SKIP_TIME_OVER_MASK  0x0002UL // 2. Endpoint skip Timeout is over
N#define EP_ABORT_PROCESS_FLAG_MASK    0x0004UL // 3. temporary flag to process the aborted endpoint
N#define EP_ABORT_START_TIMER_MASK     0x0008UL // additional flag to restart the abort timer in the timer routine if another endpoint
N
N// Only handled interrupts generate are enabled. Unrecoverable error (HC_INT_UE) and ownerchip change (HC_INT_OC) are enabled
N// because of detecting invalid host controller states!
N#define OH_ENABLED_INTERRUPTS     (HC_INT_WDH |  HC_INT_FNO | HC_INT_RHSC | HC_INT_UE | HC_INT_OC)
N
N// Unhandled interrupts status bits are also checked. Process interrupts does nothing with the following interrupt status bits
N#define OH_NOT_HANDLED_INTERRUPTS (HC_INT_SO | HC_INT_SF | HC_INT_RD | HC_INT_UE | HC_INT_OC)
N
N// Frame interval in bit times
N#define OH_DEV_NOT_USED_BITTIMES    (210 )
N#define OH_DEV_FRAME_INTERVAL       (11999) /* 12000 bits per frame (-1) */
N#define OH_DEV_LARGEST_DATA_PACKET  ((6 * (OH_DEV_FRAME_INTERVAL - OH_DEV_NOT_USED_BITTIMES)) / 7)
N#define OH_DEV_DEFAULT_FMINTERVAL   ((OH_DEV_LARGEST_DATA_PACKET << 16 ) | OH_DEV_FRAME_INTERVAL)
N#define OH_DEV_LOW_SPEED_THRESHOLD  0x0628
N
N#define OH_STOP_DELAY_TIME  2 // Delay time in ms until an stopped endpoint list is not processed for the HC
N
N// Default addresses used e.g. for creating dummy endpoints
N#define OH_DEFAULT_DEV_ADDR                 0
N#define OH_DEFAULT_EP_ADDR                  0
N#define OH_DEFAULT_SPEED                    USBH_FULL_SPEED
N#define OH_DEFAULT_MAX_PKT_SIZE             64
N
N// Maximum wait time in the initialization routine to wait for clearing the interrupt routing bit from BIOS after Ownerchangerequest was set!
N#define OH_OWNER_CHANGE_WAIT_TIME 500000 // in us = 500 ms
N#define OH_OWNER_CHANGE_TEST_TIME   1000 // in us = 1 ms
N#define OH_TIME_SOFTWARE_RESET        30 // in us
N#define OH_RESUME_TIME             30000 // 30ms in us
N#define OH_RESET_STATE_TIMEOUT     30000 // 10ms in us - Timout where the OHCI controller is hold in the reset state
N
N/*********************************************************************
N*
N*       Endpoint and transfer descriptor definitions and macros
N*
N**********************************************************************
N*/
Ntypedef enum {
N  USBH_OHCI_DEV_STATE_HALT,
N  USBH_OHCI_DEV_STATE_SUSPEND, // From USBH_OHCI_DEV_STATE_SUSPEND only halt or resume is allowed, if the host is reset then the host not be in suspend!
N  USBH_OHCI_DEV_STATE_RESUME,
N  USBH_OHCI_DEV_STATE_RUNNING
N} USBH_OHCI_DEV_STATE;
N
N// Used to transfer data from bulk control and interrupt endpoints if the transfer memory does not support bus master transfer
Ntypedef struct USBH_OHCI_TRANSFER_BUFFER {
N  USBH_HCM_ITEM_HEADER   ItemHeader;
N  U8              * pUrbBuffer;       // Current buffer pointer
X  unsigned char              * pUrbBuffer;       
N  U32               Transferred;     // Transferred length
X  unsigned long               Transferred;     
N  U32               RemainingLength; // IN: size of URB buffer OUT:not transferred bytes
X  unsigned long               RemainingLength; 
N  int               UsbToHostFlag;   // True: USB IN transfer
N} USBH_OHCI_TRANSFER_BUFFER;
N
N
N/*********************************************************************
N*
N* The USB Bus Driver Core is a software which handles the complete basic function of a USB host controller. It provides a
N* software interface that can be used to implement applications or class drivers on an abstract level.
N*
N* The USB Bus Driver Core manages the
N* - enumeration of the devices
N* - hot plug and play handling
N* - PnP notification events
N* - band width management
N* - priority schedule for the transfer types
N* - external HUB's (optional)
N*
N* The USB Bus Driver must be synchronized externally. The USB Bus Driver requires functions from an OS
N* like "Wait on an event" or "Wait for a time". See the OS abstraction layer for details.
N*
N**********************************************************************
N*/
N
N// The API interface uses the prefix UBD for USB Bus Driver. This should prevent conflicts with other libraries.
N
Ntypedef void * USBH_NOTIFICATION_HANDLE; // Handle for the notification
N
N/*********************************************************************
N*
N*       PnP and enumeration
N*
N**********************************************************************
N*/
N
Ntypedef unsigned int USBH_INTERFACE_ID; // This ID identifies an interface in a unique way, a value of zero represents an invalid ID!
Ntypedef unsigned int USBH_DEVICE_ID;    // This ID identifies a device in a unique way
N
N// Mask bits for device mask
N#define USBH_INFO_MASK_VID       0x0001
N#define USBH_INFO_MASK_PID       0x0002
N#define USBH_INFO_MASK_DEVICE    0x0004
N#define USBH_INFO_MASK_INTERFACE 0x0008
N#define USBH_INFO_MASK_CLASS     0x0010
N#define USBH_INFO_MASK_SUBCLASS  0x0020
N#define USBH_INFO_MASK_PROTOCOL  0x0040
N
N// This structure is used to describe a device. The mask contains the information, which fields are valid.
N// If the Mask is 0 the function USBH_ON_PNP_EVENT_FUNC is called for all interfaces.
Ntypedef struct USBH_INTERFACE_MASK {
N  U16 Mask;
X  unsigned short Mask;
N  U16 VendorId;
X  unsigned short VendorId;
N  U16 ProductId;
X  unsigned short ProductId;
N  U16 bcdDevice;
X  unsigned short bcdDevice;
N  U8  Interface;
X  unsigned char  Interface;
N  U8  Class;
X  unsigned char  Class;
N  U8  SubClass;
X  unsigned char  SubClass;
N  U8  Protocol;
X  unsigned char  Protocol;
N} USBH_INTERFACE_MASK;
N
Ntypedef void * USBH_INTERFACE_LIST_HANDLE; // Handle to the interface list
N
Ntypedef enum {
N  USBH_SPEED_UNKNOWN,
N  USBH_LOW_SPEED,
N  USBH_FULL_SPEED,
N  USBH_HIGH_SPEED
N} USBH_SPEED;
N
N// This structure contains information about a USB interface and the related device
Ntypedef struct USBH_INTERFACE_INFO {
N  USBH_INTERFACE_ID InterfaceId;
N  USBH_DEVICE_ID    DeviceId;
N  U16               VendorId;
X  unsigned short               VendorId;
N  U16               ProductId;
X  unsigned short               ProductId;
N  U16               bcdDevice;
X  unsigned short               bcdDevice;
N  U8                Interface;
X  unsigned char                Interface;
N  U8                Class;
X  unsigned char                Class;
N  U8                SubClass;
X  unsigned char                SubClass;
N  U8                Protocol;
X  unsigned char                Protocol;
N  unsigned int      OpenCount;
N  U8                ExclusiveUsed;
X  unsigned char                ExclusiveUsed;
N  USBH_SPEED        Speed;
N  U8                acSerialNumber[256]; // The serial number in UNICODE format, not zero terminated
X  unsigned char                acSerialNumber[256]; 
N  U8                SerialNumberSize;  // The size of the serial number, 0 means not available or error during request
X  unsigned char                SerialNumberSize;  
N} USBH_INTERFACE_INFO;
N
N/*********************************************************************
N*
N*       Compatibility macros
N*
N**********************************************************************
N*/
N#define USBH_GetInterfaceID(hInterfaceList, Index)   USBH_GetInterfaceId(hInterfaceList, Index)
N
NUSBH_INTERFACE_LIST_HANDLE USBH_CreateInterfaceList (USBH_INTERFACE_MASK        * pInterfaceMask, unsigned int * pInterfaceCount);
Nvoid                       USBH_DestroyInterfaceList(USBH_INTERFACE_LIST_HANDLE   hInterfaceList);
NUSBH_INTERFACE_ID          USBH_GetInterfaceId      (USBH_INTERFACE_LIST_HANDLE   hInterfaceList, unsigned int Index);
NUSBH_STATUS                USBH_GetInterfaceInfo    (USBH_INTERFACE_ID            InterfaceId, USBH_INTERFACE_INFO * pInterfaceInfo);
N
N// Events for the PnP function
Ntypedef enum {
N  USBH_ADD_DEVICE,
N  USBH_REMOVE_DEVICE
N} USBH_PNP_EVENT;
N
N// This function is called by the USB Bus Driver Core if a PnP event occurs.
N// It is typically called the first time in the pContext of USBH_RegisterPnPNotification.
Ntypedef void USBH_ON_PNP_EVENT_FUNC(void * pContext, USBH_PNP_EVENT Event, USBH_INTERFACE_ID InterfaceId);
N
N// struct USBH_PNP_NOTIFICATION is used as parameter to notification functions
Ntypedef struct USBH_PNP_NOTIFICATION {
N  USBH_ON_PNP_EVENT_FUNC * pfPnpNotification; // The notification function
N  void                   * pContext;         // The notification pContext, passed to USBH_RegisterPnPNotification
N  USBH_INTERFACE_MASK      InterfaceMask;   // Mask to the interface
N} USBH_PNP_NOTIFICATION;
N
NUSBH_NOTIFICATION_HANDLE           USBH_RegisterPnPNotification    (USBH_PNP_NOTIFICATION    * pPnPNotification);
Nvoid                               USBH_UnregisterPnPNotification  (USBH_NOTIFICATION_HANDLE   Handle);
Ntypedef void                     * USBH_ENUM_ERROR_HANDLE; // Handle for the notification
N
N// Error type
N#define UDB_ENUM_ERROR_EXTHUBPORT_FLAG  0x01 // The device is connected to an external hub
N#define USBH_ENUM_ERROR_RETRY_FLAG      0x02 // The enumeration is retried
N#define USBH_ENUM_ERROR_STOP_ENUM_FLAG  0x04 // The enumeration is stopped after retries
N#define USBH_ENUM_ERROR_DISCONNECT_FLAG 0x08
N// Additional information. The parent port status is disconnected, this means the USB device is not connected or it is connected
N// and has an error. USBH_RestartEnumError() does nothing if  the  port status is disconnected.
N
N// Error location
N#define USBH_ENUM_ERROR_ROOT_PORT_RESET 0x10 // Error during reset of a USB device on an root hub port
N#define USBH_ENUM_ERROR_HUB_PORT_RESET  0x20 // Error during reset of a USB device on an external hub port
N#define UDB_ENUM_ERROR_INIT_DEVICE      0x30 // Error during initialization of an device until it is in the configured state
N#define UDB_ENUM_ERROR_INIT_HUB         0x40 // Error during initialization of an configured external hub device until the installation of an interrupt IN status pipe
N#define USBH_ENUM_ERROR_LOCATION_MASK  (USBH_ENUM_ERROR_ROOT_PORT_RESET      | \
N                                        USBH_ENUM_ERROR_HUB_PORT_RESET       | \
N                                        UDB_ENUM_ERROR_INIT_DEVICE           | \
N                                        UDB_ENUM_ERROR_INIT_HUB)
X#define USBH_ENUM_ERROR_LOCATION_MASK  (USBH_ENUM_ERROR_ROOT_PORT_RESET      |                                         USBH_ENUM_ERROR_HUB_PORT_RESET       |                                         UDB_ENUM_ERROR_INIT_DEVICE           |                                         UDB_ENUM_ERROR_INIT_HUB)
N
N// This struct is only for information
Ntypedef struct USBH_ENUM_ERROR {
N  int         Flags;
N  int         PortNumber;
N  USBH_STATUS Status;
N  int         ExtendedErrorInformation; // For internal contains an state value
N} USBH_ENUM_ERROR;
N
N// This function is called by the USB Bus Driver Core if a error during USB device enumeration occurs.
N// To install this notification routine USBH_RegisterEnumErrorNotification() must be called.
Ntypedef void           USBH_ON_ENUM_ERROR_FUNC             (void * pContext, const USBH_ENUM_ERROR   * pfEnumError);
NUSBH_ENUM_ERROR_HANDLE USBH_RegisterEnumErrorNotification  (void * pContext, USBH_ON_ENUM_ERROR_FUNC * pfEnumErrorCallback);
Nvoid                   USBH_UnregisterEnumErrorNotification(USBH_ENUM_ERROR_HANDLE Handle);
Nvoid                   USBH_RestartEnumError               (void);
N
N// Used to access an interface
Ntypedef void        * USBH_INTERFACE_HANDLE;
NUSBH_STATUS           USBH_OpenInterface  (USBH_INTERFACE_ID InterfaceId, U8 Exclusive, USBH_INTERFACE_HANDLE * InterfaceHandle);
XUSBH_STATUS           USBH_OpenInterface  (USBH_INTERFACE_ID InterfaceId, unsigned char Exclusive, USBH_INTERFACE_HANDLE * InterfaceHandle);
Nvoid                  USBH_CloseInterface (USBH_INTERFACE_HANDLE hInterface);
N
N/*******************************************************************************
N*
N*       Information requests
N*
N********************************************************************************
N*/
N
NUSBH_STATUS USBH_GetDeviceDescriptor              (USBH_INTERFACE_HANDLE hInterface, U8 * pBuffer, unsigned int * pBufferSize);
XUSBH_STATUS USBH_GetDeviceDescriptor              (USBH_INTERFACE_HANDLE hInterface, unsigned char * pBuffer, unsigned int * pBufferSize);
NUSBH_STATUS USBH_GetCurrentConfigurationDescriptor(USBH_INTERFACE_HANDLE hInterface, U8 * pBuffer, unsigned int * pBufferSize);
XUSBH_STATUS USBH_GetCurrentConfigurationDescriptor(USBH_INTERFACE_HANDLE hInterface, unsigned char * pBuffer, unsigned int * pBufferSize);
NUSBH_STATUS USBH_GetSerialNumber                  (USBH_INTERFACE_HANDLE hInterface, U8 * pBuffer, unsigned int * pBufferSize);
XUSBH_STATUS USBH_GetSerialNumber                  (USBH_INTERFACE_HANDLE hInterface, unsigned char * pBuffer, unsigned int * pBufferSize);
NUSBH_STATUS USBH_GetInterfaceDescriptor           (USBH_INTERFACE_HANDLE hInterface, U8 AlternateSetting, U8 * pBuffer,   unsigned int * pBufferSize);
XUSBH_STATUS USBH_GetInterfaceDescriptor           (USBH_INTERFACE_HANDLE hInterface, unsigned char AlternateSetting, unsigned char * pBuffer,   unsigned int * pBufferSize);
N
N// Mask bits for device mask
N#define USBH_EP_MASK_INDEX     0x0001
N#define USBH_EP_MASK_ADDRESS   0x0002
N#define USBH_EP_MASK_TYPE      0x0004
N#define USBH_EP_MASK_DIRECTION 0x0008
N
Ntypedef struct USBH_EP_MASK {
N  U32 Mask;
X  unsigned long Mask;
N  U8  Index;
X  unsigned char  Index;
N  U8  Address;
X  unsigned char  Address;
N  U8  Type;
X  unsigned char  Type;
N  U8  Direction;
X  unsigned char  Direction;
N} USBH_EP_MASK;
N
N// It returns the endpoint descriptor for a given endpoint or returns with status invalid parameter.
NUSBH_STATUS USBH_GetEndpointDescriptor(USBH_INTERFACE_HANDLE hInterface, U8 AlternateSetting, const USBH_EP_MASK * pMask, U8 * pBuffer, unsigned int * pBufferSize);
XUSBH_STATUS USBH_GetEndpointDescriptor(USBH_INTERFACE_HANDLE hInterface, unsigned char AlternateSetting, const USBH_EP_MASK * pMask, unsigned char * pBuffer, unsigned int * pBufferSize);
NUSBH_STATUS USBH_GetDescriptor        (USBH_INTERFACE_HANDLE hInterface, U8 AlternateSetting,   U8 Type, U8 * pBuffer, unsigned * pBufferSize);
XUSBH_STATUS USBH_GetDescriptor        (USBH_INTERFACE_HANDLE hInterface, unsigned char AlternateSetting,   unsigned char Type, unsigned char * pBuffer, unsigned * pBufferSize);
NUSBH_STATUS USBH_GetDescriptorEx      (USBH_INTERFACE_HANDLE hInterface, U8 Type, U8 DescIndex, U16 LangId, U8 * pBuffer, unsigned * pBufferSize);
XUSBH_STATUS USBH_GetDescriptorEx      (USBH_INTERFACE_HANDLE hInterface, unsigned char Type, unsigned char DescIndex, unsigned short LangId, unsigned char * pBuffer, unsigned * pBufferSize);
N
N// Return the operating speed of the device.
NUSBH_STATUS USBH_GetSpeed        (USBH_INTERFACE_HANDLE hInterface, USBH_SPEED * pSpeed);
NUSBH_STATUS USBH_GetFrameNumber  (USBH_INTERFACE_HANDLE hInterface, U32 * pFrameNumber);
XUSBH_STATUS USBH_GetFrameNumber  (USBH_INTERFACE_HANDLE hInterface, unsigned long * pFrameNumber);
N
N// Returns the interface ID for a given handle
NUSBH_STATUS USBH_GetInterfaceIdByHandle(USBH_INTERFACE_HANDLE hInterface, USBH_INTERFACE_ID * pInterfaceId);
N
N/*********************************************************************
N*
N*       Async URB based requests
N*
N**********************************************************************
N*/
N
N// Function codes
Ntypedef enum USBH_FUNCTION_TAG {
N  USBH_FUNCTION_CONTROL_REQUEST,   // use USBH_CONTROL_REQUEST
N  USBH_FUNCTION_BULK_REQUEST,      // use USBH_BULK_INT_REQUEST
N  USBH_FUNCTION_INT_REQUEST,       // use USBH_BULK_INT_REQUEST
N  USBH_FUNCTION_ISO_REQUEST,       // use USBH_ISO_REQUEST
N  // A device reset starts a new enumeration of the device. PnP events for all related interfaces occur.
N  USBH_FUNCTION_RESET_DEVICE,      // use USBH_HEADER
N  USBH_FUNCTION_RESET_ENDPOINT,    // use USBH_ENDPOINT_REQUEST
N  USBH_FUNCTION_ABORT_ENDPOINT,    // use USBH_ENDPOINT_REQUEST
N  USBH_FUNCTION_SET_CONFIGURATION, // use USBH_SET_CONFIGURATION
N  USBH_FUNCTION_SET_INTERFACE,     // use USBH_SET_INTERFACE
N  USBH_FUNCTION_SET_POWER_STATE
N} USBH_FUNCTION;
N
Ntypedef struct USBH_URB USBH_URB;
Ntypedef void USBH_ON_COMPLETION_FUNC(USBH_URB * Urb); // The completion function
Ntypedef void USBH_ON_COMPLETION_USER_FUNC(void * pContextData);
N
Ntypedef struct USBH_HEADER_TAG {                            // Is common for all URB based requests
N  USBH_FUNCTION                  Function;                       // Function code defines the operation of the URB
N  USBH_STATUS                    Status;                         // Is returned by the USB Bus Driver Core
N  USBH_ON_COMPLETION_FUNC      * pfOnCompletion;                 // Completion function, must be a valid pointer is not optional
N  void                         * pContext;                       // This member can be used by the caller to store a pContext, it is not changed by the USB Bus Driver Core
N  USBH_DLIST                     ListEntry;                      // List entry to keep the URB in a list, the owner can use this entry
N  // For internal use
N  void                         * pUbdContext;                     // Context used from the UBD driver
N  USBH_ON_COMPLETION_FUNC      * pfOnInternalCompletion;          // Completion function, must be a valid pointer is not optional
N  void                         * pInternalContext;                // This member can be used by the caller to store a pContext, it is not changed by the USB Bus Driver Core
N  U32                            HcFlags;                         // Context used from the Host controller driver
X  unsigned long                            HcFlags;                         
N  USBH_ON_COMPLETION_USER_FUNC * pfOnUserCompletion;
N  void                         * pUserContext;
N} USBH_HEADER;
N
N
N// Used with USBH_FUNCTION_CONTROL_REQUEST
Ntypedef struct USBH_CONTROL_REQUEST {
N  USBH_SETUP_PACKET   Setup;    // The setup packet, direction of data phase, the length field must be valid!
N  U8                  Endpoint; // Use 0 for default endpoint
X  unsigned char                  Endpoint; 
N  void              * pBuffer;   // Pointer to the caller provided storage, can be NULL
N  U32                 Length;   // IN:- OUT: bytes transferred
X  unsigned long                 Length;   
N} USBH_CONTROL_REQUEST;
N
N// Used with USBH_FUNCTION_BULK_REQUEST and USBH_FUNCTION_INT_REQUEST
Ntypedef struct USBH_BULK_INT_REQUEST {
N  U8     Endpoint; // With direction bit
X  unsigned char     Endpoint; 
N  void * pBuffer;
N  U32    Length;   // IN: length in bytes of buffer OUT: bytes transferred
X  unsigned long    Length;   
N} USBH_BULK_INT_REQUEST;
N
N// A helper struct to define ISO requests. Each struct of this type describes the amount of data for one USB frame.
N// The data structure ISO_REQUEST ends with an array of such structures.
Ntypedef struct USBH_ISO_PACKET_DESCRIPTOR {
N  U32         Offset;
X  unsigned long         Offset;
N  U32         Length;
X  unsigned long         Length;
N  USBH_STATUS Status;
N} USBH_ISO_PACKET_DESCRIPTOR;
N
N// Start the transfer as soon as possible
N#define USBH_ISO_ASAP 0x01
N#define USBH_URB_GET_ISO_URB_SIZE(NumPackets) (sizeof(USBH_HEADER) + sizeof(USBH_ISO_REQUEST) + (NumPackets) * sizeof(USBH_ISO_PACKET_DESCRIPTOR))
N
N
N// Used with USBH_FUNCTION_ISO_REQUEST. At the end of this data structure is an variable sized array of ISO_FRAME.
N// The macro GET_ISO_URB_SIZE returns the size of this URB for a given number of frames.
Ntypedef struct USBH_ISO_REQUEST {
N  U8             Endpoint;   // With direction bit
X  unsigned char             Endpoint;   
N  void         * pBuffer; // Pointer to the caller provided storage, can be NULL
N  U32            Length;    // IN: buffer size, OUT: bytes transferred
X  unsigned long            Length;    
N  unsigned int   Flags;
N  unsigned int   StartFrame;
N  unsigned int                NumPackets;
N  unsigned int                ErrorCount;
N  USBH_ISO_PACKET_DESCRIPTOR  aIsoPacket[1];
N} USBH_ISO_REQUEST;
N
Ntypedef struct USBH_ENDPOINT_REQUEST {  // Used with USBH_FUNCTION_ABORT_ENDPOINT and USBH_FUNCTION_RESET_ENDPOINT.
N  U8 Endpoint;                          // With direction bit
X  unsigned char Endpoint;                          
N} USBH_ENDPOINT_REQUEST;
N
Ntypedef struct USBH_SET_CONFIGURATION { // Used with USBH_FUNCTION_SET_CONFIGURATION. Changing the configuration caused PnP events for all interfaces.
N  U8 ConfigurationDescriptorIndex;      // Zero based
X  unsigned char ConfigurationDescriptorIndex;      
N} USBH_SET_CONFIGURATION;
N
Ntypedef struct USBH_SET_INTERFACE {     // Used with USBH_FUNCTION_SET_INTERFACE. The interface is given by the handle.
N  U8 AlternateSetting;                  // Zero based
X  unsigned char AlternateSetting;                  
N} USBH_SET_INTERFACE;
N
Ntypedef enum USBH_POWER_STATE {
N  USBH_NORMAL_POWER,
N  USBH_SUSPEND
N} USBH_POWER_STATE;
N
Ntypedef struct USBH_SET_POWER_STATE {
N  USBH_POWER_STATE PowerState;
N} USBH_SET_POWER_STATE;
N
Nstruct USBH_URB {                    // Common USB request block structure. It is used for all async. Requests
N  USBH_HEADER Header;
N  union {
N    USBH_CONTROL_REQUEST   ControlRequest;
N    USBH_BULK_INT_REQUEST  BulkIntRequest;
N    USBH_ISO_REQUEST       IsoRequest;
N    USBH_ENDPOINT_REQUEST  EndpointRequest;
N    USBH_SET_CONFIGURATION SetConfiguration;
N    USBH_SET_INTERFACE     SetInterface;
N    USBH_SET_POWER_STATE   SetPowerState;
N  } Request;
N};
N
N// Interface function for all asynchronous requests. If the function returns USBH_STATUS_PENDING the completion routine is called.
N// On each other status code the completion routine is never called. The storage of the URB must be provided by the caller and
N// must be permanent until the URB is returned by the completion routine.
NUSBH_STATUS   USBH_SubmitUrb(USBH_INTERFACE_HANDLE hInterface, USBH_URB * Urb);
Nconst char  * USBH_GetStatusStr(USBH_STATUS x);
N
Ntypedef void * USBH_HC_BD_HANDLE; // Handle of the bus driver of a host controller
Ntypedef void * USBH_HC_HANDLE;    // Context for the host controller driver
N
NUSBH_STATUS USBH_BD_PreInit     (void);
NUSBH_STATUS USBH_BD_Init        (void);
Nvoid        USBH_Exit            (void);
Nvoid        USBH_EnumerateDevices(USBH_HC_BD_HANDLE HcBdHandle);
N
Ntypedef enum USBH_HOST_STATE {
N  USBH_HOST_RESET,                                                                          // Do nothing on the ports, power off
N  USBH_HOST_RUNNING,                                                                        // Turn on generation of SOF
N  USBH_HOST_SUSPEND                                                                         // Stop processing of all queues, stop SOF's
N} USBH_HOST_STATE;
N
Ntypedef void *      USBH_HC_EP_HANDLE;                                                           // Handle to an endpoint
Ntypedef enum {
N  USBH_PORT_POWER_RUNNING,
N  USBH_PORT_POWER_SUSPEND
N} USBH_PORT_POWER_STATE;
N
N
N/*********************************************************************
N*
N*       Host controller interface
N*
N**********************************************************************
N*/
N
Ntypedef void        USBH_ROOT_HUB_NOTIFICATION_FUNC(void * pContext, U32 Notification); // bit0 indicates a status change of the HUB, bit 1 of port 1 of the hub and so on.
Xtypedef void        USBH_ROOT_HUB_NOTIFICATION_FUNC(void * pContext, unsigned long Notification); 
N// Is called in the pContext of USBH_AddHostController make a basic initialization of the hardware,
N// reset the hardware, setup internal lists, leave the host in the state  UBB_HOST_RESET
Ntypedef USBH_STATUS USBH_HOST_INIT_FUNC(USBH_HC_HANDLE hHostController, USBH_ROOT_HUB_NOTIFICATION_FUNC * pfUbdRootHubNotification, void * pRootHubNotificationContext);
N
N// Is the last call on this interface. It is called after all URB's are returned, all endpoints are released and no further
N// reference to the host controller exists. In this call the host controller driver can check that all lists (URB's, Endpoints)
N// are empty and delete all resources, disable interrupts. The HC state is USBH_HOST_RESET if this function is called
Ntypedef USBH_STATUS USBH_HOST_EXIT_FUNC(USBH_HC_HANDLE hHostController);
N
N
Ntypedef USBH_STATUS USBH_SET_HC_STATE_FUNC       (USBH_HC_HANDLE   hHostController, USBH_HOST_STATE HostState); // Set the state of the HC
Ntypedef U32         USBH_GET_HC_FRAME_NUMBER_FUNC(USBH_HC_HANDLE   hHostController);                       // Returns the frame number as a 32 bit value
Xtypedef unsigned long         USBH_GET_HC_FRAME_NUMBER_FUNC(USBH_HC_HANDLE   hHostController);                       
Ntypedef void        USBH_HC_ON_COMPLETION_FUNC   (void          * Context,  USBH_URB           * Urb);
N// Returns an endpoint handle for a new created endpoint
N// EndpointType :   Type of the endpoint, one of USB_EP_TYPE_CONTROL, ...
N// DeviceAddress:   Device address, 0 is allowed
N// EndpointAddress: Endpoint address with direction bit
N// MaxFifoSize:     Maximum transfer FIFO size in the host controller for that endpoint
N// IntervalTime:    Interval time in or the NAK rate if this is an USB high speed bulk endpoint (in milliseconds)
N// Speed:           The speed of the endpoint
Ntypedef USBH_HC_EP_HANDLE USBH_ADD_ENDPOINT_FUNC(USBH_HC_HANDLE hHostController, U8 EndpointType, U8 DeviceAddress, U8 EndpointAddress, U16 MaxFifoSize, U16 IntervalTime, USBH_SPEED Speed);
Xtypedef USBH_HC_EP_HANDLE USBH_ADD_ENDPOINT_FUNC(USBH_HC_HANDLE hHostController, unsigned char EndpointType, unsigned char DeviceAddress, unsigned char EndpointAddress, unsigned short MaxFifoSize, unsigned short IntervalTime, USBH_SPEED Speed);
N// The bus driver calls these functions with valid handles. The HC must not take care to check the handles.
Ntypedef void        USBH_RELEASE_EP_COMPLETION_FUNC(void * pContext);                         // This is the  USBH_ReleaseEndpoint completion function.
Ntypedef void        USBH_RELEASE_ENDPOINT_FUNC     (USBH_HC_EP_HANDLE hEndPoint, USBH_RELEASE_EP_COMPLETION_FUNC * pfReleaseEpCompletion, void * pContext);                      // Releases that endpoint. This function returns immediately. If the Completion function is called the endpoint is removed.
Ntypedef USBH_STATUS USBH_ABORT_ENDPOINT_FUNC       (USBH_HC_EP_HANDLE hEndPoint);             // Complete all pending requests. This function returns immediately. But the URB's may completed delayed, if the hardware require this.
Ntypedef USBH_STATUS USBH_RESET_ENDPOINT_FUNC       (USBH_HC_EP_HANDLE hEndPoint);             // Resets the data toggle bit to 0. The bus driver takes care that this function is called only if no pending URB for this EP is scheduled.
Ntypedef USBH_STATUS USBH_SUBMIT_REQUEST_FUNC       (USBH_HC_EP_HANDLE hEndPoint, USBH_URB * pUrb); // Submit a request to the HC. If USBH_STATUS_PENDING is returned the request is in the queue and the completion routine is called later.
N
N/*********************************************************************
N*
N*       Root pHub Functions
N*
N**********************************************************************
N*/
N
Ntypedef unsigned int USBH_GET_PORT_COUNT_FUNC     (USBH_HC_HANDLE hHostController); // Returns the number of root hub ports. An zero value is returned on an error.
Ntypedef unsigned int USBH_GET_POWER_GOOD_TIME_FUNC(USBH_HC_HANDLE hHostController); // Returns the power on to power good time in ms
Ntypedef U32          USBH_GET_HUB_STATUS_FUNC     (USBH_HC_HANDLE hHostController); // Returns the HUB status as defined in the USB specification 11.24.2.6
Xtypedef unsigned long          USBH_GET_HUB_STATUS_FUNC     (USBH_HC_HANDLE hHostController); 
N
N// This request is identical to an hub class ClearHubFeature request with the restriction that only HUB CHANGE bits can be cleared.
N// For all other hub features other root hub functions must be used. The physical change bits are cleared in the root hub interrupt routine.
Ntypedef void USBH_CLEAR_HUB_STATUS_FUNC (USBH_HC_HANDLE hHostController, U16 FeatureSelector);
Xtypedef void USBH_CLEAR_HUB_STATUS_FUNC (USBH_HC_HANDLE hHostController, unsigned short FeatureSelector);
Ntypedef U32  USBH_GET_PORT_STATUS_FUNC  (USBH_HC_HANDLE hHostController, U8  Port); // One based index of the port / return the port status as defined in the USB specification 11.24.2.7
Xtypedef unsigned long  USBH_GET_PORT_STATUS_FUNC  (USBH_HC_HANDLE hHostController, unsigned char  Port); 
N
N// This request is identical to an hub class ClearPortFeature request with the restriction that only PORT CHANGE bits can be cleared.
N// For all other port features other root hub functions must be used. The physical change bits are cleared in the root hub interrupt routine.
Ntypedef void USBH_CLEAR_PORT_STATUS_FUNC(USBH_HC_HANDLE hHostController, U8  Port, U16 FeatureSelector); // One based index of the port
Xtypedef void USBH_CLEAR_PORT_STATUS_FUNC(USBH_HC_HANDLE hHostController, unsigned char  Port, unsigned short FeatureSelector); 
N
N// Set the power State of a port. If the HC cannot handle the power switching for individual ports, it must turn on all ports if
N// at least one port requires power. It turns off the power if no port requires power
Ntypedef void USBH_SET_PORT_POWER_FUNC   (USBH_HC_HANDLE hHostController, U8  Port, U8 PowerOn); // one based index of the port / 1 to turn the power on or 0 for off
Xtypedef void USBH_SET_PORT_POWER_FUNC   (USBH_HC_HANDLE hHostController, unsigned char  Port, unsigned char PowerOn); 
N
N// Reset the port (USB Reset) and send a port change notification if ready.
N// If reset was successful the port is enabled after reset and the speed is detected
Ntypedef void USBH_RESET_PORT_FUNC       (USBH_HC_HANDLE hHostController, U8  Port); // One based index of the port
Xtypedef void USBH_RESET_PORT_FUNC       (USBH_HC_HANDLE hHostController, unsigned char  Port); 
Ntypedef void USBH_DISABLE_PORT_FUNC     (USBH_HC_HANDLE hHostController, U8  Port); // One based index of the port// Disable the port, no requests and SOF's are issued on this port
Xtypedef void USBH_DISABLE_PORT_FUNC     (USBH_HC_HANDLE hHostController, unsigned char  Port); 
Ntypedef void USBH_SET_PORT_SUSPEND_FUNC (USBH_HC_HANDLE hHostController, U8  Port, USBH_PORT_POWER_STATE State); // One based index of the port / Switch the port power between running and suspend
Xtypedef void USBH_SET_PORT_SUSPEND_FUNC (USBH_HC_HANDLE hHostController, unsigned char  Port, USBH_PORT_POWER_STATE State); 
Ntypedef int  USBH_CHECK_INTERRUPT_FUNC  (USBH_HC_HANDLE hHostController);
Ntypedef void USBH_ISR_FUNC              (USBH_HC_HANDLE hHostController);
N
Ntypedef struct USBH_HOST_DRIVER {
N  // Global HC functions
N  USBH_HOST_INIT_FUNC           * pfHostInit;        // Is called by the bus driver in the pContext of USBH_AddHostController
N  USBH_HOST_EXIT_FUNC           * pfHostExit;
N  USBH_SET_HC_STATE_FUNC        * pfSetHcState;
N  USBH_GET_HC_FRAME_NUMBER_FUNC * pfGetFrameNumber;
N  // Endpoint functions
N  USBH_ADD_ENDPOINT_FUNC        * pfAddEndpoint;     // Add an endpoint to the HC
N  USBH_RELEASE_ENDPOINT_FUNC    * pfReleaseEndpoint; // Release the endpoint, free the endpoint structure
N  USBH_ABORT_ENDPOINT_FUNC      * pfAbortEndpoint;   // Return all pending requests from this endpoint with status USBH_STATUS_CANCELLED.
N  // The requests must not completed with in the function call.
N  USBH_RESET_ENDPOINT_FUNC      * pfResetEndpoint;   // Reset the endpoint data toggle bit
N  USBH_SUBMIT_REQUEST_FUNC      * pfSubmitRequest;   // Submit a request
N  // Root pHub functions
N  USBH_GET_PORT_COUNT_FUNC      * pfGetPortCount;
N  USBH_GET_POWER_GOOD_TIME_FUNC * pfGetPowerGoodTime;
N  USBH_GET_HUB_STATUS_FUNC      * pfGetHubStatus;
N  USBH_CLEAR_HUB_STATUS_FUNC    * pfClearHubStatus;
N  USBH_GET_PORT_STATUS_FUNC     * pfGetPortStatus;
N  USBH_CLEAR_PORT_STATUS_FUNC   * pfClearPortStatus;
N  USBH_SET_PORT_POWER_FUNC      * SetPortPower;
N  USBH_RESET_PORT_FUNC          * pfResetPort;
N  USBH_DISABLE_PORT_FUNC        * pfDisablePort;
N  USBH_SET_PORT_SUSPEND_FUNC    * pfSetPortSuspend;
N  USBH_CHECK_INTERRUPT_FUNC     * pfCheckIsr;
N  USBH_ISR_FUNC                 * pfIsr;
N} USBH_HOST_DRIVER;
N
NUSBH_HC_BD_HANDLE USBH_AddHostController   (USBH_HOST_DRIVER      * pDriver, USBH_HC_HANDLE hController);
Nvoid              USBH_RemoveHostController(USBH_HC_BD_HANDLE       HcBdHandle);
NUSBH_STATUS       USBH_ResetEndpoint       (USBH_INTERFACE_HANDLE   IfaceHandle, USBH_URB * urb, U8 Endpoint, USBH_ON_COMPLETION_FUNC Completion, void * Context);
XUSBH_STATUS       USBH_ResetEndpoint       (USBH_INTERFACE_HANDLE   IfaceHandle, USBH_URB * urb, unsigned char Endpoint, USBH_ON_COMPLETION_FUNC Completion, void * Context);
N
N
Ntypedef void * USBH_TIMER_HANDLE;                                                                   // Handle to a TAL timer object
Ntypedef void   USBH_TIMER_FUNC(void * pContext);                                              // Typedef callback function which is called on a timer Timeout
N
NUSBH_TIMER_HANDLE USBH_AllocTimer (USBH_TIMER_FUNC * pfTimerCallbackRoutine, void * Context); // Allocates a timer object and returns the timer handle.
Nvoid              USBH_FreeTimer  (USBH_TIMER_HANDLE hTimer);                                  // Frees a timer object via timer handle.
Nvoid              USBH_StartTimer (USBH_TIMER_HANDLE hTimer, U32 ms);                          // Starts a timer. The timer is restarted again if it is running.
Xvoid              USBH_StartTimer (USBH_TIMER_HANDLE hTimer, unsigned long ms);                          
Nvoid              USBH_CancelTimer(USBH_TIMER_HANDLE hTimer);                                  // Cancels an timer if running, the completion routine is not called.
N
N/*********************************************************************
N*
N*       Structs
N*
N**********************************************************************
N*/
N
N
NUSBH_BOOL USBH_IsTimeOver(U32 Waittime, U32 StartTime);
Xchar USBH_IsTimeOver(unsigned long Waittime, unsigned long StartTime);
N
N
Ntypedef struct URB_SUB_STATE {
N  U8                           TimerCancelFlag; // Timer to for detecting an Timeout
X  unsigned char                           TimerCancelFlag; 
N  USBH_TIMER_HANDLE            hTimer;
N  USBH_SUBSTATE_STATE               State;
N  USBH_URB                   * pUrb;
N  // Additional pointer for faster accesses
N  USBH_HOST_CONTROLLER       * pHostController;
N  USBH_HC_EP_HANDLE          * phEP;
N  USBH_SUBMIT_REQUEST_FUNC   * pfSubmitRequest;
N  USBH_ABORT_ENDPOINT_FUNC   * pfAbortEndpoint;
N  USB_DEVICE                 * pDevRefCnt;
N  USBH_SUBSTATE_FUNC         * pfCallback; // This callback routine is called if an URB is complete or on an timer Timeout
N  // started with USBH_URB_SubStateWait. If the timer routine runs and an pending pUrb exist
N  // then the pUrb ios aborted and the CallbackRoutine is not called.
N  void                       * pContext;
N} URB_SUB_STATE;
N
NURB_SUB_STATE * USBH_URB_SubStateAllocInit    (USBH_HOST_CONTROLLER * pHostController, USBH_HC_EP_HANDLE * phEP, USBH_SUBSTATE_FUNC * pfRoutine, void * pContext);
NUSBH_STATUS     USBH_URB_SubStateInit         (URB_SUB_STATE * pSubState, USBH_HOST_CONTROLLER * pHostController, USBH_HC_EP_HANDLE * phEP, USBH_SUBSTATE_FUNC * pfRoutine, void * pContext);
NUSBH_STATUS     USBH_URB_SubStateSubmitRequest(URB_SUB_STATE * pSubState, USBH_URB * pUrb, U32 Timeout, USB_DEVICE * pDevRefCnt);
XUSBH_STATUS     USBH_URB_SubStateSubmitRequest(URB_SUB_STATE * pSubState, USBH_URB * pUrb, unsigned long Timeout, USB_DEVICE * pDevRefCnt);
Nvoid            USBH_URB_SubStateWait         (URB_SUB_STATE * pSubState, U32 Timeout, USB_DEVICE * pDevRefCnt);
Xvoid            USBH_URB_SubStateWait         (URB_SUB_STATE * pSubState, unsigned long Timeout, USB_DEVICE * pDevRefCnt);
Nvoid            USBH_URB_SubStateExit         (URB_SUB_STATE * pSubState);
Nvoid            USBH_URB_SubStateFree         (URB_SUB_STATE * pSubState);
NUSBH_BOOL       USBH_URB_SubStateIsIdle       (URB_SUB_STATE * pSubState);
Xchar       USBH_URB_SubStateIsIdle       (URB_SUB_STATE * pSubState);
N
NUSBH_STATUS USBH_OHCI_TRANSFER_SubmitRequest       (USBH_HC_EP_HANDLE hEP, USBH_URB * pUrb);
Nvoid        USBH_OHCI_TRANSFER_ProcessDoneInterrupt(USBH_OHCI_DEVICE * pDev);
N
N// URBs HcFlags allowed values
N#define URB_CANCEL_PENDING_MASK 0x01 // Pending URB must be canceled
N
N
Ntypedef struct USBH_DEFAULT_EP {
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32                  Magic;
X  unsigned long                  Magic;
N#endif
N  USB_DEVICE         * pUsbDevice; // Pointer to the owning host controller
N  USBH_HC_EP_HANDLE    hEP;  // Endpoint handle must be used to submit an URB
N  unsigned int         UrbCount;
N} USBH_DEFAULT_EP;
N
N
N// State for device enumeration
Ntypedef enum {
N  DEV_ENUM_IDLE,                 // No enumeration running
N  DEV_ENUM_START,                // First state
N  DEV_ENUM_GET_DEVICE_DESC_PART, // Get the first 8 bytes of the device descriptor
N  DEV_ENUM_GET_DEVICE_DESC,      // Get the complete device descriptor
N  DEV_ENUM_GET_CONFIG_DESC_PART, // Get the first part of the configuration descriptor
N  DEV_ENUM_GET_CONFIG_DESC,      // Get the complete configuration descriptor
N  DEV_ENUM_GET_LANG_ID,          // Get the language ID's
N  DEV_ENUM_GET_SERIAL_DESC,      // Get the serial number
N  DEV_ENUM_SET_CONFIGURATION,    // Set the configuration
N  DEV_ENUM_INIT_HUB,             // The device is an hub and is  initialized
N  DEV_ENUM_RESTART,              // A transaction fails and a timer runs to restart
N  DEV_ENUM_REMOVED               // The device is removed, clean up enumeration
N} DEV_ENUM_STATE;
N
Ntypedef enum { // Do not modify the sequence
N  DEV_STATE_UNKNOWN = 0,
N  DEV_STATE_REMOVED,
N  DEV_STATE_ENUMERATE,
N  DEV_STATE_WORKING,
N  DEV_STATE_SUSPEND
N} USB_DEV_STATE;
N
N// Is called after the standard enumeration has been completed
Ntypedef void POST_ENUM_FUNC(void* pContext);
N
Nstruct USB_DEVICE {
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32                          Magic;
X  unsigned long                          Magic;
N#endif
N  USBH_DLIST                   ListEntry;              // To store this object in the host controller object
N  USBH_DLIST                   TempEntry;              // To store this object in an temporary list
N  USBH_BOOL                    TempFlag;
X  char                    TempFlag;
N  long                         RefCount;
N  USBH_HOST_CONTROLLER       * pHostController;         // Pointer to the owning host controller
N  USBH_DLIST                   UsbInterfaceList;       // List for interfaces
N  unsigned int                 InterfaceCount;
N  USBH_HUB_PORT              * pParentPort;             // This is the hub port where this device is connected to
N  U8                           UsbAddress;             // This is the USB address of the device
X  unsigned char                           UsbAddress;             
N  USBH_SPEED                   DeviceSpeed;            // pSpeed of the device connection
N  U8                           MaxFifoSize;            // The FIFO size
X  unsigned char                           MaxFifoSize;            
N  U8                           ConfigurationIndex;     // The index of the current configuration
X  unsigned char                           ConfigurationIndex;     
N  U8                           NumConfigurations;      // The index of the current configuration
X  unsigned char                           NumConfigurations;      
N  // Descriptors
N  USB_DEVICE_DESCRIPTOR        DeviceDescriptor;       // A typed copy
N  U8                           aDeviceDescriptorBuffer[USB_DEVICE_DESCRIPTOR_LENGTH];
X  unsigned char                           aDeviceDescriptorBuffer[(18)];
N  U8                         * pConfigDescriptor;       // Points to the current configuration descriptor
X  unsigned char                         * pConfigDescriptor;       
N  U16                          ConfigDescriptorSize;
X  unsigned short                          ConfigDescriptorSize;
N  U16                          LanguageId;             // First language ID
X  unsigned short                          LanguageId;             
N  U8                         * pSerialNumber;           // Serial number without header, UNICODE
X  unsigned char                         * pSerialNumber;           
N  unsigned int                 SerialNumberSize;
N  U16                          DevStatus;              // Device status returned from USB GetStatus
X  unsigned short                          DevStatus;              
N  USBH_DEFAULT_EP              DefaultEp;              // Embedded default endpoint
N  USB_HUB                    * pUsbHub;                 // This pointer is valid if the device is a hub
N  USB_DEV_STATE                State;                  // Current device state
N  USBH_URB                     EnumUrb;                // Embedded URB
N  void                       * pCtrlTransferBuffer;     // Used from USBH_BD_ProcessEnum and ProcessEnumHub()
N  unsigned int                 CtrlTransferBufferSize;
N  // State variables for device enumeration
N  // Enumeration state
N  URB_SUB_STATE                SubState;
N  DEV_ENUM_STATE               EnumState;
N  USBH_BOOL                    EnumSubmitFlag;         // Used during enumeration if the device is as an hub
X  char                    EnumSubmitFlag;         
N  // Post enumeration
N  POST_ENUM_FUNC             * pfPostEnumFunction;
N  void                       * pPostEnumerationContext;
N  USBH_DEVICE_ID               DeviceId;               // Device ID for this device
N};
N
N
Ntypedef struct USB_ENDPOINT {
N  USBH_DLIST          ListEntry;          // to store this object in the interface object */
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32                 Magic;
X  unsigned long                 Magic;
N#endif
N  USB_INTERFACE     * pUsbInterface;       // Backward pointer
N  U8                * pEndpointDescriptor; // Descriptors
X  unsigned char                * pEndpointDescriptor; 
N  USBH_HC_EP_HANDLE   hEP;           // Endpoint handle must be used to submit an URB
N  U32                 UrbCount;
X  unsigned long                 UrbCount;
N} USB_ENDPOINT;
N
N
N#define USB_MAX_ENDPOINTS 32 // Needs the struct and the name of the list entry inside the struct.
N
N// Make a index in the range between 0 and 31 from an EP address IN EP's in the range from 0x10 to 0x1f, OUT EP's are in the range 0x00 to 0x0f
N#define USBH_EP_INDEX(EpAddr) ((EpAddr) & 0x80) ? (((EpAddr)&0xf) | 0x10) : ((EpAddr)&0xf)
N
Nstruct USB_INTERFACE {
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32                 Magic;
X  unsigned long                 Magic;
N#endif
N  USBH_DLIST          ListEntry;                // To store this object in the device object
N  USB_DEVICE        * pDevice;                   // Backward pointer
N  USBH_DLIST          UsbEndpointList;          // List for endpoints
N  unsigned int        EndpointCount;
N  U8                  CurrentAlternateSetting;
X  unsigned char                  CurrentAlternateSetting;
N  U8                * pInterfaceDescriptor;
X  unsigned char                * pInterfaceDescriptor;
N  U8                * pAlternateSettingDescriptor;
X  unsigned char                * pAlternateSettingDescriptor;
N  U8                  NewAlternateSetting;
X  unsigned char                  NewAlternateSetting;
N  U8                * pNewAlternateSettingDescriptor;
X  unsigned char                * pNewAlternateSettingDescriptor;
N  unsigned int        OpenCount;
N  U8                  ExclusiveUsed;
X  unsigned char                  ExclusiveUsed;
N  USB_ENDPOINT      * pEpMap[USB_MAX_ENDPOINTS]; // A map for fast access to endpoint structures
X  USB_ENDPOINT      * pEpMap[32]; 
N  USBH_INTERFACE_ID   InterfaceId;              // ID of this interface
N};
N
NUSBH_STATUS USBH_BD_InitDefaultEndpoint            (USB_DEVICE    * pUsbDevice);
NUSBH_STATUS USBH_BD_DefaultEpSubmitUrb             (USB_DEVICE    * Dev,       USBH_URB * Urb);
NUSBH_STATUS USBH_BD_SubmitSetInterface             (USB_INTERFACE * UsbInterface, U16 Interface, U16 AlternateSetting, USBH_ON_COMPLETION_FUNC * Completion, USBH_URB * OriginalUrb);
XUSBH_STATUS USBH_BD_SubmitSetInterface             (USB_INTERFACE * UsbInterface, unsigned short Interface, unsigned short AlternateSetting, USBH_ON_COMPLETION_FUNC * Completion, USBH_URB * OriginalUrb);
NUSBH_STATUS USBH_BD_SubmitClearFeatureEndpointStall(USBH_DEFAULT_EP   * DefaultEp, USBH_URB * Urb, U8 Endpoint, USBH_ON_COMPLETION_FUNC * InternalCompletion, void * HcContext);
XUSBH_STATUS USBH_BD_SubmitClearFeatureEndpointStall(USBH_DEFAULT_EP   * DefaultEp, USBH_URB * Urb, unsigned char Endpoint, USBH_ON_COMPLETION_FUNC * InternalCompletion, void * HcContext);
Nvoid        USBH_BD_ReleaseDefaultEndpoint         (USBH_DEFAULT_EP   * UsbEndpoint);
Nvoid        USBH_BD_DefaultEpUrbCompletion         (USBH_URB          * Urb);
N
N// Dump the info of an allocated device /DBG_ADDREMOVE must be set
N#define DUMP_USB_DEVICE_INFO(UsbDev)                                                               \
NUSBH_LOG((USBH_MTYPE_DEVICE, "Device: Added Dev: USB addr: %d Id:%u speed: %s parent port: %d %s", \
N      (UsbDev)->DeviceId,                                                                          \
N      (int)(UsbDev)->UsbAddress,                                                                   \
N      USBH_PortSpeed2Str((UsbDev)->DeviceSpeed),                                                      \
N      (UsbDev)->pParentPort != NULL ? (int)(UsbDev)->pParentPort->HubPortNumber: -1,                 \
N      ((UsbDev)->DevStatus & USB_STATUS_SELF_POWERED) ? "self powered" : "bus powered"))
X#define DUMP_USB_DEVICE_INFO(UsbDev)                                                               USBH_LOG((USBH_MTYPE_DEVICE, "Device: Added Dev: USB addr: %d Id:%u speed: %s parent port: %d %s",       (UsbDev)->DeviceId,                                                                                (int)(UsbDev)->UsbAddress,                                                                         USBH_PortSpeed2Str((UsbDev)->DeviceSpeed),                                                            (UsbDev)->pParentPort != NULL ? (int)(UsbDev)->pParentPort->HubPortNumber: -1,                       ((UsbDev)->DevStatus & USB_STATUS_SELF_POWERED) ? "self powered" : "bus powered"))
N
N// Needs the struct and the name of the list entry inside the struct
N#define INC_REF(devPtr) (devPtr)->RefCount++ // Reference counting macros to the USB_DEVICE object
N
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N#define DEC_REF(devPtr)                                                                       \
N  (devPtr)->RefCount--;                                                                       \
N  if ((devPtr)->RefCount == 1) {                                                              \
N    USBH_LOG((USBH_MTYPE_CORE, "DEC_REF RefCount is 1 %s(%d)\n", __FILE__, __LINE__));        \
N  }                                                                                           \
N  if ((devPtr)->RefCount <  0) {                                                              \
N    USBH_LOG((USBH_MTYPE_CORE, "DEC_REF RefCount less than 0 %s(%d)\n", __FILE__, __LINE__)); \
N  }                                                                                           \
N  if ((devPtr)->RefCount == 0) {                                                              \
N    USBH_LOG((USBH_MTYPE_CORE, "DEC_REF RefCount is 0 %s(%d)\n", __FILE__, __LINE__));        \
N    USBH_DeleteDevice(devPtr);                                                                  \
N  }
X#define DEC_REF(devPtr)                                                                         (devPtr)->RefCount--;                                                                         if ((devPtr)->RefCount == 1) {                                                                  USBH_LOG((USBH_MTYPE_CORE, "DEC_REF RefCount is 1 %s(%d)\n", __FILE__, __LINE__));          }                                                                                             if ((devPtr)->RefCount <  0) {                                                                  USBH_LOG((USBH_MTYPE_CORE, "DEC_REF RefCount less than 0 %s(%d)\n", __FILE__, __LINE__));   }                                                                                             if ((devPtr)->RefCount == 0) {                                                                  USBH_LOG((USBH_MTYPE_CORE, "DEC_REF RefCount is 0 %s(%d)\n", __FILE__, __LINE__));            USBH_DeleteDevice(devPtr);                                                                    }
N#else
S#define DEC_REF(devPtr)          \
S  (devPtr)->RefCount--;          \
S  if ((devPtr)->RefCount == 0) { \
S    USBH_DeleteDevice(devPtr);     \
S  }
X#define DEC_REF(devPtr)            (devPtr)->RefCount--;            if ((devPtr)->RefCount == 0) {     USBH_DeleteDevice(devPtr);       }
N#endif
N
NUSB_DEVICE * USBH_CreateNewUsbDevice(USBH_HOST_CONTROLLER * HostController);
N
Nvoid         USBH_StartEnumeration                  (USB_DEVICE * Dev, POST_ENUM_FUNC * PostEnumFunction, void * Context);
Nvoid         USBH_DeleteDevice                      (USB_DEVICE * Dev);
Nvoid         USBH_DeleteInterfaces                  (USB_DEVICE * Dev);
Nvoid         USBH_MarkDeviceAsRemoved               (USB_DEVICE * Dev);
Nvoid         USBH_MarkParentAndChildDevicesAsRemoved(USB_DEVICE * Dev);
Nvoid         UbdProcessSetConf                      (USB_DEVICE * Dev);
NU8         * USBH_GetNextInterfaceDesc              (USB_DEVICE * Dev, U8  * Start, U8 InterfaceNumber, unsigned int AlternateSetting);
Xunsigned char         * USBH_GetNextInterfaceDesc              (USB_DEVICE * Dev, unsigned char  * Start, unsigned char InterfaceNumber, unsigned int AlternateSetting);
NU8         * USBH_GetNextEndpointDesc               (USB_DEVICE * Dev, U8  * Start, U8 Endpoint);
Xunsigned char         * USBH_GetNextEndpointDesc               (USB_DEVICE * Dev, unsigned char  * Start, unsigned char Endpoint);
Nvoid         USBH_CreateInterfaces                  (void * Context);
NU16          USBH_GetUshortFromDesc                 (void * Buffer,    U16   Offset);
Xunsigned short          USBH_GetUshortFromDesc                 (void * Buffer,    unsigned short   Offset);
NU8           USBH_GetUcharFromDesc                  (void * Buffer,    U16   Offset);
Xunsigned char           USBH_GetUcharFromDesc                  (void * Buffer,    unsigned short   Offset);
N
N/*********************************************************************
N*
N*       Helper functions
N*
N**********************************************************************
N*/
N
Nvoid         USBH_BD_EnumTimerFunction      (void       * Context);
Nvoid         USBH_BD_SetConfTimerFunction   (void       * Context);
Nvoid         USBH_BD_ProcessEnum            (void       * usbDevice);
Nunsigned int USBH_GetPendingUrbCount        (USB_DEVICE * Dev);
Nint          USBH_CheckCtrlTransferBuffer   (USB_DEVICE * Dev, U16                   RequestLength);
Xint          USBH_CheckCtrlTransferBuffer   (USB_DEVICE * Dev, unsigned short                   RequestLength);
Nvoid         USBH_EnumParentPortRestart     (USB_DEVICE * Dev, USBH_STATUS           status);
Nvoid         USBH_ProcessEnumPortError      (USB_DEVICE * dev, USBH_STATUS           enumStatus);
NUSBH_STATUS  USBH_SearchUsbInterface        (USB_DEVICE * dev, USBH_INTERFACE_MASK * iMask, USB_INTERFACE * * iface);
N
NUSBH_STATUS    USBH_GetEndpointDescriptorFromInterface(USB_INTERFACE * usbInterface, U8 alternateSetting, const USBH_EP_MASK * mask, U8 * * descriptor);
XUSBH_STATUS    USBH_GetEndpointDescriptorFromInterface(USB_INTERFACE * usbInterface, unsigned char alternateSetting, const USBH_EP_MASK * mask, unsigned char * * descriptor);
NUSBH_STATUS    USBH_GetDescriptorFromInterface(USB_INTERFACE * pUsbInterface, U8 alternateSetting, U8 Type, U8 ** ppDescriptor);
XUSBH_STATUS    USBH_GetDescriptorFromInterface(USB_INTERFACE * pUsbInterface, unsigned char alternateSetting, unsigned char Type, unsigned char ** ppDescriptor);
NUSB_ENDPOINT * USBH_BD_NewEndpoint    (USB_INTERFACE * UsbInterface, U8 * EndpointDescriptor);
XUSB_ENDPOINT * USBH_BD_NewEndpoint    (USB_INTERFACE * UsbInterface, unsigned char * EndpointDescriptor);
Nvoid           USBH_BD_DeleteEndpoint (USB_ENDPOINT  * UsbEndpoint);
NUSBH_STATUS    USBH_BD_EpSubmitUrb    (USB_ENDPOINT  * UsbEndpoint, USBH_URB * Urb);
Nvoid           USBH_BD_EpUrbCompletion(USBH_URB      * Urb);
N
N// Needs the struct and the name of the list entry inside the struct
N#define GET_EP_FROM_ADDRESS(uif,ep)     uif->pEpMap[((ep) & 0xf) | (((ep) & 0x80) >> 3)]
N#define SET_EP_FOR_ADDRESS( uif,ep,uep) uif->pEpMap[((ep) & 0xf) | (((ep) & 0x80) >> 3)] = (uep)
N
NUSB_INTERFACE * USBH_BD_NewUsbInterface    (USB_DEVICE    * pDevice);
Nvoid            USBH_BD_DeleteUsbInterface (USB_INTERFACE * pUsbInterface);
NUSBH_STATUS     USBH_BD_CreateEndpoints    (USB_INTERFACE * pUsbInterface);
Nvoid            USBH_BD_RemoveEndpoints    (USB_INTERFACE * pUsbInterface);
Nvoid            USBH_BD_AddUsbEndpoint     (USB_ENDPOINT  * pUsbEndpoint);
Nvoid            USBH_RemoveUsbEndpoint     (USB_ENDPOINT  * pUsbEndpoint);
NUSBH_STATUS     USBH_BD_CompareUsbInterface(USB_INTERFACE * pInterface, USBH_INTERFACE_MASK * pInterfaceMask, USBH_BOOL EnableHubInterfaces);
XUSBH_STATUS     USBH_BD_CompareUsbInterface(USB_INTERFACE * pInterface, USBH_INTERFACE_MASK * pInterfaceMask, char EnableHubInterfaces);
Nunsigned int    USBH_BD_GetPendingUrbCount (USB_INTERFACE * pInterface);
Nvoid            USBH_BD_AddUsbInterface    (USB_INTERFACE * pUsbInterface);
Nvoid            USBH_BD_RemoveUsbInterface (USB_INTERFACE * pUsbInterface);
N
NUSB_ENDPOINT  * USBH_BD_SearchUsbEndpointInInterface(USB_INTERFACE * Interface, const USBH_EP_MASK * mask);
N
Ntypedef struct USBH_HOST_DRIVER_INST { // The global driver object
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32               Magic;
X  unsigned long               Magic;
N#endif
N  USBH_DLIST        HostControllerList;
N  U32               HostControllerCount;
X  unsigned long               HostControllerCount;
N  // Registered PNP notifications
N  USBH_DLIST        NotificationList;
N  U32               NotificationCount;
X  unsigned long               NotificationCount;
N  // Delayed Pnp notifications, called in an timer routine
N  USBH_DLIST        DelayedPnPNotificationList;
N  U32               DelayedPnPNotificationCount;
X  unsigned long               DelayedPnPNotificationCount;
N  USBH_TIMER_HANDLE DelayedPnPNotifyTimer;
N  USBH_DLIST        EnumErrorNotificationList;
N  U32               EnumErrorNotificationCount;
X  unsigned long               EnumErrorNotificationCount;
N  // Next free ID's for a new enumerated device
N  USBH_INTERFACE_ID NextInterfaceId;
N  USBH_DEVICE_ID    NextDeviceId;
N} USBH_HOST_DRIVER_INST;
N
Nvoid USBH_BD_AddHostController            (USBH_HOST_CONTROLLER * HostController);
Nvoid USBH_BD_RemoveHostController         (USBH_HOST_CONTROLLER * HostController);
Nvoid USBH_BD_ProcessDevicePnpNotifications(USB_DEVICE * Device, USBH_PNP_EVENT event);
Nvoid USBH_BD_AddNotification              (USB_DEVICE * Device);
Nvoid USBH_BD_RemoveNotification           (USB_DEVICE * Device);
N
NUSBH_INTERFACE_ID   USBH_BD_GetNextInterfaceId(void);
NUSBH_DEVICE_ID      USBH_BD_GetNextDeviceId   (void);
NUSB_DEVICE        * USBH_BD_GetDeviceById     (USBH_DEVICE_ID    DeviceId);
NUSB_INTERFACE     * USBH_BD_GetInterfaceById     (USBH_INTERFACE_ID InterfaceId);
N
N
Ntypedef enum {
N  RH_PORTRESET_IDLE, // Only this state allows an new root hub port reset
N  RH_PORTRESET_REMOVED,
N  RH_PORTRESET_INIT, // RH_PORTRESET_INIT prevents starting of root hub enumeration until power good time is elapsed!
N  RH_PORTRESET_START,
N  RH_PORTRESET_RESTART,
N  // Following states are always entered in the pContext of a callback completion routine never by direct calling of RootHubProcessDeviceReset()
N  RH_PORTRESET_WAIT_RESTART,
N  RH_PORTRESET_RES,
N  RH_PORTRESET_WAIT_RESET,
N  RH_PORTRESET_SET_ADDRESS,
N  RH_PORTRESET_WAIT_ADDRESS
N} USBH_ROOT_HUB_PORTRESET_STATE;
N
Ntypedef struct ROOT_HUB {                       // The global driver object
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32                             Magic;
X  unsigned long                             Magic;
N#endif
N  USBH_HOST_CONTROLLER          * pHostController;      // Backward pointer to the host controller
N  unsigned int                    PowerGoodTime;       // Power on to power good time in ms
N  unsigned int                    PortCount;           // Number of ports
N  USBH_DLIST                      PortList;
N  URB_SUB_STATE                   SubState;            // Sub state machine for device reset and set address,  easier handling if both an timer and URB is started!
N  URB_SUB_STATE                   InitHubPortSubState;
N  USBH_ROOT_HUB_PORTRESET_STATE   PortResetEnumState;
N  USBH_HUB_PORT                 * pEnumPort;
N  USB_DEVICE                    * pEnumDevice;
N  USBH_URB                        EnumUrb;             // Embedded URB
N  USBH_HC_EP_HANDLE               hEnumEP;
N} ROOT_HUB;
N
NUSBH_STATUS     USBH_ROOTHUB_Init                      (USBH_HOST_CONTROLLER * pHostController);
Nvoid            USBH_ROOTHUB_OnNotification            (void     * pRootHubContext, U32 Notification);
Xvoid            USBH_ROOTHUB_OnNotification            (void     * pRootHubContext, unsigned long Notification);
Nvoid            USBH_ROOTHUB_Release                   (ROOT_HUB * pRootHub);
NUSBH_STATUS     USBH_ROOTHUB_AddPortsStartPowerGoodTime(ROOT_HUB * pRootHub);
NUSBH_BOOL       USBH_ROOTHUB_ServicePorts              (ROOT_HUB * pRootHub);
Xchar       USBH_ROOTHUB_ServicePorts              (ROOT_HUB * pRootHub);
NUSBH_HUB_PORT * USBH_ROOTHUB_GetPortByNumber           (ROOT_HUB * pRootHub, U8 Port);
XUSBH_HUB_PORT * USBH_ROOTHUB_GetPortByNumber           (ROOT_HUB * pRootHub, unsigned char Port);
N
N#define DEFAULT_NOTIFY_RETRY_TIMEOUT      100
N#define USBHUB_DEFAULT_ALTERNATE_SETTING  0
N#define USBHUB_DEFAULT_INTERFACE          0
N
Ntypedef enum {
N  PORT_UNKNOWN,
N  PORT_REMOVED,               // Set from notification
N  PORT_CONNECTED,             // Set from notification
N  PORT_RESTART,               // Set from notification or enumeration (both functions are synchronized)
N  PORT_SUSPEND,               // Set from notification
N  PORT_RESET,                 // Set from enumeration
N  PORT_ENABLED,               // Set from enumeration
N  PORT_ERROR                  // Errors during port enumeration
N} PORT_STATE;
N
Nstruct USBH_HUB_PORT {              // Global driver object
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32                  Magic;
X  unsigned long                  Magic;
N#endif
N  USBH_DLIST           ListEntry;          // Entry for hub or root hub
N  ROOT_HUB           * RootHub;            // Null if no root hub port
N  USB_HUB            * ExtHub;             // Null if no external hub
N  U32                  PortStatus;         // A copy of the port status returned from the HUB
X  unsigned long                  PortStatus;         
N  U32                  PortStatusShadow;   // Shadow register
X  unsigned long                  PortStatusShadow;   
N  USBH_SPEED           PortSpeed;          // The current speed of the device
N  PORT_STATE           PortState;          // The current port state of the port
N  USB_DEVICE         * Device;             // Device connected to this port, for tree operation
N  U8                   HubPortNumber;      // The one based index of the hub port
X  unsigned char                   HubPortNumber;      
N  unsigned int         RetryCounter;       // Counts the number of retries
N  U8                   ConfigurationIndex; // This is the configuration index for the device
X  unsigned char                   ConfigurationIndex; 
N  USBH_BOOL            HighPowerFlag;      // True if the port is an high powered port min.500ma
X  char            HighPowerFlag;      
N};
N
Ntypedef enum { // Device reset
N  USBH_HUB_PORTRESET_IDLE,
N  USBH_HUB_PORTRESET_REMOVED,               // Port or Hub is not connected
N  USBH_HUB_PORTRESET_START,
N  USBH_HUB_PORTRESET_RESTART,
N  USBH_HUB_PORTRESET_WAIT_RESTART,
N  USBH_HUB_PORTRESET_RES,
N  USBH_HUB_PORTRESET_IS_ENABLED,
N  USBH_HUB_PORTRESET_WAIT_RESET,
N  USBH_HUB_PORTRESET_SET_ADDRESS,
N  USBH_HUB_PORTRESET_WAIT_SET_ADDRESS,
N  USBH_HUB_PORTRESET_START_DEVICE_ENUM,
N  USBH_HUB_PORTRESET_DISABLE_PORT
N} USBH_HUB_PORTRESET_STATE;
N
Ntypedef enum { // Hub initialization state machine
N  USBH_HUB_ENUM_IDLE,                  // Idle
N  USBH_HUB_ENUM_START,                 // Start the state machine
N  USBH_HUB_ENUM_GET_STATUS,            // Get the device status
N  USBH_HUB_ENUM_HUB_DESC,              // Check the hub descriptor
N  USBH_HUB_ENUM_SET_POWER,             // Set power for all ports
N  USBH_HUB_ENUM_POWER_GOOD,            // Power good time elapsed
N  USBH_HUB_ENUM_PORT_STATE,            // Get all port status, set the port state
N  USBH_HUB_ENUM_ADD_DEVICE,            // Add the hub device to the hosts device list
N  USBH_HUB_ENUM_REMOVED                // Active if the parent port is removed
N} USBH_HUB_ENUM_STATE;
N
N// This states are used in conjunction with the NotifySubState
Ntypedef enum {
N  USBH_HUB_NOTIFY_IDLE,               // Idle
N  USBH_HUB_NOTIFY_START,              // Start state
N  USBH_HUB_NOTIFY_GET_HUB_STATUS,     // Start the state machine
N  USBH_HUB_NOTIFY_CLEAR_HUB_STATUS,
N  USBH_HUB_NOTIFY_GET_PORT_STATUS,    // Set power for all ports
N  USBH_HUB_NOTIFY_CLR_PORT_STATUS,    // Power good time elapsed
N  USBH_HUB_NOTIFY_CHECK_OVER_CURRENT,
N  USBH_HUB_NOTIFY_CHECK_CONNECT,
N  USBH_HUB_NOTIFY_CHECK_REMOVE,
N  USBH_HUB_NOTIFY_DISABLE_PORT,       // Disable an port
N  USBH_HUB_NOTIFY_REMOVED,            // Hub device state is not WORKING
N  USBH_HUB_NOTIFY_ERROR               // Error submitting of an URB to the hub device after max. retries
N} USBH_HUB_NOTIFY_STATE;
N
Nstruct USB_HUB { // USB HUB object
N#if USBH_DEBUG > 1
X#if 2 > 1
N  U32                   Magic;
X  unsigned long                   Magic;
N#endif
N  USB_DEVICE          * pHubDevice;                   // Backward pointer to the USB hub device
N  unsigned int          PowerGoodTime;               // Power on to power good time in ms
N  unsigned int          Characteristics;             // Power on to power good time in ms
N  unsigned int          PortCount;                   // Number of ports
N  USBH_DLIST            PortList;                    // List of ports
N  USBH_BOOL             SubmitFlag;                  // Helper var. in ProcessHubNotification
X  char             SubmitFlag;                  
N
N  // Hub notification
N  // This urb contains hub notification information and is used for all hub requests in ProcessHubNotification()
N  USBH_URB              NotifyUrb;
N  USBH_HUB_NOTIFY_STATE NotifyState;
N  USBH_HUB_NOTIFY_STATE OldNotifyState;
N  URB_SUB_STATE         NotifySubState;              // hub notify sub state machine (submitting and aborting of URBs)
N
N  // Current not processed ports in ProcessHubNotification()
N  unsigned int          NotifyPortCt;
N  USBH_HUB_PORT       * NotifyPort;
N  U32                   NotifyTemp;                  // Temporary variable
X  unsigned long                   NotifyTemp;                  
N  U32                   Notification;                // Received Notification max. 4 bytes
X  unsigned long                   Notification;                
N  U32                   Status;                      // todo: read hub status after hub status
X  unsigned long                   Status;                      
N  USBH_HUB_PORT       * EnumPort;                    // Hub device enumeration
N  USB_DEVICE          * EnumDevice;
N  USBH_URB              EnumUrb;
N  USBH_HUB_ENUM_STATE   EnumState;                   // State of the Hubs initialization process
N  URB_SUB_STATE         EnumSubState;                // helper sub state for hub enumeration
N
N  // Hold post function and pContext! Used in the state USBH_HUB_ENUM_ADD_DEVICE in ProcessEnumHub()
N  POST_ENUM_FUNC  * PostEnumFunction;
N  void                * PostEnumContext;
N  USBH_HUB_PORTRESET_STATE   PortResetEnumState;          // Hub port reset state machine / Current HubProcessPortResetSetAddress() state
N
N  // Helper sub state machines
N  URB_SUB_STATE         PortResetSubState;
N  URB_SUB_STATE         PortResetControlUrbSubState;
N  USBH_HC_EP_HANDLE     PortResetEp0Handle;
N
N  // To get hub and port notifications
N  USB_ENDPOINT        * InterruptEp;
N  USBH_URB              interruptUrb;
N  void                * InterruptTransferBuffer;
N  unsigned int          InterruptTransferBufferSize;
N};
N
Nvoid      USBH_BD_DeleteHub(USB_HUB * hub);
Nvoid      USBH_BD_StartHub (USB_HUB * Hub, POST_ENUM_FUNC * PostEnumFunction, void * Context);
NUSB_HUB * USBH_BD_AllocInitUsbHub (USB_DEVICE  * dev);
N
N/* Called if the root hub does not need any service */
Nvoid USBH_BD_ServiceAllHubs         (USBH_HOST_CONTROLLER * hc);
Nvoid USBH_BD_HubPrepareClrFeatureReq(USBH_URB * urb, U16 feature, U16 selector);
Xvoid USBH_BD_HubPrepareClrFeatureReq(USBH_URB * urb, unsigned short feature, unsigned short selector);
N
N
NUSBH_HUB_PORT * USBH_BD_NewHubPort   (void); // Return null on error
Nvoid       USBH_BD_DeleteHubPort(USBH_HUB_PORT * HubPort);
Nvoid       USBH_BD_SetPortState (USBH_HUB_PORT * hubPort, PORT_STATE state);
N
N/*********************************************************************
N*
N*       USBH_BD_HubBuildChildDeviceList
N*
N*  Function Description:
N*    Builds a device list of all devices that are connected to a parent
N*    device inclusive the parent device. The first device in the list is
N*    the parent device. The list ends if no hub device on an port is found!
N*
N*  Parameters:
N*    pHubDevice: Parent device
N*    pDevList:   Pointer to a temporary list
N*
N*  Return value:
N*    Number of devices in the list inclusive the rootHubDevice!
N*    0: rootHubDevice is no hub device!
N*/
Nint USBH_BD_HubBuildChildDeviceList(USB_DEVICE * pHubDevice, USBH_DLIST * pDevList);
N
N// Returns the hub port by port number.
N// Attention: The state of the hub device is not checked!
NUSBH_HUB_PORT * USBH_BD_HubGetPortByNumber(USB_HUB * Hub, unsigned char Number);
N
Ntypedef enum {
N  HC_UNKNOWN,
N  HC_REMOVED,
N  HC_WORKING,
N  HC_SUSPEND
N} HOST_CONTROLLER_STATE;
N
Nstruct USBH_HOST_CONTROLLER {                   // Global driver object
N  USBH_DLIST              ListEntry;            // List entry for USB driver
N  long                    RefCount;             // Ref pCount
N  HOST_CONTROLLER_STATE   State;                // The state of the HC
N  USBH_HOST_DRIVER_INST * pInst;                // Backward pointer
N  USBH_DLIST              DeviceList;           // List of USB devices
N  U32                     DeviceCount;
X  unsigned long                     DeviceCount;
N  USBH_HOST_DRIVER      * pDriver;              // Host controller entry
N  USBH_HC_HANDLE          hHostController;      // Handle for the HC driver. It is passed to each function
N  U8                      UsbAddressArray[128];
X  unsigned char                      UsbAddressArray[128];
N  ROOT_HUB                RootHub;              // Embedded root hub
N  USBH_HC_EP_HANDLE       LowSpeedEndpoint;
N  USBH_HC_EP_HANDLE       FullSpeedEndpoint;
N  USBH_HC_EP_HANDLE       HighSpeedEndpoint;
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32                     Magic;
X  unsigned long                     Magic;
N#endif
N  // PortResetActive points to a port where the port reset state machine is started or is active. At the end of the
N  // set address state of a port reset or if the device where the port is located is removed this pointer is set to NULL!
N  USBH_HUB_PORT              * pActivePortReset;
N};
N
N#define HC_INC_REF(devPtr) (devPtr)->RefCount++                                                    // Reference counting macros to the USB_DEVICE object
N
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N#define HC_DEC_REF(pDevice)                                                                         \
N    (pDevice)->RefCount--;                                                                          \
N    if ((pDevice)->RefCount == 1) {                                                                 \
N      USBH_LOG((USBH_MTYPE_CORE, "HC_DEC_REF RefCount is 1 %s(%d)\n", __FILE__, __LINE__));        \
N    }                                                                                              \
N    if ((pDevice)->RefCount <  0) {                                                                 \
N      USBH_LOG((USBH_MTYPE_CORE, "HC_DEC_REF RefCount less than 0 %s(%d)\n", __FILE__, __LINE__)); \
N    }                                                                                              \
N    if ((pDevice)->RefCount == 0) {                                                                 \
N      USBH_LOG((USBH_MTYPE_CORE, "HC_DEC_REF RefCount is 0 %s(%d)\n", __FILE__, __LINE__));        \
N      USBH_DeleteHostController(pDevice);                                                             \
N    }
X#define HC_DEC_REF(pDevice)                                                                             (pDevice)->RefCount--;                                                                              if ((pDevice)->RefCount == 1) {                                                                       USBH_LOG((USBH_MTYPE_CORE, "HC_DEC_REF RefCount is 1 %s(%d)\n", __FILE__, __LINE__));            }                                                                                                  if ((pDevice)->RefCount <  0) {                                                                       USBH_LOG((USBH_MTYPE_CORE, "HC_DEC_REF RefCount less than 0 %s(%d)\n", __FILE__, __LINE__));     }                                                                                                  if ((pDevice)->RefCount == 0) {                                                                       USBH_LOG((USBH_MTYPE_CORE, "HC_DEC_REF RefCount is 0 %s(%d)\n", __FILE__, __LINE__));              USBH_DeleteHostController(pDevice);                                                                 }
N#else
S  #define HC_DEC_REF(pDevice)           \
S    (pDevice)->RefCount--;              \
S    if ((pDevice)->RefCount == 0) {     \
S      USBH_DeleteHostController(pDevice); \
S    }
X  #define HC_DEC_REF(pDevice)               (pDevice)->RefCount--;                  if ((pDevice)->RefCount == 0) {           USBH_DeleteHostController(pDevice);     }
N#endif
N
N#define USBH_OHC_Add   USBH_OHCI_Add
N
NUSBH_HOST_CONTROLLER * USBH_CreateHostController      (USBH_HOST_DRIVER * pDriver, USBH_HC_HANDLE hController);
Nvoid                   USBH_BD_FreeUsbAddress         (USBH_HOST_CONTROLLER * HostController, U8 Address);
Xvoid                   USBH_BD_FreeUsbAddress         (USBH_HOST_CONTROLLER * HostController, unsigned char Address);
Nvoid                   USBH_HC_ServicePorts           (USBH_HOST_CONTROLLER * HostController);
NU8                     USBH_BD_GetUsbAddress          (USBH_HOST_CONTROLLER * HostController);
Xunsigned char                     USBH_BD_GetUsbAddress          (USBH_HOST_CONTROLLER * HostController);
Nvoid                   USBH_DeleteHostController      (USBH_HOST_CONTROLLER * Host);
Nvoid                   USBH_AddUsbDevice              (USB_DEVICE      * Device);
Nvoid                   USBH_HC_RemoveDeviceFromList   (USB_DEVICE      * Device);
Nvoid                   USBH_DefaultReleaseEpCompletion(void            * Context);
Nvoid                   USBH_Task                      (void);
Nvoid                   USBH_ISRTask                   (void);
Nvoid                   USBH_EnumTask                  (void);
Nvoid                   USBH_ConfigTransferBufferSize  (U32 Size);
Xvoid                   USBH_ConfigTransferBufferSize  (unsigned long Size);
Nvoid                   USBH_ConfigRootHub             (U8 SupportOvercurrent, U8 PortsAlwaysPowered, U8 PerPortPowered);
Xvoid                   USBH_ConfigRootHub             (unsigned char SupportOvercurrent, unsigned char PortsAlwaysPowered, unsigned char PerPortPowered);
Nvoid                   USBH_ConfigMaxUSBDevices       (U8 NumDevices);
Xvoid                   USBH_ConfigMaxUSBDevices       (unsigned char NumDevices);
Nvoid                   USBH_ConfigMaxNumEndpoints     (U8 MaxNumBulkEndpoints, U8 MaxNumIntEndpoints, U8 MaxNumIsoEndpoints);
Xvoid                   USBH_ConfigMaxNumEndpoints     (unsigned char MaxNumBulkEndpoints, unsigned char MaxNumIntEndpoints, unsigned char MaxNumIsoEndpoints);
Nvoid                   USBH_ConfigSupportExternalHubs (U8 OnOff);
Xvoid                   USBH_ConfigSupportExternalHubs (unsigned char OnOff);
Nvoid                   USBH_AddController             (void);
Nvoid                   USBH_OHCI_Add                  (void * pBase);
Nvoid                   USBH_STM32_Add                 (void * pBase);
Nvoid                   USBH_ProcessISR                (unsigned Index);
Nvoid                   USBH_ServiceISR                (unsigned Index);
NUSBH_URB *             USBH_AllocIsoUrb               (unsigned NumIsoPackets, unsigned NumBytesForBuffer);
Nvoid                   USBH_FreeIsoUrb                (USBH_URB * pUrb);
N
Ntypedef enum {
N  USBH_DEVICE_EVENT_ADD,
N  USBH_DEVICE_EVENT_REMOVE
N} USBH_DEVICE_EVENT;
N
Ntypedef void USBH_NOTIFICATION_FUNC(void * pContext, U8 DevIndex, USBH_DEVICE_EVENT Event);
Xtypedef void USBH_NOTIFICATION_FUNC(void * pContext, unsigned char DevIndex, USBH_DEVICE_EVENT Event);
N
N
N/*********************************************************************
N*
N*       USBH_HID
N*/
Ntypedef struct {
N  unsigned Code;
N  int      Value;
N} USBH_HID_KEYBOARD_DATA;
N
Ntypedef struct {
N  int xChange;
N  int yChange;
N  int WheelChange;
N  int ButtonState;
N} USBH_HID_MOUSE_DATA;
N
Ntypedef enum {
N  USBH_HID_INPUT_REPORT = 0,
N  USBH_HID_OUTPUT_REPORT,
N  USBH_HID_FEATURE_REPORT
N} USBH_HID_REPORT_TYPE;
N
Ntypedef int USBH_HID_HANDLE;
Ntypedef struct {
N  USBH_HID_REPORT_TYPE ReportType;
N  U32 ReportId;
X  unsigned long ReportId;
N  U32 ReportSize;
X  unsigned long ReportSize;
N} USBH_HID_REPORT_INFO;
N
Ntypedef struct {
N  U16  InputReportSize;
X  unsigned short  InputReportSize;
N  U16  OutputReportSize;
X  unsigned short  OutputReportSize;
N  U16  ProductId;
X  unsigned short  ProductId;
N  U16  VendorId;
X  unsigned short  VendorId;
N  char acName[7];
N} USBH_HID_DEVICE_INFO;
N
Ntypedef void USBH_HID_USER_FUNC(void * pContext);
N
N
Ntypedef void (USBH_HID_ON_KEYBOARD_FUNC) (USBH_HID_KEYBOARD_DATA * pKeyData);
Ntypedef void (USBH_HID_ON_MOUSE_FUNC)    (USBH_HID_MOUSE_DATA    * pMouseData);
N
Nvoid      USBH_HID_Exit(void);
NUSBH_BOOL USBH_HID_Init(void);
Xchar USBH_HID_Init(void);
Nvoid      USBH_HID_SetOnMouseStateChange   (USBH_HID_ON_MOUSE_FUNC    * pfOnChange);
Nvoid      USBH_HID_SetOnKeyboardStateChange(USBH_HID_ON_KEYBOARD_FUNC * pfOnChange);
N
NUSBH_STATUS     USBH_HID_Close                    (USBH_HID_HANDLE hDevice);
Nint             USBH_HID_GetNumDevices            (USBH_HID_DEVICE_INFO * pDevInfo, U32 NumItems);
Xint             USBH_HID_GetNumDevices            (USBH_HID_DEVICE_INFO * pDevInfo, unsigned long NumItems);
NUSBH_STATUS     USBH_HID_GetReportDescriptorParsed(USBH_HID_HANDLE hDevice, USBH_HID_REPORT_INFO * pReportInfo, unsigned * pNumEntries);
NUSBH_STATUS     USBH_HID_GetDeviceInfo            (USBH_HID_HANDLE hDevice, USBH_HID_DEVICE_INFO * pDevInfo);
NUSBH_STATUS     USBH_HID_GetReportDescriptor      (USBH_HID_HANDLE hDevice, U8 * pReportDescriptor, unsigned NumBytes);
XUSBH_STATUS     USBH_HID_GetReportDescriptor      (USBH_HID_HANDLE hDevice, unsigned char * pReportDescriptor, unsigned NumBytes);
NUSBH_STATUS     USBH_HID_GetReport                (USBH_HID_HANDLE hDevice, U8 * pReport, U32 NumBytes, USBH_HID_USER_FUNC * pfFunc, void * pContextData);
XUSBH_STATUS     USBH_HID_GetReport                (USBH_HID_HANDLE hDevice, unsigned char * pReport, unsigned long NumBytes, USBH_HID_USER_FUNC * pfFunc, void * pContextData);
NUSBH_HID_HANDLE USBH_HID_Open                     (const char * sName);
NUSBH_STATUS     USBH_HID_SetReport                (USBH_HID_HANDLE hDevice, const U8 * pReport, U32 NumBytes, USBH_HID_USER_FUNC * pfFunc, void * pContextData);
XUSBH_STATUS     USBH_HID_SetReport                (USBH_HID_HANDLE hDevice, const unsigned char * pReport, unsigned long NumBytes, USBH_HID_USER_FUNC * pfFunc, void * pContextData);
NUSBH_STATUS     USBH_HID_CancelIo                 (USBH_HID_HANDLE hDevice);
Nvoid            USBH_HID_RegisterNotification     (USBH_NOTIFICATION_FUNC * pfNotification, void * pContext);
N
N/*********************************************************************
N*
N*       USBH_LCD, used to control an EPSON USB 2 LCD controller
N*/
N
Ntypedef int USBH_LCD_HANDLE;
N
NUSBH_BOOL       USBH_LCD_Init(void);
Xchar       USBH_LCD_Init(void);
Nvoid            USBH_LCD_Exit(void);
NUSBH_LCD_HANDLE USBH_LCD_Open(const char * sName);
NUSBH_STATUS     USBH_LCD_WriteCmd(USBH_LCD_HANDLE hDevice, U8 * pCmdBuffer, unsigned NumBytesCmd, U8 * pStatusBuffer, unsigned NumBytesStatus);
XUSBH_STATUS     USBH_LCD_WriteCmd(USBH_LCD_HANDLE hDevice, unsigned char * pCmdBuffer, unsigned NumBytesCmd, unsigned char * pStatusBuffer, unsigned NumBytesStatus);
NUSBH_STATUS     USBH_LCD_WriteDisplayData(USBH_LCD_HANDLE hDevice, U8 * pData, unsigned NumBytes);
XUSBH_STATUS     USBH_LCD_WriteDisplayData(USBH_LCD_HANDLE hDevice, unsigned char * pData, unsigned NumBytes);
NUSBH_STATUS     USBH_LCD_Close(USBH_LCD_HANDLE hDevice);
Nint             USBH_LCD_GetNumDevices(void);
N
N/*********************************************************************
N*
N*       USBH_LCD, used to control an EPSON USB 2 LCD controller
N*/
N
Ntypedef int USBH_PRINTER_HANDLE;
N/*********************************************************************
N*
N*       USBH_PRINTER
N*/
N// Function parameter for the user callback function USBH_DEVICE_LUN_NOTIFICATION_FUNC
N
NUSBH_BOOL           USBH_PRINTER_Init(void);
Xchar           USBH_PRINTER_Init(void);
Nvoid                USBH_PRINTER_Exit(void);
NUSBH_PRINTER_HANDLE USBH_PRINTER_Open(const char * sName);
NUSBH_STATUS         USBH_PRINTER_Write(USBH_PRINTER_HANDLE hDevice, const U8 * pData, unsigned NumBytes);
XUSBH_STATUS         USBH_PRINTER_Write(USBH_PRINTER_HANDLE hDevice, const unsigned char * pData, unsigned NumBytes);
NUSBH_STATUS         USBH_PRINTER_Read(USBH_PRINTER_HANDLE hDevice, U8 * pData, unsigned NumBytes);
XUSBH_STATUS         USBH_PRINTER_Read(USBH_PRINTER_HANDLE hDevice, unsigned char * pData, unsigned NumBytes);
NUSBH_STATUS         USBH_PRINTER_GetPortStatus(USBH_PRINTER_HANDLE hDevice, U8 * pStatus);
XUSBH_STATUS         USBH_PRINTER_GetPortStatus(USBH_PRINTER_HANDLE hDevice, unsigned char * pStatus);
NUSBH_STATUS         USBH_PRINTER_ExecSoftReset(USBH_PRINTER_HANDLE hDevice);
NUSBH_STATUS         USBH_PRINTER_GetDeviceId(USBH_PRINTER_HANDLE hDevice, U8 * pData, unsigned NumBytes);
XUSBH_STATUS         USBH_PRINTER_GetDeviceId(USBH_PRINTER_HANDLE hDevice, unsigned char * pData, unsigned NumBytes);
NUSBH_STATUS         USBH_PRINTER_Close(USBH_PRINTER_HANDLE hDevice);
Nint                 USBH_PRINTER_GetNumDevices(void);
Nvoid                USBH_PRINTER_RegisterNotification(USBH_NOTIFICATION_FUNC * pfNotification, void * pContext);
Nvoid                USBH_PRINTER_ConfigureTimeout(U32 Timeout);
Xvoid                USBH_PRINTER_ConfigureTimeout(unsigned long Timeout);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif
N
N/********************************* EOF ******************************/
L 28 "USBH\USBH_Int.h" 2
N#include "USBH_ConfDefaults.h"
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" { // Make sure we have C-declarations in C++ programs
N#endif
N
N#ifdef USBHCORE_C
S  #define EXTERN
N#else
N  #define EXTERN extern
N#endif
N
N#if USBH_SUPPORT_LOG
X#if 1
N  #define USBH_LOG(p) USBH_Logf p
N#else
S  #define USBH_LOG(p)
N#endif
N
N#if USBH_SUPPORT_WARN
X#if 1
N  #define USBH_WARN(p) USBH_Warnf p
N#else
S  #define USBH_WARN(p)
N#endif
N
N#if USBH_DEBUG >= 3
X#if 2 >= 3
S  #define USBH_WARN_INTERNAL(p) USBH_Warnf p
N#else
N  #define USBH_WARN_INTERNAL(p)
N#endif
N
N// Useful macros:
N#define USBH_MIN(x,y)    ((x)  <  (y)   ?  (x)   :  (y))
N#define USBH_MAX(x,y)    ((x)  >  (y)   ?  (x)   :  (y))
N#define USBH_COUNTOF(a)  (sizeof(a)/sizeof(a[0]))
N
N/*********************************************************************
N*
N*       USBH_GLOBAL
N*/
N
Ntypedef struct USBH_GLOBAL {
N  U8                      ConfigCompleted;
X  unsigned char                      ConfigCompleted;
N  U8                      InitCompleted;
X  unsigned char                      InitCompleted;
N  USBH_HC_HANDLE          hHC;
N  USBH_HC_BD_HANDLE       hHCBD;
N  USBH_HOST_DRIVER_INST   DriverInst;
N  USBH_HOST_DRIVER      * pDriver;
N  struct {
N    U32 TransferBufferSize;
X    unsigned long TransferBufferSize;
N    U8  NumRootHubs;
X    unsigned char  NumRootHubs;
N    U8  RootHubPortsAlwaysPowered;
X    unsigned char  RootHubPortsAlwaysPowered;
N    U8  RootHubPerPortPowered;
X    unsigned char  RootHubPerPortPowered;
N    U8  RootHubSupportOvercurrent;
X    unsigned char  RootHubSupportOvercurrent;
N    U8  NumUSBDevices;
X    unsigned char  NumUSBDevices;
N    U8  NumBulkEndpoints;
X    unsigned char  NumBulkEndpoints;
N    U8  NumIntEndpoints;
X    unsigned char  NumIntEndpoints;
N    U8  NumIsoEndpoints;
X    unsigned char  NumIsoEndpoints;
N    U8  SupportExternalHubs;
X    unsigned char  SupportExternalHubs;
N  } Config;
N} USBH_GLOBAL;
N
NEXTERN USBH_GLOBAL USBH_Global;
Xextern USBH_GLOBAL USBH_Global;
N
N#define USBH_PRINT_STATUS_VALUE(Type, status) USBH_WARN((Type, "%s", USBH_GetStatusStr(status)))
N
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  #define USBH_ASSERT(condition)          if (!(condition)) { USBH_WARN((USBH_MTYPE_CORE, "\nASSERTION FAILED: %s(%d)\n", __FILE__, __LINE__)); }
N  #define USBH_ASSERT_PTR(Ptr)               USBH_ASSERT(Ptr != NULL)
N  #define USBH_ASSERT_MAGIC(ptr,type)        USBH_ASSERT(USBH_IS_PTR_VALID((ptr),type))
N  #define USBH_ASSERT0                       USBH_WARN((USBH_MTYPE_CORE, "\nASSERT0: %s(%d)\n", __FILE__, __LINE__));
N#else
S  #define USBH_ASSERT(condition)
S  #define USBH_ASSERT_PTR(Ptr)
S  #define USBH_ASSERT_MAGIC(ptr, type)
S  #define USBH_ASSERT0
N#endif
N
N#define FOUR_CHAR_ULONG(c1,c2,c3,c4)   (((U32)(c1)) | (((U32)(c2))<<8) | (((U32)(c3))<<16) | (((U32)(c4))<<24)) // Generates a magic ulong (four char code)
N#define TWO_CHAR_USHORT(c1,c2)         (((U16)(c1)) | ( (U16)(c2) <<8))                                         // Generates a magic ulong (four char code)
N#define GET_MASK_FROM_BITNUMBER(BitNb) (((U32)(1))<<(BitNb))
N// Calculate the pointer to the base of an object given its type and a pointer to a field within the object.
N#define USBH_ZERO_MEMORY(        mem,count)     USBH_MEMSET((mem), 0,   (count))
N#define USBH_ZERO_STRUCT(        s)             USBH_ZERO_MEMORY(&(s),sizeof(s))
N#define USBH_ZERO_ARRAY(         s)             USBH_ZERO_MEMORY( (s),sizeof(s))
N#define USBH_ARRAY_ELEMENTS(     a)             (sizeof(a)     / sizeof(a[0]))
N#define USBH_ARRAY_LIMIT(        a)             (&a[USBH_ARRAY_ELEMENTS(a)])
N
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  #define USBH_IS_PTR_VALID(p,type) ((p)!=NULL && (p)->Magic==type##_MAGIC) // Takes a pointer and its type and compares the Magic field with a constant
N#else
S  #define USBH_IS_PTR_VALID(ptr,type)
N#endif
N
N// Helper macro, used to convert enum constants to string values
N// lint -save -e773
N#define USBH_ENUM_TO_STR(e) (x==(e)) ? #e
N// lint -restore
N#define USBH_IS_ALIGNED(val,size) (((val) &  ((size)-1)) == 0)          // Returns true if the given value is aligned to a 'size' boundary
N#define USBH_ALIGN_UP(  val,size) (((val) +  ((size)-1)) & ~((size)-1)) // Round up a value to the next 'size' boundary
N#define USBH_ALIGN_DOWN(val,size) ( (val) & ~((size)-1))                // Round down a value to the next 'size' boundary
N
N#if (USBH_DEBUG > 1)                                                  // Handy macro to enable code in debug builds only
X#if (2 > 1)                                                  
N  #define IFDBG(x) { x; }
N#else
S  #define IFDBG(x)
N#endif
N
N/* xyxy */
N#define URB_BUFFER_POOL_MAGIC                   FOUR_CHAR_ULONG('T','P','O','O')
N#define ENUM_ERROR_NOTIFICATION_MAGIC           FOUR_CHAR_ULONG('E','N','O','T')
N#define USBH__PNP_NOTIFICATION_MAGIC            FOUR_CHAR_ULONG('P','N','P','N')
N#define DELAYED_PNP_NOTIFY_CONTEXT_MAGIC        FOUR_CHAR_ULONG('P','N','P','D')
N#define INTERFACE_ENTRY_MAGIC                   FOUR_CHAR_ULONG('I','F','A','E')
N#define OHD_EP0_MAGIC                           FOUR_CHAR_ULONG('E','P','0','M')
N#define USBH_OHCI_DEVICE_MAGIC                  FOUR_CHAR_ULONG('O','D','E','V')
N#define USBH_STM32_INST_MAGIC                   FOUR_CHAR_ULONG('S','T','M','I')
N#define DEFAULT_EP_MAGIC                        FOUR_CHAR_ULONG('E','P','0',' ')
N#define USB_ENDPOINT_MAGIC                      FOUR_CHAR_ULONG('E','N','D','P')
N#define USB_INTERFACE_MAGIC                     FOUR_CHAR_ULONG('U','I','F','U')
N#define USB_DEVICE_MAGIC                        FOUR_CHAR_ULONG('U','D','E','V')
N#define USBH_HOST_DRIVER_INST_MAGIC             FOUR_CHAR_ULONG('U','D','R','V')
N#define ROOT_HUB_MAGIC                          FOUR_CHAR_ULONG('R','H','U','B')
N#define USB_HUB_MAGIC                           FOUR_CHAR_ULONG('U','H','U','B')
N#define USBH_HUB_PORT_MAGIC                     FOUR_CHAR_ULONG('P','O','R','T')
N#define USBH_HOST_CONTROLLER_MAGIC              FOUR_CHAR_ULONG('H','O','S','T')
N#define USBH_HCM_POOL_MAGIC                     FOUR_CHAR_ULONG('P','O','O','L')
N#define USBH_HCM_ITEM_HEADER_MAGIC                   FOUR_CHAR_ULONG('I','T','E','M')
N
N
N#define USBH_HCM_POOL_VALID(pPool)               USBH_ASSERT(USBH_IS_PTR_VALID((pPool),       USBH_HCM_POOL))
N#define USBH_HCM_ASSERT_ITEM_HEADER(pItemHeader) USBH_ASSERT(USBH_IS_PTR_VALID((pItemHeader), USBH_HCM_ITEM_HEADER))
N#define USBH_OCHI_IS_DEV_VALID(pDev)        USBH_ASSERT(USBH_IS_PTR_VALID(pDev, USBH_OHCI_DEVICE))
N#define USBH_OHCI_HANDLE_TO_PTR(pDev,USBH_hc_handle)     (pDev) = ((USBH_OHCI_DEVICE *)(USBH_hc_handle))
N#define USBH_STM32_IS_DEV_VALID(pDev)       USBH_ASSERT(USBH_IS_PTR_VALID(pDev, USBH_STM32_INST))
N#define USBH_STM32_HANDLE_TO_PTR(pDev,USBH_hc_handle)     (pDev) = ((USBH_STM32_INST *)(USBH_hc_handle))
N
N// Some Macros used for calculation of structure pointers.
N
N// Calculate the byte offset of a field in a structure of type type.
N// @func long | STRUCT_FIELD_OFFSET |
N//   This macro calculates the offset of <p field> relative to the base of the structure <p type>.
N// @parm IN<spc>| type |
N//   Type name of the structure
N// @parm IN<spc>| field |
N//   Field name
N// @rdesc
N//   Offset of the field <p field> relative to the base of the structure <p type>.
N// lint -emacro({413},STRUCT_FIELD_OFFSET)
N// lint -emacro({613},STRUCT_FIELD_OFFSET)
N#define STRUCT_FIELD_OFFSET(type, field)((long)&(((type *)0)->field) )
N
N// Calculate the pointer to the base of the structure given its type and a pointer to a field within the structure.
N// @func (type *) | STRUCT_BASE_POINTER |
N//   This macro calculates the pointer to the base of the structure given its type and a pointer to a field within the structure.
N// @parm IN<spc>| fieldptr |
N//   Pointer to the field <p field> of the structure
N// @parm IN<spc>| type |
N//   Type name of the structure
N// @parm IN<spc>| field |
N//   Field name
N// @rdesc
N//   Address of the structure which contains <p field>.
N// @comm
N//   The returned pointer is of type 'pointer to <p type>'.
N// lint -emacro({413},STRUCT_BASE_POINTER)
N// lint -emacro({613},STRUCT_BASE_POINTER)
N#define STRUCT_BASE_POINTER(fieldptr, type, field)((type *)(((char *)(fieldptr)) - ((char *)(&(((type *)0)->field)))))
N
N
N
N// Needs the struct and the name of the list entry inside the struct
N#define GET_HCMITEM_FROM_ENTRY(pListEntry)                    STRUCT_BASE_POINTER(pListEntry, USBH_HCM_ITEM_HEADER,            Link.ListEntry)
N#define GET_BUFFER_FROM_ENTRY(pListEntry)                     STRUCT_BASE_POINTER(pListEntry, URB_BUFFER,                 ListEntry)
N#define GET_ENUM_ERROR_NOTIFICATION_FROM_ENTRY(pListEntry)    STRUCT_BASE_POINTER(pListEntry, ENUM_ERROR_NOTIFICATION,    ListEntry)
N#define GET_PNP_NOTIFICATION_FROM_ENTRY(pListEntry)           STRUCT_BASE_POINTER(pListEntry, USBH__PNP_NOTIFICATION,     ListEntry)
N#define GET_DELAYED_PNP_NOTIFY_CONTEXT_FROM_ENTRY(pListEntry) STRUCT_BASE_POINTER(pListEntry, DELAYED_PNP_NOTIFY_CONTEXT, ListEntry)
N#define GET_INTERFACE_ENTRY_FROM_ENTRY(pListEntry)            STRUCT_BASE_POINTER(pListEntry, INTERFACE_ENTRY,            ListEntry)
N#define GET_CONTROL_EP_FROM_ENTRY(pListEntry)                 STRUCT_BASE_POINTER(pListEntry, USBH_OHCI_EP0,              ListEntry)
N#define GET_HCM_ITEM_HEADER_FROM_ENTRY(pListEntry)            STRUCT_BASE_POINTER(pListEntry, USBH_HCM_ITEM_HEADER,            Link.ListEntry)
N#define GET_URB_HEADER_FROM_ENTRY(pListEntry)                 STRUCT_BASE_POINTER(pListEntry, USBH_HEADER,                ListEntry)
N#define GET_CONTROL_EP_FROM_ENTRY(pListEntry)                 STRUCT_BASE_POINTER(pListEntry, USBH_OHCI_EP0,              ListEntry)
N#define GET_BULKINT_EP_FROM_ENTRY(pListEntry)                 STRUCT_BASE_POINTER(pListEntry, USBH_OHCI_BULK_INT_EP,            ListEntry)
N#define GET_ISO_EP_FROM_ENTRY(pListEntry)                     STRUCT_BASE_POINTER(pListEntry, USBH_OHCI_ISO_EP,           ListEntry)
N#define GET_HUB_PORT_PTR(pListEntry)                          STRUCT_BASE_POINTER(pListEntry, USBH_HUB_PORT,              ListEntry)
N#define GET_BULKINT_EP_FROM_ENTRY(pListEntry)                 STRUCT_BASE_POINTER(pListEntry, USBH_OHCI_BULK_INT_EP,            ListEntry)
N#define GET_USB_DEVICE_FROM_ENTRY(pListEntry)                 STRUCT_BASE_POINTER(pListEntry, USB_DEVICE,                 ListEntry)
N#define GET_USB_DEVICE_FROM_TEMP_ENTRY(pListEntry)            STRUCT_BASE_POINTER(pListEntry, USB_DEVICE,                 TempEntry)
N#define GET_HOST_CONTROLLER_FROM_ENTRY(pListEntry)            STRUCT_BASE_POINTER(pListEntry, USBH_HOST_CONTROLLER,       ListEntry)
N#define GET_USB_ENDPOINT_FROM_ENTRY(pListEntry)               STRUCT_BASE_POINTER(pListEntry, USB_ENDPOINT,               ListEntry)
N#define GET_USB_INTERFACE_FROM_ENTRY(pListEntry)              STRUCT_BASE_POINTER(pListEntry, USB_INTERFACE,              ListEntry)
N
Ntypedef struct URB_BUFFER_POOL {
N  U32                   Magic;
X  unsigned long                   Magic;
N  USBH_DLIST            ListEntry;
N  U32                   NumberOfBuffer; // Allocated number number of buffers in pool
X  unsigned long                   NumberOfBuffer; 
N  U32                   BufferCt;       // Number of buffers in buffer pool
X  unsigned long                   BufferCt;       
N  U32                   Size;           // Size of one buffer in bytes
X  unsigned long                   Size;           
N  USBH_INTERFACE_HANDLE hInterface;
N  U8                    Endpoint;
X  unsigned char                    Endpoint;
N  U32                   Index;
X  unsigned long                   Index;
N  int                   ResetFlag;
N  int                   BusMasterMemoryFlag;
N} URB_BUFFER_POOL;
N
N
Ntypedef struct URB_BUFFER {
N  USBH_DLIST        ListEntry;
N  U8              * pTransferBuffer; // Transfer buffer
X  unsigned char              * pTransferBuffer; 
N  USBH_URB          Urb;            // Allocated URB
N  U32               Size;           // Size of buffer in bytes
X  unsigned long               Size;           
N  URB_BUFFER_POOL * pPool;           // Owning pool
N  U32               Index;          // Index number for debugging
X  unsigned long               Index;          
N} URB_BUFFER;
N
NURB_BUFFER_POOL * USBH_URB_CreateTransferBufferPool(USBH_INTERFACE_HANDLE IfaceHandle, U8 Endpoint, U32 SizePerBuffer, U32 BufferNumbers, int BusMasterTransferMemoryFlag);
XURB_BUFFER_POOL * USBH_URB_CreateTransferBufferPool(USBH_INTERFACE_HANDLE IfaceHandle, unsigned char Endpoint, unsigned long SizePerBuffer, unsigned long BufferNumbers, int BusMasterTransferMemoryFlag);
N
NURB_BUFFER * USBH_URB_GetFromTransferBufferPool  (URB_BUFFER_POOL * Pool);
Nvoid         USBH_URB_PutToTransferBufferPool    (URB_BUFFER      * Buffer);
Nvoid         USBH_URB_DeleteTransferBufferPool   (URB_BUFFER_POOL * Pool);
Nvoid         USBH_URB_InitUrbBulkTransfer        (URB_BUFFER      * Buffer, USBH_ON_COMPLETION_FUNC * pfOnCompletion, void * Context);
NU32          USBH_URB_GetPendingCounterBufferPool(URB_BUFFER_POOL * Pool);
Xunsigned long          USBH_URB_GetPendingCounterBufferPool(URB_BUFFER_POOL * Pool);
N
N// Allocates always USBH_TRANSFER_BUFFER_ALIGNMENT aligned transfer buffer from the heap
Nvoid * USBH_URB_BufferAllocateTransferBuffer(U32 size);
Xvoid * USBH_URB_BufferAllocateTransferBuffer(unsigned long size);
N// Frees buffer allocated with USBH_URB_BufferAllocateTransferBuffer
Nvoid   USBH_URB_BufferFreeTransferBuffer(void * pMemBlock);
N
N// This macro need the struct and the name of the list entry inside the struct.
N
Ntypedef struct ENUM_ERROR_NOTIFICATION {
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32                       Magic;
X  unsigned long                       Magic;
N#endif
N  USBH_DLIST                ListEntry;         // To store this object in the BUS_DRIVER object
N  void                    * pContext;           // User context / A copy of the parameter passed to USBH_RegisterEnumErrorNotification
N  USBH_ON_ENUM_ERROR_FUNC * pfOnEnumError;
N} ENUM_ERROR_NOTIFICATION;
N
Nvoid   UbdFireEnumErrorNotification                (USBH_ENUM_ERROR * pEnumError);                                                          // Walk trough the device driver enum error notification list and call registered notify callback routines!
Nvoid   UbdSetEnumErrorNotificationRootPortReset    (USBH_HUB_PORT   * pPort, USBH_ROOT_HUB_PORTRESET_STATE state,  USBH_STATUS status);      // Notify about an root hub pPort reset error
Nvoid   UbdSetEnumErrorNotificationProcessDeviceEnum(USBH_HUB_PORT   * pPort, DEV_ENUM_STATE state,      USBH_STATUS status, int hub_flag);   // Notify about a USB device enumeration error
Nvoid   UbdSetEnumErrorNotificationHubPortReset(     USBH_HUB_PORT   * pPort, USBH_HUB_PORTRESET_STATE state, USBH_STATUS status);  // Notify about an external hub pPort reset error
N
N#define USBH_MAX_RECURSIVE 20
N
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  #define INC_RECURSIVE_CT(funcname)                                                   \
N    static int USBH_recursive_ct;                                                      \
N    USBH_recursive_ct++;                                                               \
N    if (USBH_recursive_ct > USBH_MAX_RECURSIVE) {                                      \
N      USBH_WARN((USBH_MTYPE_CORE, ""#funcname ":recursive-ct:%ld",USBH_recursive_ct)); \
N    }
X  #define INC_RECURSIVE_CT(funcname)                                                       static int USBH_recursive_ct;                                                          USBH_recursive_ct++;                                                                   if (USBH_recursive_ct > USBH_MAX_RECURSIVE) {                                            USBH_WARN((USBH_MTYPE_CORE, ""#funcname ":recursive-ct:%ld",USBH_recursive_ct));     }
N
N  // The second test is only for testing of the macro
N  #define DEC_RECURSIVE_CT(funcname)                                                        \
N    if(0>=USBH_recursive_ct){                                                               \
N      USBH_WARN((USBH_MTYPE_CORE, ""#funcname ":recursive <= 0 ct:%ld",USBH_recursive_ct)); \
N    }                                                                                       \
N    USBH_recursive_ct--
X  #define DEC_RECURSIVE_CT(funcname)                                                            if(0>=USBH_recursive_ct){                                                                     USBH_WARN((USBH_MTYPE_CORE, ""#funcname ":recursive <= 0 ct:%ld",USBH_recursive_ct));     }                                                                                           USBH_recursive_ct--
N#else
S  #define INC_RECURSIVE_CT(funcname)
S  #define DEC_RECURSIVE_CT(funcname)
N#endif
N
N// Return the pointer to the beginning of the descriptor or NULL if not Desc. is found
N// const void * PrevDesc - Pointer to a descriptor
N// int * Length          - IN:  Remaining bytes from Desc.
N//                         OUT: If the descriptor is found then that is the remaining length from the beginning of the returned descriptor
N// int DescType          - Descriptor type, see USB spec
Nconst void * USBH_SearchNextDescriptor(const void * PrevDesc, int * Length, int DescType);
N
N
N// This macro need the struct and the name of the list entry inside the struct.
N
Ntypedef struct USBH__PNP_NOTIFICATION { // The USB device object
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32                   Magic;
X  unsigned long                   Magic;
N#endif
N  USBH_DLIST                 ListEntry;       // To store this object in the BUS_DRIVER object
N  USBH_PNP_NOTIFICATION UbdNotification; // A copy of the notification passed to USBH_RegisterPnPNotification
N} USBH__PNP_NOTIFICATION;
N
N
N// Used for indirect calling of the user notification routine
Ntypedef struct DELAYED_PNP_NOTIFY_CONTEXT {
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32 Magic;
X  unsigned long Magic;
N#endif
N  // To store this object in the BUS_DRIVER object
N  USBH_DLIST               ListEntry;
N  void                   * pContext;
N  USBH_PNP_EVENT           Event;
N  USBH_ON_PNP_EVENT_FUNC * NotifyCallback;
N  USBH_INTERFACE_ID        Id;
N} DELAYED_PNP_NOTIFY_CONTEXT;
N
NUSBH__PNP_NOTIFICATION * USBH_PNP_NewNotification    (USBH_PNP_NOTIFICATION  * pfOnUbdNotification);
Nvoid                     USBH_PNP_ReleaseNotification(USBH__PNP_NOTIFICATION * pfOnPnpNotification);
N
N// If this interface matches with the interface Mask of pfOnPnpNotification the event notification function is called with the event.
N// Parameters:
N//   pfOnPnpNotification: Pointer to the notification
N//   pDev:             Pointer to an device
N//   event:           device is connected, device is removed!
N//                    Normally one device at the time is changed!
Nvoid USBH_PNP_ProcessDeviceNotifications(USBH__PNP_NOTIFICATION * pfOnPnpNotification, USB_DEVICE * pDev, USBH_PNP_EVENT Event);
N
N// Check the notification against all interfaces. If an device is removed or connected and the interface matches
N// and the event has been not sent the notification function is called.
Nvoid USBH_PNP_ProcessNotification(USBH__PNP_NOTIFICATION * PnpNotification);
Nvoid USBH_PNP_NotifyWrapperCallbackRoutine(void    * Context);
N
N// This macro need the struct and the name of the list entry inside the struct
N
N// The interface list object based on one host controller!
Ntypedef struct INTERFACE_LIST {
N  USBH_DLIST   UsbInterfaceEntryList; // List for interfaces of type INTERFACE_ENTRY
N  unsigned int InterfaceCount;        // Number of entries in the UsbInterfaceList
N} INTERFACE_LIST;
N
N// the entry to keep this object in the InterfaceList
Ntypedef struct INTERFACE_ENTRY {
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32                      Magic;
X  unsigned long                      Magic;
N#endif
N  USBH_DLIST               ListEntry;
N  USBH_HOST_CONTROLLER   * HostController; // Pointer to the owning host controller
N  USBH_INTERFACE_ID        InterfaceID;    // The interface ID
N} INTERFACE_ENTRY;
N
N/*********************************************************************
N*
N*       OHCI specific
N*
N**********************************************************************
N*/
N#define OH_ISO_VALID(OHD_ISO_EP_Ptr)              USBH_HCM_ASSERT_ITEM_HEADER(&OHD_ISO_EP_Ptr->ItemHeader)
N#define OH_BULKINT_VALID(OHD_BULK_INT_EP_Ptr)     USBH_HCM_ASSERT_ITEM_HEADER(&OHD_BULK_INT_EP_Ptr->ItemHeader)
N#define OH_EP0_VALID(OHD_EP0_Ptr)                 USBH_HCM_ASSERT_ITEM_HEADER(&OHD_EP0_Ptr->ItemHeader)
N#define OH_ASSERT_PORT_NUMBER(devPtr,PortNumber)  USBH_ASSERT((PortNumber) != 0); USBH_ASSERT((PortNumber) <= (devPtr) -> RootHub.PortCount)
N
N
N//lint -emacro((826),OhcWriteReg)
N// Base must be an character pointer.
N#define OhHalWriteReg(Base, Offset, Value) USBH_WriteReg32 (((Base) + (Offset)), (Value))
N//lint -emacro((826),OhcReadReg)
N#define OhHalReadReg( Base, Offset)        USBH_ReadReg32  (((Base) + (Offset)))
N#define OhHalTestReg( Base, Offset, Mask) (0 != (OhHalReadReg((Base), (Offset)) & (Mask)) ? TRUE : FALSE)
N
N#define OhHalSetReg(Base,Offset, Mask)                      \
N  { U32    temp;                                            \
N    temp = OhHalReadReg((Base), (Offset));                  \
N    OhHalWriteReg      ((Base), (Offset), (temp | (Mask))); \
N  }
X#define OhHalSetReg(Base,Offset, Mask)                        { U32    temp;                                                temp = OhHalReadReg((Base), (Offset));                      OhHalWriteReg      ((Base), (Offset), (temp | (Mask)));   }
N
N#define OhHalClrReg(Base,Offset, Mask)            \
N  { U32 temp;                                     \
N    temp  = OhHalReadReg((Base), (Offset));       \
N    temp &= ~(U32)(Mask);                         \
N    OhHalWriteReg       ((Base), (Offset), temp); \
N  }
X#define OhHalClrReg(Base,Offset, Mask)              { U32 temp;                                         temp  = OhHalReadReg((Base), (Offset));           temp &= ~(U32)(Mask);                             OhHalWriteReg       ((Base), (Offset), temp);   }
N
NU8   USBH_ReadReg8  (U8  * pAddr);
Xunsigned char   USBH_ReadReg8  (unsigned char  * pAddr);
NU16  USBH_ReadReg16 (U16 * pAddr);
Xunsigned short  USBH_ReadReg16 (unsigned short * pAddr);
Nvoid USBH_WriteReg32(U8  * pAddr, U32 Value);
Xvoid USBH_WriteReg32(unsigned char  * pAddr, unsigned long Value);
NU32  USBH_ReadReg32 (U8  * pAddr);
Xunsigned long  USBH_ReadReg32 (unsigned char  * pAddr);
N
N// Control endpoint states
Ntypedef enum USBH_EP0_PHASE {
N  ES_IDLE   = 0,
N  ES_SETUP,
N  ES_DATA,
N  ES_COPY_DATA,
N  ES_PROVIDE_HANDSHAKE,
N  ES_HANDSHAKE,
N  ES_ERROR
N} USBH_EP0_PHASE;
N
Ntypedef struct SETUP_BUFFER {
N  // Recommended!!!:
N  //   first filed:  USBH_HCM_ITEM_HEADER
N  //   second field: U8 EndpointType
N  USBH_HCM_ITEM_HEADER ItemHeader;
N} SETUP_BUFFER;
N
N#define OHD_MAX_TD 200         // Maximum number of all transfer descriptors
N
Ntypedef enum T_OHD_TD_STATUS { // Events for the PnP function
N  OH_TD_PENDING,               // The TD is pending
N  OH_TD_COMPLETED,             // TD is complete
N  OH_TD_CANCELED,              // TD is canceled
N  OH_TD_EMPTY                  // The TD is not used
N} OHD_TD_STATUS;
N
Ntypedef enum T_OHD_TD_PID {
N  OH_SETUP_PID = 0,
N  OH_OUT_PID,
N  OH_IN_PID
N} USBH_OHCI_TD_PID;
N
N// This bits in the OHCI TD and ISO TD DWORD 0 are not modified and are used
N#define OHCI_TD_DONE_MASK GET_MASK_FROM_BITNUMBER(OHCI_TD_NOT_USED_BIT_1)
N#define OHCI_TD_ISO_MASK  GET_MASK_FROM_BITNUMBER(OHCI_TD_NOT_USED_BIT_2)
N
N// The logical general transfer descriptor object ! General Transfer descriptor of the host controller driver, this includes a
N// memory pool object that contains the physical address of the host controller transfer descriptor.
Ntypedef struct USBH_OHCI_INFO_GENERAL_TRANS_DESC {
N  USBH_HCM_ITEM_HEADER  ItemHeader;        // The struct must always begin with an item header that includes the physical address
N  OHD_TD_STATUS         Status;            // Current TD status
N  USBH_BOOL             CancelPendingFlag; // True if the URB request has been canceled and this TD is waiting for cleanup!
X  char             CancelPendingFlag; 
N  U32                   Size;              // Total number of bytes that are queued for this transfer
X  unsigned long                   Size;              
N  U8                    EndpointType;      // the type of the endpoint, one of USB_EP_TYPE_CONTROL, ... used to find the endpoint list
X  unsigned char                    EndpointType;      
N  void                * pEp;               // Pointer to the endpoint to which the transfer is queued
N} USBH_OHCI_INFO_GENERAL_TRANS_DESC;
N
N// This tow operations are only valid on the TD if the TD not in the ED list of the host or the ED list is disabled!
N#define OH_ED_SET_SKIP_BIT(edPtr) (edPtr->Dword0 |=       OHCI_ED_K)
N#define OH_ED_CLR_SKIP_BIT(edPtr) (edPtr->Dword0 &= (U32)~OHCI_ED_K)
N#define OH_MAX_PKT_SIZE_EP0_LOWSPEED  8
N#define OH_MAX_PKT_SIZE_EP0           64
N#define OH_MAX_PKT_SIZE_BULK          64
N#define OH_MAX_PKT_SIZE_INT           64
N#define OH_MAX_PKT_SIZE_ISO           1023
N
N// Additional endpoint mask bits
N
N// Endpoint flags field
N#define OH_DUMMY_ED_EPFLAG    0x01UL
N#define OH_SHORT_PKT_EPFLAG   0x01UL
N
N// Endpoint states
N
Ntypedef enum USBH_EP_STATE {
N  OH_EP_IDLE,        // The endpoint is not linked
N  OH_EP_UNLINK,      // If the timer routine runs then the endpoint is removed and deleted
N  OH_EP_LINK,        // The endpoint is linked
N  OH_EP_UNLINK_TIMER // Endpoint is unlinked but the current timer routine must restart the timer
N} USBH_EP_STATE;
N
N// The logical control EP object
Ntypedef struct USBH_OHCI_EP0 {
N  // Recommended!!!:
N  //   first filed:  USBH_HCM_ITEM_HEADER
N  //   second field: U8 EndpointType
N  USBH_HCM_ITEM_HEADER              ItemHeader;
N  U8                                EndpointType;        // Endpoint type
X  unsigned char                                EndpointType;        
N  USBH_OHCI_DEVICE                * pDev;                 // Backward pointer to the device
N  USBH_EP_STATE                     State;
N  USBH_DLIST                        ListEntry;           // USBH_OHCI_EP0 list
N  USBH_DLIST                        UrbList;             // submitted URB list
N  U16                               UrbCount;            // number of requests
X  unsigned short                               UrbCount;            
N  USBH_URB                        * pPendingUrb;          // pending URB
N  U16                               TdCounter;           // number of TDs on this endpoint
X  unsigned short                               TdCounter;           
N  U8                                AbortMask;
X  unsigned char                                AbortMask;
N  USBH_EP0_PHASE                    Ep0Phase;            // pSetup, data or handshake phase
N  U8                              * pSetup;               // pointer to the address of the buffer in pSetupPacket
X  unsigned char                              * pSetup;               
N  SETUP_BUFFER                    * pSetupPacket;         // pointer to an HCM pool entry which contains the pSetup packet address
N  USBH_OHCI_TRANSFER_BUFFER       * pDataPhaseCopyBuffer; // buffer used during data phase,  pointer is only valid in the data phase
N  USBH_RELEASE_EP_COMPLETION_FUNC * pfReleaseCompletion;
N  void                            * pReleaseContext;
N  U32                               Mask;
X  unsigned long                               Mask;
N  U8                                DeviceAddress;
X  unsigned char                                DeviceAddress;
N  U8                                EndpointAddress;
X  unsigned char                                EndpointAddress;
N  U16                               MaxPacketSize;      // Maximum packet size for that endpoint
X  unsigned short                               MaxPacketSize;      
N  USBH_SPEED                        Speed;
N} USBH_OHCI_EP0;
N
N
Ntypedef struct USBH_OHCI_BULK_INT_EP { // Logical bulk and interrupt EP object
N  // Recommended:
N  //   First  field: USBH_HCM_ITEM_HEADER
N  //   Second field: U8 EndpointType
N  USBH_HCM_ITEM_HEADER              ItemHeader;
N  U8                                EndpointType;
X  unsigned char                                EndpointType;
N  USBH_OHCI_DEVICE                * pDev;
N  USBH_EP_STATE                     State;
N  USBH_DLIST                        ListEntry;         // The entry to keep the element in the HC list
N  USBH_DLIST                        UrbList;           // Submitted URB list
N  U16                               UrbCount;          // Number of requests
X  unsigned short                               UrbCount;          
N  USBH_URB                        * pPendingUrb;       // Active URB  removed from the list
N  USBH_OHCI_TRANSFER_BUFFER       * pCopyBuffer;       // If URB's buffer address lies out of transfer memory range the buffer is copied
N  U16                               UrbTotalTdNumber;  // Number of Tds for the current URB
X  unsigned short                               UrbTotalTdNumber;  
N  U16                               UrbDoneTdNumber;   // Current number of doen tds
X  unsigned short                               UrbDoneTdNumber;   
N  U16                               TdCounter;         // Current number of TDs on this ED
X  unsigned short                               TdCounter;         
N  U16                               UpDownTDCounter;   // DoneTDCounter is used in the done interrupt endpoint functions
X  unsigned short                               UpDownTDCounter;   
N  U8                                AbortMask;         // Current abort state  see also EP_SKIP_TIMEOUT_MASK and EP_ABORT_MASK
X  unsigned char                                AbortMask;         
N
N  U8                                CancelPendingFlag; // TRUE if pfAbortEndpoint is called
X  unsigned char                                CancelPendingFlag; 
N  USBH_OHCI_DUMMY_INT_EP          * pDummyIntEp;       // pDummyIntEp holds an backward pointer to an dummy interrupt endpoint
N  USBH_RELEASE_EP_COMPLETION_FUNC * pfOnReleaseCompletion; // Callback function that is called if the endpoint is removed
N  void                            * pReleaseContext;
N  U32                               Flags;             // Endpoint flags
X  unsigned long                               Flags;             
N  // Members for operation
N  U8                                DeviceAddress;
X  unsigned char                                DeviceAddress;
N  U8                                EndpointAddress;
X  unsigned char                                EndpointAddress;
N  U16                               MaxPacketSize;        // Maximum transfer fifo size in the host controller for that endpoint
X  unsigned short                               MaxPacketSize;        
N  USBH_SPEED                        Speed;
N  U16                               IntervalTime;
X  unsigned short                               IntervalTime;
N  U8                                HaltFlag;          // Set in DONE routine if HALT condition can not deleted! Reset only with an endpoint reset.
X  unsigned char                                HaltFlag;          
N// This flag prevents submitting of new URBs!
N} USBH_OHCI_BULK_INT_EP;
N
Ntypedef struct USBH_OHCI_ISO_EP { // Logical ISO EP object
N  // Recommended:
N  //   First  field: USBH_HCM_ITEM_HEADER
N  //   Second field: U8 EndpointType
N  USBH_HCM_ITEM_HEADER              ItemHeader;
N  USBH_OHCI_DEVICE                * pDev;
N  USBH_EP_STATE                     State;
N  USBH_DLIST                        ListEntry;         // The entry to keep the element in the HC list
N  USBH_DLIST                        UrbList;           // Submitted URB list
N  U16                               UrbCount;          // Number of requests
X  unsigned short                               UrbCount;          
N  USBH_URB                        * pPendingUrb;       // Active URB  removed from the list
N  USBH_OHCI_TRANSFER_BUFFER       * pCopyBuffer;       // If URB's buffer address lies out of transfer memory range the buffer is copied
N  U16                               UrbTotalTdNumber;  // Number of Tds for the current URB
X  unsigned short                               UrbTotalTdNumber;  
N  U16                               UrbDoneTdNumber;   // Current number of doen tds
X  unsigned short                               UrbDoneTdNumber;   
N  U16                               TdCounter;         // Current number of TDs on this ED
X  unsigned short                               TdCounter;         
N  U16                               UpDownTDCounter;   // DoneTDCounter is used in the done interrupt endpoint functions
X  unsigned short                               UpDownTDCounter;   
N  U8                                AbortMask;         // Current abort state  see also EP_SKIP_TIMEOUT_MASK and EP_ABORT_MASK
X  unsigned char                                AbortMask;         
N  U8                                CancelPendingFlag; // TRUE if pfAbortEndpoint is called
X  unsigned char                                CancelPendingFlag; 
N  USBH_RELEASE_EP_COMPLETION_FUNC * pfOnReleaseCompletion; // Callback function that is called if the endpoint is removed
N  void                            * pReleaseContext;
N  U32                               Flags;             // Endpoint flags
X  unsigned long                               Flags;             
N  // Members for operation
N  U8                                DeviceAddress;
X  unsigned char                                DeviceAddress;
N  U8                                EndpointAddress;
X  unsigned char                                EndpointAddress;
N  U16                               MaxPacketSize;        // Maximum transfer fifo size in the host controller for that endpoint
X  unsigned short                               MaxPacketSize;        
N  USBH_SPEED                        Speed;
N  U16                               IntervalTime;
X  unsigned short                               IntervalTime;
N  U8                                HaltFlag;          // Set in DONE routine if HALT condition can not deleted! Reset only with an endpoint reset.
X  unsigned char                                HaltFlag;          
N  USBH_OHCI_DUMMY_INT_EP          * pDummyIntEp;       // pDummyIntEp holds an backward pointer to an dummy interrupt endpoint
N  // This flag prevents submitting of new URBs!
N} USBH_OHCI_ISO_EP;
N
N
Nstruct USBH_OHCI_DUMMY_INT_EP { // Logical bulk and interrupt EP object
N  // Recommended!!!:
N  //   First  field: USBH_HCM_ITEM_HEADER
N  //   Second field: U8 EndpointType
N  USBH_HCM_ITEM_HEADER   ItemHeader;
N  U8                     EndpointType;  // Endpoint type
X  unsigned char                     EndpointType;  
N  USBH_OHCI_DEVICE     * pDev;        // Entry to keep the element in the HC list
N  USBH_EP_STATE          State;
N  USBH_DLIST             ActiveList;    // USBH_OHCI_BULK_INT_EP (user endpoint) list
N  U32                    Bandwidth;     // Sum of max packet sizes all appended user endpoints
X  unsigned long                    Bandwidth;     
N  void                 * pNextDummyEp;  // Points to an NULL pointer if this is the 1ms interval or to the next dummy endpoint.
N  U16                    IntervalTime;  // Interval time 1,2 4,..ms
X  unsigned short                    IntervalTime;  
N  U8                     Mask;          // Bits see usbohc_epglob.h
X  unsigned char                     Mask;          
N};
N
N/*********************************************************************
N*
N*       Endpoint descriptor
N*
N**********************************************************************
N*/
N
Ntypedef struct USBH_OHCI_ED {
N  volatile U32 Dword0;
X  volatile unsigned long Dword0;
N  volatile U32 TailP;
X  volatile unsigned long TailP;
N  volatile U32 HeadP;
X  volatile unsigned long HeadP;
N  volatile U32 NextED;
X  volatile unsigned long NextED;
N} USBH_OHCI_ED;
N
N#define OH_ED_SIZE          (sizeof(USBH_OHCI_ED))
N#define OH_ED_ALIGNMENT     16
N#define OHCI_ED_FA          0x0000007fUL // Function addresses
N#define OHCI_ED_EN          0x00000780UL // Endpoint number
N#define OHCI_ED_EN_BIT      7
N#define OHCI_ED_D           0x00001800UL // direction
N#define OHCI_ED_DIR_BIT     11
N#define OHCI_ED_S           0x00002000UL // Low Speed active
N#define OHCI_ED_K           0x00004000UL // Skip
N#define OHCI_ED_F           0x00008000UL // Format (iso)
N#define OHCI_ED_MPS         0x07ff0000UL // Maximum packet size
N#define OHCI_ED_RSV         0xf8000000UL // Reserved bits
N#define OHCI_ED_DIR_FROM_TD 0x00
N#define OHCI_ED_OUT_DIR     0x01
N#define OHCI_ED_IN_DIR      0x02
N
N// Mask on ED fields HeadP
N#define OHCI_ED_C           0x02UL // Last data toggle carry bit
N#define OHCI_ED_H           0x01UL // ED halt bit
N
N/*********************************************************************
N*
N*       General transfer descriptor
N*
N**********************************************************************
N*/
N
Ntypedef struct USBH_OHCI_TRANSFER_DESC {
N  volatile U32 Dword0;
X  volatile unsigned long Dword0;
N  volatile U32 CBP;
X  volatile unsigned long CBP;
N  volatile U32 NextTD;
X  volatile unsigned long NextTD;
N  volatile U32 BE;
X  volatile unsigned long BE;
N} USBH_OHCI_TRANSFER_DESC;
N
N#define OH_GTD_SIZE         (sizeof(USBH_OHCI_TRANSFER_DESC))
N#define OH_GTD_ALIGNMENT    16
N#define OHCI_TD_RSV         0x0003ffff // Reserved values
N#define OHCI_TD_R           0x00040000 // Buffer rounding bit
N#define OHCI_TD_DP          0x00180000 // PID
N#define OHCI_TD_PID_BIT     19
N#define OHCI_TD_DI          0x00e00000 // Delay interrupt
N#define OHCI_TD_DI_BIT      21
N#define OHCI_TD_T           0x03000000 // Toggle Mask MSB=1 -> toggle value taken from LSB bit 24
N#define OHCI_TD_T_MSB       0x02000000
N#define OHCI_TD_T_LSB       0x01000000
N#define OHCI_TD_T_BIT       24
N
N// Forces an DATA 0 or DATA 1 toggle bit at the next start or transfer if not used the toggle bit is taken fro the endpoint
N#define OHCI_TD_FORCE_DATA0 0x02000000 // DATA0
N#define OHCI_TD_FORCE_DATA1 0x03000000 // DATA1
N#define OHCI_TD_EC          0x0c000000 // Error Counter
N#define OHCI_TD_CC          0xf0000000 // Condition code
N#define OHCI_TD_CC_BIT      28         // Condition code code starts with LSB bit 28
N
N/*********************************************************************
N*
N*       Isochronous transfer descriptor
N*
N**********************************************************************
N*/
N
Ntypedef struct USBH_OHCI_ISO_TRANS_DESC {
N  volatile U32 Dword0;
X  volatile unsigned long Dword0;
N  volatile U32 Dword1;
X  volatile unsigned long Dword1;
N  volatile U32 NextTD;
X  volatile unsigned long NextTD;
N  volatile U32 BE;
X  volatile unsigned long BE;
N  volatile U16 OfsPsw[8];
X  volatile unsigned short OfsPsw[8];
N} USBH_OHCI_ISO_TRANS_DESC;
N
N#define OH_ISO_TD_SIZE          (sizeof(USBH_OHCI_ISO_TRANS_DESC))
N#define OH_ISO_TD_ALIGNMENT     32
N// Dword0
N#define OHCI_TDI_SF             0x0000ffffUL
N#define OHCI_TDI_RSV            0x001f0000UL
N#define OHCI_TDI_DI             0x00e00000UL
N#define OHCI_TDI_FC             0x07000000UL
N#define OHCI_TDI_RSV1           0x08000000UL
N#define OHCI_TDI_CC             0xf0000000UL
N// Dword1
N#define OHCI_TDI_BP0            0xfffff000UL
N#define OHCI_TDI_RSV2           0x00000fffUL
N// Following TD bits can be used for own information
N#define OHCI_TD_NOT_USED_BIT_1  16
N#define OHCI_TD_NOT_USED_BIT_2  17
N
N/*********************************************************************
N*
N*       Host Controller Communications area HCCA
N*
N**********************************************************************
N*/
N
Ntypedef struct USBH_OHCI_HCCA_REG { // 256 bytes
N  volatile U32 InterruptTable[32];
X  volatile unsigned long InterruptTable[32];
N  volatile U16 FrameNumber;
X  volatile unsigned short FrameNumber;
N  volatile U16 Pad1;
X  volatile unsigned short Pad1;
N  volatile U32 DoneHead;
X  volatile unsigned long DoneHead;
N  volatile U32 Reserved[30];
X  volatile unsigned long Reserved[30];
N} USBH_OHCI_HCCA_REG;
N
N#define OH_DONE_HEAD_INT_MASK  0x00000001UL // Set if another OHCI interrupt is occurred
N
N/*********************************************************************
N*
N*       Host Controller Register
N*
N**********************************************************************
N*/
N
N// Number of downstream ports
N//#define RH_NDP                  2
N#define RH_NDP                  3 // VOS 15.08.01
N#define OH_REVISION_MASK        0xff
N#define OH_REVISION             0x10
N// There are three downstream ports
N
N// OHCI Register
N#define OH_REG_REVISION         0x000
N#define OH_REG_CONTROL          0x004
N#define OH_REG_COMMANDSTATUS    0x008
N#define OH_REG_INTERRUPTSTATUS  0x00c
N#define OH_REG_INTERRUPTENABLE  0x010
N#define OH_REG_INTERRUPTDISABLE 0x014
N#define OH_REG_HCCA             0x018
N#define OH_REG_PERIODCURRENTED  0x01c
N#define OH_REG_CONTROLHEADED    0x020
N#define OH_REG_CONTROLCURRENTED 0x024
N#define OH_REG_BULKHEADED       0x028
N#define OH_REG_BULKCURRENTED    0x02c
N#define OH_REG_DONEHEAD         0x030
N#define OH_REG_FMINTERVAL       0x034
N#define OH_REG_FMREMAINING      0x038
N#define OH_REG_FMNUMBER         0x03c
N#define OH_REG_PERIODICSTART    0x040
N#define OH_REG_LSTHRESHOLD      0x044
N#define OH_REG_RHDESCRIPTORA    0x048
N#define OH_REG_RHDESCRIPTORB    0x04c
N#define OH_REG_RHSTATUS         0x050
N#define OH_REG_RHPORTSTATUS     0x054
N
N#define GET_PORTSTATUS_REG(pPort) (OH_REG_RHPORTSTATUS + (((pPort)-1) << 2))  // Return the pPort status register param: Port: Portindex is an one based index
N
N#define HC_CONTROL_CBSR       0x00000003UL                                   // Control bulk ratio
N#define HC_CONTROL_PLE        0x00000004UL                                   // Periodic list enable
N#define HC_CONTROL_IE         0x00000008UL                                   // Isochronous enable
N#define HC_CONTROL_CLE        0x00000010UL                                   // Control list enable
N#define HC_CONTROL_BLE        0x00000020UL                                   // Bulk list enable
N#define HC_CONTROL_HCFS       0x000000c0UL                                   // Host functional state mask
N#define HC_CONTROL_IR         0x00000100UL                                   // Interrupt routing enable
N#define HC_CONTROL_RWC        0x00000200UL                                   // Indicates whether HC supports remote wakeup signaling.
N#define HC_CONTROL_RWE        0x00000400UL                                   // Enable remote wakeup
N#define HC_USB_RESET          0x00
N#define HC_USB_RESUME         0x40
N#define HC_USB_OPERATIONAL    0x80
N#define HC_USB_SUSPEND        0xc0
N#define HC_COMMAND_STATUS_HCR 0x00000001UL // Host reset
N#define HC_COMMAND_STATUS_CLF 0x00000002UL // Control list filled
N#define HC_COMMAND_STATUS_BLF 0x00000004UL // Bulk list filled
N#define HC_COMMAND_STATUS_OCR 0x00000008UL // Ownership change request
N#define HC_COMMAND_STATUS_SOC 0x00030000UL // Scheduling overrun
N
N// HcInterruptEnable / Disable HCInterruptStatus
N#define HC_INT_SO   0x00000001UL                     // Scheduling overrun
N#define HC_INT_WDH  0x00000002UL                     // HcDoenHead
N#define HC_INT_SF   0x00000004UL                     // SOF
N#define HC_INT_RD   0x00000008UL                     // Resume detect
N#define HC_INT_UE   0x00000010UL                     // Unrecoverable error
N#define HC_INT_FNO  0x00000020UL                     // Frame number overflow, resume no frame number generation
N#define HC_INT_RHSC 0x00000040UL                     // Root hub status change
N#define HC_INT_OC   0x40000000UL                     // Ownership change
N#define HC_INT_MIE  0x80000000UL                     // Master interrupt bit
N
N#define HC_INT_STATUS_VALIDATION_BIT (1UL << 31) // Bit in the HC_INT_STATUS_VALID_MASK in the interrupt status register must be zero
N#define HC_INT_STATUS_MASK_WITHOUT_OWNERCHIP 0x07f
N
N// Frame interval
N#define HC_FM_INTERVAL_FIT        (1UL<<31)
N#define HC_FM_INTERVAL_FSMPS_BIT  16
N#define HC_FM_INTERVAL_FSMPS_MASK 0x7FFF0000UL
N#define HC_FM_INTERVAL_FI_MASK    0x00003FFFUL
N
N
N// Interrupt intervals
N#define OHD_1MS   1
N#define OHD_2MS   2
N#define OHD_4MS   4
N#define OHD_8MS   8
N#define OHD_16MS  16
N#define OHD_32MS  32
N
N#define OHD_DUMMY_INT_NUMBER  (OHD_1MS + OHD_2MS + OHD_4MS + OHD_8MS + OHD_16MS +  OHD_32MS)
N
N
N
N
N
N
N
N
N
N
N/*********************************************************************
N*
N*       Externals
N*
N**********************************************************************
N*/
N
N// All timeouts in milliseconds!
N#define POWERON_TO_POWERGOOD_TIME   150 // This time the library waits internally after detection of an connect
N
N#if (POWERON_TO_POWERGOOD_TIME/2) > 0xff
X#if (150/2) > 0xff
S  #error POWERON_TO_POWERGOOD_TIME
N#endif
N
N
N/*********************************************************************
N*
N*       Additional external hub definitions
N*
N**********************************************************************
N*/
N
Ntypedef struct USBH_OHCI_HUB_PORT { // pHub pPort object
N  U8  Port;                     // One base pPort index
X  unsigned char  Port;                     
N  U8  Power;                    // 1- power on 0 -power off
X  unsigned char  Power;                    
N  U16 Status;                  // Port status and change bits
X  unsigned short Status;                  
N  U16 Change;
X  unsigned short Change;
N} USBH_OHCI_HUB_PORT;
N
Ntypedef struct USBH_OHCI_ROOT_HUB {                       // Root pHub object
N  USBH_OHCI_DEVICE                * pDev;
N  USBH_ROOT_HUB_NOTIFICATION_FUNC * pfUbdRootHubNotification; // External init values and callback functions
N  void                            * pRootHubNotificationContext;
N  U16                               PortCount;
X  unsigned short                               PortCount;
N  U16                               PowerOnToPowerGoodTime;
X  unsigned short                               PowerOnToPowerGoodTime;
N  U16                               Status; // pHub status and change bits
X  unsigned short                               Status; 
N  U16                               Change;
X  unsigned short                               Change;
N  USBH_OHCI_HUB_PORT              * apHcdPort;
N} USBH_OHCI_ROOT_HUB;
N
N
N
Ntypedef void REMOVE_HC_COMPLETION_FUNC (void * pContext);
N
N#define OH_HCCA_VALID(OHD_HCCA_Ptr) USBH_HCM_ASSERT_ITEM_HEADER(&OHD_HCCA_Ptr->ItemHeader)
N
Ntypedef struct USBH_OHCI_HCCA {  // Logical HCCA object
N  USBH_HCM_ITEM_HEADER ItemHeader; // For dynamic allocating the struct must begin with the specific memory pool header
N} USBH_OHCI_HCCA;
N
Nstruct USBH_OHCI_DEVICE { // The global driver object. The object is cleared in the function USBH_HostInit!
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  U32 Magic;
X  unsigned long Magic;
N#endif
N  USBH_HCM_POOL                 TransferBufferPool; // If the transfer buffer in an URB out of physical memory address range then this buffer is transferred with an buffer from this pool
N  // EP pools
N  USBH_HCM_POOL                 IsoEPPool;
N  USBH_HCM_POOL                 BulkEPPool;
N  USBH_HCM_POOL                 IntEPPool;
N  USBH_HCM_POOL                 DummyIntEPPool;
N  USBH_HCM_POOL                 ControlEPPool;
N  USBH_HCM_POOL                 SetupPacketPool;  // Setup buffer pool
N  USBH_HCM_POOL                 GTDPool;          // GTD pool
N  USBH_HCM_POOL                 IsoTDPool;        // ISO TD pool
N  USBH_HCM_POOL                 HccaPool;         // HCCA pPool
N  USBH_OHCI_HCCA              * pHcca;            // Pointer to the HccaPoolItem
N  volatile USBH_OHCI_HCCA_REG * pOhHcca;      // OHCI HCCA memory, points to the base address of HCCA,  used to access the HCCA memory
N  // Control endpoints
N  USBH_DLIST                    ControlEpList; // Number of pending endpoints on the HC
N  U32                           ControlEpCount;
X  unsigned long                           ControlEpCount;
N  USBH_TIMER_HANDLE             ControlEpRemoveTimer;
N  USBH_TIMER_HANDLE             ControlEpAbortTimer;
N  USBH_BOOL                     ControlEpRemoveTimerRunFlag;    // True if timer is started, set to false in the timer routine
X  char                     ControlEpRemoveTimerRunFlag;    
N  USBH_BOOL                     ControlEpRemoveTimerCancelFlag;
X  char                     ControlEpRemoveTimerCancelFlag;
N  USBH_BOOL                     ControlEpAbortTimerRunFlag;
X  char                     ControlEpAbortTimerRunFlag;
N  USBH_BOOL                     ControlEpAbortTimerCancelFlag;
X  char                     ControlEpAbortTimerCancelFlag;
N  // Bulk endpoints
N  USBH_DLIST                    BulkEpList;
N  U32                           BulkEpCount;
X  unsigned long                           BulkEpCount;
N  USBH_TIMER_HANDLE             hBulkEpRemoveTimer;
N  USBH_BOOL                     BulkEpRemoveTimerRunFlag;     // True if timer is started, set to false in the timer routine
X  char                     BulkEpRemoveTimerRunFlag;     
N  USBH_BOOL                     BulkEpRemoveTimerCancelFlag;
X  char                     BulkEpRemoveTimerCancelFlag;
N  USBH_TIMER_HANDLE             hBulkEpAbortTimer;
N  USBH_BOOL                     BulkEpAbortTimerRunFlag;      // True if timer is started, set to false in the timer routine
X  char                     BulkEpAbortTimerRunFlag;      
N  USBH_BOOL                     BulkEpAbortTimerCancelFlag;
X  char                     BulkEpAbortTimerCancelFlag;
N  // Interrupt endpoints
N  // The array index 0 contains the dummy EP of 1milliseconds, the index 1 the dummy EPs of 2 milliseconds and so on
N  // IntervalStartEpIndex = Intervaltime - 1. Every dummy EP!
N  USBH_OHCI_DUMMY_INT_EP      * DummyInterruptEpArr[OHD_DUMMY_INT_NUMBER];
X  USBH_OHCI_DUMMY_INT_EP      * DummyInterruptEpArr[(1 + 2 + 4 + 8 + 16 + 32)];
N  U32                           IntEpCount;                  // IntEpCount is an reference counter that counts the number of active interrupt endpoints without the dummy interrupt endpoints
X  unsigned long                           IntEpCount;                  
N  USBH_TIMER_HANDLE             hIntEpRemoveTimer;
N  USBH_BOOL                     IntEpRemoveTimerRunFlag;     // True if timer is started, set to false in the timer routine
X  char                     IntEpRemoveTimerRunFlag;     
N  USBH_BOOL                     IntEpRemoveTimerCancelFlag;
X  char                     IntEpRemoveTimerCancelFlag;
N  USBH_TIMER_HANDLE             hIntEpAbortTimer;
N  USBH_BOOL                     IntEpAbortTimerRunFlag;      // True if timer is started, set to false in the timer routine
X  char                     IntEpAbortTimerRunFlag;      
N  USBH_BOOL                     IntEpAbortTimerCancelFlag;
X  char                     IntEpAbortTimerCancelFlag;
N#if (USBH_DEBUG > 1)
X#if (2 > 1)
N  USBH_BOOL                     IntRemoveFlag;
X  char                     IntRemoveFlag;
N  USBH_BOOL                     IsoRemoveFlag;
X  char                     IsoRemoveFlag;
N#endif
N  // Iso endpoints
N  USBH_DLIST                    IsoEpList;
N  U32                           IsoEpCount;
X  unsigned long                           IsoEpCount;
N  USBH_TIMER_HANDLE             hIsoEpRemoveTimer;
N  USBH_BOOL                     IsoEpRemoveTimerRunFlag;     // True if timer is started, set to false in the timer routine
X  char                     IsoEpRemoveTimerRunFlag;     
N  USBH_BOOL                     IsoEpRemoveTimerCancelFlag;
X  char                     IsoEpRemoveTimerCancelFlag;
N  USBH_TIMER_HANDLE             hIsoEpAbortTimer;
N  USBH_BOOL                     IsoEpAbortTimerRunFlag;      // True if timer is started, set to false in the timer routine
X  char                     IsoEpAbortTimerRunFlag;      
N  USBH_BOOL                     IsoEpAbortTimerCancelFlag;
X  char                     IsoEpAbortTimerCancelFlag;
N  // General information
N  USBH_TIMER_HANDLE             hInitDeviceTimer;            // This timer is used in the initialization routine
N  volatile U16                  UpperFrameCounter;           // UpperFrameCounter: valid bits: Bit 16..to Bit 31, LSB frame word: in the Hc area.
X  volatile unsigned short                  UpperFrameCounter;           
N  volatile U16                  LastFrameCounter;
X  volatile unsigned short                  LastFrameCounter;
N  U8                          * pRegBase;      // OHCI register base address
X  unsigned char                          * pRegBase;      
N  U32                           FmIntervalReg; // Saved content from interval register
X  unsigned long                           FmIntervalReg; 
N  USBH_OHCI_DEV_STATE           State;  // Devices state
N  USBH_OHCI_ROOT_HUB            RootHub;
N  USBH_HC_BD_HANDLE             hBusDriver;
N  REMOVE_HC_COMPLETION_FUNC   * pfRemoveCompletion;   // pfHostExit Callback function and pContext
N  void                        * pRemoveContext;
N};
N
N/*********************************************************************
N*
N*       Operations
N*
N**********************************************************************
N*/
N#define  USBH_OHC_CreateController USBH_OHCI_CreateController
N#define  USBH_OHC_ServiceISR       USBH_OHCI_ServiceISR
N#define  USBH_OHC_AddController    USBH_OHCI_AddController
N#define  USBH_OHC_RemoveController USBH_OHCI_RemoveController
N#define  USBH_OHC_DeleteController USBH_OHCI_DeleteController
N#define  USBH_OHC_ProcessInterrupt USBH_OHCI_ProcessInterrupt
N
N
NUSBH_STATUS    USBH_OHCI_AddController             (USBH_HC_HANDLE       HcHandle, USBH_HC_BD_HANDLE    * HcBdHandle);
NUSBH_HC_HANDLE USBH_OHCI_CreateController          (void               * pBaseAddress);
Nint            USBH_OHCI_ServiceISR                (USBH_HC_HANDLE       HcHandle);
NUSBH_STATUS    USBH_OHCI_RemoveController          (USBH_HC_HANDLE       HcHandle, REMOVE_HC_COMPLETION_FUNC * pfOnCompletion, void * pContext);
Nvoid           USBH_OHCI_DeleteController          (USBH_HC_HANDLE       HcHandle);
Nvoid           USBH_OHCI_ProcessInterrupt          (USBH_HC_HANDLE       HcHandle);
N
N
NUSBH_STATUS     USBH_OHCI_EP0_Init                  (USBH_OHCI_EP0            * Ep,  USBH_OHCI_DEVICE * pDev, U32 Mask, U8 DeviceAddress, U8 EndpointAddress, U16 MaxFifoSize, USBH_SPEED Speed);
XUSBH_STATUS     USBH_OHCI_EP0_Init                  (USBH_OHCI_EP0            * Ep,  USBH_OHCI_DEVICE * pDev, unsigned long Mask, unsigned char DeviceAddress, unsigned char EndpointAddress, unsigned short MaxFifoSize, USBH_SPEED Speed);
Nvoid            USBH_OHCI_EP0_Insert                (USBH_OHCI_EP0            * Ep);
Nvoid            USBH_OHCI_EP0_ReleaseEp             (USBH_OHCI_EP0            * Ep,  USBH_RELEASE_EP_COMPLETION_FUNC * pfOnReleaseEpCompletion, void * pContext);
NUSBH_STATUS     USBH_OHCI_EP0_AbortEp               (USBH_OHCI_EP0            * Ep);
NUSBH_STATUS     USBH_OHCI_EP0_AddUrb                (USBH_OHCI_EP0            * Ep,  USBH_URB * Urb);
Nvoid            USBH_OHCI_EP0_DoneCheckForCompletion(USBH_OHCI_INFO_GENERAL_TRANS_DESC * Gtd);
Nvoid            USBH_OHCI_Ep0RemoveEndpoints        (USBH_OHCI_DEVICE     * pDev, USBH_BOOL AllEndpointFlag);
Xvoid            USBH_OHCI_Ep0RemoveEndpoints        (USBH_OHCI_DEVICE     * pDev, char AllEndpointFlag);
Nvoid            USBH_OHCI_EP0_OnReleaseEpTimer      (void               * pContext); // Common ep0 timer callback routine
Nvoid            USBH_OHCI_EP0_OnAbortUrbTimer       (void               * pContext);
NUSBH_STATUS     USBH_OHCI_EP0_Alloc                 (USBH_HCM_POOL * EpPool, USBH_HCM_POOL * SetupPacketPool, U32 Numbers);  // Allocates all resources needed for control transfer, endpoints will not added to the control list
XUSBH_STATUS     USBH_OHCI_EP0_Alloc                 (USBH_HCM_POOL * EpPool, USBH_HCM_POOL * SetupPacketPool, unsigned long Numbers);  
Nvoid            USBH_OHCI_Ep0Free                   (USBH_HCM_POOL * EpPool); // Releases all needed resources used for all control endpoints
NUSBH_OHCI_EP0 * USBH_OHCI_EP0_Get                   (USBH_HCM_POOL * EpPool, USBH_HCM_POOL * pSetupPacketPool);
Nvoid            USBH_OHCI_EP0_Put                   (USBH_OHCI_EP0  * Ep);     // Puts first all appended TDs back to the pool and as last the  control endpoint object
N
Nvoid                       USBH_OHCI_EpGlobInitED              (USBH_HCM_ITEM_HEADER * Header,   U8                DeviceAddr,  U8    EpWithDirection, U32 MaxPktSize, USBH_BOOL IsoFlag, USBH_BOOL SkipFlag, USBH_SPEED Speed);
Xvoid                       USBH_OHCI_EpGlobInitED              (USBH_HCM_ITEM_HEADER * Header,   unsigned char                DeviceAddr,  unsigned char    EpWithDirection, unsigned long MaxPktSize, char IsoFlag, char SkipFlag, USBH_SPEED Speed);
Nvoid                       USBH_OHCI_EpGlobInsertTD            (USBH_HCM_ITEM_HEADER * EpHeader, USBH_HCM_ITEM_HEADER * NewTdHeader, U16 * TdCounter);
Xvoid                       USBH_OHCI_EpGlobInsertTD            (USBH_HCM_ITEM_HEADER * EpHeader, USBH_HCM_ITEM_HEADER * NewTdHeader, unsigned short * TdCounter);
Nvoid                       USBH_OHCI_EpGlobDeleteAllPendingTD  (USBH_HCM_ITEM_HEADER * EpHeader, U16             * TdCounter);
Xvoid                       USBH_OHCI_EpGlobDeleteAllPendingTD  (USBH_HCM_ITEM_HEADER * EpHeader, unsigned short             * TdCounter);
Nvoid                       USBH_OHCI_EpGlobLinkEds             (USBH_HCM_ITEM_HEADER * Last,     USBH_HCM_ITEM_HEADER * New);
NU32                        USBH_OHCI_EpGlobUnlinkEd            (USBH_HCM_ITEM_HEADER * Prev,     USBH_HCM_ITEM_HEADER * Remove);
Xunsigned long                        USBH_OHCI_EpGlobUnlinkEd            (USBH_HCM_ITEM_HEADER * Prev,     USBH_HCM_ITEM_HEADER * Remove);
Nvoid                       USBH_OHCI_EpGlobRemoveAllTDtoPool   (USBH_HCM_ITEM_HEADER * EpHeader, U16 * pTdCounter);
Xvoid                       USBH_OHCI_EpGlobRemoveAllTDtoPool   (USBH_HCM_ITEM_HEADER * EpHeader, unsigned short * pTdCounter);
Nint                        USBH_OHCI_EpGlobIsTDActive          (USBH_HCM_ITEM_HEADER * EpHeader);
NUSBH_OHCI_INFO_GENERAL_TRANS_DESC * USBH_OHCI_EpGlobGetLastTDFromED     (USBH_HCM_ITEM_HEADER * EpHeader);
NUSBH_OHCI_INFO_GENERAL_TRANS_DESC * USBH_OHCI_EpGlobGetFirstTDFromED    (USBH_HCM_ITEM_HEADER * EpHeader);
Nvoid                       USBH_OHCI_EpGlobDeleteDoneTD        (USBH_HCM_ITEM_HEADER * TdItem,   U16 * pTdCounter);
Xvoid                       USBH_OHCI_EpGlobDeleteDoneTD        (USBH_HCM_ITEM_HEADER * TdItem,   unsigned short * pTdCounter);
Nvoid                       USBH_OHCI_EpGlobClearSkip           (USBH_HCM_ITEM_HEADER * EpHeader);
Nvoid                       USBH_OHCI_EpGlobSetSkip             (USBH_HCM_ITEM_HEADER * EpHeader);
Nint                        USBH_OHCI_EpGlobIsSkipped           (USBH_HCM_ITEM_HEADER * EpHeader);
Nvoid                       USBH_OHCI_EpGlobClearHalt           (USBH_HCM_ITEM_HEADER * EpHeader);
Nint                        USBH_OHCI_EpGlobIsHalt              (USBH_HCM_ITEM_HEADER * EpHeader);
Nvoid                       USBH_OHCI_EpClearToggle             (USBH_HCM_ITEM_HEADER * EpHeader);
Nvoid                       USBH_OHCI_EpSetToggle               (USBH_HCM_ITEM_HEADER * EpHeader, USBH_BOOL Toggle);
Xvoid                       USBH_OHCI_EpSetToggle               (USBH_HCM_ITEM_HEADER * EpHeader, char Toggle);
NUSBH_BOOL                  USBH_OHCI_EpGetToggle               (USBH_HCM_ITEM_HEADER * EpHeader);
Xchar                  USBH_OHCI_EpGetToggle               (USBH_HCM_ITEM_HEADER * EpHeader);
NU32                        USBH_OHCI_EpGlobGetTdCount          (USBH_HCM_ITEM_HEADER * EpHeader, USBH_HCM_POOL * TdPool);
Xunsigned long                        USBH_OHCI_EpGlobGetTdCount          (USBH_HCM_ITEM_HEADER * EpHeader, USBH_HCM_POOL * TdPool);
N
N/*********************************************************************
N*
N*       Resources allocation and releasing functions
N*
N**********************************************************************
N*/
NUSBH_STATUS             USBH_OHCI_BULK_INT_AllocPool(USBH_HCM_POOL        * EpPool, unsigned int MaxEps);
NUSBH_OHCI_BULK_INT_EP * USBH_OHCI_BULK_INT_GetEp    (USBH_HCM_POOL        * EpPool);
Nvoid                    USBH_OHCI_BULK_INT_PutEp    (USBH_OHCI_BULK_INT_EP * Ep);
N
N/*********************************************************************
N*
N*       Operations
N*
N**********************************************************************
N*/
N
NUSBH_OHCI_BULK_INT_EP * USBH_OHCI_BULK_INT_InitEp                    (USBH_OHCI_BULK_INT_EP * Ep, USBH_OHCI_DEVICE * Dev, U8 EndpointType, U8 DeviceAddress, U8 EndpointAddress, U16 MaxFifoSize, U16 IntervalTime, USBH_SPEED Speed, U32 Flags);
XUSBH_OHCI_BULK_INT_EP * USBH_OHCI_BULK_INT_InitEp                    (USBH_OHCI_BULK_INT_EP * Ep, USBH_OHCI_DEVICE * Dev, unsigned char EndpointType, unsigned char DeviceAddress, unsigned char EndpointAddress, unsigned short MaxFifoSize, unsigned short IntervalTime, USBH_SPEED Speed, unsigned long Flags);
NUSBH_STATUS             USBH_OHCI_BULK_INT_AddUrb                    (USBH_OHCI_BULK_INT_EP * Ep, USBH_URB * Urb);
NUSBH_STATUS             USBH_OHCI_BULK_INT_AbortEp                   (USBH_OHCI_BULK_INT_EP * Ep);
NUSBH_STATUS             USBH_OHCI_BULK_INT_CheckAndCancelAbortedUrbs (USBH_OHCI_BULK_INT_EP * Ep, int TDDoneFlag);
Nvoid                    USBH_OHCI_BULK_ReleaseEp                     (USBH_OHCI_BULK_INT_EP * Ep, USBH_RELEASE_EP_COMPLETION_FUNC * pfOnReleaseEpCompletion, void * pContext);
Nvoid                    USBH_OHCI_BULK_INT_SubmitUrbsFromList        (USBH_OHCI_BULK_INT_EP * Ep);
Nvoid                    USBH_OHCI_BULK_InsertEp                      (USBH_OHCI_BULK_INT_EP * Ep);
Nvoid                    USBH_OHCI_BULK_INT_UpdateTDLengthStatus      (USBH_OHCI_INFO_GENERAL_TRANS_DESC * Gtd);
Nvoid                    USBH_OHCI_BULK_INT_CheckForCompletion        (USBH_OHCI_INFO_GENERAL_TRANS_DESC * Gtd);
N
NUSBH_STATUS             USBH_OHCI_INT_DummyEpAllocPool               (USBH_HCM_POOL            * pEpPool);
Nvoid                    USBH_OHCI_INT_ReleaseEp                      (USBH_OHCI_BULK_INT_EP    * pEp, USBH_RELEASE_EP_COMPLETION_FUNC * pfOnReleaseEpCompletion, void * pContext);
NUSBH_STATUS             USBH_OHCI_INT_InsertEp                       (USBH_OHCI_BULK_INT_EP    * pEp);
NUSBH_STATUS             USBH_OHCI_INT_InitAllocDummyIntEps           (USBH_OHCI_DEVICE * pDev);
Nvoid                    USBH_OHCI_INT_PutAllDummyEp                  (USBH_OHCI_DEVICE * pDev);
Nvoid                    USBH_OHCI_INT_BuildDummyEpTree               (USBH_OHCI_DEVICE * pDev);
Nvoid                    USBH_OHCI_INT_RemoveAllUserEDFromPhysicalLink(USBH_OHCI_DEVICE * pDev);
NUSBH_BOOL               USBH_OHCI_INT_RemoveEDFromLogicalListAndFree (USBH_OHCI_DEVICE * pDev, USBH_BOOL All);
Xchar               USBH_OHCI_INT_RemoveEDFromLogicalListAndFree (USBH_OHCI_DEVICE * pDev, char All);
NU32                     USBH_OHCI_INT_GetBandwidth                   (USBH_OHCI_DEVICE * pDev, U16 IntervalTime, USBH_OHCI_DUMMY_INT_EP ** ppEp);
Xunsigned long                     USBH_OHCI_INT_GetBandwidth                   (USBH_OHCI_DEVICE * pDev, unsigned short IntervalTime, USBH_OHCI_DUMMY_INT_EP ** ppEp);
N
Nvoid                    USBH_OHCI_BULK_RemoveEps                     (USBH_OHCI_DEVICE * pDev, USBH_BOOL AllEndpointFlag);
Xvoid                    USBH_OHCI_BULK_RemoveEps                     (USBH_OHCI_DEVICE * pDev, char AllEndpointFlag);
N
Nvoid                    USBH_OHCI_INT_OnReleaseEpTimer               (void    * pContext);
Nvoid                    USBH_OHCI_INT_OnAbortUrbTimer                (void    * pContext);
Nvoid                    USBH_OHCI_BULK_OnAbortUrbTimer               (void    * pContext);
Nvoid                    USBH_OHCI_BULK_INT_OnRemoveEpTimer           (void    * pContext);
N
N/*********************************************************************
N*
N*       Iso operations
N*
N**********************************************************************
N*/
NUSBH_STATUS        USBH_OHCI_ISO_AllocPool                (USBH_HCM_POOL    * EpPool, unsigned int MaxEps);
NUSBH_OHCI_ISO_EP * USBH_OHCI_ISO_GetEp                    (USBH_HCM_POOL    * EpPool);
Nvoid               USBH_OHCI_ISO_PutEp                    (USBH_OHCI_ISO_EP * Ep);
NUSBH_OHCI_ISO_EP * USBH_OHCI_ISO_InitEp                   (USBH_OHCI_ISO_EP * Ep, USBH_OHCI_DEVICE * Dev, U8 EndpointType, U8 DeviceAddress, U8 EndpointAddress, U16 MaxFifoSize, U16 IntervalTime, USBH_SPEED Speed, U32 Flags);
XUSBH_OHCI_ISO_EP * USBH_OHCI_ISO_InitEp                   (USBH_OHCI_ISO_EP * Ep, USBH_OHCI_DEVICE * Dev, unsigned char EndpointType, unsigned char DeviceAddress, unsigned char EndpointAddress, unsigned short MaxFifoSize, unsigned short IntervalTime, USBH_SPEED Speed, unsigned long Flags);
NUSBH_STATUS        USBH_OHCI_ISO_AddUrb                   (USBH_OHCI_ISO_EP * Ep, USBH_URB * Urb);
NUSBH_STATUS        USBH_OHCI_ISO_AbortEp                  (USBH_OHCI_ISO_EP * Ep);
NUSBH_STATUS        USBH_OHCI_ISO_CheckAndCancelAbortedUrbs(USBH_OHCI_ISO_EP * Ep, int TDDoneFlag);
Nvoid               USBH_OHCI_ISO_ReleaseEndpoint          (USBH_OHCI_ISO_EP * Ep, USBH_RELEASE_EP_COMPLETION_FUNC * pfOnReleaseEpCompletion, void * pContext);
Nvoid               USBH_OHCI_ISO_SubmitUrbsFromList       (USBH_OHCI_ISO_EP * Ep);
NUSBH_STATUS        USBH_OHCI_ISO_InsertEp                 (USBH_OHCI_ISO_EP * Ep);
Nvoid               USBH_OHCI_ISO_UpdateTDLengthStatus     (USBH_OHCI_INFO_GENERAL_TRANS_DESC * Gtd);
Nvoid               USBH_OHCI_ISO_CheckForCompletion       (USBH_OHCI_INFO_GENERAL_TRANS_DESC * Gtd);
Nvoid               USBH_OHCI_ISO_OnAbortUrbTimer          (void    * pContext);
Nvoid               USBH_OHCI_ISO_OnRemoveEpTimer          (void    * pContext);
Nvoid               USBH_OHCI_ISO_RemoveEps                (USBH_OHCI_DEVICE * dev, USBH_BOOL AllEndpointFlag);
Xvoid               USBH_OHCI_ISO_RemoveEps                (USBH_OHCI_DEVICE * dev, char AllEndpointFlag);
N
NUSBH_STATUS                      USBH_OHCI_TdGetStatusAndLength(USBH_OHCI_INFO_GENERAL_TRANS_DESC  * Gtd,            U32 * Transferred,  USBH_BOOL     * shortPkt);
XUSBH_STATUS                      USBH_OHCI_TdGetStatusAndLength(USBH_OHCI_INFO_GENERAL_TRANS_DESC  * Gtd,            unsigned long * Transferred,  char     * shortPkt);
NUSBH_STATUS                      USBH_OHCI_TdAlloc             (USBH_HCM_POOL * GeneralTd,      U32   GeneralTdNumbers, unsigned Alignment);
XUSBH_STATUS                      USBH_OHCI_TdAlloc             (USBH_HCM_POOL * GeneralTd,      unsigned long   GeneralTdNumbers, unsigned Alignment);
Nvoid                             USBH_OHCI_TdInit              (USBH_OHCI_INFO_GENERAL_TRANS_DESC  * gtd, void * Ep, U8    EndpointType, USBH_OHCI_TD_PID   Pid, U32 StartAddr, U32 EndAddr, U32 Dword0Mask);
Xvoid                             USBH_OHCI_TdInit              (USBH_OHCI_INFO_GENERAL_TRANS_DESC  * gtd, void * Ep, unsigned char    EndpointType, USBH_OHCI_TD_PID   Pid, unsigned long StartAddr, unsigned long EndAddr, unsigned long Dword0Mask);
NUSBH_OHCI_INFO_GENERAL_TRANS_DESC * USBH_OHCI_GetTransDesc     (USBH_HCM_POOL * GeneralTd);
NU32                              USBH_OHCI_TdGetNextTd         (U32             TdAddress);
Xunsigned long                              USBH_OHCI_TdGetNextTd         (unsigned long             TdAddress);
Nvoid                             USBH_OHCI_IsoTdInit           (USBH_OHCI_INFO_GENERAL_TRANS_DESC * gtd, USBH_OHCI_ISO_EP * pIsoEp, USBH_ISO_REQUEST * pIsoRequest, U32 DWord0, U32 StartAddr, int NumBytes, int Index);
Xvoid                             USBH_OHCI_IsoTdInit           (USBH_OHCI_INFO_GENERAL_TRANS_DESC * gtd, USBH_OHCI_ISO_EP * pIsoEp, USBH_ISO_REQUEST * pIsoRequest, unsigned long DWord0, unsigned long StartAddr, int NumBytes, int Index);
NUSBH_STATUS                      USBH_OHCI_ISO_TdGetStatusAndLength(USBH_OHCI_INFO_GENERAL_TRANS_DESC * pGlobalTransDesc, U32 * pTransferred, USBH_BOOL * pShortPacket);
XUSBH_STATUS                      USBH_OHCI_ISO_TdGetStatusAndLength(USBH_OHCI_INFO_GENERAL_TRANS_DESC * pGlobalTransDesc, unsigned long * pTransferred, char * pShortPacket);
N
N
N
N
N/*********************************************************************
N*
N*       Host device driver interface functions
N*
N**********************************************************************
N*/
Nvoid                 USBH_OHCI_ReleaseEndpoint (USBH_HC_EP_HANDLE hEP,             USBH_RELEASE_EP_COMPLETION_FUNC *  pfReleaseEpCompletion,    void * pContext);
NUSBH_STATUS          USBH_OHCI_HostInit        (USBH_HC_HANDLE    hHostController, USBH_ROOT_HUB_NOTIFICATION_FUNC *  pfUbdRootHubNotification, void * pRootHubNotificationContext);
NUSBH_STATUS          USBH_OHCI_SetHcState      (USBH_HC_HANDLE    hHostController, USBH_HOST_STATE HostState);
NUSBH_STATUS          USBH_OHCI_HostExit        (USBH_HC_HANDLE    hHostController);
NUSBH_HC_EP_HANDLE    USBH_OHCI_AddEndpoint     (USBH_HC_HANDLE    hHostController, U8 EndpointType, U8 DeviceAddress, U8 EndpointAddress, U16 MaxFifoSize, U16 IntervalTime, USBH_SPEED Speed);
XUSBH_HC_EP_HANDLE    USBH_OHCI_AddEndpoint     (USBH_HC_HANDLE    hHostController, unsigned char EndpointType, unsigned char DeviceAddress, unsigned char EndpointAddress, unsigned short MaxFifoSize, unsigned short IntervalTime, USBH_SPEED Speed);
N
NU32                  USBH_OHCI_GetFrameNumber         (USBH_HC_HANDLE     hHostController);
Xunsigned long                  USBH_OHCI_GetFrameNumber         (USBH_HC_HANDLE     hHostController);
NUSBH_OHCI_TRANSFER_BUFFER * USBH_OHCI_GetCopyTransferBuffer           (USBH_HCM_POOL           * pTransferBufferPool);
NUSBH_OHCI_TRANSFER_BUFFER * USBH_OHCI_GetInitializedCopyTransferBuffer(USBH_HCM_POOL           * pTransferBufferPool, U8 * pUrbBuffer, U32 UrbBufferLength);
XUSBH_OHCI_TRANSFER_BUFFER * USBH_OHCI_GetInitializedCopyTransferBuffer(USBH_HCM_POOL           * pTransferBufferPool, unsigned char * pUrbBuffer, unsigned long UrbBufferLength);
NU32                  USBH_OHCI_FillCopyTransferBuffer                 (USBH_OHCI_TRANSFER_BUFFER * pTransferBuffer);
Xunsigned long                  USBH_OHCI_FillCopyTransferBuffer                 (USBH_OHCI_TRANSFER_BUFFER * pTransferBuffer);
NU32                  USBH_OHCI_CopyToUrbBufferUpdateTransferBuffer    (USBH_OHCI_TRANSFER_BUFFER * pTransferBuffer,     U32   Transferred);
Xunsigned long                  USBH_OHCI_CopyToUrbBufferUpdateTransferBuffer    (USBH_OHCI_TRANSFER_BUFFER * pTransferBuffer,     unsigned long   Transferred);
NU32                  USBH_OHCI_UpdateCopyTransferBuffer               (USBH_OHCI_TRANSFER_BUFFER * pTransferBuffer,     U32   Transferred);
Xunsigned long                  USBH_OHCI_UpdateCopyTransferBuffer               (USBH_OHCI_TRANSFER_BUFFER * pTransferBuffer,     unsigned long   Transferred);
NU8                 * USBH_OHCI_GetBufferLengthFromCopyTransferBuffer  (USBH_OHCI_TRANSFER_BUFFER * pTransferBuffer,     U32 * pLength);
Xunsigned char                 * USBH_OHCI_GetBufferLengthFromCopyTransferBuffer  (USBH_OHCI_TRANSFER_BUFFER * pTransferBuffer,     unsigned long * pLength);
Nvoid                 USBH_OHCI_UpdateUpperFrameCounter                (USBH_OHCI_DEVICE * pDev);
Nvoid                 USBH_OHCI_EndpointListEnable                     (USBH_OHCI_DEVICE * pDev, U8 EpType, USBH_BOOL Enable, USBH_BOOL ListFill);
Xvoid                 USBH_OHCI_EndpointListEnable                     (USBH_OHCI_DEVICE * pDev, unsigned char EpType, char Enable, char ListFill);
N
N/*********************************************************************
N*
N*       Driver root hub interface
N*
N**********************************************************************
N*/
N
Nunsigned int USBH_OHCI_ROOTHUB_GetPortCount    (USBH_HC_HANDLE hHostController);
Nunsigned int USBH_OHCI_ROOTHUB_GetPowerGoodTime(USBH_HC_HANDLE hHostController);
NU32          USBH_OHCI_ROOTHUB_GetHubStatus    (USBH_HC_HANDLE hHostController);
Xunsigned long          USBH_OHCI_ROOTHUB_GetHubStatus    (USBH_HC_HANDLE hHostController);
Nvoid         USBH_OHCI_ROOTHUB_ClearHubStatus  (USBH_HC_HANDLE hHostController,          U16 FeatureSelector);
Xvoid         USBH_OHCI_ROOTHUB_ClearHubStatus  (USBH_HC_HANDLE hHostController,          unsigned short FeatureSelector);
Nvoid         USBH_OHCI_ROOTHUB_ClearPortStatus (USBH_HC_HANDLE hHostController, U8 Port, U16 FeatureSelector);
Xvoid         USBH_OHCI_ROOTHUB_ClearPortStatus (USBH_HC_HANDLE hHostController, unsigned char Port, unsigned short FeatureSelector);
NU32          USBH_OHCI_ROOTHUB_GetPortStatus   (USBH_HC_HANDLE hHostController, U8 Port);
Xunsigned long          USBH_OHCI_ROOTHUB_GetPortStatus   (USBH_HC_HANDLE hHostController, unsigned char Port);
Nvoid         USBH_OHCI_ROOTHUB_SetPortPower    (USBH_HC_HANDLE hHostController, U8 Port, U8 PowerOn);
Xvoid         USBH_OHCI_ROOTHUB_SetPortPower    (USBH_HC_HANDLE hHostController, unsigned char Port, unsigned char PowerOn);
Nvoid         USBH_OHCI_ROOTHUB_ResetPort       (USBH_HC_HANDLE hHostController, U8 Port);
Xvoid         USBH_OHCI_ROOTHUB_ResetPort       (USBH_HC_HANDLE hHostController, unsigned char Port);
Nvoid         USBH_OHCI_ROOTHUB_DisablePort     (USBH_HC_HANDLE hHostController, U8 Port);
Xvoid         USBH_OHCI_ROOTHUB_DisablePort     (USBH_HC_HANDLE hHostController, unsigned char Port);
Nvoid         USBH_OHCI_ROOTHUB_SetPortSuspend  (USBH_HC_HANDLE hHostController, U8 Port, USBH_PORT_POWER_STATE State);
Xvoid         USBH_OHCI_ROOTHUB_SetPortSuspend  (USBH_HC_HANDLE hHostController, unsigned char Port, USBH_PORT_POWER_STATE State);
NUSBH_STATUS  USBH_OHCI_ROOTHUB_Init            (USBH_OHCI_DEVICE * pDev, USBH_ROOT_HUB_NOTIFICATION_FUNC * pfUbdRootHubNotification, void * pfRootHubNotificationContext);
Nvoid         USBH_OHCI_ROOTHUB_ProcessInterrupt(USBH_OHCI_ROOT_HUB    * pHub);
N
N
N
NUSBH_OHCI_HCCA * USBH_OHCI_HccaAlloc            (USBH_HCM_POOL * Pool);
Nvoid             USBH_OHCI_HccaRelease          (USBH_OHCI_HCCA * OhdHcca);
Nvoid             USBH_OHCI_HccaSetInterruptTable(USBH_OHCI_HCCA * OhdHcca, USBH_OHCI_DUMMY_INT_EP * dummyInterruptEndpointList []);
N
Nvoid             USBH_OnISREvent                     (void);
Nvoid             USBH_Free                           (void               * pMemBlock);
Nvoid           * USBH_Malloc                         (U32                  Size);
Xvoid           * USBH_Malloc                         (unsigned long                  Size);
Nvoid           * USBH_MallocZeroed                   (U32                  Size);
Xvoid           * USBH_MallocZeroed                   (unsigned long                  Size);
Nvoid           * USBH_TryMalloc                      (U32                  Size);
Xvoid           * USBH_TryMalloc                      (unsigned long                  Size);
Nvoid           * USBH_AllocTransferMemory            (U32                  NumBytes, unsigned Alignment);
Xvoid           * USBH_AllocTransferMemory            (unsigned long                  NumBytes, unsigned Alignment);
N
NUSBH_HC_HANDLE USBH_STM32_CreateController(void * pBaseAddress);
N
N
N/*********************************************************************
N*
N*       Utility functions
N*
N*  RS: Maybe we should move them into a UTIL module some time ? (We can keep macros here for compatibility)
N*
N**********************************************************************
N*/
NI32          USBH_BringInBounds(I32 v, I32 Min, I32 Max);
Xsigned long          USBH_BringInBounds(signed long v, signed long Min, signed long Max);
NU32          USBH_LoadU32BE(const U8 * pData);
Xunsigned long          USBH_LoadU32BE(const unsigned char * pData);
NU32          USBH_LoadU32LE(const U8 * pData);
Xunsigned long          USBH_LoadU32LE(const unsigned char * pData);
NU32          USBH_LoadU32TE(const U8 * pData);
Xunsigned long          USBH_LoadU32TE(const unsigned char * pData);
Nunsigned     USBH_LoadU16BE(const U8 * pData);
Xunsigned     USBH_LoadU16BE(const unsigned char * pData);
Nunsigned     USBH_LoadU16LE(const U8 * pData);
Xunsigned     USBH_LoadU16LE(const unsigned char * pData);
Nvoid         USBH_StoreU16BE     (U8 * p, unsigned v);
Xvoid         USBH_StoreU16BE     (unsigned char * p, unsigned v);
Nvoid         USBH_StoreU16LE     (U8 * p, unsigned v);
Xvoid         USBH_StoreU16LE     (unsigned char * p, unsigned v);
Nvoid         USBH_StoreU32BE     (U8 * p, U32      v);
Xvoid         USBH_StoreU32BE     (unsigned char * p, unsigned long      v);
Nvoid         USBH_StoreU32LE     (U8 * p, U32      v);
Xvoid         USBH_StoreU32LE     (unsigned char * p, unsigned long      v);
NU32          USBH_SwapU32                (U32      v);
Xunsigned long          USBH_SwapU32                (unsigned long      v);
N
Nvoid         USBH_HC_ClrActivePortReset(USBH_HOST_CONTROLLER * pHost, USBH_HUB_PORT * pEnumPort);
Nvoid         USBH_HC_SetActivePortReset(USBH_HOST_CONTROLLER * pHost, USBH_HUB_PORT * pEnumPort);
N
Nconst char * USBH_PortSpeed2Str(USBH_SPEED    x);
Nconst char * USBH_GetStatusStr(USBH_STATUS   x);
Nconst char * USBH_PortState2Str(PORT_STATE    x);
Nconst char * USBH_UrbFunction2Str(USBH_FUNCTION x);
N
Nconst char * USBH_HubPortResetState2Str   (USBH_HUB_PORTRESET_STATE x);
Nconst char * USBH_HubNotificationState2Str(USBH_HUB_NOTIFY_STATE    x);
Nconst char * USBH_HubEnumState2Str        (USBH_HUB_ENUM_STATE      x);
Nconst char * USBH_EnumState2Str       (DEV_ENUM_STATE        x);
Nconst char * USBH_RhPortResetState2Str(USBH_ROOT_HUB_PORTRESET_STATE    x);
Nconst char * USBH_HcState2Str         (HOST_CONTROLLER_STATE x);
Nconst char * USBH_Ep0State2Str        (USBH_EP0_PHASE x);
N
Nvoid         USBH_DLIST_Append     (USBH_DLIST * ListHead, USBH_DLIST * List);
Nvoid         USBH_DLIST_InsertTail (USBH_DLIST * ListHead, USBH_DLIST * Entry);
Nvoid         USBH_DLIST_InsertHead (USBH_DLIST * ListHead, USBH_DLIST * Entry);
Nvoid         USBH_DLIST_InsertEntry(USBH_DLIST * Entry,    USBH_DLIST * NewEntry);
Nvoid         USBH_DLIST_RemoveTail (USBH_DLIST * ListHead, USBH_DLIST ** Entry);
Nvoid         USBH_DLIST_RemoveHead (USBH_DLIST * ListHead, USBH_DLIST ** Entry);
Nvoid         USBH_DLIST_RemoveEntry(USBH_DLIST * Entry);
NUSBH_DLIST * USBH_DLIST_GetPrev    (USBH_DLIST * Entry);
NUSBH_DLIST * USBH_DLIST_GetNext    (USBH_DLIST * Entry);
Nint          USBH_DLIST_IsEmpty    (USBH_DLIST * ListHead);
Nvoid         USBH_DLIST_Init       (USBH_DLIST * ListHead);
N
N
N/*********************************************************************
N*
N*       USBH_DLIST
N*/
Ntypedef struct USBH_DLIST_ITEM {
N  struct USBH_DLIST_ITEM * pNext;
N  struct USBH_DLIST_ITEM * pPrev;
N} USBH_DLIST_ITEM;
N
Ntypedef struct {
N  struct USBH_DLIST_ITEM * pFirst;
N  int NumItems;
N} USBH_DLIST_HEAD;
N
Nvoid USBH_DLIST_Remove(USBH_DLIST_HEAD * pHead, USBH_DLIST_ITEM * pItem);
Nvoid USBH_DLIST_Add   (USBH_DLIST_HEAD * pHead, USBH_DLIST_ITEM * pNew);
N
Nvoid USBH__ConvSetupPacketToBuffer(const USBH_SETUP_PACKET * Setup, U8 * pBuffer);
Xvoid USBH__ConvSetupPacketToBuffer(const USBH_SETUP_PACKET * Setup, unsigned char * pBuffer);
N
N
N#undef EXTERN
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif
N
N/******************************* EOF ********************************/
L 26 "Config\USBH_ConfigIO.c" 2
N#include "RTOS.h"
L 1 "OS\RTOS.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : RTOS.h
NPurpose : include file for embOS,
N          to be included in every C-module accessing embOS-routines
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef RTOS_H_INCLUDED        /* Avoid multiple inclusion          */
N#define RTOS_H_INCLUDED
N
N/*********************************************************************
N*
N*       Chip specifics for ARM7TDMI / ARM9TDMI and KEIL ARM MDK
N*
N**********************************************************************
N*/
N
N#include <string.h>                            /* req. for memset.h */
N
N/*********************************************************************
N*
N*     Specifics for ARM cores and KEIL-MDK compiler
N*
N**********************************************************************
N*/
N
N#define OS_PORT_REVISION          (1)                // Port specific revision
N#define OS_PTR_OP_IS_ATOMIC       (1)
N#define OS_GetTime()              (OS_Time)
N#define OS_GetTime32()            (OS_Time)
N#define OS_I32                    int
N#define OS_SIZEOF_INT             (4)                // Size of integer in bytes
N#define OS_BIG_ENDIAN             (0)                
N#define OS_SUPPORT_SYSSTACK_INFO  (1)                // Option to supply more info  to viewer
N#define OS_SUPPORT_OS_ALLOC       (1)                // Define whether OS_Alloc is supported
N#define OS_SP_ADJUST              (0)
N#define OS_EnterIntStack()                           // Int stack is automatically used by ARM
N#define OS_LeaveIntStack()                           // Int stack is automatically used by ARM
N
N/*****  Core specific configuration *********************************/
N
N#define OS_SUPPORT_INTSTACK_INFO            (1)      // Option to supply more info  to viewer
N#define OS_SWITCH_FROM_INT_MODIFIES_STACK   (1)
N#define OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY (0)
N#define OS_SUPPORT_INT_PRIORITY             (0)              // No selectable interrupt priorities with ARM
N
N/*****  End of configuration settings *******************************/
N
N#ifdef __TARGET_ARCH_4T
N  #define OS_CPU "ARM4/KEIL_MDK"
N#else
S  #define OS_CPU "ARM5/KEIL_MDK"
N#endif
N
N#define OS_DI() __disable_irq()    /* We use the default intrinsic function */
N#define OS_EI() __enable_irq()     /* We use the default intrinsic function */
N
N
N/* Option to get Stack pointer information  */
N#define OS_INIT_STACK_INFO()
N
N/*********************************************************************
N*
N*       Port specific (non OS generic) functions
N*/
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N  typedef void    OS_ISR_HANDLER(void);
N  void            OS_irq_handler(void);     /* Declare function to make sure it is arm pcs */
N  void            OS_IRQ_SERVICE(void);     /* embOS int handler in RTOSVect.asm  */
N  void            OS_USER_irq_func(void);   /* User interrupt handler from UserIrq.c */
N  OS_ISR_HANDLER* OS_ARM_InstallISRHandler (int ISRIndex, OS_ISR_HANDLER* pFunc);
N  void            OS_ARM_EnableISR         (int ISRIndex);
N  void            OS_ARM_DisableISR        (int ISRIndex);
N  int             OS_ARM_ISRSetPrio        (int ISRIndex, int Prio);
N  void            OS_ARM_AssignISRSource   (int ISRIndex, int Source);
N  void            OS_ARM_EnableISRSource   (int SourceIndex);
N  void            OS_ARM_DisableISRSource  (int SourceIndex);
N  void            OS_StartTask             (void);
N  void            OS_InitPLL               (void);
N
N/*********************************************************************
N*
N*       Core specific implementation
N*/
N
N/****** Support for ARM VFP *****************************************/
N  
Nextern const struct OS_EXTEND_TASK_CONTEXT OS_VFP_ExtendContext;
N
N/****** Support for ARM MMU and caches ******************************/
N
Nvoid OS_ARM_ICACHE_Enable(void);
Nvoid OS_ARM_DCACHE_Enable(void);
Nvoid OS_ARM_DCACHE_CleanRange     (void* p, unsigned int NumBytes);
Nvoid OS_ARM_DCACHE_InvalidateRange(void* p, unsigned int NumBytes);
Nvoid OS_ARM_CACHE_Sync(void);
N
Nvoid OS_ARM_MMU_Enable(unsigned int* pTranslationTable);
Nvoid OS_ARM_MMU_InitTT(unsigned int* pTranslationTable);
Nvoid OS_ARM_MMU_AddTTEntries(unsigned int* pTranslationTable, unsigned int CacheMode, unsigned int VIndex, unsigned int PIndex, unsigned int NumEntries);
N
Nvoid OS_ARM720_CACHE_Enable(void);
Nvoid OS_ARM720_CACHE_CleanRange(void* p, unsigned int NumBytes);
Nvoid OS_ARM720_CACHE_InvalidateRange(void* p, unsigned int NumBytes);
N
Nvoid OS_ARM720_MMU_Enable(unsigned int* pTranslationTable);
Nvoid OS_ARM720_MMU_InitTT(unsigned int* pTranslationTable);
Nvoid OS_ARM720_MMU_AddTTEntries(unsigned int* pTranslationTable, unsigned int CacheMode, unsigned int VIndex, unsigned int PIndex, unsigned int NumEntries);
N
N#define OS_ARM_CACHEMODE_NC_NB    ((0 << 3) | (0 << 2))
N#define OS_ARM_CACHEMODE_C_NB     ((1 << 3) | (0 << 2))
N#define OS_ARM_CACHEMODE_NC_B     ((0 << 3) | (1 << 2))
N#define OS_ARM_CACHEMODE_C_B      ((1 << 3) | (1 << 2))
N#define OS_ARM_CACHEMODE_ILLEGAL  (0x01)
N
N#ifdef __cplusplus
S  } 
N#endif
N
N/*********************************************************************
N*
N*     Port specific revision
N*/
N
N/*********************************************************************
N*
N*       Check configuration
N*
N**********************************************************************
N
NThis is required in order to automatically create the correct identifiers
Nin order to be able to autoamitcally remap the identifiers.
N
N*/
N
N#ifdef __thumb
N  #define OS_CPUMODE_PREFIX "T"
N#else
S  #define OS_CPUMODE_PREFIX "A"
N#endif
N
N#ifdef __TARGET_ARCH_4T
N  #define OS_CPU_PREFIX "4"
N#else
S  #define OS_CPU_PREFIX "5"
N#endif
N
N#ifdef __BIG_ENDIAN
S  #define OS_ENDIAN_PREFIX "B"
N#else
N  #define OS_ENDIAN_PREFIX "L"
N#endif
N
N#define OS_MODEL OS_CPUMODE_PREFIX OS_CPU_PREFIX OS_ENDIAN_PREFIX
N
N
N/****** End of chip / compiler specific part ************************/
N
N/*********************************************************************
N*
N*       Generic portion of the OS starts here
N*
N**********************************************************************
NThis file (original name OS_RAW.h) is part of RTOS.h, the include
Nfile for the OS.
N*/
N
N#if (!defined(OS_LIBMODE_XR) && !defined(OS_LIBMODE_R)  &&   \
N     !defined(OS_LIBMODE_S)  && !defined(OS_LIBMODE_SP) &&   \
N     !defined(OS_LIBMODE_D)  && !defined(OS_LIBMODE_DP) &&   \
N     !defined(OS_LIBMODE_DT))
X#if (!0L && !0L  &&        !0L  && !0L &&        !0L  && !0L &&        !0L)
N#include "OS_Config.h"
L 1 "Config\OS_Config.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef OS_CONFIG_H                     /* Avoid multiple inclusion */
N#define OS_CONFIG_H
N
N/*********************************************************************
N*
N*       Configuration for RTOS build and UART
N*
N*  One of the following builds needs to be selected for both DEBUG and Release builds:
N*
N*  OS_LIBMODE_XR    Extremly small release build without Round robin
N*  OS_LIBMODE_R     Release build
N*  OS_LIBMODE_S     Release build with stack check
N*  OS_LIBMODE_SP    Release build with stack check and profiling
N*  OS_LIBMODE_D     Debug build
N*  OS_LIBMODE_DP    Debug build with profiling
N*  OS_LIBMODE_DT    Debug build with trace
N*/
N
N#ifndef   DEBUG
S  #define DEBUG 0
N#endif
N
N#if DEBUG
X#if 1
N  #define OS_LIBMODE_DP
N#else
S  #define OS_LIBMODE_R
S  #define OS_VIEW_ENABLE   0
N#endif
N
N#endif                                  /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 187 "OS\RTOS.h" 2
N#endif
N
N#define OS_VERSION_GENERIC (36004)      /*   Generic version 3.60d  */
N
N#ifndef   OS_PORT_REVISION
S  #define OS_PORT_REVISION 0
N#endif
N
N#define OS_VERSION OS_VERSION_GENERIC + (OS_PORT_REVISION * 25)
N
N/*********************************************************************
N*
N*       Defines for library types
N*
N**********************************************************************
N*/
N
N/* If library type is not selected yet (on project level,
N   for example), then select DP by default
N*/
N#if (!defined(OS_LIBMODE_XR) && !defined(OS_LIBMODE_R)  &&   \
N     !defined(OS_LIBMODE_S)  && !defined(OS_LIBMODE_SP) &&   \
N     !defined(OS_LIBMODE_D)  && !defined(OS_LIBMODE_DP) &&   \
N     !defined(OS_LIBMODE_DT))
X#if (!0L && !0L  &&        !0L  && !0L &&        !0L  && !1L &&        !0L)
S#define OS_LIBMODE_DP
N#endif
N
N#if defined(OS_LIBMODE_XR)                                   // Extremely small release - without Round robin support
X#if 0L                                   
S  #define OS_CHECKSTACK       0
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_RR_SUPPORTED     0
S  #define OS_TRACKNAME        0
S  #define OS_SUPPORT_SAVE_RESTORE_HOOK 0
S  #define OS_CreateTask   OS_CreateTask_XR
S  #define OS_CreateTaskEx OS_CreateTaskEx_XR
S  #define OS_LIBMODE "XR"
S#elif defined(OS_LIBMODE_R)                                  // Release build
X#elif 0L                                  
S  #define OS_CHECKSTACK       0
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_R
S  #define OS_CreateTaskEx OS_CreateTaskEx_R
S  #define OS_LIBMODE "R"
S#elif defined(OS_LIBMODE_S)                                  // Release build with stack check
X#elif 0L                                  
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_S
S  #define OS_CreateTaskEx OS_CreateTaskEx_S
S  #define OS_LIBMODE "S"
S#elif defined(OS_LIBMODE_SP)                                 // Release build with stack check and profiling
X#elif 0L                                 
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            0
S  #define OS_PROFILE          1
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_SP
S  #define OS_CreateTaskEx OS_CreateTaskEx_SP
S  #define OS_LIBMODE "SP"
S#elif defined(OS_LIBMODE_D)                                  // Debug build
X#elif 0L                                  
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            1
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_D
S  #define OS_CreateTaskEx OS_CreateTaskEx_D
S  #define OS_LIBMODE "D"
N#elif defined(OS_LIBMODE_DP)                                  // Debug build with profiling
X#elif 1L                                  
N  #define OS_CHECKSTACK       1
N  #define OS_PROFILE          1
N  #define OS_DEBUG            1
N  #define OS_SUPPORT_TICKSTEP 1
N  #define OS_TRACE            0
N  #define OS_CreateTask   OS_CreateTask_DP
N  #define OS_CreateTaskEx OS_CreateTaskEx_DP
N  #define OS_LIBMODE "DP"
N#elif defined(OS_LIBMODE_DT)                                  // Debug build with profiling and trace
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            1
S  #define OS_PROFILE          1
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            1
S  #define OS_CreateTask   OS_CreateTask_DT
S  #define OS_CreateTaskEx OS_CreateTaskEx_DT
S  #define OS_LIBMODE "DT"
S#else
S  #error Please define library type used !
N#endif
N
N/*********************************************************************
N*
N*       OS compile time switches
N*
N**********************************************************************
N
NThese compile time switches can be modified when recompiling
Nthe library. Usually, the values are in OSCHIP.H, which is then
Nmerged with OS_RAW.H to form RTOS.H.
NIf the values are not defined in OSCHIP.H, the default values
Nbelow are used.
N*/
N
N/* Make it possible to place const data in RAM via
N   define and therefore via command line. This is required
N   for some smaller CPUs in small memory models
N   It is defined to be "const" by default, but can be defined to nothing
N   by simply adding a -DOS_CONST_DATA on the commandline
N*/
N
N#ifndef   OS_CONST_DATA
N  #define OS_CONST_DATA const  /* Default      */
N#else
S  #undef  OS_CONST_DATA
S  #define OS_CONST_DATA        /* define blank */
N#endif
N
N#ifndef   OS_INTERWORK
N  #define OS_INTERWORK
N#endif
N
N#ifndef   OS_SCHEDULER_ACTIVATED_BY_EXCEPTION
N  #define OS_SCHEDULER_ACTIVATED_BY_EXCEPTION   (0)
N#endif
N
N#ifndef   OS_STACK_ADR
N  #define OS_STACK_ADR OS_U32
N#endif
N
N#ifndef   OS_MODEL
S  #define OS_MODEL ""
N#endif
N
N#ifndef   OS_MEMSET
N  #define OS_MEMSET(a,v,s) memset(a,v,s)
N#endif
N
N#ifndef   OS_MEMCPY
N  #define OS_MEMCPY(dest,src,cnt) memcpy(dest,src,cnt)
N#endif
N
N#ifndef   OS_STRLEN
N  #define OS_STRLEN(s) strlen(s)
N#endif
N
N#ifndef   OS_DUMMY_STATEMENT
N  #define OS_DUMMY_STATEMENT()
N#endif
N
N#ifndef   OS_USEPARA
N  #define OS_USEPARA(para) para=para
N#endif
N
N#ifndef   OS_SUPPORT_TICKSTEP
S  #define OS_SUPPORT_TICKSTEP 0
N#endif
N
N#ifndef   OS_TRACKNAME
N  #define OS_TRACKNAME (1)
N#endif
N
N#ifndef   OS_TRACE
S  #define OS_TRACE (0)
N#endif
N
N#ifndef   OS_SUPPORT_SAVE_RESTORE_HOOK
N  #define OS_SUPPORT_SAVE_RESTORE_HOOK  (1)
N#endif
N
N#ifndef   OS_RR_SUPPORTED
N  #define OS_RR_SUPPORTED (1)
N#endif
N
N#ifndef   OS_STACK_AT_BOTTOM
N  #define OS_STACK_AT_BOTTOM (0)
N#endif
N
N/*  Settings for NON-ANSI compiler syntax
N    The default behaviour complies with IAR.
N*/
N#ifndef   OS_COMPILER_LOCATION_LEFT
N  #define OS_COMPILER_LOCATION_LEFT 1  /* (req. for IAR) */
N#endif
N
N#ifndef   OS_COMPILER_STORAGE_MODIFIER_LEFT
N  #define OS_COMPILER_STORAGE_MODIFIER_LEFT 1  /* default for all except KEIL */
N#endif
N
N#define OS_LINK_MAILBOXES (OS_DEBUG)
N
N#ifndef   OS_CHECK
N  #define OS_CHECK 0
N#endif
N
N#ifndef   OS_ALIGN_PTR
N  #define OS_ALIGN_PTR (1)
N#endif
N
N#ifndef   OS_ALIGN_INT
N  #define OS_ALIGN_INT (1)
N#endif
N
N#ifndef   OS_PTR_TO_VALUE
N  #define OS_PTR_TO_VALUE(p) (p)
N#endif
N
N#ifndef   OS_IDLE
N  #define OS_IDLE() OS_Idle()
N#endif
N
N#ifndef   OS_PTR_OP_IS_ATOMIC
S  #define OS_PTR_OP_IS_ATOMIC   (0)         // Helps to minimize code size and execution time. Some code is not required if setting pointers is an atomic operation (32 bit CPUs or 16 bit CPUs in near model)
N#endif
N
N#ifndef   OS_SUSPEND_TASK_ON_TERMINATE      // Sets the task state of a terminated task to "suspended". Primarily used in the OS simulation, because the windows scheduler might re-activate a suspended task
N  #define OS_SUSPEND_TASK_ON_TERMINATE (0)
N#endif
N
N#ifndef   OS_INIT_EXPLICITLY
N  #define OS_INIT_EXPLICITLY  (0)           // If enabled, OS_InitKern() initializes Non-Zero globals. Required only for faulty compiler (or startup-code) which do not perform proper init of globals during startup.
N#endif
N
N#ifndef   OS_TASK_LIST_HAS_PPREV
N  #define OS_TASK_LIST_HAS_PPREV   OS_RR_SUPPORTED
N#else
S  #if (OS_TASK_LIST_HAS_PPREV == 0) && OS_RR_SUPPORTED
S    #error  "Invalid combination of config switches"
S  #endif
N#endif
N
N#ifndef   OS_SUPPORT_CALL_ISR
N  #define OS_SUPPORT_CALL_ISR (1)
N#endif
N
N#ifndef   OS_PREPARE_STACKPOINTER
N  #define OS_PREPARE_STACKPOINTER()
N#endif
N
N#ifndef   OS_SUPPORT_POWER
N  #define OS_SUPPORT_POWER (1)
N#endif
N
N#ifndef   OS_POWER_NUM_COUNTERS
N  #define OS_POWER_NUM_COUNTERS (5)
N#endif
N
N/*********************************************************************
N*
N*       Check Compile time switches
N*
N**********************************************************************
N*/
N
N#ifndef OS_SIZEOF_INT
S  #error "Please define OS_SIZEOF_INT (OSChip.h)"
N#endif
N#ifndef OS_BIG_ENDIAN
S  #error "Please define OS_BIG_ENDIAN (OSChip.h)"
N#endif
N
N#if (OS_STACK_AT_BOTTOM != 0) && (OS_STACK_AT_BOTTOM != 1)
X#if ((0) != 0) && ((0) != 1)
S  /*
S  *  Only 0 or 1 is allowed, because OS_STACK_AT_BOTTOM is used for calculations!
S  */
S  #error "OS_STACK_AT_BOTTOM has to be defined to 0 or 1"
N#endif
N
N/*********************************************************************
N*
N*       Basic type defines
N*
N**********************************************************************
N*/
N
N#ifndef   OS_I8
N  #define OS_I8 signed char
N#endif
N
N#ifndef   OS_U8
N  #define OS_U8 unsigned char
N#endif
N
N#ifndef   OS_I16
N  #define OS_I16 signed short
N#endif
N
N#ifndef   OS_U16
N  #define OS_U16 unsigned short
N#endif
N
N#ifndef   OS_I32
S  #define OS_I32 long
N#endif
N
N#ifndef   OS_U32
N  #define OS_U32 unsigned OS_I32
N#endif
N
N/* Defines a true integer. This type is guaranteed
N   a) to have at least 8 bits,
N   b) to compile and execute best on the target CPU
N   It will normally be the same as an int, but on most
N   8-bit CPUs it will be replaced by a character because
N   the CPU can deal with 8 bits more efficient than with
N   16 bit integers.
N   Use with care !
N*/
N#ifndef   OS_INT
N  #define OS_INT       int
N#endif
N
N#ifndef   OS_UINT
N  #define OS_UINT      unsigned OS_INT
N#endif
N
N#ifndef   OS_TIME
N  #define OS_TIME      int
N#endif
N
N
N/*********************************************************************
N*
N*       Error codes
N*
N**********************************************************************
N*/
N
N/* User 0..99  ***********************************/
N
N/* Port 100..119 *********************************/
N#define OS_ERR_ISR_INDEX                      (100)
N#define OS_ERR_ISR_VECTOR                     (101)
N#define OS_ERR_ISR_PRIO                       (102)
N
N/* OS generic ************************************/
N/* stack overflow or invalid stack */
N#define OS_ERR_STACK                          (120)
N
N/* Counting semaphore overflow */
N#define OS_ERR_CSEMA_OVERFLOW                 (121)
N
N/* Power management module */
N#define OS_ERR_POWER_OVER                     (122)
N#define OS_ERR_POWER_UNDER                    (123)
N#define OS_ERR_POWER_INDEX                    (124)
N
N
N/* invalid or non-initialized data structures */
N#define OS_ERR_INV_TASK                       (128)
N#define OS_ERR_INV_TIMER                      (129)
N#define OS_ERR_INV_MAILBOX                    (130)
N#define OS_ERR_INV_CSEMA                      (132)
N#define OS_ERR_INV_RSEMA                      (133)
N
N/* Using GetMail1 or PutMail1 or GetMailCond1 or PutMailCond1 on
N   a non-1 byte mailbox  */
N#define OS_ERR_MAILBOX_NOT1                   (135)
N
N/* Waitable objects deleted with waiting tasks or occupied by task */
N#define OS_ERR_MAILBOX_DELETE                 (136)
N#define OS_ERR_CSEMA_DELETE                   (137)
N#define OS_ERR_RSEMA_DELETE                   (138)
N
N/* internal errors, please contact SEGGER Microcontrollersysteme */
N#define OS_ERR_MAILBOX_NOT_IN_LIST            (140)
N#define OS_ERR_TASKLIST_CORRUPT               (142)
N
N/* not matching routine calls or macro usage */
N#define OS_ERR_UNUSE_BEFORE_USE               (150)
N#define OS_ERR_LEAVEREGION_BEFORE_ENTERREGION (151)
N#define OS_ERR_LEAVEINT                       (152)
N#define OS_ERR_DICNT                          (153)
N#define OS_ERR_INTERRUPT_DISABLED             (154)
N#define OS_ERR_TASK_ENDS_WITHOUT_TERMINATE    (155)
N#define OS_ERR_RESOURCE_OWNER                 (156)
N
N#define OS_ERR_ILLEGAL_IN_ISR                 (160)  /* not a legal system call during interrupt */
N#define OS_ERR_ILLEGAL_IN_TIMER               (161)  /* not a legal system call during timer */
N#define OS_ERR_ILLEGAL_OUT_ISR                (162)  /* not a legal system call outside interrupt */
N#define OS_ERR_NOT_IN_ISR                     (163)  /* OS_EnterInterrupt() has been called, but CPU is not in ISR state */
N#define OS_ERR_IN_ISR                         (164)  /* OS_EnterInterrupt() has not been called, but CPU is in ISR state */
N
N#define OS_ERR_INIT_NOT_CALLED                (165)  /* OS_InitKern() was not called */
N
N/* Double used data structures */
N#define OS_ERR_2USE_TASK                      (170)
N#define OS_ERR_2USE_TIMER                     (171)
N#define OS_ERR_2USE_MAILBOX                   (172)
N#define OS_ERR_2USE_BSEMA                     (173)
N#define OS_ERR_2USE_CSEMA                     (174)
N#define OS_ERR_2USE_RSEMA                     (175)
N#define OS_ERR_2USE_MEMF                      (176)
N
N/* Communication errors (OSCOM) */
N#define OS_ERR_NESTED_RX_INT                  (180)
N
N/* Fixed block memory pool  */
N#define OS_ERR_MEMF_INV                       (190)
N#define OS_ERR_MEMF_INV_PTR                   (191)
N#define OS_ERR_MEMF_PTR_FREE                  (192)
N#define OS_ERR_MEMF_RELEASE                   (193)
N#define OS_ERR_POOLADDR                       (194)
N#define OS_ERR_BLOCKSIZE                      (195)
N
N/* Task suspend / resume errors */
N#define OS_ERR_SUSPEND_TOO_OFTEN              (200)
N#define OS_ERR_RESUME_BEFORE_SUSPEND          (201)
N
N/* Other task related errors */
N#define OS_ERR_TASK_PRIORITY                  (202)
N
N/* Event object */
N#define OS_ERR_EVENT_INVALID                  (210)
N#define OS_ERR_2USE_EVENTOBJ                  (211)
N#define OS_ERR_EVENT_DELETE                   (212)
N
N/* Waitlist (checked build) */
N#define OS_ERR_WAITLIST_RING                  (220)
N#define OS_ERR_WAITLIST_PREV                  (221)
N#define OS_ERR_WAITLIST_NEXT                  (222)
N
N/* Other potential problems discovered in checked build */
N#define OS_ERR_NOT_IN_REGION                  (225)
N
N/* Cache related */
N#define OS_ERR_NON_ALIGNED_INVALIDATE         (230)
N
N/* OS special build, or internal */
N#define OS_ERR_TRIAL_LIMIT                    (254)
N
N/*********************************************************************
N*
N*       Trace identifier
N*
N**********************************************************************
N
NIdentifier from 0 to 99 are reserved for the OS
NEven when not all of those are currently used,
Nthey may be defined in the future
N
N*/
N
N#define OS_TRACE_ID_DEACTIVATE      (1)
N#define OS_TRACE_ID_ACTIVATE        (2)
N#define OS_TRACE_ID_TIMERCALLBACK   (3)
N
N/* Task group */
N#define OS_TRACE_ID_DELAY           (10)
N#define OS_TRACE_ID_DELAYUNTIL      (11)
N#define OS_TRACE_ID_SETPRIORITY     (12)
N#define OS_TRACE_ID_WAKETASK        (13)
N#define OS_TRACE_ID_CREATETASK      (14)
N#define OS_TRACE_ID_TERMINATETASK   (15)
N#define OS_TRACE_ID_SUSPENDTASK     (16)
N#define OS_TRACE_ID_RESUMETASK      (17)
N#define OS_TRACE_ID_CREATETASK_EX   (18)
N#define OS_TRACE_ID_YIELD           (19)
N
N/* Event group */
N#define OS_TRACE_ID_WAITEVENT       (20)
N#define OS_TRACE_ID_WAITEVENT_TIMED (21)
N#define OS_TRACE_ID_SIGNALEVENT     (22)
N#define OS_TRACE_ID_CLEAREVENTS     (23)
N
N/* Mailbox group  */
N#define OS_TRACE_ID_CREATEMB        (30)
N#define OS_TRACE_ID_CLEARMB         (31)
N#define OS_TRACE_ID_DELETEMB        (32)
N#define OS_TRACE_ID_PUTMAIL         (33)
N#define OS_TRACE_ID_GETMAIL         (34)
N#define OS_TRACE_ID_PUTMAILCOND     (35)
N#define OS_TRACE_ID_GETMAILCOND     (36)
N#define OS_TRACE_ID_PUTMAIL_TIMED   (37)
N#define OS_TRACE_ID_GETMAIL_TIMED   (38)
N#define OS_TRACE_ID_WAITMAIL        (39)
N
N#define OS_TRACE_ID_PUTMAIL1        (40)
N#define OS_TRACE_ID_GETMAIL1        (41)
N#define OS_TRACE_ID_PUTMAILCOND1    (42)
N#define OS_TRACE_ID_GETMAILCOND1    (43)
N#define OS_TRACE_ID_PUTMAIL_TIMED1  (44)
N#define OS_TRACE_ID_GETMAIL_TIMED1  (45)
N
N#define OS_TRACE_ID_PUTMAIL_F       (46)
N#define OS_TRACE_ID_PUTMAIL_F1      (47)
N#define OS_TRACE_ID_PUTMAIL_FCOND   (48)
N#define OS_TRACE_ID_PUTMAIL_FCOND1  (49)
N
N/* Resource group */
N#define OS_TRACE_ID_CREATERSEMA     (50)
N#define OS_TRACE_ID_USE             (51)
N#define OS_TRACE_ID_UNUSE           (52)
N#define OS_TRACE_ID_REQUEST         (53)
N#define OS_TRACE_ID_GETSEMAVALUE    (54)
N#define OS_TRACE_ID_DELETE_RSEMA    (55)
N
N/* Counting Semaphore group */
N#define OS_TRACE_ID_CREATECSEMA     (60)
N#define OS_TRACE_ID_DELETECSEMA     (61)
N#define OS_TRACE_ID_SIGNALCSEMA     (62)
N#define OS_TRACE_ID_WAITCSEMA       (63)
N#define OS_TRACE_ID_WAITCSEMATIMED  (64)
N#define OS_TRACE_ID_SIGNALCSEMA_MAX (65)
N#define OS_TRACE_ID_SET_CSEMAVALUE  (66)
N#define OS_TRACE_ID_CSEMAREQUEST    (67)
N
N/* Timer group    */
N#define OS_TRACE_ID_CREATETIMER     (70)
N#define OS_TRACE_ID_DELETETIMER     (71)
N#define OS_TRACE_ID_STARTTIMER      (72)
N#define OS_TRACE_ID_STOPTIMER       (73)
N#define OS_TRACE_ID_RETRIGGERTIMER  (74)
N#define OS_TRACE_ID_SETTIMERPERIOD  (75)
N#define OS_TRACE_ID_CREATETIMER_EX  (76)
N
N/* Heap type memory management  */
N#define OS_TRACE_ID_MALLOC          (80)
N#define OS_TRACE_ID_FREE            (81)
N#define OS_TRACE_ID_REALLOC         (82)
N
N/* Fixed block type memory management  */
N#define OS_TRACE_ID_MEMF_CREATE     (90)
N#define OS_TRACE_ID_MEMF_DELETE     (91)
N#define OS_TRACE_ID_MEMF_ALLOC      (92)
N
N
N/*********************************************************************
N*
N*       Assertions
N*
N**********************************************************************
N
N  Assertions are used to generate code in the debug version
N  of the OS in order catch programming faults like
N  bad pointers or uninitialized data structures
N*/
N
N#if OS_DEBUG
X#if 1
N  #define OS_ASSERT(Exp, ErrCode) { if (!(Exp)) OS_Error(ErrCode); }
N#else
S  #define OS_ASSERT(Exp, ErrCode)
N#endif
N
N#define OS_ASSERT_INT()           OS_ASSERT((OS_InInt != 0),          OS_ERR_ILLEGAL_OUT_ISR)
N#define OS_ASSERT_NOINT()         OS_ASSERT((OS_InInt == 0),          OS_ERR_ILLEGAL_IN_ISR)
N#define OS_ASSERT_NOTIMER()       OS_ASSERT((OS_InTimer == 0),        OS_ERR_ILLEGAL_IN_TIMER)
N#define OS_ASSERT_DICnt()         OS_ASSERT(((OS_DICnt & 0xf0) == 0), OS_ERR_DICNT)
N#define OS_ASSERT_INIT_CALLED()   OS_ASSERT((OS_InitCalled != 0),     OS_ERR_INIT_NOT_CALLED)
N
N/*********************************************************************
N*
N*       Memory attributes
N*
N**********************************************************************
N*/
N
N#ifndef OS_STACKPTR
N  #define OS_STACKPTR
N#endif
N
N#ifndef OS_SADDR
N  #ifdef SADDR
S    #define OS_SADDR SADDR
N  #else
N    #define OS_SADDR
N  #endif
N#endif
N
N/* pointer modifier for data items */
N#ifndef OS_DATAPTR
N  #define OS_DATAPTR
N#endif
N
N#ifndef OS_RSEMAPTR
N  #define OS_RSEMAPTR
N#endif
N
N#ifndef   OS_CSEMAPTR
N  #define OS_CSEMAPTR
N#endif
N
N#ifndef   OS_MBPTR
N  #define OS_MBPTR
N#endif
N
N#ifndef   OS_TCBPTR
N  #define OS_TCBPTR
N#endif
N
N#ifndef   OS_TIMERPTR
N  #define OS_TIMERPTR
N#endif
N
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N/*********************************************************************
N*
N*       Data structures
N*
N**********************************************************************
N*/
N
Ntypedef struct OS_TASK         OS_TASK;
Ntypedef struct OS_WAIT_LIST    OS_WAIT_LIST;
Ntypedef struct OS_WAIT_OBJ     OS_WAIT_OBJ;
Ntypedef struct OS_WAIT_OBJ_EX  OS_WAIT_OBJ_EX;
Ntypedef struct OS_REGS         OS_REGS;
N
Ntypedef void voidRoutine(void);
Ntypedef void OS_RX_CALLBACK(OS_U8 Data);
Xtypedef void OS_RX_CALLBACK(unsigned char Data);
Ntypedef void OS_TIMERROUTINE(void);
Ntypedef void OS_TIMER_EX_ROUTINE(void *);
Ntypedef void OS_ON_TERMINATE_FUNC(OS_TASK *);
N
Ntypedef void OS_TICK_HOOK_ROUTINE(void);
N
N/**********************************************************************
N*
N*       OS_WAIT_OBJ
N*       OS_WAIT_LIST
N*       OS_WAIT_OBJ_EX
N*/
Nstruct OS_WAIT_OBJ {
N  OS_WAIT_LIST * pWaitList;
N};
N
Nstruct OS_WAIT_OBJ_EX {
N  OS_WAIT_OBJ WaitObj;
N  int v;
N};
N
Nstruct OS_WAIT_LIST {
N  OS_WAIT_LIST * pNext;    /* Needs to be first element ! */
N  OS_WAIT_LIST * pPrev;
N  OS_WAIT_OBJ  * pWaitObj;
N  OS_TASK      * pTask;
N};
N
N
N/**********************************************************************
N*
N*       OS_EXTEND_TASK_CONTEXT
N*
N*  This structure is used to define a save and restore function for
N*  extension of the task context.
N*  A pointer to this structure is part of the task control block
N*  It is initialized by OS_ExtendTaskContext();
N*/
Ntypedef struct OS_EXTEND_TASK_CONTEXT {
N  void (*pfSave)   (      void * pStack);
N  void (*pfRestore)(const void * pStack);
N} OS_EXTEND_TASK_CONTEXT;
N
N
N/**********************************************************************
N*
N*       OS_TASK
N*
N*  This structure (referred to as "task control block" or TCB) holds all relevant information
N*  about a single task. Note that some elements are optional, depending on the compile time
N*  options, especially the type of build
N*/
Nstruct OS_TASK {
N  //
N  // Elements required for all builds
N  //
N  // Start of assembly relevant section. Do not move these elements
N  OS_TASK * pNext;                        // Points to the TCB of the next task in the list (with equal or lower priority). Needs to be first element !
N  OS_REGS OS_STACKPTR * pStack;           // Typically contains the stack pointer if the task is suspended.                 Needs to be second element !
X  OS_REGS  * pStack;           
N  // End of assembly relevant section
N  OS_WAIT_LIST * pWaitList;               // Points to a waitable object if task is suspended.
N  OS_TIME        Timeout;
X  int        Timeout;
N  OS_U8          Priority;
X  unsigned char          Priority;
N  OS_U8          Stat;
X  unsigned char          Stat;
N  OS_U8          Events;                  // Event storage
X  unsigned char          Events;                  
N  OS_U8          EventMask;               // Event mask
X  unsigned char          EventMask;               
N  //
N  // PPrev is required only in builds with doubly-linked task lists
N  //
N  #if OS_TASK_LIST_HAS_PPREV
X  #if (1)
N    OS_TASK      * pPrev;                   //
N  #endif
N  //
N  // Elements required with "Track-name" functionality only. Typically available in all builds, but can be disabled at compile time
N  //
N  #if OS_TRACKNAME
X  #if (1)
N    const char * Name;
N  #endif
N  //
N  // Elements required with "Stack-check" functionality only. Available in stack-check and debug builds.
N  //
N  #if OS_CHECKSTACK
X  #if 1
N    OS_UINT  StackSize;            // Stack size in bytes. Not required for functionality, just for analysis
X    unsigned int  StackSize;            
N    OS_U8 OS_STACKPTR* pStackBot;  // First byte of stack. Not required for functionality, just for analysis
X    unsigned char * pStackBot;  
N  #endif
N  //
N  // Elements required with profiling or debug builds
N  //
N  #if (OS_PROFILE || OS_DEBUG)
X  #if (1 || 1)
N    OS_U32 NumActivations;         // Counts how many times task has been activated
X    unsigned int NumActivations;         
N    OS_U32 NumPreemptions;         // Counts how many times task has been preempted
X    unsigned int NumPreemptions;         
N  #endif
N  //
N  // Elements required with profiling builds
N  //
N  #if OS_PROFILE
X  #if 1
N    OS_U32 ExecTotal;              // Time spent executing
X    unsigned int ExecTotal;              
N    OS_U32 ExecLast;               // Time spent executing (Reference)
X    unsigned int ExecLast;               
N    OS_U32 Load;                   // Profiling builds only:
X    unsigned int Load;                   
N  #endif
N  //
N  // Elements required with Round-robin functionality only. Typically available in all builds, but can be disabled at compile time
N  //
N  #if OS_RR_SUPPORTED
X  #if (1)
N    OS_U8  TimeSliceRem;
X    unsigned char  TimeSliceRem;
N    OS_U8  TimeSliceReload;
X    unsigned char  TimeSliceReload;
N  #endif
N  //
N  // Optional Save & Restore hook support (usually only for bigger CPUs)
N  //
N  #if OS_SUPPORT_SAVE_RESTORE_HOOK
X  #if (1)
N    const OS_EXTEND_TASK_CONTEXT * pExtendContext;
N  #endif
N  //
N  // Elements required with debug builds
N  //
N  #if OS_DEBUG
X  #if 1
N    char Id;                       // Debug builds only: Id of this control block.
N  #endif
N  //
N  // Allow port specific extension to the task control block. Not used in most ports
N  //
N  #ifdef OS_TCB_CPU_EX
S    OS_TCB_CPU_EX
N  #endif
N};
N
N/**********************************************************************
N*
N*       OS_TIMER
N*/
Ntypedef struct OS_timer OS_TIMER;
Nstruct OS_timer {
N  OS_TIMER * pNext;
N  voidRoutine* Hook;
N  OS_TIME Time;
X  int Time;
N  OS_TIME Period;
X  int Period;
N  char    Active;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_TIMER_EX
N*/
Ntypedef struct {
N  OS_TIMER Timer;
N  OS_TIMER_EX_ROUTINE * pfUser;
N  void * pData;
N} OS_TIMER_EX;
N
N/**********************************************************************
N*
N*       OS_TICK_HOOK
N*/
Ntypedef struct OS_TICK_HOOK OS_TICK_HOOK;
Nstruct OS_TICK_HOOK {
N  OS_TICK_HOOK*          pNext;
N  OS_TICK_HOOK_ROUTINE * pfUser;
N};
N
N/**********************************************************************
N*
N*       OS_RSEMA
N*/
Ntypedef struct OS_RSEMA OS_RSEMA;
Nstruct OS_RSEMA {
N  OS_WAIT_OBJ WaitObj;
N  OS_TASK * pTask;                /* Owner */
N  OS_U8 UseCnt;
X  unsigned char UseCnt;
N  OS_RSEMA * pNext;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_CSEMA
N*/
Ntypedef struct OS_CSEMA OS_CSEMA;
Nstruct OS_CSEMA {
N  OS_WAIT_OBJ WaitObj;
N  OS_UINT Cnt;
X  unsigned int Cnt;
N#if OS_DEBUG
X#if 1
N  OS_CSEMA * pNext;
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_MAILBOX
N*/
Ntypedef struct OS_MAILBOX OS_MAILBOX;
Nstruct OS_MAILBOX {
N  OS_WAIT_OBJ WaitObj;
N#if OS_LINK_MAILBOXES
X#if (1)
N  OS_MAILBOX * pNext;
N#endif
N  char *pData;
N  OS_UINT nofMsg;
X  unsigned int nofMsg;
N  OS_UINT maxMsg;
X  unsigned int maxMsg;
N  OS_UINT iRd;
X  unsigned int iRd;
N  OS_U8  sizeofMsg;
X  unsigned char  sizeofMsg;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_Q
N*/
Ntypedef struct OS_Q OS_Q;
Nstruct OS_Q {
N  OS_WAIT_OBJ WaitObj;
N  OS_Q*    pNext;          /* ptr to next queue (for debugging / monitoring) */
N  OS_U8*   pData;
X  unsigned char*   pData;
N  OS_UINT  Size;
X  unsigned int  Size;
N  OS_UINT  MsgCnt;
X  unsigned int  MsgCnt;
N  OS_UINT  offFirst;
X  unsigned int  offFirst;
N  OS_UINT  offLast;
X  unsigned int  offLast;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_MEMF
N*/
N#ifndef   OS_MEMF_MAX_ITEMS
N  #define OS_MEMF_MAX_ITEMS 20
N#endif
N
N#define OS_MEMF_SIZEOF_BLOCKCONTROL 0  /* sizeof(int) in future version for debugging */
N
Ntypedef struct OS_MEMF OS_MEMF;
Nstruct OS_MEMF {
N  OS_WAIT_OBJ WaitObj;
N  OS_MEMF* pNext;          /* ptr to next memory pool */
N  void*    pPool;
N  OS_U16   NumBlocks;
X  unsigned short   NumBlocks;
N  OS_U16   BlockSize;
X  unsigned short   BlockSize;
N  OS_U16   NumFreeBlocks;
X  unsigned short   NumFreeBlocks;
N  OS_U16   MaxUsed;
X  unsigned short   MaxUsed;
N  void*    pFree;
N  #if OS_DEBUG
X  #if 1
N    int  aiPurpose[OS_MEMF_MAX_ITEMS];
X    int  aiPurpose[20];
N    char Id;
N  #endif
N};
N
N/**********************************************************************
N*
N*       OS_EVENT
N*/
Ntypedef struct  OS_EVENT OS_EVENT;
N
Nstruct OS_EVENT {
N  OS_WAIT_OBJ WaitObj;
N  OS_U8       Signaled;
X  unsigned char       Signaled;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_TRACE_ENTRY
N*/
Ntypedef struct {
N  OS_U32  Time;
X  unsigned int  Time;
N  void    *pCurrentTask;
N  void    *p;
N  OS_U32  v;
X  unsigned int  v;
N  OS_U8   iRout;
X  unsigned char   iRout;
N} OS_TRACE_ENTRY;
N
N
N/*********************************************************************
N*
N*       Globals
N*
N**********************************************************************
N*/
N
N/*
N    Handle DEFinition (storage is actually allocted) versus DEClaration
N    (reference) of RTOS variables depending upon who includes this header file.
N*/
N#ifdef __OSGLOBAL_C__
S  #define OS_EXTERN        /* Declare variables if included by RTOSKERN.C */
S  #define OS_EXTERN_INIT(Var, Val) Var=Val
N#else
N  #define OS_EXTERN extern /* Define variables if included by anyone else */
N  #define OS_EXTERN_INIT(Var, Val) Var
N#endif
N
N/*****  Mark start of memory pragma area ****************************/
N
N/* Some compilers can not deal with memory attributes and need pragmas */
N#if defined(__ghs_zda)
X#if 0L
S  #pragma ghs startzda
N#endif
N
N/********************************************************************/
N
Ntypedef union {
N  int Dummy;            // Make sure a full integer (32 bit on 32 bit CPUs) is used.
N  struct {
N    OS_U8 Region;
X    unsigned char Region;
N    OS_U8 DI;
X    unsigned char DI;
N  } Cnt;
N} OS_COUNTERS;
N
N
N#if OS_COMPILER_STORAGE_MODIFIER_LEFT  /* default */
X#if 1   
N  OS_EXTERN OS_SADDR  volatile OS_I32 OS_Time;
X  extern   volatile int OS_Time;
N  OS_EXTERN OS_SADDR  OS_TIME         OS_EXTERN_INIT(OS_TimeDex, 16384);
X  extern   int         OS_TimeDex;
N  OS_EXTERN OS_SADDR  OS_COUNTERS OS_Counters;
X  extern   OS_COUNTERS OS_Counters;
N
N  OS_EXTERN OS_SADDR  OS_U8  OS_EXTERN_INIT(OS_IntMSInc, 1);
X  extern   unsigned char  OS_IntMSInc;
N  OS_EXTERN OS_SADDR  OS_U8  OS_Pending;
X  extern   unsigned char  OS_Pending;
N  OS_EXTERN OS_SADDR  volatile OS_U8  OS_Status;
X  extern   volatile unsigned char  OS_Status;
N
N  #if OS_RR_SUPPORTED
X  #if (1)
N    OS_EXTERN OS_SADDR  OS_U8  OS_TimeSlice;
X    extern   unsigned char  OS_TimeSlice;
N    OS_EXTERN OS_SADDR  OS_U8  OS_TimeSliceAtStart;
X    extern   unsigned char  OS_TimeSliceAtStart;
N  #endif
N  #if OS_SUPPORT_TICKSTEP
X  #if 1
N    OS_EXTERN OS_SADDR  volatile OS_U8   OS_TickStep;
X    extern   volatile unsigned char   OS_TickStep;
N    OS_EXTERN OS_SADDR  volatile int     OS_TickStepTime;
X    extern   volatile int     OS_TickStepTime;
N  #endif
N  OS_EXTERN OS_SADDR        OS_UINT OS_TicksPerMS;
X  extern         unsigned int OS_TicksPerMS;
N  OS_EXTERN OS_SADDR        int     OS_IntTicksInc;
X  extern         int     OS_IntTicksInc;
N  #if OS_PROFILE
X  #if 1
N    OS_EXTERN OS_SADDR OS_U32 OS_TS_ExecStart;
X    extern  unsigned int OS_TS_ExecStart;
N    OS_EXTERN OS_SADDR OS_U8  ProfilingOn;
X    extern  unsigned char  ProfilingOn;
N  #endif
N  #if OS_DEBUG
X  #if 1
N    OS_EXTERN OS_SADDR OS_U8 OS_InInt;
X    extern  unsigned char OS_InInt;
N    OS_EXTERN OS_SADDR OS_U8 OS_InTimer;
X    extern  unsigned char OS_InTimer;
N    OS_EXTERN OS_SADDR OS_U8 OS_InitCalled;
X    extern  unsigned char OS_InitCalled;
N  #endif
N
N  #if OS_SUPPORT_POWER
X  #if (1)
N    OS_EXTERN OS_SADDR OS_U8 OS_POWER_Levels[OS_POWER_NUM_COUNTERS];
X    extern  unsigned char OS_POWER_Levels[(5)];
N  #endif
N
N  /*** Pointers ***
N    Unfortunately there is no real standard on how to define/declare
N    pointers properly with extended memory attributes. There are
N    currently 2 different standards, which we both support.
N  */
N  #if OS_COMPILER_LOCATION_LEFT
X  #if 1
N    OS_EXTERN OS_SADDR  OS_TASK      * OS_pTask;             /* linked list of all Tasks */
X    extern   OS_TASK      * OS_pTask;              
N    OS_EXTERN OS_SADDR  OS_TASK      * OS_pCurrentTask;      /* pointer to current Task */
X    extern   OS_TASK      * OS_pCurrentTask;       
N    OS_EXTERN OS_SADDR  OS_TASK volatile * volatile OS_pActiveTask;
X    extern   OS_TASK volatile * volatile OS_pActiveTask;
N    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pTimer;            /* linked list of all active Timers */
X    extern   OS_TIMER     * OS_pTimer;             
N    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pCurrentTimer;     /* Actual expired timer which called callback */
X    extern   OS_TIMER     * OS_pCurrentTimer;      
N    OS_EXTERN OS_SADDR OS_RSEMA      * OS_pRSema;
X    extern  OS_RSEMA      * OS_pRSema;
N    #if OS_LINK_MAILBOXES
X    #if (1)
N      OS_EXTERN OS_SADDR OS_MAILBOX  * OS_pMailbox;
X      extern  OS_MAILBOX  * OS_pMailbox;
N    #endif
N    #if OS_DEBUG
X    #if 1
N      OS_EXTERN OS_SADDR OS_CSEMA    * OS_pCSema;
X      extern  OS_CSEMA    * OS_pCSema;
N    #endif
N    OS_EXTERN   OS_SADDR OS_MEMF      * OS_pMEMF;            /* linked list of all fixed size memory pools */
X    extern    OS_MEMF      * OS_pMEMF;             
N    OS_EXTERN   OS_SADDR OS_TICK_HOOK * OS_pTickHook;        /* linked list of all tick hook functions */
X    extern    OS_TICK_HOOK * OS_pTickHook;         
N  #else
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pTask;          /* linked list of all Tasks */
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pCurrentTask;   /* pointer to current Task */
S    OS_EXTERN OS_TASK    volatile * OS_SADDR volatile OS_pActiveTask;
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pTimer;         /* linked list of all active Timers */
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pCurrentTimer;  /* Actual expired timer which called callback */
S    OS_EXTERN OS_RSEMA            * OS_SADDR OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_MAILBOX        * OS_SADDR OS_pMailbox;
S    #endif
S
S    #if OS_DEBUG
S      OS_EXTERN  OS_CSEMA         * OS_SADDR OS_pCSema;
S    #endif
S    OS_EXTERN OS_MEMF             * OS_SADDR OS_pMEMF;          /* linked list of all fixed size memory pools */
S    OS_EXTERN OS_TICK_HOOK        * OS_SADDR OS_pTickHook;      /* linked list of all tick hook functions */
N  #endif
N
N#else  /*  OS_COMPILER_STORAGE_MODIFIER_LEFT == 0, needed for Keil 166 */
S  OS_EXTERN volatile OS_I32 OS_SADDR OS_Time;
S  OS_EXTERN OS_TIME         OS_SADDR OS_EXTERN_INIT(OS_TimeDex, 16384);
S  OS_EXTERN OS_COUNTERS OS_SADDR OS_Counters;
S
S  OS_EXTERN OS_U8 OS_SADDR OS_EXTERN_INIT(OS_IntMSInc, 1);
S  OS_EXTERN OS_U8 OS_SADDR OS_Pending;
S  OS_EXTERN volatile OS_U8 OS_SADDR OS_Status;
S  #if OS_RR_SUPPORTED
S    OS_EXTERN OS_U8 OS_SADDR OS_TimeSlice;
S    OS_EXTERN OS_U8 OS_SADDR OS_TimeSliceAtStart;
S  #endif
S  #if OS_SUPPORT_TICKSTEP
S    OS_EXTERN volatile OS_U8 OS_SADDR OS_TickStep;
S    OS_EXTERN volatile int   OS_SADDR OS_TickStepTime;
S  #endif
S  OS_EXTERN OS_UINT OS_SADDR OS_TicksPerMS;
S  OS_EXTERN int     OS_SADDR OS_IntTicksInc;
S  #if OS_PROFILE
S    OS_EXTERN OS_U32 OS_SADDR OS_TS_ExecStart;
S    OS_EXTERN OS_U8  OS_SADDR ProfilingOn;
S  #endif
S  #if OS_DEBUG
S    OS_EXTERN OS_U8 OS_SADDR OS_InInt;
S    OS_EXTERN OS_U8 OS_SADDR OS_InTimer;
S    OS_EXTERN OS_U8 OS_SADDR OS_InitCalled;
S  #endif
S
S  #if OS_SUPPORT_POWER
S    OS_EXTERN OS_U8 OS_SADDR OS_POWER_Levels[OS_POWER_NUM_COUNTERS];
S  #endif
S
S  /*** Pointers ***
S    Unfortunately there is no real standard on how to define/declare
S    pointers properly with extended memory attributes. There are
S    currently 2 different standards, which we both support.
S  */
S  #if OS_COMPILER_LOCATION_LEFT
S    OS_EXTERN OS_SADDR  OS_TASK      * OS_pTask;             /* linked list of all Tasks */
S    OS_EXTERN OS_SADDR  OS_TASK      * OS_pCurrentTask;      /* pointer to current Task */
S    OS_EXTERN OS_SADDR  OS_TASK volatile * volatile OS_pActiveTask;
S    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pTimer;            /* linked list of all active Timers */
S    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pCurrentTimer;     /* Actual expired timer which called callback */
S    OS_EXTERN OS_SADDR OS_RSEMA      * OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_SADDR OS_MAILBOX  * OS_pMailbox;
S    #endif
S    #if OS_DEBUG
S      OS_EXTERN OS_SADDR OS_CSEMA    * OS_pCSema;
S    #endif
S      OS_EXTERN OS_SADDR OS_MEMF      * OS_pMEMF;            /* linked list of all fixed size memory pools */
S      OS_EXTERN OS_SADDR OS_TICK_HOOK * OS_pTickHook;        /* linked list of all tick hook functions */
S
S  #else
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pTask;          /* linked list of all Tasks */
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pCurrentTask;   /* pointer to current Task */
S    OS_EXTERN OS_TASK    volatile * volatile OS_SADDR OS_pActiveTask;
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pTimer;         /* linked list of all active Timers */
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pCurrentTimer;  /* Actual expired timer which called callback */
S    OS_EXTERN OS_RSEMA            * OS_SADDR OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_MAILBOX        * OS_SADDR OS_pMailbox;
S    #endif
S    #if OS_DEBUG
S      OS_EXTERN OS_CSEMA          * OS_SADDR OS_pCSema;
S    #endif
S
S    OS_EXTERN OS_MEMF             * OS_SADDR OS_pMEMF;          /* linked list of all fixed size memory pools */
S    OS_EXTERN OS_TICK_HOOK        * OS_SADDR OS_pTickHook;      /* linked list of all tick hook functions */
S  #endif
S
N#endif  /*  OS_COMPILER_STORAGE_MODIFIER_LEFT  */
N
N/***** Mark end of memory pragma area *******************************/
N#if defined(__ghs_zda)
X#if 0L
S  #pragma ghs endzda
N#endif
N
N/********************************************************************/
N
N#define OS_RegionCnt OS_Counters.Cnt.Region
N#define OS_DICnt     OS_Counters.Cnt.DI
N
N/*********************************************************************
N*
N*       OS_CREATETASK macro
N*       OS_CREATETASK_EX macro
N*/
N#if OS_RR_SUPPORTED
X#if (1)
N  #define CTPARA_TIMESLICE ,2
N#else
S  #define CTPARA_TIMESLICE
N#endif
N
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack) \
N  OS_CreateTask (pTask,                                      \
N                  Name,                                      \
N                  Priority,                                  \
N                  Hook,                                      \
N                  (void OS_STACKPTR*)pStack,                 \
N                  sizeof(pStack)                             \
N                  CTPARA_TIMESLICE                           \
N               )
X  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack)   OS_CreateTask (pTask,                                                        Name,                                                        Priority,                                                    Hook,                                                        (void OS_STACKPTR*)pStack,                                   sizeof(pStack)                                               CTPARA_TIMESLICE                                          )
N#else
S  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack) \
S  OS_CreateTask (pTask,                                      \
S                  Priority,                                  \
S                  Hook,                                      \
S                  (void OS_STACKPTR*)pStack,                 \
S                  sizeof(pStack)                             \
S                  CTPARA_TIMESLICE                           \
S               )
X  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack)   OS_CreateTask (pTask,                                                        Priority,                                                    Hook,                                                        (void OS_STACKPTR*)pStack,                                   sizeof(pStack)                                               CTPARA_TIMESLICE                                          )
N#endif
N
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext) \
N  OS_CreateTaskEx  (pTask,                                                \
N                    Name,                                                 \
N                    Priority,                                             \
N                    Hook,                                                 \
N                    (void OS_STACKPTR*)pStack,                            \
N                    sizeof(pStack)                                        \
N                    CTPARA_TIMESLICE,                                     \
N                    pContext                                              \
N               )
X  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext)   OS_CreateTaskEx  (pTask,                                                                    Name,                                                                     Priority,                                                                 Hook,                                                                     (void OS_STACKPTR*)pStack,                                                sizeof(pStack)                                                            CTPARA_TIMESLICE,                                                         pContext                                                             )
N#else
S  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext) \
S  OS_CreateTaskEx  (pTask,                                                \
S                    Priority,                                             \
S                    Hook,                                                 \
S                    (void OS_STACKPTR*)pStack,                            \
S                    sizeof(pStack)                                        \
S                    CTPARA_TIMESLICE,                                     \
S                    pContext                                              \
S               )
X  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext)   OS_CreateTaskEx  (pTask,                                                                    Priority,                                                                 Hook,                                                                     (void OS_STACKPTR*)pStack,                                                sizeof(pStack)                                                            CTPARA_TIMESLICE,                                                         pContext                                                             )
N#endif
N
N/*********************************************************************
N*
N*       OS_CreateTask
N*       OS_CreateTaskEx
N*/
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATE_TASK_PARA_NAME      const char*Name,
N#else
S  #define OS_CREATE_TASK_PARA_NAME
N#endif
N
N#if OS_RR_SUPPORTED
X#if (1)
N  #define OS_CREATE_TASK_PARA_TS   ,OS_UINT TimeSlice
N#else
S  #define OS_CREATE_TASK_PARA_TS
N#endif
N
Nvoid OS_CreateTask  ( OS_TASK * pTask,
Xvoid OS_CreateTask_DP  ( OS_TASK * pTask,
N                      OS_CREATE_TASK_PARA_NAME
X                      const char*Name,
N                      OS_U8 Priority,
X                      unsigned char Priority,
N                      void (*pRoutine)(void),
N                      void OS_STACKPTR *pStack,
X                      void  *pStack,
N                      OS_UINT StackSize
X                      unsigned int StackSize
N                      OS_CREATE_TASK_PARA_TS
X                      ,unsigned int TimeSlice
N        );
Nvoid OS_CreateTaskEx  ( OS_TASK * pTask,
Xvoid OS_CreateTaskEx_DP  ( OS_TASK * pTask,
N                        OS_CREATE_TASK_PARA_NAME
X                        const char*Name,
N                        OS_U8 Priority,
X                        unsigned char Priority,
N                        void (*pRoutine)(void *),
N                        void OS_STACKPTR *pStack,
X                        void  *pStack,
N                        OS_UINT StackSize
X                        unsigned int StackSize
N                        OS_CREATE_TASK_PARA_TS,
X                        ,unsigned int TimeSlice,
N                        void * pContext
N        );
N#if OS_SUPPORT_SAVE_RESTORE_HOOK
X#if (1)
Nvoid OS_ExtendTaskContext(const OS_EXTEND_TASK_CONTEXT * pExtendContext);
N#endif
N/*********************************************************************
N*
N*       Task related routines
N*
N**********************************************************************
N*/
N
Nvoid  OS_Delay(OS_TIME ms);                /* OSKern.c              */
Xvoid  OS_Delay(int ms);                 
Nvoid  OS_DelayUntil(OS_TIME t);            /* OSKern.c              */
Xvoid  OS_DelayUntil(int t);             
NOS_U8 OS_GetSuspendCnt  (OS_TASK* pTask);  /* OS_GetSuspendCnt.c    */
Xunsigned char OS_GetSuspendCnt  (OS_TASK* pTask);   
Nvoid  OS_GetState       (OS_TASK* pTask);
Nchar  OS_IsTask         (OS_TASK* pTask);  /* OSIsTask.c            */
Nvoid  OS_Resume         (OS_TASK* pTask);  /* OS_Suspend.c          */
Nvoid  OS_SetTaskName    (OS_TASK * pTask, const char* s);
Nvoid  OS_SetPriority    (OS_TASK* pTask, OS_U8 Prio); /* OSSetP.c   */
Xvoid  OS_SetPriority    (OS_TASK* pTask, unsigned char Prio);  
Nvoid  OS_Suspend        (OS_TASK* pTask);  /* OS_Suspend.c          */
Nvoid  OS_Terminate      (OS_TASK* pTask);  /* OSTerm.c              */
Nvoid  OS_TerminateError (void);            /* OSTermE.c             */
Nvoid  OS_WakeTask       (OS_TASK* pTask);  /* OSWake.c              */
Nvoid  OS_Yield          (void);            /* OS_Yield              */
N
N#if OS_SUSPEND_TASK_ON_TERMINATE           /* Set task state of a terminated task to "suspended" */
X#if (0)            
S  #define OS_SUSPEND_TERMINATED_TASK(pTask) (pTask->Stat = 0x01)
N#else
N  #define OS_SUSPEND_TERMINATED_TASK(pTask)
N#endif
N
N/*********************************************************************
N*
N*       Info routines (OSInfo.c)
N*
N**********************************************************************
N*/
N
Nconst char* OS_GetCPU(void);
Nconst char* OS_GetLibMode(void);
Nconst char* OS_GetModel(void);
Nconst char* OS_GetLibName(void);
N
NOS_UINT OS_GetVersion(void);
Xunsigned int OS_GetVersion(void);
N#define OS_GetType() OS_GetLibMode()
N
N#define OS_TASKID OS_TASK *
N#define OS_GetTaskID() OS_pCurrentTask
N
N#define OS_GetpCurrentTask()    OS_pCurrentTask
N#define OS_GetpCurrentTimer()   OS_pCurrentTimer
N#define OS_GetpCurrentTimerEx() ((OS_TIMER_EX*)OS_pCurrentTimer)
N
N#if OS_TRACKNAME
X#if (1)
N  const char* OS_GetTaskName(OS_TASK *);
N#else
S  #define OS_GetTaskName(pt)  ("n/a")
N#endif
N
N#if OS_CHECKSTACK
X#if 1
N  void OS_CheckStack(void);              /* internal usage */
N  int  OS_GetStackSpace(OS_TASK * pTask);
N  int  OS_GetStackUsed (OS_TASK * pTask);
N  int  OS_GetStackSize (OS_TASK OS_TCBPTR * pTask);
X  int  OS_GetStackSize (OS_TASK  * pTask);
N  void OS_STACKPTR* OS_GetStackBase(OS_TASK OS_TCBPTR *pTask);
X  void * OS_GetStackBase(OS_TASK  *pTask);
N#else
S  #define OS_CheckStack()
S  #define OS_GetStackSpace(pt) 0
S  #define OS_GetStackUsed(pt)  0
S  #define OS_GetStackSize(pt)  0
S  #define OS_GetStackBase(pt)  0
N#endif
N
NOS_STACK_ADR OS_GetSysStackBase(void);  /* RTOS asm part */
Xunsigned int OS_GetSysStackBase(void);   
Nunsigned int OS_GetSysStackSize(void);  /* RTOS asm part */
NOS_STACK_ADR OS_GetIntStackBase(void);  /* RTOS asm part */
Xunsigned int OS_GetIntStackBase(void);   
Nunsigned int OS_GetIntStackSize(void);  /* RTOS asm part */
N
N#if OS_RR_SUPPORTED
X#if (1)
N  OS_U8 OS_SetTimeSlice(OS_TASK * pTask, OS_U8 TimeSlice);
X  unsigned char OS_SetTimeSlice(OS_TASK * pTask, unsigned char TimeSlice);
N  OS_U8 OS_GetTimeSliceRem(OS_TASK OS_TCBPTR * pTask);
X  unsigned char OS_GetTimeSliceRem(OS_TASK  * pTask);
N  #define OS_GetTimeSliceReload(pTask)  pTask->TimeSliceReload
N#else
S  #define OS_GetTimeSliceRem(pTask)     0
S  #define OS_GetTimeSliceReload(pTask)  0
N#endif
N
NOS_U8    OS_GetPriority(OS_TASK * pTask);  /* OS_GetPrio.c       */
Xunsigned char    OS_GetPriority(OS_TASK * pTask);   
N#define OS_GET_PRIORITY(pt) pt->Priority
N
Nint     OS_GetNumTasks(void);              /* OS_GetNumTasks.c   */
N
NOS_TASK* OS_TaskIndex2Ptr(int TaskIndex);  /* OS_TaskIndex2Ptr.c */
N
N#if OS_PROFILE >=1
X#if 1 >=1
N  OS_U32 OS_STAT_GetExecTime_Cycles (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetExecTime_Cycles (OS_TASK *pTask);   
N  int    OS_STAT_GetLoad            (OS_TASK *pTask);  /* OSStatGL.c */
N  void   OS_STAT_NotifyReadyStart   (OS_TASK *pTask);  /* OSStat.c   */
N  void   OS_STAT_Sample(void);                         /* OSStat.c   */
N#else
S  #define OS_STAT_NotifyExecEnd()
S  #define OS_STAT_GetExecTime_Cycles(pTask)   0
S  #define OS_STAT_GetLoad(pTask)              0
S  #define OS_STAT_Sample()
S  #define OS_STAT_SetClocksPerUnit(ClocksPerUnit)
S  #define OS_STAT_NOTIFYREADYSTART(pTask)
N#endif
N
N
N#if ((OS_PROFILE >= 1) || (OS_DEBUG > 0))  /* Also available in Debug build since V3.32b */
X#if ((1 >= 1) || (1 > 0))   
N  OS_U32 OS_STAT_GetNumActivations  (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetNumActivations  (OS_TASK *pTask);   
N  OS_U32 OS_STAT_GetNumPreemptions  (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetNumPreemptions  (OS_TASK *pTask);   
N#else
S  #define OS_STAT_GetNumActivations(pTask)    0
S  #define OS_STAT_GetNumPreemptions(pTask)    0
N#endif
N
N/*********************************************************************
N*
N*       Size info routines (OS_GetSize.c)
N*
N**********************************************************************
N*/
N
Nint OS_WAIT_OBJ_GetSize(void);
Nint OS_WAIT_OBJ_EX_GetSize(void);
Nint OS_WAIT_LIST_GetSize(void);
Nint OS_EXTEND_TASK_CONTEXT_GetSize(void);
Nint OS_TASK_GetSize(void);
Nint OS_REGS_GetSize(void);
Nint OS_TIMER_GetSize(void);
Nint OS_TIMER_EX_GetSize(void);
Nint OS_TICK_HOOK_GetSize(void);
Nint OS_RSEMA_GetSize(void);
Nint OS_CSEMA_GetSize(void);
Nint OS_MAILBOX_GetSize(void);
Nint OS_Q_GetSize(void);
Nint OS_MEMF_GetSize(void);
Nint OS_EVENT_GetSize(void);
Nint OS_TRACE_ENTRY_GetSize(void);
N
N/*********************************************************************
N*
N*       Critical regions (OsKern.c)
N*
N**********************************************************************
N*/
N
N#define OS_EnterRegion() {OS_RegionCnt++; }
Nvoid OS_LeaveRegion(void);
N
N/* Macro for OS_Leaveregion.
N   Main purposes:
N   - Used in OS-Kernel
N   - Offers the high speed variant (macro) instead of the function call
N*/
N
N#define OS_LEAVEREGION_STD()        \
N  if (--OS_RegionCnt == 0) {        \
N    OS_DI();                        \
N    if (OS_Pending) {               \
N      OS_RegionCnt = 1;             \
N      OS_Switch();                  \
N      OS_RegionCnt = 0;             \
N    }                               \
N    OS_RESTORE_I();                 \
N  }
X#define OS_LEAVEREGION_STD()          if (--OS_RegionCnt == 0) {            OS_DI();                            if (OS_Pending) {                     OS_RegionCnt = 1;                   OS_Switch();                        OS_RegionCnt = 0;                 }                                   OS_RESTORE_I();                   }
N
N#if OS_DEBUG
X#if 1
N #define OS_LEAVEREGION() \
N   if (!OS_RegionCnt) OS_Error(OS_ERR_LEAVEREGION_BEFORE_ENTERREGION); \
N   OS_LEAVEREGION_STD()
X #define OS_LEAVEREGION()    if (!OS_RegionCnt) OS_Error(OS_ERR_LEAVEREGION_BEFORE_ENTERREGION);    OS_LEAVEREGION_STD()
N#else
S  #define OS_LEAVEREGION()  OS_LEAVEREGION_STD()
N#endif
N
N/*********************************************************************
N*
N*       Interrupt save/disable/restore macros
N*
N**********************************************************************
N*/
N#define OS_IncDI()       { OS_ASSERT_DICnt(); OS_DI(); OS_DICnt++; }
N#define OS_DecRI()       { OS_ASSERT_DICnt(); if (--OS_DICnt==0) OS_EI(); }
N#define OS_RESTORE_I()   { OS_ASSERT_DICnt(); if (OS_DICnt==0)   OS_EI(); }
N
Nvoid OS_RestoreI(void);  /* OS_Kern.c */
N
N/*********************************************************************
N*
N*       ISR (Interrupt service routine) support
N*
N**********************************************************************
N*/
N
N#define RTOS_PPENDING           (1)     /*      Preemption  pending */
N#define RTOS_TSPENDING          (2)     /*      Task switch pending */
N#define RTOS_RRPENDING          (4)     /*      Round robin pending */
N
N
N#ifndef   OS_SUPPORT_INT_PRIORITY
S  #define OS_SUPPORT_INT_PRIORITY (1)
N#endif
N
N#if OS_SUPPORT_INT_PRIORITY
X#if (0)
S  #ifndef   OS_IPL_EI_DEFAULT
S    #error "Please define OS_IPL_EI_DEFAULT (OSChip.h)"
S  #endif
S
S  #ifndef   OS_IPL_DI_DEFAULT
S    #error "Please define OS_IPL_DI_DEFAULT (OSChip.h)"
S  #endif
S
S  #if OS_COMPILER_STORAGE_MODIFIER_LEFT
S    OS_EXTERN OS_SADDR unsigned int  OS_EXTERN_INIT(OS_Ipl_EI, OS_IPL_EI_DEFAULT);
S    OS_EXTERN OS_SADDR unsigned int  OS_EXTERN_INIT(OS_Ipl_DI, OS_IPL_DI_DEFAULT);
S  #else
S    OS_EXTERN unsigned int OS_SADDR  OS_EXTERN_INIT(OS_Ipl_EI, OS_IPL_EI_DEFAULT);
S    OS_EXTERN unsigned int OS_SADDR  OS_EXTERN_INIT(OS_Ipl_DI, OS_IPL_DI_DEFAULT);
S  #endif
N#endif
N
N#if OS_DEBUG
X#if 1
N  #define OS_MARK_IN_ISR()         {OS_InInt++;}
N  #define OS_MARK_OUTOF_ISR()      {if (!OS_InInt--) OS_Error(OS_ERR_LEAVEINT);}
N#else
S  #define OS_MARK_IN_ISR()
S  #define OS_MARK_OUTOF_ISR()
N#endif
N
N#if OS_SUPPORT_CALL_ISR            // Not allowed for some CPUs
X#if (1)            
Nvoid OS_CallISR        (void (*pRoutine)(void));
Nvoid OS_CallNestableISR(void (*pRoutine)(void));
N#endif
N
N#if (OS_SWITCH_FROM_INT_MODIFIES_STACK == 0) && (OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY != 0) && (OS_SCHEDULER_ACTIVATED_BY_EXCEPTION == 0)
X#if ((1) == 0) && ((0) != 0) && ((0) == 0)
S  //
S  // FOR CPUs without separate interrupt stack which do not disable interrupts on entry,
S  // OS_Enter- / Leave- Interrupt() is not defined.
S  // OS_CallISR() has to be used
S  //
N#else
N
N  #ifndef   OS_ENABLE_INTS_SAVE_IPL
N    #define OS_ENABLE_INTS_SAVE_IPL() OS_EI()
N  #endif
N
N  #ifndef   OS_RESTORE_IPL
N    #define OS_RESTORE_IPL()
N  #endif
N
N  #ifndef   OS_EI_ON_LEAVE
N    #define OS_EI_ON_LEAVE()        // Required for CPUs with do not restore DI-flag by RETI. Currently only CM3.
N  #endif
N
N  #if OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY
X  #if (0)
S    #define OS_DI_ON_ENTRY() OS_DI()
N  #else
N    #define OS_DI_ON_ENTRY()
N  #endif
N
N  #if OS_SWITCH_FROM_INT_MODIFIES_STACK
X  #if (1)
N    #define OS_HANDLE_REGION_CNT_ON_LI()                                          \
N      else {                                                                      \
N        OS_RegionCnt--;                                                           \
N      }
X    #define OS_HANDLE_REGION_CNT_ON_LI()                                                else {                                                                              OS_RegionCnt--;                                                                 }
N  #else
S    #define OS_HANDLE_REGION_CNT_ON_LI()                                          \
S      OS_RegionCnt--;
X    #define OS_HANDLE_REGION_CNT_ON_LI()                                                OS_RegionCnt--;
N  #endif
N
N
N  #define OS_SWITCH_FROM_INT_IF_REQUIRED()                                      \
N    if ((OS_RegionCnt == 1) && OS_Pending) {                                    \
N      OS_SwitchFromInt();                                                       \
N    }
X  #define OS_SWITCH_FROM_INT_IF_REQUIRED()                                          if ((OS_RegionCnt == 1) && OS_Pending) {                                          OS_SwitchFromInt();                                                           }
N
N  #define OS_EnterInterrupt() { \
N    OS_DI_ON_ENTRY();           \
N    OS_MARK_IN_ISR();           \
N    OS_RegionCnt++;             \
N    OS_DICnt++;                 \
N  }
X  #define OS_EnterInterrupt() {     OS_DI_ON_ENTRY();               OS_MARK_IN_ISR();               OS_RegionCnt++;                 OS_DICnt++;                   }
N
N  #define OS_LeaveInterrupt() {                                                 \
N    OS_MARK_OUTOF_ISR();                                                        \
N    OS_DICnt--; /* Must have been zero initially ! (We could put =0 instead) */ \
N    OS_SWITCH_FROM_INT_IF_REQUIRED()                                            \
N    OS_HANDLE_REGION_CNT_ON_LI();                                               \
N    OS_EI_ON_LEAVE();                                                           \
N  }
X  #define OS_LeaveInterrupt() {                                                     OS_MARK_OUTOF_ISR();                                                            OS_DICnt--;       OS_SWITCH_FROM_INT_IF_REQUIRED()                                                OS_HANDLE_REGION_CNT_ON_LI();                                                   OS_EI_ON_LEAVE();                                                             }
N
N  #define OS_LeaveInterruptNoSwitch() { \
N    OS_MARK_OUTOF_ISR();                \
N    OS_DICnt--;                         \
N    OS_RegionCnt--;                     \
N    OS_EI_ON_LEAVE();                   \
N  }
X  #define OS_LeaveInterruptNoSwitch() {     OS_MARK_OUTOF_ISR();                    OS_DICnt--;                             OS_RegionCnt--;                         OS_EI_ON_LEAVE();                     }
N
N  #define OS_EnterNestableInterrupt() { \
N    OS_MARK_IN_ISR();                   \
N    OS_RegionCnt++;                     \
N    OS_ENABLE_INTS_SAVE_IPL();          \
N  }
X  #define OS_EnterNestableInterrupt() {     OS_MARK_IN_ISR();                       OS_RegionCnt++;                         OS_ENABLE_INTS_SAVE_IPL();            }
N
N  #define OS_LeaveNestableInterrupt() {                                         \
N    OS_DI();                                                                    \
N    OS_MARK_OUTOF_ISR();                                                        \
N    OS_SWITCH_FROM_INT_IF_REQUIRED()                                            \
N    OS_HANDLE_REGION_CNT_ON_LI();                                               \
N    OS_RESTORE_IPL();                                                           \
N    OS_EI_ON_LEAVE();                                                           \
N  }
X  #define OS_LeaveNestableInterrupt() {                                             OS_DI();                                                                        OS_MARK_OUTOF_ISR();                                                            OS_SWITCH_FROM_INT_IF_REQUIRED()                                                OS_HANDLE_REGION_CNT_ON_LI();                                                   OS_RESTORE_IPL();                                                               OS_EI_ON_LEAVE();                                                             }
N
N  #define OS_LeaveNestableInterruptNoSwitch() { \
N    OS_DI();                                    \
N    OS_MARK_OUTOF_ISR();                        \
N    OS_RegionCnt--;                             \
N    OS_RESTORE_IPL();                           \
N    OS_EI_ON_LEAVE();                           \
N  }
X  #define OS_LeaveNestableInterruptNoSwitch() {     OS_DI();                                        OS_MARK_OUTOF_ISR();                            OS_RegionCnt--;                                 OS_RESTORE_IPL();                               OS_EI_ON_LEAVE();                             }
N#endif
N
N#ifndef OS_EnterIntStack
S  void OS__EnterIntStack(void);
S  #define OS_EnterIntStack() {OS_DI(); OS__EnterIntStack(); OS_RESTORE_I(); }
N#endif
N
N#ifndef OS_LeaveIntStack
S  void OS__LeaveIntStack(void);
S  #define OS_LeaveIntStack() {OS_DI(); OS__LeaveIntStack(); }
N#endif
N
Nvoid OS_SetFastIntPriorityLimit(OS_UINT Priority);
Xvoid OS_SetFastIntPriorityLimit(unsigned int Priority);
N
N/*********************************************************************
N*
N*       Resource semaphores
N*
N**********************************************************************
N*/
N
Nint      OS_Use             (OS_RSEMA * pRSema); /* OSRsem.c   */
Nvoid     OS_Unuse           (OS_RSEMA * pRSema); /* OSRsem.c   */
Nchar     OS_Request         (OS_RSEMA * pRSema); /* OSRsemRQ.c */
Nint      OS_GetSemaValue    (OS_RSEMA * pRSema); /* OSRSemGV.c */
NOS_TASK* OS_GetResourceOwner(OS_RSEMA * pRSema); /* OSRsemGO.c */
N
Nvoid     OS_CreateRSema     (OS_RSEMA * pRSema); /* OSRsem.c   */
Nvoid     OS_DeleteRSema     (OS_RSEMA * pRSema); /* OSDelRS.c  */
N
N#define  OS_CREATERSEMA(ps) OS_CreateRSema(ps)
N
N/*********************************************************************
N*
N*       Counting semaphores
N*
N**********************************************************************
N*/
N
Nvoid  OS_CreateCSema    (OS_CSEMA * pCSema, OS_UINT InitValue);  /* OSCSEM.c             */
Xvoid  OS_CreateCSema    (OS_CSEMA * pCSema, unsigned int InitValue);   
Nvoid  OS_DeleteCSema    (OS_CSEMA * pCSema);                     /* OSDELCS.c            */
Nint   OS_GetCSemaValue  (OS_CSEMA * pCSema);                     /* OSCSEMGV.c           */
NOS_U8 OS_SetCSemaValue  (OS_CSEMA * pCSema, OS_UINT value);      /* OS_SetCSemaValue.c   */
Xunsigned char OS_SetCSemaValue  (OS_CSEMA * pCSema, unsigned int value);       
Nvoid  OS_SignalCSema    (OS_CSEMA * pCSema);                     /* OSCSEM.c             */
Nvoid  OS_SignalCSemaMax (OS_CSEMA * pCSema, OS_UINT MaxValue);   /* OS_CSEMA_SignalMax.c */
Xvoid  OS_SignalCSemaMax (OS_CSEMA * pCSema, unsigned int MaxValue);    
Nvoid  OS_WaitCSema      (OS_CSEMA * pCSema);                     /* OSCSEM.c             */
Nint   OS_WaitCSemaTimed (OS_CSEMA * pCSema, OS_TIME TimeOut);    /* OSCSEMT.c            */
Xint   OS_WaitCSemaTimed (OS_CSEMA * pCSema, int TimeOut);     
Nchar  OS_CSemaRequest   (OS_CSEMA * pCSema);                     /* OSCSEMRQ.c           */
N
N#define OS_CREATECSEMA(ps) OS_CreateCSema(ps,0)
N
N/*********************************************************************
N*
N*       Mailboxes
N*
N**********************************************************************
N*/
N#define CREATEMB(MAILBOX, size, max, Buffer) OS_CreateMB(MAILBOX,size, max, Buffer);
Nvoid OS_CreateMB          (OS_MAILBOX * pMB, OS_U8 sizeofMsg, OS_UINT maxnofMsg, void* Buffer);    /* initialize mailbox */
Xvoid OS_CreateMB          (OS_MAILBOX * pMB, unsigned char sizeofMsg, unsigned int maxnofMsg, void* Buffer);     
Nvoid OS_ClearMB           (OS_MAILBOX * pMB);
Nvoid OS_PutMail           (OS_MAILBOX * pMB, void* pMail);
Nchar OS_PutMailCond       (OS_MAILBOX * pMB, void* pMail);
Nvoid OS_PutMailFront      (OS_MAILBOX * pMB, void* pMail);
Nchar OS_PutMailFrontCond  (OS_MAILBOX * pMB, void* pMail);
Nvoid OS_GetMail           (OS_MAILBOX * pMB, void* pDest);
Nchar OS_GetMailCond       (OS_MAILBOX * pMB, void* pDest);
Nvoid OS_PutMail1          (OS_MAILBOX * pMB, const char* pMail);
Nchar OS_PutMailCond1      (OS_MAILBOX * pMB, const char* pMail);
Nvoid OS_PutMailFront1     (OS_MAILBOX * pMB, const char* pMail);
Nchar OS_PutMailFrontCond1 (OS_MAILBOX * pMB, const char* pMail);
Nvoid OS_GetMail1          (OS_MAILBOX * pMB, char* pDest);
Nchar OS_GetMailCond1      (OS_MAILBOX * pMB, char* pDest);
Nchar OS_GetMailTimed      (OS_MAILBOX * pMB, void* pDest, OS_TIME Timeout);
Xchar OS_GetMailTimed      (OS_MAILBOX * pMB, void* pDest, int Timeout);
Nvoid OS_DeleteMB          (OS_MAILBOX * pMB);
Nvoid OS_WaitMail          (OS_MAILBOX * pMB);
N
N#if OS_DEBUG == 0
X#if 1 == 0
S  #define OS_GetMessageCnt(pMB) (*pMB).nofMsg
N#else
N  OS_UINT OS_GetMessageCnt(OS_MAILBOX * pMB);   /* get no. of available Messages */
X  unsigned int OS_GetMessageCnt(OS_MAILBOX * pMB);    
N#endif
N
N/*********************************************************************
N*
N*       Message Queues (OSQ.c)
N*
N**********************************************************************
N*/
N
Nvoid    OS_Q_Create       (OS_Q* pQ, void*pData, OS_UINT Size);
Xvoid    OS_Q_Create       (OS_Q* pQ, void*pData, unsigned int Size);
Nvoid    OS_Q_Clear        (OS_Q* pQ);                                /* OSQCL.c  */
Nint     OS_Q_GetMessageCnt(OS_Q* pQ);                                /* OSQGMC.c */
Nint     OS_Q_Put          (OS_Q* pQ, const void* pSrc, OS_UINT Size);
Xint     OS_Q_Put          (OS_Q* pQ, const void* pSrc, unsigned int Size);
Nint     OS_Q_GetPtr       (OS_Q* pQ, void**ppData);
Nint     OS_Q_GetPtrCond   (OS_Q* pQ, void**ppData);                  /* OSQGPC.c */
Nint     OS_Q_GetPtrTimed  (OS_Q* pQ, void**ppData, OS_TIME Timeout); /* OSQGPT.c */
Xint     OS_Q_GetPtrTimed  (OS_Q* pQ, void**ppData, int Timeout);  
Nvoid    OS_Q_Purge        (OS_Q* pQ);
N
N/*********************************************************************
N*
N*       Events
N*
N**********************************************************************
N*/
N
Nchar OS_ClearEvents          (OS_TASK * pTask);                 /* OSEVENCL.c  */
Nchar OS_GetEventsOccured     (OS_TASK * pTask);                 /* OSEVENGE.c  */
Nvoid OS_SignalEvent          (char Event, OS_TASK * pTask);     /* OSENENS.c   */
Nchar OS_WaitEvent            (char EventMask);                  /* OSEVENW.c   */
Nchar OS_WaitEventTimed       (char EventMask, OS_TIME TimeOut); /* OSEVENT.c   */
Xchar OS_WaitEventTimed       (char EventMask, int TimeOut);  
Nchar OS_WaitSingleEvent      (char EventMask);                  /* OSEVENWS.c  */
Nchar OS_WaitSingleEventTimed (char EventMask, OS_TIME TimeOut); /* OSEVENWST.c */
Xchar OS_WaitSingleEventTimed (char EventMask, int TimeOut);  
N
N/*********************************************************************
N*
N*       Timers(OSTIME.c)
N*
N**********************************************************************
N*/
N
N#ifdef OS_SIZEOF_INT
N  #if OS_SIZEOF_INT == 2
X  #if (4) == 2
S    #define OS_TIMER_MAX_TIME 0x7F00
N  #elif OS_SIZEOF_INT == 4
X  #elif (4) == 4
N    #define OS_TIMER_MAX_TIME 0x7FFFFF00
N  #else
S    #error "OS_SIZEOF_INT not correctly defined"
N  #endif
N#endif
N
Nvoid    OS_CreateTimer    (OS_TIMER * pTimer, OS_TIMERROUTINE* Callback, OS_TIME Timeout);
Xvoid    OS_CreateTimer    (OS_TIMER * pTimer, OS_TIMERROUTINE* Callback, int Timeout);
Nvoid    OS_RetriggerTimer (OS_TIMER * pTimer);
Nvoid    OS_StartTimer     (OS_TIMER * pTimer);
Nvoid    OS_StopTimer      (OS_TIMER * pTimer);
Nvoid    OS_DeleteTimer    (OS_TIMER * pTimer);                  /* OSTIMED.c  */
NOS_TIME OS_GetTimerPeriod (OS_TIMER * pTimer);                  /* OSTIMEGP.c */
Xint OS_GetTimerPeriod (OS_TIMER * pTimer);                   
NOS_U8   OS_GetTimerStatus (OS_TIMER * pTimer);                  /* OSTIMEGS.c */
Xunsigned char   OS_GetTimerStatus (OS_TIMER * pTimer);                   
NOS_TIME OS_GetTimerValue  (OS_TIMER * pTimer);                  /* OSTIMEGV.c */
Xint OS_GetTimerValue  (OS_TIMER * pTimer);                   
Nvoid    OS_SetTimerPeriod (OS_TIMER * pTimer, OS_TIME Period);  /* OSTIMES.c  */
Xvoid    OS_SetTimerPeriod (OS_TIMER * pTimer, int Period);   
N
N#define OS_CREATETIMER(pTimer,c,d)  \
N        OS_CreateTimer(pTimer,c,d); \
N        OS_StartTimer(pTimer);
X#define OS_CREATETIMER(pTimer,c,d)          OS_CreateTimer(pTimer,c,d);         OS_StartTimer(pTimer);
N
N/*********************************************************************
N*
N*       Extended timers (OSTIMERX.c)
N*
N**********************************************************************
N*/
Nvoid    OS_CreateTimerEx (OS_TIMER_EX * pTimerEx, OS_TIMER_EX_ROUTINE* Callback, OS_TIME Timeout, void * pData);
Xvoid    OS_CreateTimerEx (OS_TIMER_EX * pTimerEx, OS_TIMER_EX_ROUTINE* Callback, int Timeout, void * pData);
N
N#define OS_RetriggerTimerEx(pTimerEx)         OS_RetriggerTimer(&(pTimerEx)->Timer)
N#define OS_StartTimerEx(pTimerEx)             OS_StartTimer(&(pTimerEx)->Timer)
N#define OS_StopTimerEx(pTimerEx)              OS_StopTimer(&(pTimerEx)->Timer)
N#define OS_DeleteTimerEx(pTimerEx)            OS_DeleteTimer(&(pTimerEx)->Timer)
N#define OS_GetTimerPeriodEx(pTimerEx)         OS_GetTimerPeriod(&(pTimerEx)->Timer)
N#define OS_GetTimerStatusEx(pTimerEx)         OS_GetTimerStatus(&(pTimerEx)->Timer)
N#define OS_GetTimerValueEx(pTimerEx)          OS_GetTimerValue(&(pTimerEx)->Timer)
N#define OS_SetTimerPeriodEx(pTimerEx,Period)  OS_SetTimerPeriod(&(pTimerEx)->Timer, Period)
N
N#define OS_CREATETIMER_EX(pTimerEx,cb,Timeout,pData) \
N        OS_CreateTimerEx(pTimerEx,cb,Timeout,pData); \
N        OS_StartTimerEx(pTimerEx)
X#define OS_CREATETIMER_EX(pTimerEx,cb,Timeout,pData)         OS_CreateTimerEx(pTimerEx,cb,Timeout,pData);         OS_StartTimerEx(pTimerEx)
N
N/*********************************************************************
N*
N*       Heap type memory management (OS_Alloc.c)
N*
N**********************************************************************
N
N  This functions might not be implemented in all OS ports.
N  Therefore declaration depends on condition OS_SUPPORT_OS_ALLOC
N  which has to be defined in CPU specific part
N
N*/
N
N#if OS_SUPPORT_OS_ALLOC
X#if (1)
N  void* OS_malloc(unsigned int);
N  void  OS_free  (void* pMemBlock);
N  void* OS_realloc  (void* pMemBlock, unsigned NewSize);
N#endif
N
N/*********************************************************************
N*
N*       Fixed Block memory management
N*
N**********************************************************************
N*/
N
Nvoid  OS_MEMF_Create(OS_MEMF* pMEMF, void* pPool, OS_U16 NumBlocks, OS_U16 BlockSize);
Xvoid  OS_MEMF_Create(OS_MEMF* pMEMF, void* pPool, unsigned short NumBlocks, unsigned short BlockSize);
Nvoid  OS_MEMF_Delete(OS_MEMF* pMEMF);
Nvoid* OS_MEMF_Alloc(OS_MEMF* pMEMF, int Purpose);
Nvoid* OS_MEMF_AllocTimed(OS_MEMF* pMEMF, OS_TIME Timeout, int Purpose);
Xvoid* OS_MEMF_AllocTimed(OS_MEMF* pMEMF, int Timeout, int Purpose);
Nvoid* OS_MEMF_Request(OS_MEMF* pMEMF, int Purpose);
Nvoid  OS_MEMF_Release(OS_MEMF* pMEMF, void* pMemBlock);
Nvoid  OS_MEMF_FreeBlock(void* pMemBlock);
Nint   OS_MEMF_GetNumFreeBlocks(OS_MEMF* pMEMF);
Nchar  OS_MEMF_IsInPool(OS_MEMF* pMEMF, void* pMemBlock);
Nint   OS_MEMF_GetMaxUsed(OS_MEMF* pMEMF);
Nint   OS_MEMF_GetNumBlocks(OS_MEMF* pMEMF);
Nint   OS_MEMF_GetBlockSize(OS_MEMF* pMEMF);
N
N/*********************************************************************
N*
N*       Event object module
N*
N**********************************************************************
N*/
N
N/****** Simple OS_EVENT functions ************************************/
N
Nvoid  OS_EVENT_Create    (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Delete    (OS_EVENT* pEvent);
N
NOS_U8 OS_EVENT_Get       (OS_EVENT* pEvent);
Xunsigned char OS_EVENT_Get       (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Pulse     (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Reset     (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Set       (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Wait      (OS_EVENT* pEvent);
Nchar  OS_EVENT_WaitTimed (OS_EVENT* pEvent, OS_TIME Timeout);
Xchar  OS_EVENT_WaitTimed (OS_EVENT* pEvent, int Timeout);
N
N/*********************************************************************
N*
N*       Timing support (OSTiming.c)
N*
N**********************************************************************
N
N New in V3.04, but not yet documented to the end user. Great for
N run-time measurement.
N*/
N
N#define OS_TIMING OS_U32
Nvoid    OS_Timing_Start(OS_TIMING* pCycle);
Xvoid    OS_Timing_Start(unsigned int* pCycle);
Nvoid    OS_Timing_End(OS_TIMING* pCycle);
Xvoid    OS_Timing_End(unsigned int* pCycle);
NOS_U32  OS_Timing_Getus(OS_TIMING* pCycle);
Xunsigned int  OS_Timing_Getus(unsigned int* pCycle);
N#define OS_Timing_GetCycles(pPara) (*pPara)
N
N
N/*********************************************************************
N*
N*       OS Power control module OS_Power.c
N*
N**********************************************************************
N*/
N#if OS_SUPPORT_POWER
X#if (1)
N#define OS_POWER_LEVEL0  (0x0001)
N#define OS_POWER_LEVEL1  (0x0002)
N#define OS_POWER_LEVEL2  (0x0004)
N#define OS_POWER_LEVEL3  (0x0008)
N#define OS_POWER_LEVEL4  (0x0010)
N#define OS_POWER_LEVEL5  (0x0020)
N#define OS_POWER_LEVEL6  (0x0040)
N#define OS_POWER_LEVEL8  (0x0080)
N
Nvoid    OS_POWER_UsageInc(OS_UINT Level);
Xvoid    OS_POWER_UsageInc(unsigned int Level);
Nvoid    OS_POWER_UsageDec(OS_UINT Level);
Xvoid    OS_POWER_UsageDec(unsigned int Level);
NOS_UINT OS_POWER_GetMask(void);
Xunsigned int OS_POWER_GetMask(void);
N#endif
N
N/*********************************************************************
N*
N*       Advanced profiling support (Module OsKern.c)
N*
N**********************************************************************
N*/
N#if OS_PROFILE >= 1
X#if 1 >= 1
N  void OS_EnableProfiling(int Period);
N  #define OS_DisableProfiling() { OS_ProfilingOn=0; }
N#else
S  #define OS_EnableProfiling(Period);
S  #define OS_DisableProfiling()
N#endif
N
N/*********************************************************************
N*
N*       Configuration
N*
N**********************************************************************
N*/
N
N#define OS_CONFIG_FRACT(f, div)                    \
N  OS_TicksPerMS  = f/1000;                         \
N  OS_IntMSInc    = div*1000L/f;                    \
N  OS_IntTicksInc = div-(f/1000)*(div*1000L/f);
X#define OS_CONFIG_FRACT(f, div)                      OS_TicksPerMS  = f/1000;                           OS_IntMSInc    = div*1000L/f;                      OS_IntTicksInc = div-(f/1000)*(div*1000L/f);
N
N#define OS_CONFIG(f, div)     \
N  OS_IntMSInc    = div*1000L/f;
X#define OS_CONFIG(f, div)       OS_IntMSInc    = div*1000L/f;
N
N
N/*********************************************************************
N*
N*       Trace support (OSTrace.c)
N*
N**********************************************************************
N
NTrace support is enabled by defining OS_TRACE 1.
NThis is automatically done, when OS_LIBMODE_T is defined.
N
N*/
N
N#if OS_TRACE
X#if 0
S  /* Declare trace function prototypes */
S  void OS_TraceVoid (OS_U8 id);
S  void OS_TracePtr  (OS_U8 id, void* p);
S  void OS_TraceData (OS_U8 id, int v);
S  void OS_TraceDataPtr (OS_U8 id, int v, void*p);
S  void OS_TraceU32Ptr  (OS_U8 id, OS_U32 p0, void*p1);
S  void OS_TraceEnable(void);
S  void OS_TraceDisable(void);
S  void OS_TraceEnableAll(void);                              /* OSTrace1.c */
S  void OS_TraceDisableAll(void);                             /* OSTrace1.c */
S  void OS_TraceEnableId(OS_U8 id);                           /* OSTrace1.c */
S  void OS_TraceDisableId(OS_U8 id);                          /* OSTrace1.c */
S  void OS_TraceEnableFilterId(OS_U8 FilterIndex, OS_U8 id);  /* OSTrace1.c */
S  void OS_TraceDisableFilterId(OS_U8 FilterIndex, OS_U8 id); /* OSTrace1.c */
S
S  /* Trace function macros, used in API functions */
S  #define OS_TRACE_VOID(id)            OS_TraceVoid(id)
S  #define OS_TRACE_PTR(id, p)          OS_TracePtr(id, p)
S  #define OS_TRACE_DATA(id, v)         OS_TraceData(id, v)
S  #define OS_TRACE_DATA_PTR(id, v, p)  OS_TraceDataPtr(id, v, p)
S  #define OS_TRACE_U32_PTR(id, p0, p1) OS_TraceU32Ptr(id, p0, p1)
S
S  #define OS_TRACE_START()                    { OS_EnterRegion();                                }
S  #define OS_TRACE_START_VOID(id)             { OS_EnterRegion(); OS_TraceVoid(id);              }
S  #define OS_TRACE_START_PTR(id, p)           { OS_EnterRegion(); OS_TracePtr(id, p);            }
S  #define OS_TRACE_START_DATA(id, v)          { OS_EnterRegion(); OS_TraceData(id, v);           }
S  #define OS_TRACE_START_DATA_PTR(id, v, p)   { OS_EnterRegion(); OS_TraceDataPtr(id, v, p);     }
S  #define OS_TRACE_START_U32_PTR(id, p0, p1)  { OS_EnterRegion(); OS_TraceU32Ptr(id, u, p);      }
S  #define OS_TRACE_END()                      { OS_LeaveRegion();                                }
S
N#else
N  /* Replace trace functions by empty macros if trace is not enabled */
N  #define OS_TraceVoid(id)
N  #define OS_TracePtr(id, p)
N  #define OS_TraceData(id, v)
N  #define OS_TraceDataPtr(id, v, p)
N  #define OS_TraceU32Ptr(id, p0, p1)
N  #define OS_TraceEnable()
N  #define OS_TraceDisable()
N  #define OS_TraceEnableAll()
N  #define OS_TraceDisableAll()
N  #define OS_TraceEnableId(id)
N  #define OS_TraceDisableId(id)
N  #define OS_TraceEnableFilterId(FilterIndex, id)
N  #define OS_TraceDisableFilterId(FilterIndex, id)
N  /* Trace function macros, used in API functions. */
N  /* Expand to nothing if trace is disabled       */
N  #define OS_TRACE_VOID(id)
N  #define OS_TRACE_PTR(id, p)
N  #define OS_TRACE_DATA(id, v)
N  #define OS_TRACE_DATA_PTR(id, v, p)
N  #define OS_TRACE_U32_PTR(id, p0, p1)
N
N  #define OS_TRACE_START()
N  #define OS_TRACE_START_VOID(id)
N  #define OS_TRACE_START_PTR(id, p)
N  #define OS_TRACE_START_DATA(id, v)
N  #define OS_TRACE_START_DATA_PTR(id, v, p)
N  #define OS_TRACE_START_U32_PTR(id, p0, p1)
N  #define OS_TRACE_END()
N#endif
N
N/*********************************************************************
N*
N*        RTOSInit and misc.
N*
N**********************************************************************
N
NThe routines declared below are available on all targets.
N
N*/
N
N/* Routines in RTOSInit.c */
Nvoid   OS_InitHW(void);
Nvoid   OS_Idle(void);
NOS_U32 OS_ConvertCycles2us(OS_U32 Cycles);
Xunsigned int OS_ConvertCycles2us(unsigned int Cycles);
NOS_U32 OS_GetTime_Cycles(void);
Xunsigned int OS_GetTime_Cycles(void);
Nvoid   OS_COM_Init(void);
Nvoid   OS_COM_Send1(unsigned char c);
N
N/* Routines in OS_Error.c, delivered as source file */
Nvoid   OS_Error(int code);
N
NOS_INTERWORK void  OS_Start(void);                  /* RTOS ASM part   */
X void  OS_Start(void);                   
NOS_INTERWORK void  OS_Switch(void);                 /* RTOS ASM part   */
X void  OS_Switch(void);                  
NOS_INTERWORK int   OS_SwitchFromInt(void);          /* RTOS ASM part   */
X int   OS_SwitchFromInt(void);           
N
Nvoid  OS_InitKern(void);             /* OSKern.c        */
NOS_U8 OS_OnTx(void);                 /* OSComRxTx1.c, Returns 1 on last byte */
Xunsigned char OS_OnTx(void);                  
Nvoid  OS_OnRx(unsigned char c);      /* OSComRxTx1.c    */
Nvoid  OS_Send1(OS_U8 c);             /* not implemented */
Xvoid  OS_Send1(unsigned char c);              
Nvoid  OS_SendString(const char* s);  /* OSSend.c        */
NOS_RX_CALLBACK* OS_SetRxCallback(OS_RX_CALLBACK* cb);
NOS_U8 OS_EvaPacketEx(const OS_U8 * pSrc, OS_U16 SrcLen, OS_U8** pReturn);  /* OS_EvaPacketEx.c */
Xunsigned char OS_EvaPacketEx(const unsigned char * pSrc, unsigned short SrcLen, unsigned char** pReturn);   
N
Nvoid  OS_COM_ClearTxActive(void);    /* OSCom2.c */
N
N/*********************************************************************
N*
N*        RTOS misc. optional
N*
N**********************************************************************
N
NThe routines declared below are available on some targets
Nonly. (Because they do not make much sense on others)
N*/
N
N/* Timing routines. Their existance depends on the CPU. In general,
N  8-bit CPUs require both routines, where 16-bit CPUs require one
N  and 32-bit CPUs require none of these.
N*/
N#ifndef OS_GetTime
S  OS_TIME OS_GetTime(void);
N#endif
N#ifndef OS_GetTime32
S  #if (OS_SIZEOF_INT == 4)
S    #define OS_GetTime32() (OS_Time)
S  #else
S    OS_I32 OS_GetTime32(void);
S  #endif
N#endif
N
Nvoid OS__di(void);
Nvoid OS__ei(void);
Nvoid OS__SaveIPL(void);
Nvoid OS__RestIPL(void);
Nvoid OS_SIM_Init(void);
N
N/* Standard tick handler which increment OS time variable by one on each interrupt */
Nvoid OS_HandleTick(void);       /* New version of OS_TickHandler() without Enter- Leave-Interrupt    */
Nvoid OS_HandleTickDI(void);     /* OSTickDI.c */
N
N/* Non standard tick handler which increment the OS time variable by OS_IntMsInc once on each interrupt */
N/* One of these handler has to be used when OS_CONFIG() is used to set a tick increment unequal to 0    */
Nvoid OS_HandleTick_Ex(void);    /* OS_HandleTick_Ex.c */
Nvoid OS_HandleTickDI_Ex(void);  /* OSTickDI_Ex.c      */
N
Nvoid OS_AddTickHook(OS_TICK_HOOK* pHook, OS_TICK_HOOK_ROUTINE * pfUser);
Nvoid OS_RemoveTickHook(OS_TICK_HOOK* pHook);
N
N/* Routines for the PC-version running in native mode (non-windows) */
Nvoid OS_SetIntFreq(OS_UINT f);
Xvoid OS_SetIntFreq(unsigned int f);
Nvoid OS_Exit(int code);
Nvoid OS_UseDos(void);
Nvoid OS_UnuseDos(void);
Nint  OS_GetKey(void);
Nint  OS_WaitKey(void);
N
N/* Compatibility with manual */
N#define OS_CREATEMB          OS_CreateMB
N#define OS_GetUseCnt         OS_GetSemaValue
N#define OS_WaitCSema_Timed   OS_WaitCSemaTimed
N#define OS_WaitEvent_Timed   OS_WaitEventTimed
N
N/********************************************************************/
N
N#ifdef __cplusplus
S  }
N#endif
N
N#endif /* RTOS_H_INCLUDED */
N
N/*****  EOF  ********************************************************/
N
L 27 "Config\USBH_ConfigIO.c" 2
N
N/*********************************************************************
N*
N*       Defines, configurable
N*
N*       This section is normally the only section which requires changes on most embedded systems
N*/
N#define USE_DCC        0
N#define SHOW_TIME      1
N#define SHOW_TASK      1
N#define USE_EMBOS_VIEW 0
N
N#if USE_DCC
X#if 0
S  #include "JLINKDCC.h"
N#endif
N
N/*********************************************************************
N*
N*       _puts
N*
N*  Function description
N*    Local (static) replacement for puts.
N*    The reason why puts is not used is that puts always appends a NL character, which screws up our formatting.
N*/
Nstatic void _puts(const char * s) {
N  char c;
N
N#if USE_EMBOS_VIEW
X#if 0
S  OS_SendString(s);
N#else
N  for (;;) {
N    c = *s++;
N    if (c == 0) {
N      break;
N    }
N#if USE_DCC
X#if 0
S    JLINKDCC_SendChar(c);
N#else
N    putchar(c);
X    putc(c, (& __stdout));
N#endif
N  }
N#endif
N}
N
N/*********************************************************************
N*
N*       _WriteUnsigned
N*
N*  Function description
N*/
Nstatic char * _WriteUnsigned(char * s, U32 v, int NumDigits) {
Xstatic char * _WriteUnsigned(char * s, unsigned long v, int NumDigits) {
N  unsigned   Base;
N  unsigned   Div;
N  U32        Digit;
X  unsigned long        Digit;
N  Digit    = 1;
N  Base     = 10;
N  //
N  // Count how many digits are required
N  //
N  while (((v / Digit) >= Base) | (NumDigits-- > 1)) {
N    Digit *= Base;
N  }
N  //
N  // Output digits
N  //
N  do {
N    Div = v / Digit;
N    v  -= Div * Digit;
N    *s++ = (char)('0' + Div);
N    Digit /= Base;
N  } while (Digit);
N  *s = 0;
N  return s;
N}
N
N/*********************************************************************
N*
N*       _ShowStamp
N*
N*  Function description
N*/
Nstatic void _ShowStamp(void) {
N#if SHOW_TIME
X#if 1
N  I32    Time;
X  signed long    Time;
N  char   ac[20];
N  char * sBuffer = &ac[0];
N  Time           = OS_GetTime32();
X  Time           = (OS_Time);
N  sBuffer        = _WriteUnsigned(sBuffer, Time / 1000, 0);
N  *sBuffer++     = ':';
N  sBuffer        = _WriteUnsigned(sBuffer, Time % 1000, 3);
N  *sBuffer++     = ' ';
N  *sBuffer++     = 0;
N  _puts(ac);
N#endif
N
N#if SHOW_TASK
X#if 1
N{
N  const char * s;
N  s = OS_GetTaskName(OS_pCurrentTask);
N  if (s) {
N    _puts(s);
N    _puts(" - ");
N  }
N}
N#endif
N}
N
N/*********************************************************************
N*
N*       USBH_Panic
N*
N*  Function description
N*    Is called if the stack encounters a critical situation.
N*    In a release build, this function may not be linked in.
N*/
Nvoid USBH_Panic(const char * s) {
N  USBH_OS_DisableInterrupt();
N#if USBH_DEBUG > 1
X#if 2 > 1
N  _puts("*** Fatal error, System halted: ");
N  _puts(s);
N  _puts("\n");
N#endif
N  while (1);
N}
N
N/*********************************************************************
N*
N*       USBH_Log
N*
N*  Function description
N*    This function is called by the stack in debug builds with log output.
N*    In a release build, this function may not be linked in.
N*
N*  Notes
N*    (1)  Interrupts and task switches
N*         printf() has a reentrance problem on  alot of systems if interrupts are not disabled.
N*                  which would scramble strings if printf() called from an ISR interrupts an other printf.
N*         In order to avoid this problem, interrupts are disabled.
N*/
Nvoid USBH_Log(const char * s) {
N  USBH_OS_DisableInterrupt();
N  _ShowStamp();
N  _puts(s);
N  _puts("\n");
N  USBH_OS_EnableInterrupt();
N}
N
N/*********************************************************************
N*
N*       USBH_Warn
N*
N*  Function description
N*    This function is called by the stack in debug builds with log output.
N*    In a release build, this function may not be linked in.
N*
N*  Notes
N*    (1)  Interrupts and task switches
N*         See USBH_Log()
N*/
Nvoid USBH_Warn(const char * s) {
N  USBH_OS_DisableInterrupt();
N  _ShowStamp();
N  _puts("*** Warning *** ");
N  _puts(s);
N  _puts("\n");
N  USBH_OS_EnableInterrupt();
N}
N
N/********************************* EOF ******************************/
