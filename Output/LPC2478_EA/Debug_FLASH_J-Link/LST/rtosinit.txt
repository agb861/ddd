; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--thumb --list --debug -c --asm --interleave -o.\output\lpc2478_ea\debug_flash_j-link\obj\rtosinit.o --asm_dir=.\Output\LPC2478_EA\Debug_FLASH_J-Link\LST\ --list_dir=.\Output\LPC2478_EA\Debug_FLASH_J-Link\LST\ --depend=.\output\lpc2478_ea\debug_flash_j-link\obj\rtosinit.d --feedback=.\Output\LPC2478_EA\Debug_FLASH_J-Link\OBJ\Start_LPC2478_EA.fed --apcs=interwork -O0 -IApplication\SEGGERDEMO -IApplication\SEGGERDEMO\Src -ISetup -IInc -IConfig -IFS -IIP -IIP\IP_FS\FS_RO\Generated -IGUI -IOS -IUSB -IUSBH -I"C:\Program Files (x86)\Keil\V473\ARM\RV31\INC" -I"C:\Program Files (x86)\Keil\V473\ARM\CMSIS\Include" -I"C:\Program Files (x86)\Keil\V473\ARM\Inc\Philips" -DDEBUG=1 --omf_browse=.\output\lpc2478_ea\debug_flash_j-link\obj\rtosinit.crf Setup\RTOSInit.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _InitPLL PROC
;;;401    */
;;;402    static void _InitPLL(void) {
000000  48fe              LDR      r0,|L1.1020|
;;;403      if (_PLLSTAT & (1 << 25)) {
000002  6880              LDR      r0,[r0,#8]
000004  2101              MOVS     r1,#1
000006  0649              LSLS     r1,r1,#25
000008  4208              TST      r0,r1
00000a  d009              BEQ      |L1.32|
;;;404        _PLLCON  |= (1 << 1);
00000c  48fb              LDR      r0,|L1.1020|
00000e  6800              LDR      r0,[r0,#0]
000010  2102              MOVS     r1,#2
000012  4308              ORRS     r0,r0,r1
000014  49f9              LDR      r1,|L1.1020|
000016  6008              STR      r0,[r1,#0]
;;;405        _PLLFEED  = 0xAA;
000018  20aa              MOVS     r0,#0xaa
00001a  60c8              STR      r0,[r1,#0xc]
;;;406        _PLLFEED  = 0x55;
00001c  2055              MOVS     r0,#0x55
00001e  60c8              STR      r0,[r1,#0xc]
                  |L1.32|
;;;407      }
;;;408      _PLLCON     = 0;                         // Set PLL disabled and disconnected
000020  2000              MOVS     r0,#0
000022  49f6              LDR      r1,|L1.1020|
000024  6008              STR      r0,[r1,#0]
;;;409      _PLLFEED    = 0xAA;
000026  20aa              MOVS     r0,#0xaa
000028  60c8              STR      r0,[r1,#0xc]
;;;410      _PLLFEED    = 0x55;
00002a  2055              MOVS     r0,#0x55
00002c  60c8              STR      r0,[r1,#0xc]
;;;411    #if (OS_USE_INTERNAL_RC)
;;;412      _CLKSRCSEL  = 0;                         // Select internal RC oscillator 4 MHz as clock source
;;;413    #else
;;;414      _SCS        &= ~(1 << 4);                // The frequency range of the main oscillator is 1 MHz to 20 MHz.
00002e  48f4              LDR      r0,|L1.1024|
000030  6a00              LDR      r0,[r0,#0x20]
000032  2110              MOVS     r1,#0x10
000034  4388              BICS     r0,r0,r1
000036  49f2              LDR      r1,|L1.1024|
000038  6208              STR      r0,[r1,#0x20]
;;;415      _SCS        |=  (1 << 5);                // Main oscillator enable.
00003a  0008              MOVS     r0,r1
00003c  6a00              LDR      r0,[r0,#0x20]
00003e  2120              MOVS     r1,#0x20
000040  4308              ORRS     r0,r0,r1
000042  49ef              LDR      r1,|L1.1024|
000044  6208              STR      r0,[r1,#0x20]
;;;416      _CLKSRCSEL  = 1;                         // Select main oscillator 12 MHz as clock source
000046  2001              MOVS     r0,#1
000048  49ec              LDR      r1,|L1.1020|
00004a  3180              ADDS     r1,r1,#0x80
00004c  60c8              STR      r0,[r1,#0xc]
;;;417    #endif
;;;418      _PLLCFG     = (OS_PLL_MULTIPLIER - 1);   // MSEL: Multiplier - 1
00004e  200b              MOVS     r0,#0xb
000050  49ea              LDR      r1,|L1.1020|
000052  6048              STR      r0,[r1,#4]
;;;419      _PLLFEED    = 0xAA;
000054  20aa              MOVS     r0,#0xaa
000056  60c8              STR      r0,[r1,#0xc]
;;;420      _PLLFEED    = 0x55;
000058  2055              MOVS     r0,#0x55
00005a  60c8              STR      r0,[r1,#0xc]
;;;421      _PLLCON     = 1;                         // Enable PLL, Disconnect
00005c  2001              MOVS     r0,#1
00005e  6008              STR      r0,[r1,#0]
;;;422      _PLLFEED    = 0xAA;
000060  20aa              MOVS     r0,#0xaa
000062  60c8              STR      r0,[r1,#0xc]
;;;423      _PLLFEED    = 0x55;
000064  2055              MOVS     r0,#0x55
000066  60c8              STR      r0,[r1,#0xc]
;;;424      do {
000068  46c0              MOV      r8,r8
                  |L1.106|
;;;425      } while ((_PLLSTAT & (1 << 26)) == 0);   // Check PLOCK bit	
00006a  48e4              LDR      r0,|L1.1020|
00006c  6880              LDR      r0,[r0,#8]
00006e  2101              MOVS     r1,#1
000070  0689              LSLS     r1,r1,#26
000072  4208              TST      r0,r1
000074  d0f9              BEQ      |L1.106|
;;;426      _CPUCLKCFG  = 4;                         // Set CPU clock divider, value = Division ratio - 1)
000076  2004              MOVS     r0,#4
000078  49e0              LDR      r1,|L1.1020|
00007a  3180              ADDS     r1,r1,#0x80
00007c  6048              STR      r0,[r1,#4]
;;;427      _USBCLKCFG  = 5;                         // Set USB clock divider, value = Division ratio - 1)
00007e  2005              MOVS     r0,#5
000080  6088              STR      r0,[r1,#8]
;;;428    
;;;429      _PCLKSEL0   = _PCLKSEL_VALUE;
000082  48e0              LDR      r0,|L1.1028|
000084  49de              LDR      r1,|L1.1024|
000086  6288              STR      r0,[r1,#0x28]
;;;430      _PCLKSEL1   = _PCLKSEL_VALUE;
000088  62c8              STR      r0,[r1,#0x2c]
;;;431    
;;;432      _PLLCON     = (1 << 0) | (1 << 1);       // Enable PLL and select as clock source
00008a  2003              MOVS     r0,#3
00008c  49db              LDR      r1,|L1.1020|
00008e  6008              STR      r0,[r1,#0]
;;;433      _PLLFEED    =  0xAA;
000090  20aa              MOVS     r0,#0xaa
000092  60c8              STR      r0,[r1,#0xc]
;;;434      _PLLFEED    =  0x55;
000094  2055              MOVS     r0,#0x55
000096  60c8              STR      r0,[r1,#0xc]
;;;435    }
000098  4770              BX       lr
;;;436    
                          ENDP

                  OS_ARM_InstallISRHandler PROC
;;;970    */
;;;971    OS_ISR_HANDLER* OS_ARM_InstallISRHandler (int ISRIndex, OS_ISR_HANDLER* pISRHandler) {
00009a  b5f8              PUSH     {r3-r7,lr}
00009c  0004              MOVS     r4,r0
00009e  000e              MOVS     r6,r1
;;;972      OS_ISR_HANDLER*  pOldHandler;
;;;973      OS_ISR_HANDLER** papISR;
;;;974    
;;;975    #if DEBUG
;;;976      if ((unsigned)ISRIndex >= _NUM_INT_VECTORS) {
0000a0  2c20              CMP      r4,#0x20
0000a2  d306              BCC      |L1.178|
;;;977        OS_Error(OS_ERR_ISR_INDEX);
0000a4  2064              MOVS     r0,#0x64
0000a6  f7fffffe          BL       OS_Error
;;;978        return NULL;
0000aa  2000              MOVS     r0,#0
                  |L1.172|
;;;979      }
;;;980    #endif
;;;981      OS_DI();
;;;982      papISR = (OS_ISR_HANDLER**) &_VIC_VECT_0;
;;;983      pOldHandler          = *(papISR + ISRIndex);
;;;984      *(papISR + ISRIndex) = pISRHandler;
;;;985      OS_RestoreI();
;;;986      return pOldHandler;
;;;987    }
0000ac  bcf8              POP      {r3-r7}
0000ae  bc08              POP      {r3}
0000b0  4718              BX       r3
                  |L1.178|
0000b2  f7fffffe          BL       __ARM_common_disable_irq
0000b6  4dd4              LDR      r5,|L1.1032|
0000b8  00a0              LSLS     r0,r4,#2              ;983
0000ba  582f              LDR      r7,[r5,r0]            ;983
0000bc  00a0              LSLS     r0,r4,#2              ;984
0000be  502e              STR      r6,[r5,r0]            ;984
0000c0  f7fffffe          BL       OS_RestoreI
0000c4  0038              MOVS     r0,r7                 ;986
0000c6  e7f1              B        |L1.172|
;;;988    
                          ENDP

                  _Init_VIC PROC
;;;443    */
;;;444    static void _Init_VIC(void) {
0000c8  b510              PUSH     {r4,lr}
;;;445      int Index;
;;;446    
;;;447      _VIC_INTENABLECLEAR = 0xFFFFFFFF;            // Disable all source interrupts
0000ca  2000              MOVS     r0,#0
0000cc  43c0              MVNS     r0,r0
0000ce  0301              LSLS     r1,r0,#12
0000d0  6148              STR      r0,[r1,#0x14]
;;;448      _VIC_VECTORADDR     = 0;                     // Write to vector, reset VIC
0000d2  2000              MOVS     r0,#0
0000d4  1109              ASRS     r1,r1,#4
0000d6  6008              STR      r0,[r1,#0]
;;;449      for (Index = 0; Index < _NUM_INT_VECTORS; Index++) {
0000d8  2400              MOVS     r4,#0
0000da  e004              B        |L1.230|
                  |L1.220|
;;;450        OS_ARM_InstallISRHandler(Index, NULL);      // Set vector to 0;
0000dc  2100              MOVS     r1,#0
0000de  0020              MOVS     r0,r4
0000e0  f7fffffe          BL       OS_ARM_InstallISRHandler
0000e4  1c64              ADDS     r4,r4,#1              ;449
                  |L1.230|
0000e6  2c20              CMP      r4,#0x20              ;449
0000e8  dbf8              BLT      |L1.220|
;;;451      }
;;;452      _VIC_SOFTINTCLEAR   = 0xFFFFFFFF;            // Disable all soft interrupts
0000ea  2000              MOVS     r0,#0
0000ec  43c0              MVNS     r0,r0
0000ee  0301              LSLS     r1,r0,#12
0000f0  61c8              STR      r0,[r1,#0x1c]
;;;453      _VIC_INTSELECT      = 0;                     // Set all channels to generate IRQ
0000f2  2000              MOVS     r0,#0
0000f4  60c8              STR      r0,[r1,#0xc]
;;;454    }
0000f6  bc10              POP      {r4}
0000f8  bc08              POP      {r3}
0000fa  4718              BX       r3
;;;455    
                          ENDP

                  _OS_ISR_Tick PROC
;;;459    */
;;;460    static void _OS_ISR_Tick(void) {
0000fc  b510              PUSH     {r4,lr}
;;;461      _OS_TIM_IR = (1 << _OS_TIM_IR_BIT);  // Clear OS timer interrupt flag
0000fe  2001              MOVS     r0,#1
000100  49c2              LDR      r1,|L1.1036|
000102  6008              STR      r0,[r1,#0]
;;;462      OS_HandleTick();                     // Call OS tick handler
000104  f7fffffe          BL       OS_HandleTick
;;;463    #if DEBUG
;;;464      DCC_Process();
000108  f7fffffe          BL       JLINKDCC_Process
;;;465    #endif
;;;466    }
00010c  bc10              POP      {r4}
00010e  bc08              POP      {r3}
000110  4718              BX       r3
;;;467    
                          ENDP

                  _EMC_Init PROC
;;;474    */
;;;475    static void _EMC_Init(void) {
000112  b082              SUB      sp,sp,#8
;;;476      volatile unsigned long i;
;;;477      volatile unsigned long Dummy;
;;;478    
;;;479      _EMCCONTROL  = (1 << 0);    // EMC enable
000114  2001              MOVS     r0,#1
000116  49be              LDR      r1,|L1.1040|
000118  6008              STR      r0,[r1,#0]
;;;480      _PCONP      |= (1 << 11);   // Turn on EMC peripheral clock
00011a  48b8              LDR      r0,|L1.1020|
00011c  3040              ADDS     r0,r0,#0x40
00011e  6840              LDR      r0,[r0,#4]
000120  2101              MOVS     r1,#1
000122  02c9              LSLS     r1,r1,#11
000124  4308              ORRS     r0,r0,r1
000126  49b5              LDR      r1,|L1.1020|
000128  3140              ADDS     r1,r1,#0x40
00012a  6048              STR      r0,[r1,#4]
;;;481      _PINSEL4     = 0
00012c  2005              MOVS     r0,#5
00012e  0700              LSLS     r0,r0,#28
000130  49b8              LDR      r1,|L1.1044|
000132  6108              STR      r0,[r1,#0x10]
;;;482                     | (1 << 28)  // Reserved
;;;483                     | (1 << 30)  // Reserved
;;;484                     ;
;;;485    #if DATABUS_32BIT
;;;486      _PINSEL5     = 0
000134  48b8              LDR      r0,|L1.1048|
000136  6148              STR      r0,[r1,#0x14]
;;;487                     | (1 <<  0)  // CAS
;;;488                     | (1 <<  2)  // RAS
;;;489                     | (1 <<  4)  // CLKOUT0
;;;490                     | (1 <<  8)  // DYCS0
;;;491                     | (1 << 16)  // CKEOUT0
;;;492                     | (1 << 24)  // DQMOUT0
;;;493                     | (1 << 26)  // DQMOUT1
;;;494                     | (1 << 28)  // DQMOUT2
;;;495                     | (1 << 30)  // DQMOUT3
;;;496                     ;
;;;497      _PINSEL7     = 0
000138  48b2              LDR      r0,|L1.1028|
00013a  43c0              MVNS     r0,r0
00013c  61c8              STR      r0,[r1,#0x1c]
;;;498                     | (1 <<  0)  // D16
;;;499                     | (1 <<  2)  // D17
;;;500                     | (1 <<  4)  // D18
;;;501                     | (1 <<  6)  // D19
;;;502                     | (1 <<  8)  // D20
;;;503                     | (1 << 10)  // D21
;;;504                     | (1 << 12)  // D22
;;;505                     | (1 << 14)  // D23
;;;506                     | (1 << 16)  // D24
;;;507                     | (1 << 18)  // D25
;;;508                     | (1 << 20)  // D26
;;;509                     | (1 << 22)  // D27
;;;510                     | (1 << 24)  // D28
;;;511                     | (1 << 26)  // D29
;;;512                     | (1 << 28)  // D30
;;;513                     | (1 << 30)  // D31
;;;514                     ;
;;;515    #else
;;;516      _PINSEL5     = 0
;;;517                     | (1 <<  0)  // CAS
;;;518                     | (1 <<  2)  // RAS
;;;519                     | (1 <<  4)  // CLKOUT0
;;;520                     | (1 <<  6)  // CLKOUT1
;;;521                     | (1 <<  8)  // DYCS0
;;;522                     | (1 << 10)  // DYCS1
;;;523                     | (1 << 16)  // CKEOUT0
;;;524                     | (1 << 18)  // CKEOUT1
;;;525                     | (1 << 24)  // DQMOUT0
;;;526                     | (1 << 26)  // DQMOUT1
;;;527                     ;
;;;528    #endif
;;;529      _PINSEL6     = 0
00013e  6188              STR      r0,[r1,#0x18]
;;;530                     | (1 <<  0)  // D0
;;;531                     | (1 <<  2)  // D1
;;;532                     | (1 <<  4)  // D2
;;;533                     | (1 <<  6)  // D3
;;;534                     | (1 <<  8)  // D4
;;;535                     | (1 << 10)  // D5
;;;536                     | (1 << 12)  // D6
;;;537                     | (1 << 14)  // D7
;;;538                     | (1 << 16)  // D8
;;;539                     | (1 << 18)  // D9
;;;540                     | (1 << 20)  // D10
;;;541                     | (1 << 22)  // D11
;;;542                     | (1 << 24)  // D12
;;;543                     | (1 << 26)  // D13
;;;544                     | (1 << 28)  // D14
;;;545                     | (1 << 30)  // D15
;;;546                     ;
;;;547      _PINSEL8     = 0
000140  6208              STR      r0,[r1,#0x20]
;;;548                     | (1 <<  0)  // A0
;;;549                     | (1 <<  2)  // A1
;;;550                     | (1 <<  4)  // A2
;;;551                     | (1 <<  6)  // A3
;;;552                     | (1 <<  8)  // A4
;;;553                     | (1 << 10)  // A5
;;;554                     | (1 << 12)  // A6
;;;555                     | (1 << 14)  // A7
;;;556                     | (1 << 16)  // A8
;;;557                     | (1 << 18)  // A9
;;;558                     | (1 << 20)  // A10
;;;559                     | (1 << 22)  // A11
;;;560                     | (1 << 24)  // A12
;;;561                     | (1 << 26)  // A13
;;;562                     | (1 << 28)  // A14
;;;563                     | (1 << 30)  // A15
;;;564                     ;
;;;565      _PINSEL9     = 0
000142  48b6              LDR      r0,|L1.1052|
000144  6248              STR      r0,[r1,#0x24]
;;;566                     | (1 <<  0)  // A16
;;;567                     | (1 <<  2)  // A17
;;;568                     | (1 <<  4)  // A18
;;;569                     | (1 <<  6)  // A19
;;;570                     | (1 <<  8)  // A20
;;;571                     | (1 << 10)  // A21
;;;572                     | (1 << 12)  // A22
;;;573                     | (1 << 14)  // A23
;;;574                     | (1 << 16)  // OE
;;;575                     | (1 << 18)  // WE
;;;576                     | (1 << 20)  // BLS0
;;;577                     | (1 << 22)  // BLS1
;;;578                     | (1 << 28)  // CS0
;;;579                     | (1 << 30)  // P4.31 (NAND CE)
;;;580                     ;
;;;581    #if DATABUS_32BIT
;;;582      //
;;;583      // Set memory cycles
;;;584      //
;;;585      _EMCDYNAMIC_RP         = 1;
000146  2001              MOVS     r0,#1
000148  49b1              LDR      r1,|L1.1040|
00014a  6308              STR      r0,[r1,#0x30]
;;;586      _EMCDYNAMIC_RAS        = 3;
00014c  2003              MOVS     r0,#3
00014e  6348              STR      r0,[r1,#0x34]
;;;587      _EMCDYNAMIC_SREX       = 5;
000150  2005              MOVS     r0,#5
000152  6388              STR      r0,[r1,#0x38]
;;;588      _EMCDYNAMIC_APR        = 1;
000154  2001              MOVS     r0,#1
000156  63c8              STR      r0,[r1,#0x3c]
;;;589      _EMCDYNAMIC_DAL        = 5;
000158  2005              MOVS     r0,#5
00015a  49ad              LDR      r1,|L1.1040|
00015c  3140              ADDS     r1,r1,#0x40
00015e  6008              STR      r0,[r1,#0]
;;;590      _EMCDYNAMIC_WR         = 1;
000160  2001              MOVS     r0,#1
000162  6048              STR      r0,[r1,#4]
;;;591      _EMCDYNAMIC_RC         = 5;
000164  2005              MOVS     r0,#5
000166  6088              STR      r0,[r1,#8]
;;;592      _EMCDYNAMIC_RFC        = 5;
000168  60c8              STR      r0,[r1,#0xc]
;;;593      _EMCDYNAMIC_XSR        = 5;
00016a  6108              STR      r0,[r1,#0x10]
;;;594      _EMCDYNAMIC_RRD        = 1;
00016c  2001              MOVS     r0,#1
00016e  6148              STR      r0,[r1,#0x14]
;;;595      _EMCDYNAMIC_MRD        = 1;
000170  6188              STR      r0,[r1,#0x18]
;;;596      _EMCDYNAMIC_READCONFIG = 1;
000172  49a7              LDR      r1,|L1.1040|
000174  6288              STR      r0,[r1,#0x28]
;;;597    
;;;598      _EMCDYNAMIC_RASCAS0 = 0
000176  48aa              LDR      r0,|L1.1056|
000178  49aa              LDR      r1,|L1.1060|
00017a  6048              STR      r0,[r1,#4]
;;;599                            | (0x2 << 0)  // RAS latency, two CCLK cycles
;;;600                            | (0x2 << 8)  // CAS latency, two CCLK cycles
;;;601                            ;
;;;602      _EMCDYNAMIC_CONFIG0 = 0x5488;       // 128MB (8Mx16), 4 banks, row length = 12, column length = 9
00017c  48aa              LDR      r0,|L1.1064|
00017e  6008              STR      r0,[r1,#0]
;;;603    #else
;;;604      //
;;;605      // Set memory cycles
;;;606      //
;;;607      _EMCDYNAMIC_RP         = 2;
;;;608      _EMCDYNAMIC_RAS        = 3;
;;;609      _EMCDYNAMIC_SREX       = 7;
;;;610      _EMCDYNAMIC_APR        = 2;
;;;611      _EMCDYNAMIC_DAL        = 5;
;;;612      _EMCDYNAMIC_WR         = 1;
;;;613      _EMCDYNAMIC_RC         = 5;
;;;614      _EMCDYNAMIC_RFC        = 5;
;;;615      _EMCDYNAMIC_XSR        = 7;
;;;616      _EMCDYNAMIC_RRD        = 1;
;;;617      _EMCDYNAMIC_MRD        = 2;
;;;618      _EMCDYNAMIC_READCONFIG = 1;
;;;619    
;;;620      _EMCDYNAMIC_RASCAS0 = 0
;;;621                            | (0x3 << 0)  // RAS latency, three CCLK cycles
;;;622                            | (0x3 << 8)  // CAS latency, three CCLK cycles
;;;623                            ;
;;;624      _EMCDYNAMIC_CONFIG0 = 0x0680;       // 256MB (16Mx16), 4 banks, row length = 13, column length = 9
;;;625    #endif
;;;626      //
;;;627      // Delay at least 100 us
;;;628      //
;;;629      for (i = 0; i < 5000; i++) {        // Delay
000180  2000              MOVS     r0,#0
000182  9001              STR      r0,[sp,#4]
000184  e002              B        |L1.396|
                  |L1.390|
000186  9801              LDR      r0,[sp,#4]
000188  1c40              ADDS     r0,r0,#1
00018a  9001              STR      r0,[sp,#4]
                  |L1.396|
00018c  49a7              LDR      r1,|L1.1068|
00018e  9801              LDR      r0,[sp,#4]
000190  4288              CMP      r0,r1
000192  d3f8              BCC      |L1.390|
;;;630      }
;;;631      _EMCDYNAMIC_CONTROL = 0
000194  20ff              MOVS     r0,#0xff
000196  3084              ADDS     r0,r0,#0x84
000198  499d              LDR      r1,|L1.1040|
00019a  6208              STR      r0,[r1,#0x20]
;;;632                            | (1   << 0)  // Dynamic memory clock enable (CE), all clock enables are driven high continuously
;;;633                            | (1   << 1)  // Dynamic memory clock control (CS), CLKOUT runs continuously
;;;634                            | (0x3 << 7)  // Issue SDRAM NOP command
;;;635                            ;
;;;636      //
;;;637      // Delay at least 200 us
;;;638      //
;;;639      for (i = 0; i < 10000; i++) {       // Delay
00019c  2000              MOVS     r0,#0
00019e  9001              STR      r0,[sp,#4]
0001a0  e002              B        |L1.424|
                  |L1.418|
0001a2  9801              LDR      r0,[sp,#4]
0001a4  1c40              ADDS     r0,r0,#1
0001a6  9001              STR      r0,[sp,#4]
                  |L1.424|
0001a8  49a1              LDR      r1,|L1.1072|
0001aa  9801              LDR      r0,[sp,#4]
0001ac  4288              CMP      r0,r1
0001ae  d3f8              BCC      |L1.418|
;;;640      }
;;;641      _EMCDYNAMIC_CONTROL = 0
0001b0  20ff              MOVS     r0,#0xff
0001b2  3004              ADDS     r0,#4
0001b4  4996              LDR      r1,|L1.1040|
0001b6  6208              STR      r0,[r1,#0x20]
;;;642                            | (1 << 0)    // Dynamic memory clock enable (CE), all clock enables are driven high continuously
;;;643                            | (1 << 1)    // Dynamic memory clock control (CS), CLKOUT runs continuously
;;;644                            | (1 << 8)    // Issue SDRAM PALL (precharge all) command
;;;645                            ;
;;;646      _EMCDYNAMIC_REFRESH = 0x02;         // n x 16 CCLKs between SDRAM refresh cycles
0001b8  2002              MOVS     r0,#2
0001ba  6248              STR      r0,[r1,#0x24]
;;;647      //
;;;648      // Delay at least 100 us
;;;649      //
;;;650      for (i = 0; i < 5000; i++) {        // Delay
0001bc  2000              MOVS     r0,#0
0001be  9001              STR      r0,[sp,#4]
0001c0  e002              B        |L1.456|
                  |L1.450|
0001c2  9801              LDR      r0,[sp,#4]
0001c4  1c40              ADDS     r0,r0,#1
0001c6  9001              STR      r0,[sp,#4]
                  |L1.456|
0001c8  4998              LDR      r1,|L1.1068|
0001ca  9801              LDR      r0,[sp,#4]
0001cc  4288              CMP      r0,r1
0001ce  d3f8              BCC      |L1.450|
;;;651      }
;;;652      _EMCDYNAMIC_REFRESH = 0x1C;         // Set correct refresh period, n x 16 CCLKs between SDRAM refresh cycles
0001d0  201c              MOVS     r0,#0x1c
0001d2  498f              LDR      r1,|L1.1040|
0001d4  6248              STR      r0,[r1,#0x24]
;;;653      _EMCDYNAMIC_CONTROL = 0
0001d6  2083              MOVS     r0,#0x83
0001d8  6208              STR      r0,[r1,#0x20]
;;;654                            | (1 << 0)    // Dynamic memory clock enable (CE), all clock enables are driven high continuously
;;;655                            | (1 << 1)    // Dynamic memory clock control (CS), CLKOUT runs continuously
;;;656                            | (1 << 7)    // Issue SDRAM MODE command
;;;657                            ;
;;;658    #if DATABUS_32BIT
;;;659      Dummy = *((volatile unsigned long*)(SDRAM_BASE_ADDR | (0x22 << 11)));  //Set mode register in SDRAM
0001da  4896              LDR      r0,|L1.1076|
0001dc  6800              LDR      r0,[r0,#0]
0001de  9000              STR      r0,[sp,#0]
;;;660    #else
;;;661      Dummy = *((volatile unsigned long*)(SDRAM_BASE_ADDR | (0x33 << 12)));  //Set mode register in SDRAM
;;;662    #endif
;;;663      _EMCDYNAMIC_CONTROL  = 0x00;        // Issue SDRAM NORMAL operation command
0001e0  2000              MOVS     r0,#0
0001e2  6208              STR      r0,[r1,#0x20]
;;;664      _EMCDYNAMIC_CONFIG0 |= (1 << 19);   // Enable buffer
0001e4  488f              LDR      r0,|L1.1060|
0001e6  6800              LDR      r0,[r0,#0]
0001e8  2101              MOVS     r1,#1
0001ea  04c9              LSLS     r1,r1,#19
0001ec  4308              ORRS     r0,r0,r1
0001ee  498d              LDR      r1,|L1.1060|
0001f0  6008              STR      r0,[r1,#0]
;;;665      //
;;;666      // Initial system delay, at least 100 us
;;;667      //
;;;668      for (i = 0; i < (50 * 100); i++) { // Delay
0001f2  2000              MOVS     r0,#0
0001f4  9001              STR      r0,[sp,#4]
0001f6  e002              B        |L1.510|
                  |L1.504|
0001f8  9801              LDR      r0,[sp,#4]
0001fa  1c40              ADDS     r0,r0,#1
0001fc  9001              STR      r0,[sp,#4]
                  |L1.510|
0001fe  498b              LDR      r1,|L1.1068|
000200  9801              LDR      r0,[sp,#4]
000202  4288              CMP      r0,r1
000204  d3f8              BCC      |L1.504|
;;;669      }
;;;670      _EMCSTATIC_WAITWEN0  = 0x02;       // n + 1 CCLK cycle delay between assertion of chip select and write enable
000206  2002              MOVS     r0,#2
000208  498b              LDR      r1,|L1.1080|
00020a  6048              STR      r0,[r1,#4]
;;;671      _EMCSTATIC_WAITOEN0  = 0x02;       // n cycle delay.
00020c  6088              STR      r0,[r1,#8]
;;;672      _EMCSTATIC_WAITRD0   = 0x1F;       // 32 CCLK cycles for read accesses
00020e  201f              MOVS     r0,#0x1f
000210  60c8              STR      r0,[r1,#0xc]
;;;673      _EMCSTATIC_WAITPAGE0 = 0x1F;       // 32 CCLK cycle read access time
000212  6108              STR      r0,[r1,#0x10]
;;;674      _EMCSTATIC_WAITWR0   = 0x1F;       // 33 CCLK cycle write access time
000214  6148              STR      r0,[r1,#0x14]
;;;675      _EMCSTATIC_WAITTURN0 = 0x0F;       // 16 CCLK turnaround cycles
000216  200f              MOVS     r0,#0xf
000218  6188              STR      r0,[r1,#0x18]
;;;676      _EMCSTATIC_CONFIG0   = 0
00021a  2081              MOVS     r0,#0x81
00021c  6008              STR      r0,[r1,#0]
;;;677                             | (1 << 0)  // 16bit memory width
;;;678                             | (1 << 7)  // Bit lane state
;;;679                             ;
;;;680      _EMCSTATIC_WAITWEN1  = 0x02;       // n + 1 CCLK cycle delay between assertion of chip select and write enable
00021e  2002              MOVS     r0,#2
000220  6248              STR      r0,[r1,#0x24]
;;;681      _EMCSTATIC_WAITOEN1  = 0x02;       // n cycle delay.
000222  6288              STR      r0,[r1,#0x28]
;;;682      _EMCSTATIC_WAITRD1   = 0x08;       // n + 1 CCLK cycle delay
000224  2008              MOVS     r0,#8
000226  62c8              STR      r0,[r1,#0x2c]
;;;683      _EMCSTATIC_WAITPAGE1 = 0x1F;       // 32 CCLK cycle read access time
000228  201f              MOVS     r0,#0x1f
00022a  6308              STR      r0,[r1,#0x30]
;;;684      _EMCSTATIC_WAITWR1   = 0x08;       // n + 2 CCLK cycle write access time
00022c  2008              MOVS     r0,#8
00022e  6348              STR      r0,[r1,#0x34]
;;;685      _EMCSTATIC_WAITTURN1 = 0x0F;       // 16 CCLK turnaround cycles
000230  200f              MOVS     r0,#0xf
000232  6388              STR      r0,[r1,#0x38]
;;;686      _EMCSTATIC_CONFIG1   = (1 << 7);   // Bit lane state
000234  2080              MOVS     r0,#0x80
000236  6208              STR      r0,[r1,#0x20]
;;;687      //
;;;688      // Delay, at least 10 us
;;;689      //
;;;690      for (i = 0; i < (50 * 10); i++) {  // Delay
000238  2000              MOVS     r0,#0
00023a  9001              STR      r0,[sp,#4]
00023c  e002              B        |L1.580|
                  |L1.574|
00023e  9801              LDR      r0,[sp,#4]
000240  1c40              ADDS     r0,r0,#1
000242  9001              STR      r0,[sp,#4]
                  |L1.580|
000244  21ff              MOVS     r1,#0xff
000246  31f5              ADDS     r1,r1,#0xf5
000248  9801              LDR      r0,[sp,#4]
00024a  4288              CMP      r0,r1
00024c  d3f7              BCC      |L1.574|
;;;691      }
;;;692    }
00024e  b002              ADD      sp,sp,#8
000250  4770              BX       lr
;;;693    
                          ENDP

                  _DCC_OnTx PROC
;;;880    */
;;;881    static void _DCC_OnTx(unsigned Channel) {
000252  b510              PUSH     {r4,lr}
000254  0004              MOVS     r4,r0
;;;882      OS_OnTx();
000256  f7fffffe          BL       OS_OnTx
;;;883    }
00025a  bc10              POP      {r4}
00025c  bc08              POP      {r3}
00025e  4718              BX       r3
;;;884    
                          ENDP

                  _DCC_OnRx PROC
;;;872    */
;;;873    static void _DCC_OnRx(unsigned Channel, OS_U8 Data) {
000260  b570              PUSH     {r4-r6,lr}
000262  0005              MOVS     r5,r0
000264  000c              MOVS     r4,r1
;;;874      OS_OnRx(Data);
000266  0020              MOVS     r0,r4
000268  f7fffffe          BL       OS_OnRx
;;;875    }
00026c  bc70              POP      {r4-r6}
00026e  bc08              POP      {r3}
000270  4718              BX       r3
;;;876    
                          ENDP

                  OS_COM_Init PROC
;;;889    */
;;;890    void OS_COM_Init(void) {
000272  b510              PUSH     {r4,lr}
;;;891      JLINKDCC_SetpfOnRx(1, _DCC_OnRx);
000274  4971              LDR      r1,|L1.1084|
000276  2001              MOVS     r0,#1
000278  f7fffffe          BL       JLINKDCC_SetpfOnRx
;;;892      JLINKDCC_SetpfOnTx(1, _DCC_OnTx);
00027c  4970              LDR      r1,|L1.1088|
00027e  2001              MOVS     r0,#1
000280  f7fffffe          BL       JLINKDCC_SetpfOnTx
;;;893    }
000284  bc10              POP      {r4}
000286  bc08              POP      {r3}
000288  4718              BX       r3
;;;894    
                          ENDP

                  OS_ARM_ISRSetPrio PROC
;;;1024   */
;;;1025   int OS_ARM_ISRSetPrio(int ISRIndex, int Prio) {
00028a  b5f8              PUSH     {r3-r7,lr}
00028c  0004              MOVS     r4,r0
00028e  000f              MOVS     r7,r1
;;;1026     OS_U32* pPrio;
;;;1027     int     OldPrio;
;;;1028   #if DEBUG
;;;1029     if ((unsigned)ISRIndex >= _NUM_INT_VECTORS) {
000290  2c20              CMP      r4,#0x20
000292  d306              BCC      |L1.674|
;;;1030       OS_Error(OS_ERR_ISR_INDEX);
000294  2064              MOVS     r0,#0x64
000296  f7fffffe          BL       OS_Error
;;;1031       return 0;
00029a  2000              MOVS     r0,#0
                  |L1.668|
;;;1032     }
;;;1033   #endif
;;;1034     OS_DI();
;;;1035     pPrio = (OS_U32*) _VIC_PRIO_BASE_ADDR;
;;;1036     OldPrio = pPrio[ISRIndex];
;;;1037     pPrio[ISRIndex] = (OldPrio & ~_INT_PRIORITY_MASK) | (Prio & _INT_PRIORITY_MASK);
;;;1038     OS_RestoreI();
;;;1039     return OldPrio & _INT_PRIORITY_MASK;
;;;1040   }
00029c  bcf8              POP      {r3-r7}
00029e  bc08              POP      {r3}
0002a0  4718              BX       r3
                  |L1.674|
0002a2  f7fffffe          BL       __ARM_common_disable_irq
0002a6  4d67              LDR      r5,|L1.1092|
0002a8  00a0              LSLS     r0,r4,#2              ;1036
0002aa  582e              LDR      r6,[r5,r0]            ;1036
0002ac  0930              LSRS     r0,r6,#4              ;1037
0002ae  0100              LSLS     r0,r0,#4              ;1037
0002b0  0739              LSLS     r1,r7,#28             ;1037
0002b2  0f09              LSRS     r1,r1,#28             ;1037
0002b4  4308              ORRS     r0,r0,r1              ;1037
0002b6  00a1              LSLS     r1,r4,#2              ;1037
0002b8  5068              STR      r0,[r5,r1]            ;1037
0002ba  f7fffffe          BL       OS_RestoreI
0002be  0730              LSLS     r0,r6,#28             ;1039
0002c0  0f00              LSRS     r0,r0,#28             ;1039
0002c2  e7eb              B        |L1.668|
;;;1041   
                          ENDP

                  OS_ARM_EnableISR PROC
;;;992    */
;;;993    void OS_ARM_EnableISR(int ISRIndex) {
0002c4  b510              PUSH     {r4,lr}
0002c6  0004              MOVS     r4,r0
;;;994    #if DEBUG
;;;995      if ((unsigned)ISRIndex >= _NUM_INT_VECTORS) {
0002c8  2c20              CMP      r4,#0x20
0002ca  d305              BCC      |L1.728|
;;;996        OS_Error(OS_ERR_ISR_INDEX);
0002cc  2064              MOVS     r0,#0x64
0002ce  f7fffffe          BL       OS_Error
                  |L1.722|
;;;997        return;
;;;998      }
;;;999    #endif
;;;1000     OS_DI();
;;;1001     _VIC_INTENABLE = (1UL << ISRIndex);
;;;1002     OS_RestoreI();
;;;1003   }
0002d2  bc10              POP      {r4}
0002d4  bc08              POP      {r3}
0002d6  4718              BX       r3
                  |L1.728|
0002d8  f7fffffe          BL       __ARM_common_disable_irq
0002dc  2001              MOVS     r0,#1                 ;1001
0002de  40a0              LSLS     r0,r0,r4              ;1001
0002e0  4959              LDR      r1,|L1.1096|
0002e2  6108              STR      r0,[r1,#0x10]         ;1001
0002e4  f7fffffe          BL       OS_RestoreI
0002e8  46c0              MOV      r8,r8
0002ea  e7f2              B        |L1.722|
;;;1004   
                          ENDP

                  OS_InitHW PROC
;;;708    */
;;;709    void OS_InitHW(void) {
0002ec  b510              PUSH     {r4,lr}
;;;710      OS_DI();
0002ee  f7fffffe          BL       __ARM_common_disable_irq
;;;711      _Init_VIC();                   // Initialize VIC, clear and disable all interrupts
0002f2  f7fffffe          BL       _Init_VIC
;;;712      // Initialize timer for OS
;;;713      _PCONP      |=  (1 << _TIMER_PCONP_BIT);   // Enable Clock for OS timer
0002f6  4841              LDR      r0,|L1.1020|
0002f8  3040              ADDS     r0,r0,#0x40
0002fa  6840              LDR      r0,[r0,#4]
0002fc  2102              MOVS     r1,#2
0002fe  4308              ORRS     r0,r0,r1
000300  493e              LDR      r1,|L1.1020|
000302  3140              ADDS     r1,r1,#0x40
000304  6048              STR      r0,[r1,#4]
;;;714      _OS_TIM_TCR &= ~(1 << 0);                  // Disable timer
000306  4841              LDR      r0,|L1.1036|
000308  6840              LDR      r0,[r0,#4]
00030a  0840              LSRS     r0,r0,#1
00030c  0040              LSLS     r0,r0,#1
00030e  493f              LDR      r1,|L1.1036|
000310  6048              STR      r0,[r1,#4]
;;;715      _OS_TIM_IR   =  (1 << _OS_TIM_IR_BIT);     // Clear OS timer interrupt flag
000312  2001              MOVS     r0,#1
000314  6008              STR      r0,[r1,#0]
;;;716      _OS_TIM_PR   = 0;                          // Count on every pclk
000316  2000              MOVS     r0,#0
000318  60c8              STR      r0,[r1,#0xc]
;;;717      _OS_TIM_MR0  = _OS_TIMER_INTERVAL - 1;     // Initialize match register 1
00031a  484c              LDR      r0,|L1.1100|
00031c  6188              STR      r0,[r1,#0x18]
;;;718      _OS_TIM_MCR  =  (1 << 0)                   // Interrupt on match channel 0
00031e  2003              MOVS     r0,#3
000320  6148              STR      r0,[r1,#0x14]
;;;719                    | (1 << 1);                  // Counter reset on match channel 0
;;;720      _OS_TIM_TC   =  0;                         // Clear counter
000322  2000              MOVS     r0,#0
000324  6088              STR      r0,[r1,#8]
;;;721      _OS_TIM_TCR |=  (1 << 0);                  // Enable timer
000326  0008              MOVS     r0,r1
000328  6840              LDR      r0,[r0,#4]
00032a  2101              MOVS     r1,#1
00032c  4308              ORRS     r0,r0,r1
00032e  4937              LDR      r1,|L1.1036|
000330  6048              STR      r0,[r1,#4]
;;;722      // Setup interrupt controller
;;;723      OS_ARM_InstallISRHandler(_OS_TIMER_INT_INDEX, &_OS_ISR_Tick); // Timer/counter interrupt vector.
000332  4947              LDR      r1,|L1.1104|
000334  2004              MOVS     r0,#4
000336  f7fffffe          BL       OS_ARM_InstallISRHandler
;;;724      OS_ARM_EnableISR(_OS_TIMER_INT_INDEX);                        // Enable timer/counter 0 interrupt.
00033a  2004              MOVS     r0,#4
00033c  f7fffffe          BL       OS_ARM_EnableISR
;;;725      OS_ARM_ISRSetPrio(_OS_TIMER_INT_INDEX, 15);                   // lowest priority
000340  210f              MOVS     r1,#0xf
000342  2004              MOVS     r0,#4
000344  f7fffffe          BL       OS_ARM_ISRSetPrio
;;;726      // optionally initialize UART for OSView
;;;727      OS_COM_Init();
000348  f7fffffe          BL       OS_COM_Init
;;;728      OS_RestoreI();
00034c  f7fffffe          BL       OS_RestoreI
;;;729    }
000350  bc10              POP      {r4}
000352  bc08              POP      {r3}
000354  4718              BX       r3
;;;730    
                          ENDP

                  OS_Idle PROC
;;;742    */
;;;743    void OS_Idle(void) {     // Idle loop: No task is ready to exec
000356  46c0              MOV      r8,r8
                  |L1.856|
;;;744      while (1) {
000358  e7fe              B        |L1.856|
;;;745      }
;;;746    }
;;;747    
                          ENDP

                  OS_GetTime_Cycles PROC
;;;755    */
;;;756    OS_U32 OS_GetTime_Cycles(void) {
00035a  482c              LDR      r0,|L1.1036|
;;;757      OS_U32 time;
;;;758      OS_U32 count;
;;;759    
;;;760      count = _OS_TIM_TC;                               // Read current timer value
00035c  6882              LDR      r2,[r0,#8]
;;;761      time  = OS_GetTime32();                           // Read current OS time
00035e  483d              LDR      r0,|L1.1108|
000360  6801              LDR      r1,[r0,#0]  ; OS_Time
;;;762      if ((_OS_TIM_IR & (1 << _OS_TIM_IR_BIT)) != 0) {  // Timer Interrupt pending ?
000362  482a              LDR      r0,|L1.1036|
000364  6800              LDR      r0,[r0,#0]
000366  07c0              LSLS     r0,r0,#31
000368  0fc0              LSRS     r0,r0,#31
00036a  d002              BEQ      |L1.882|
;;;763        time++;                                         // Adjust result, read timer again
00036c  1c49              ADDS     r1,r1,#1
;;;764        count = _OS_TIM_TC;                             // Read again
00036e  4827              LDR      r0,|L1.1036|
000370  6882              LDR      r2,[r0,#8]
                  |L1.882|
;;;765      }
;;;766      return (_OS_TIMER_INTERVAL) * time + count;
000372  20e1              MOVS     r0,#0xe1
000374  01c0              LSLS     r0,r0,#7
000376  4348              MULS     r0,r1,r0
000378  1880              ADDS     r0,r0,r2
;;;767    }
00037a  4770              BX       lr
;;;768    
                          ENDP

                  OS_COM_Send1 PROC
;;;899    */
;;;900    void OS_COM_Send1(OS_U8 c) {
00037c  b510              PUSH     {r4,lr}
00037e  0004              MOVS     r4,r0
;;;901      JLINKDCC_SendCharOnChannelNB(1, c);
000380  0021              MOVS     r1,r4
000382  2001              MOVS     r0,#1
000384  f7fffffe          BL       JLINKDCC_SendCharOnChannelNB
;;;902    }
000388  bc10              POP      {r4}
00038a  bc08              POP      {r3}
00038c  4718              BX       r3
;;;903    
                          ENDP

                  _OS_ISR_Undefined PROC
;;;933    */
;;;934    static void _OS_ISR_Undefined(void) {
00038e  b081              SUB      sp,sp,#4
;;;935      #if (OS_IGNORE_UNDEFINED_INTERRUPT == 0)
;;;936        volatile OS_U32 Dummy;
;;;937    
;;;938        Dummy = 1;
000390  2001              MOVS     r0,#1
000392  9000              STR      r0,[sp,#0]
;;;939        /* You may set a breakpoint here to detect undefined interrupts */
;;;940        while (Dummy > 0) {
000394  46c0              MOV      r8,r8
                  |L1.918|
000396  9800              LDR      r0,[sp,#0]
000398  2800              CMP      r0,#0
00039a  d1fc              BNE      |L1.918|
;;;941        }
;;;942      #endif
;;;943    }
00039c  b001              ADD      sp,sp,#4
00039e  4770              BX       lr
;;;944    
                          ENDP

                  OS_irq_handler PROC
;;;952    */
;;;953    OS_INTERWORK void OS_irq_handler(void) {
0003a0  b510              PUSH     {r4,lr}
;;;954      OS_ISR_HANDLER* pISR;
;;;955      pISR = (OS_ISR_HANDLER*) _VIC_VECTORADDR;   // Get current interrupt handler
0003a2  20ff              MOVS     r0,#0xff
0003a4  43c0              MVNS     r0,r0
0003a6  6804              LDR      r4,[r0,#0]
;;;956      OS_EnterNestableInterrupt();                // Now interrupts may be reenabled. If nesting should be allowed
0003a8  482b              LDR      r0,|L1.1112|
0003aa  7800              LDRB     r0,[r0,#0]  ; OS_InInt
0003ac  1c40              ADDS     r0,r0,#1
0003ae  492a              LDR      r1,|L1.1112|
0003b0  7008              STRB     r0,[r1,#0]
0003b2  482a              LDR      r0,|L1.1116|
0003b4  7800              LDRB     r0,[r0,#0]  ; OS_Counters
0003b6  1c40              ADDS     r0,r0,#1
0003b8  4928              LDR      r1,|L1.1116|
0003ba  7008              STRB     r0,[r1,#0]
0003bc  f7fffffe          BL       __ARM_common_enable_irq
;;;957      if (pISR != NULL) {
0003c0  2c00              CMP      r4,#0
0003c2  d002              BEQ      |L1.970|
;;;958        pISR();                                   // Call installed interrupt service routine
0003c4  f7fffffe          BL       __ARM_common_call_via_r4
0003c8  e001              B        |L1.974|
                  |L1.970|
;;;959      } else {
;;;960        _OS_ISR_Undefined();
0003ca  f7fffffe          BL       _OS_ISR_Undefined
                  |L1.974|
;;;961      }
;;;962      OS_DI();                                    // Disable interrupts and unlock
0003ce  f7fffffe          BL       __ARM_common_disable_irq
;;;963      _VIC_VECTORADDR = 0;                        // Clear current interrupt pending condition, reset VIC
0003d2  2000              MOVS     r0,#0
0003d4  21ff              MOVS     r1,#0xff
0003d6  43c9              MVNS     r1,r1
0003d8  6008              STR      r0,[r1,#0]
;;;964      OS_LeaveNestableInterrupt();                // Replace by OS_LeaveInterrupt(), when nesting was disabled
0003da  f7fffffe          BL       __ARM_common_disable_irq
0003de  481e              LDR      r0,|L1.1112|
0003e0  7801              LDRB     r1,[r0,#0]  ; OS_InInt
0003e2  7800              LDRB     r0,[r0,#0]  ; OS_InInt
0003e4  1e40              SUBS     r0,r0,#1
0003e6  4a1c              LDR      r2,|L1.1112|
0003e8  7010              STRB     r0,[r2,#0]
0003ea  2900              CMP      r1,#0
0003ec  d102              BNE      |L1.1012|
0003ee  2098              MOVS     r0,#0x98
0003f0  f7fffffe          BL       OS_Error
                  |L1.1012|
0003f4  4819              LDR      r0,|L1.1116|
0003f6  7800              LDRB     r0,[r0,#0]  ; OS_Counters
0003f8  2801              CMP      r0,#1
0003fa  e031              B        |L1.1120|
                  |L1.1020|
                          DCD      0xe01fc080
                  |L1.1024|
                          DCD      0xe01fc180
                  |L1.1028|
                          DCD      0xaaaaaaaa
                  |L1.1032|
                          DCD      0xfffff100
                  |L1.1036|
                          DCD      0xe0004000
                  |L1.1040|
                          DCD      0xffe08000
                  |L1.1044|
                          DCD      0xe002c000
                  |L1.1048|
                          DCD      0x55010115
                  |L1.1052|
                          DCD      0x50555555
                  |L1.1056|
                          DCD      0x00000202
                  |L1.1060|
                          DCD      0xffe08100
                  |L1.1064|
                          DCD      0x00005488
                  |L1.1068|
                          DCD      0x00001388
                  |L1.1072|
                          DCD      0x00002710
                  |L1.1076|
                          DCD      0xa0011000
                  |L1.1080|
                          DCD      0xffe08200
                  |L1.1084|
                          DCD      _DCC_OnRx
                  |L1.1088|
                          DCD      _DCC_OnTx
                  |L1.1092|
                          DCD      0xfffff200
                  |L1.1096|
                          DCD      0xfffff000
                  |L1.1100|
                          DCD      0x0000707f
                  |L1.1104|
                          DCD      _OS_ISR_Tick
                  |L1.1108|
                          DCD      OS_Time
                  |L1.1112|
                          DCD      OS_InInt
                  |L1.1116|
                          DCD      OS_Counters
                  |L1.1120|
000460  d106              BNE      |L1.1136|
000462  480f              LDR      r0,|L1.1184|
000464  7800              LDRB     r0,[r0,#0]  ; OS_Pending
000466  2800              CMP      r0,#0
000468  d002              BEQ      |L1.1136|
00046a  f7fffffe          BL       OS_SwitchFromInt
00046e  e004              B        |L1.1146|
                  |L1.1136|
000470  480c              LDR      r0,|L1.1188|
000472  7800              LDRB     r0,[r0,#0]  ; OS_Counters
000474  1e40              SUBS     r0,r0,#1
000476  490b              LDR      r1,|L1.1188|
000478  7008              STRB     r0,[r1,#0]
                  |L1.1146|
;;;965    }
00047a  bc10              POP      {r4}
00047c  bc08              POP      {r3}
00047e  4718              BX       r3
;;;966    
                          ENDP

                  __low_level_init PROC
;;;1050   OS_INTERWORK int __low_level_init(void);       /* Avoid "No prototype" warning */
;;;1051   OS_INTERWORK int __low_level_init(void) {
000480  b510              PUSH     {r4,lr}
;;;1052     #if OS_INIT_PLL
;;;1053       _InitPLL();
000482  f7fffffe          BL       _InitPLL
;;;1054     #endif
;;;1055     #if OS_INIT_MAM                // Speedup CPU
;;;1056       _MAMCR  = 0x00;              // Disable Memory accelerator module
000486  2000              MOVS     r0,#0
000488  4907              LDR      r1,|L1.1192|
00048a  6008              STR      r0,[r1,#0]
;;;1057       _MAMTIM = _OS_MAMTIM_VALUE;  // Depends on OS_FSYS
00048c  2005              MOVS     r0,#5
00048e  6048              STR      r0,[r1,#4]
;;;1058       _MAMCR  = 0x01;              // Enable Memory accelerator module partially , refer to [1], MAM.1 operation
000490  2001              MOVS     r0,#1
000492  6008              STR      r0,[r1,#0]
;;;1059     #endif
;;;1060     //
;;;1061     // Init SDRAM, NAND- and NOR-flash
;;;1062     //
;;;1063     _EMC_Init();
000494  f7fffffe          BL       _EMC_Init
;;;1064   
;;;1065     return 1;                      // Always initialize segments !
000498  2001              MOVS     r0,#1
;;;1066   };
00049a  bc10              POP      {r4}
00049c  bc08              POP      {r3}
00049e  4718              BX       r3
;;;1067   
                          ENDP

                  |L1.1184|
                          DCD      OS_Pending
                  |L1.1188|
                          DCD      OS_Counters
                  |L1.1192|
                          DCD      0xe01fc000

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.2||, ||.text||
                  OS_ConvertCycles2us PROC
;;;401    */
;;;402    static void _InitPLL(void) {
000000  b510              PUSH     {r4,lr}
;;;403      if (_PLLSTAT & (1 << 25)) {
000002  0004              MOVS     r4,r0
000004  211c              MOVS     r1,#0x1c
000006  0020              MOVS     r0,r4
000008  f7fffffe          BL       __aeabi_uidivmod
;;;404        _PLLCON  |= (1 << 1);
00000c  bc10              POP      {r4}
00000e  bc08              POP      {r3}
000010  4718              BX       r3
;;;405        _PLLFEED  = 0xAA;
;;;406        _PLLFEED  = 0x55;
;;;407      }
;;;408      _PLLCON     = 0;                         // Set PLL disabled and disconnected
;;;409      _PLLFEED    = 0xAA;
;;;410      _PLLFEED    = 0x55;
;;;411    #if (OS_USE_INTERNAL_RC)
;;;412      _CLKSRCSEL  = 0;                         // Select internal RC oscillator 4 MHz as clock source
;;;413    #else
;;;414      _SCS        &= ~(1 << 4);                // The frequency range of the main oscillator is 1 MHz to 20 MHz.
;;;415      _SCS        |=  (1 << 5);                // Main oscillator enable.
;;;416      _CLKSRCSEL  = 1;                         // Select main oscillator 12 MHz as clock source
;;;417    #endif
;;;418      _PLLCFG     = (OS_PLL_MULTIPLIER - 1);   // MSEL: Multiplier - 1
;;;419      _PLLFEED    = 0xAA;
;;;420      _PLLFEED    = 0x55;
;;;421      _PLLCON     = 1;                         // Enable PLL, Disconnect
;;;422      _PLLFEED    = 0xAA;
;;;423      _PLLFEED    = 0x55;
;;;424      do {
;;;425      } while ((_PLLSTAT & (1 << 26)) == 0);   // Check PLOCK bit	
;;;426      _CPUCLKCFG  = 4;                         // Set CPU clock divider, value = Division ratio - 1)
;;;427      _USBCLKCFG  = 5;                         // Set USB clock divider, value = Division ratio - 1)
;;;428    
;;;429      _PCLKSEL0   = _PCLKSEL_VALUE;
;;;430      _PCLKSEL1   = _PCLKSEL_VALUE;
;;;431    
;;;432      _PLLCON     = (1 << 0) | (1 << 1);       // Enable PLL and select as clock source
;;;433      _PLLFEED    =  0xAA;
;;;434      _PLLFEED    =  0x55;
;;;435    }
;;;436    
                          ENDP


                          AREA ||area_number.3||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.3||, ||.text||
                  OS_ARM_DisableISR PROC
;;;401    */
;;;402    static void _InitPLL(void) {
000000  b510              PUSH     {r4,lr}
;;;403      if (_PLLSTAT & (1 << 25)) {
000002  0004              MOVS     r4,r0
000004  2c20              CMP      r4,#0x20
000006  d305              BCC      |L3.20|
000008  2064              MOVS     r0,#0x64
00000a  f7fffffe          BL       OS_Error
                  |L3.14|
;;;404        _PLLCON  |= (1 << 1);
00000e  bc10              POP      {r4}
000010  bc08              POP      {r3}
000012  4718              BX       r3
                  |L3.20|
000014  f7fffffe          BL       __ARM_common_disable_irq
;;;405        _PLLFEED  = 0xAA;
000018  2001              MOVS     r0,#1
00001a  40a0              LSLS     r0,r0,r4
;;;406        _PLLFEED  = 0x55;
00001c  4902              LDR      r1,|L3.40|
00001e  6148              STR      r0,[r1,#0x14]
;;;407      }
;;;408      _PLLCON     = 0;                         // Set PLL disabled and disconnected
000020  f7fffffe          BL       OS_RestoreI
000024  46c0              MOV      r8,r8
;;;409      _PLLFEED    = 0xAA;
000026  e7f2              B        |L3.14|
;;;410      _PLLFEED    = 0x55;
;;;411    #if (OS_USE_INTERNAL_RC)
;;;412      _CLKSRCSEL  = 0;                         // Select internal RC oscillator 4 MHz as clock source
;;;413    #else
;;;414      _SCS        &= ~(1 << 4);                // The frequency range of the main oscillator is 1 MHz to 20 MHz.
;;;415      _SCS        |=  (1 << 5);                // Main oscillator enable.
;;;416      _CLKSRCSEL  = 1;                         // Select main oscillator 12 MHz as clock source
;;;417    #endif
;;;418      _PLLCFG     = (OS_PLL_MULTIPLIER - 1);   // MSEL: Multiplier - 1
;;;419      _PLLFEED    = 0xAA;
;;;420      _PLLFEED    = 0x55;
;;;421      _PLLCON     = 1;                         // Enable PLL, Disconnect
;;;422      _PLLFEED    = 0xAA;
;;;423      _PLLFEED    = 0x55;
;;;424      do {
;;;425      } while ((_PLLSTAT & (1 << 26)) == 0);   // Check PLOCK bit	
;;;426      _CPUCLKCFG  = 4;                         // Set CPU clock divider, value = Division ratio - 1)
;;;427      _USBCLKCFG  = 5;                         // Set USB clock divider, value = Division ratio - 1)
;;;428    
;;;429      _PCLKSEL0   = _PCLKSEL_VALUE;
;;;430      _PCLKSEL1   = _PCLKSEL_VALUE;
;;;431    
;;;432      _PLLCON     = (1 << 0) | (1 << 1);       // Enable PLL and select as clock source
;;;433      _PLLFEED    =  0xAA;
;;;434      _PLLFEED    =  0x55;
;;;435    }
;;;436    
                          ENDP

                  |L3.40|
                          DCD      0xfffff000

                          AREA ||i.__ARM_common_call_via_r4||, COMGROUP=__ARM_common_call_via_r4, CODE, READONLY, ALIGN=1

                  __ARM_common_call_via_r4 PROC
000000  4720              BX       r4
                          ENDP


                          AREA ||i.__ARM_common_enable_irq||, COMGROUP=__ARM_common_enable_irq, CODE, READONLY, ALIGN=2

                          ARM
                  __ARM_common_enable_irq PROC
000000  e10f0000          MRS      r0,APSR ; formerly CPSR
000004  e3c00080          BIC      r0,r0,#0x80
000008  e121f000          MSR      CPSR_c,r0
00000c  e12fff1e          BX       lr
                          ENDP


                          AREA ||i.__ARM_common_disable_irq||, COMGROUP=__ARM_common_disable_irq, CODE, READONLY, ALIGN=2

                  __ARM_common_disable_irq PROC
000000  e10f0000          MRS      r0,APSR ; formerly CPSR
000004  e3801080          ORR      r1,r0,#0x80
000008  e121f001          MSR      CPSR_c,r1
00000c  e2000080          AND      r0,r0,#0x80
000010  e12fff1e          BX       lr
                          ENDP

