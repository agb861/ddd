L 1 "GUI\GUI_VNC_X_StartServer.c"
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI_VNC_X_StartServer.c
NPurpose     : Starts the VNC server via TCP/IP.
N              This code works with embOS/IP.
N              However, it can be easily modified to work with
N              different kernel and IP Stack
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#include <stdlib.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 22 "GUI\GUI_VNC_X_StartServer.c" 2
N
N#include "IP.h"       // BSD socket interface
L 1 "IP\IP.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : IP.h
NPurpose     : API of the TCP/IP stack
N---------------------------END-OF-HEADER------------------------------
N*/
N/* Additional Copyrights: */
N/* Copyright  2000 By InterNiche Technologies Inc. All rights reserved */
N/* Portions Copyright 1990,1993 by NetPort Software. */
N/* Portions Copyright 1986 by Carnegie Mellon */
N/* Portions Copyright 1983 by the Massachusetts Institute of Technology */
N
N#ifndef _IP_H_
N#define _IP_H_
N
N#include "Global.h"
L 1 "GUI\Global.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : GLOBAL.h
NPurpose : Global types etc.
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GLOBAL_H            // Guard against multiple inclusion
N#define GLOBAL_H
N
N/*********************************************************************
N*
N*       Macros
N*
N**********************************************************************
N*/
N#define U8    unsigned char
N#define U16   unsigned short
N#define U32   unsigned long
N#define I8    signed char
N#define I16   signed short
N#define I32   signed long
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 27 "IP\IP.h" 2
N#include "IP_ConfDefaults.h"
L 1 "IP\IP_ConfDefaults.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : IP_ConfDefaults.h
NPurpose :
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef IP_CONFDEFAULTS_H
N#define IP_CONFDEFAULTS_H
N
N#include "IP_Conf.h"
L 1 "Setup\IP_Conf.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef _IP_CONF_H_
N#define _IP_CONF_H_ 1
N
N//
N// IAR ARM compiler related macros
N//
N#ifdef __ICCARM__
S  #if ((__TID__ >> 4) & 0x0F) < 6   // For any ARM CPU core < v7, we will use optimized routines
S    #include "Util.h"
S    #define IP_MEMCPY(pDest, pSrc, NumBytes) ARM_memcpy(pDest, pSrc, NumBytes)    // Speed optimization: Our memcpy is much faster!
S    U16 ARM_IP_cksum(void * ptr, unsigned NumHWords);
S    #define IP_CKSUM(p, NumItems) ARM_IP_cksum((p), (NumItems))
S  #endif
S  #define IP_IS_BIG_ENDIAN (1 - __LITTLE_ENDIAN__)
N#endif
N
N//
N// Change endianess if required, default is IP_IS_BIG_ENDIAN == 0
N//
N//#define IP_IS_BIG_ENDIAN    1
N//#define IP_MEMCPY(pDest, pSrc, NumBytes) UTIL_memcpy(pDest, pSrc, NumBytes)    // Speed optimization: Our memcpy is much faster!
N
N#ifdef DEBUG
N  #if DEBUG
X  #if 1
N    #define IP_DEBUG        2   // Debug level: 1: Support "Panic" checks, 2: Support warn & log
N  #endif
N#endif
N
N#endif     // Avoid multiple inclusion
N
N
L 22 "IP\IP_ConfDefaults.h" 2
N
N
N#ifndef   IP_DEBUG
S  #define IP_DEBUG                  (0)
N#endif
N
N#ifndef   IP_MEMCPY
N  #define IP_MEMCPY  memcpy
N#endif
N
N#ifndef   IP_MEMSET
N  #define IP_MEMSET  memset
N#endif
N
N#ifndef   IP_MEMMOVE
N  #define IP_MEMMOVE memmove
N#endif
N
N#ifndef   IP_MEMCMP
N  #define IP_MEMCMP  memcmp
N#endif
N
N#ifndef   IP_CKSUM
N  #define IP_CKSUM(p, NumHWords) IP_cksum(p, NumHWords)
N#endif
N
N#ifndef   IP_OPTIMIZE
N  #define IP_OPTIMIZE
N#endif
N
N#ifndef   IP_IS_BIG_ENDIAN
N  #define IP_IS_BIG_ENDIAN 0      // Little endian is default
N#endif
N
N
N
N#ifndef   IP_INCLUDE_STAT         // Allow override in IP_Conf.h
N  #if IP_DEBUG > 0
X  #if 2 > 0
N    #define IP_INCLUDE_STAT 1     // Can be set to 0 to disable statistics for extremly small release builds
N  #else
S    #define IP_INCLUDE_STAT 0
N  #endif
N#endif
N
N#ifndef IP_DEBUG_Q                // Allow override in IP_Conf.h
N  #if IP_DEBUG
X  #if 2
N    #define IP_DEBUG_Q 1
N  #else
S    #define IP_DEBUG_Q 0
N  #endif
N#endif
N//
N// TCP retransmission range defaults
N//
N#ifndef   IP_TCP_RETRANS_MIN
N  #define IP_TCP_RETRANS_MIN   200   // Min. delay for retransmit. Real delay is computed, this minimum applies only if computed delay is shorter.
N#endif
N
N#ifndef   IP_TCP_RETRANS_MAX
N  #define IP_TCP_RETRANS_MAX  5000   // Max. delay for retransmit. Real delay is computed, this maximum applies only if computed delay is longer.
N#endif
N
N//
N// TCP keep-alive defaults
N//
N#ifndef IP_TCP_KEEPALIVE_INIT
N  #define  IP_TCP_KEEPALIVE_INIT     20000       // Initial connect keep alive, 20 sec.
N#endif
N
N#ifndef IP_TCP_KEEPALIVE_IDLE
N  #define  IP_TCP_KEEPALIVE_IDLE     60000       // Default time before probing
N#endif
N
N#ifndef IP_TCP_KEEPALIVE_PERIOD
N  #define  IP_TCP_KEEPALIVE_PERIOD   10000       // Default probe interval
N#endif
N
N#ifndef IP_TCP_KEEPALIVE_MAX_REPS
N  #define  IP_TCP_KEEPALIVE_MAX_REPS     8       // Max probes before drop
N#endif
N
N#ifndef IP_TCP_MSL
N  #define  IP_TCP_MSL                 2000       // Max segment lifetime
N#endif
N
N
N#define IP_TCP_DACK_PERIOD    10   // Time base for delayed acknowledges
N#define IP_TCP_SLOW_PERIOD    10
N
N
N#define INCLUDE_ARP          1   // Include Ethernet ARP ?
N#define INCLUDE_ICMP         1   // Include ICMP || ping only
N#define INCLUDE_TCP          1
N#define INCLUDE_UDP          1
N#define TCP_ZEROCOPY         1  // Enable zero-copy Socket extension
N#define TCP_TIMESTAMP        1  // Are we using RFC-1323 TCP timestamp feature to compute RTT ?
N#ifndef   IP_SUPPORT_MULTICAST
N  #define IP_SUPPORT_MULTICAST  0   // Experimental
N#endif
N
N#ifndef IP_MAX_DNS_SERVERS
N  #define IP_MAX_DNS_SERVERS  2
N#endif
N
N#ifndef IP_PANIC
N  #if   IP_DEBUG
X  #if   2
N    #define IP_PANIC(s)     IP_Panic(s)
N  #else
S    #define IP_PANIC(s)
N  #endif
N#endif
N
N#ifndef   IP_SUPPORT_LOG
N  #if   IP_DEBUG > 1
X  #if   2 > 1
N    #define IP_SUPPORT_LOG  1
N  #else
S    #define IP_SUPPORT_LOG  0
N  #endif
N#endif
N
N#ifndef   IP_SUPPORT_WARN
N  #if   IP_DEBUG > 1
X  #if   2 > 1
N    #define IP_SUPPORT_WARN  1
N  #else
S    #define IP_SUPPORT_WARN  0
N  #endif
N#endif
N
N
N
N#if   IP_INCLUDE_STAT
X#if   1
N  #define IP_STAT_DEC(Cnt)     (Cnt)--
N  #define IP_STAT_INC(Cnt)     (Cnt)++
N  #define IP_STAT_ADD(Cnt, v) { Cnt += v; }
N#else
S  #define IP_STAT_DEC(Cnt)
S  #define IP_STAT_INC(Cnt)
S  #define IP_STAT_ADD(Cnt, v)
N#endif
N
N#define TPS        1000    /* cticks per second */
N
N#define IP_TTL        64 /* define IP hop count for this port */
N#define IP_TCP_DELAY_ACK_DEFAULT 200       // [ms]
N
N#define DO_DELAY_ACKS  (1)   // Defining enables delayed acks
N//#define TCP_SACK       (1)
N#define TCP_WIN_SCALE  (0)     // We do not want to use it per default, since it requires a sufficiently big buffer in the hardware.
N#define IP_PTR_OP_IS_ATOMIC       (1)
N
N#define IP_MAX_IFACES       1  /* max ifaces to support at one time */
N
N#endif // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
N
N
N
L 28 "IP\IP.h" 2
N#include "IP_socket.h"
L 1 "IP\IP_socket.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : IP_socket.h
NPurpose :
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N/* Additional Copyrights: */
N/* Copyright 1997 - 2000 By InterNiche Technologies Inc. All rights reserved */
N/* Copyright (c) 1982, 1986 Regents of the University of California.
N* All rights reserved.
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N* 1. Redistributions of source code must retain the above copyright
N*    notice, this list of conditions and the following disclaimer.
N* 2. Redistributions in binary form must reproduce the above copyright
N*    notice, this list of conditions and the following disclaimer in the
N*    documentation and/or other materials provided with the distribution.
N* 3. [rescinded 22 July 1999]
N* 4. Neither the name of the University nor the names of its contributors
N*    may be used to endorse or promote products derived from this software
N*    without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
N* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N* ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
N* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N* SUCH DAMAGE.
N*/
N
N
N
N#ifndef SOCKET_H                         // Avoid multiple inclusion
N#define  SOCKET_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*
N * Address families, for socket() call and "domain" variables.
N */
N
N#define  AF_INET     2     /* internetwork: UDP, TCP, etc. */
N#define  AF_INET6    3     /* IPv6 */
N#define  PF_INET6    AF_INET6
N
N
N/* IPPROTO_... definitions, from BSD <netinet/in.h> */
N#define     IPPROTO_IP     0  /* added for IP multicasting changes */
N#define     IPPROTO_IGMP   2  /* added for IP multicasting changes */
N#define     IPPROTO_TCP    6
N#define     IPPROTO_UDP    17
N#define     IPPROTO_RAW    255
N
N
N
N/* BSD sockets errors */
N
N#define     ENOBUFS        1
N#define     ETIMEDOUT      2
N#define     EISCONN        3
N#define     EOPNOTSUPP     4
N#define     ECONNABORTED   5
N#define     EWOULDBLOCK    6
N#define     ECONNREFUSED   7
N#define     ECONNRESET     8
N#define     ENOTCONN       9
N#define     EALREADY       10
N#define     EINVAL         11
N#define     EMSGSIZE       12
N#define     EPIPE          13
N#define     EDESTADDRREQ   14
N#define     ESHUTDOWN      15
N#define     ENOPROTOOPT    16
N#define     EHAVEOOB       17
N#define     ENOMEM         18
N#define     EADDRNOTAVAIL  19
N#define     EADDRINUSE     20
N#define     EAFNOSUPPORT   21
N#define     EINPROGRESS    22
N#define     ELOWER         23    /* lower layer (IP) error */
N#define     ENOTSOCK       24    /* Includes sockets which closed while blocked */
N#define     EIEIO 27 /* bad input/output on Old Macdonald's farm :-) */
N#define     ETOOMANYREFS   28    // Multicast only
N#define     EFAULT         29
N#define     ENETUNREACH    30
N
N
N
N
N
N
N
N
N
N/*
N * Types
N */
N#define     SOCK_STREAM    1     /* stream socket */
N#define     SOCK_DGRAM     2     /* datagram socket */
N#define     SOCK_RAW       3     /* raw-protocol interface */
N#define     SOCK_RDM       4     /* reliably-delivered message */
N#define     SOCK_SEQPACKET 5     /* sequenced packet stream */
N
N/*
N * Option flags per-socket.
N */
N#define     SO_DEBUG       0x00001     /* turn on debugging info recording */
N#define     SO_ACCEPTCONN  0x00002     /* socket has had listen() */
N#define     SO_REUSEADDR   0x00004     /* allow local address reuse */
N#define     SO_KEEPALIVE   0x00008     /* keep connections alive */
N#define     SO_DONTROUTE   0x00010     /* just use interface addresses */
N#define     SO_BROADCAST   0x00020     /* permit sending of broadcast msgs */
N#define     SO_USELOOPBACK 0x00040     /* bypass hardware when possible */
N#define     SO_LINGER      0x00080     /* linger on close if data present */
N#define     SO_OOBINLINE   0x00100     /* leave received OOB data in line */
N#define     SO_TCPSACK     0x00200     /* Allow TCP SACK (Selective acknowledgment) */
N#define     SO_WINSCALE    0x00400     /* Set scaling window option */
N#define     SO_TIMESTAMP   0x00800     /* Set TCP timestamp option */
N#define     SO_BIGCWND     0x01000     /* Large initial TCP Congenstion window */
N#define     SO_HDRINCL     0x02000     /* user access to IP hdr for SOCK_RAW */
N#define     SO_NOSLOWSTART 0x04000     /* suppress slowstart on this socket */
N#define     SO_FULLMSS     0x08000     /* force packets to all be MAX size */
N
N/* for compatability with second-rate stacks: */
N#define SO_EXPEDITE     SO_NOSLOWSTART
N#define SO_THROUGHPUT   SO_FULLMSS
N
N/*
N * Additional options, not kept in so_options.
N */
N#define  SO_SNDBUF      0x1001      /* send buffer size */
N#define  SO_RCVBUF      0x1002      /* receive buffer size */
N#define  SO_SNDLOWAT    0x1003      /* send low-water mark */
N#define  SO_RCVLOWAT    0x1004      /* receive low-water mark */
N#define  SO_SNDTIMEO    0x1005      /* send timeout */
N#define  SO_RCVTIMEO    0x1006      /* receive timeout */
N#define  SO_ERROR       0x1007      /* get error status and clear */
N#define  SO_TYPE        0x1008      /* get socket type */
N#define  SO_HOPCNT      0x1009      /* Hop count to get to dst   */
N#define  SO_MAXMSG      0x1010      /* get TCP_MSS (max segment size) */
N
N/* ...And some netport additions to setsockopt: */
N#define  SO_RXDATA      0x1011      /* get count of bytes in sb_rcv */
N#define  SO_TXDATA      0x1012      /* get count of bytes in sb_snd */
N#define  SO_MYADDR      0x1013      /* return my IP address */
N#define  SO_NBIO        0x1014      /* set socket into NON-blocking mode */
N#define  SO_BIO         0x1015      /* set socket into blocking mode */
N#define  SO_NONBLOCK    0x1016      /* set/get blocking mode via optval param */
N#define  SO_CALLBACK    0x1017      /* set/get zero_copy callback routine */
N
N/*
N * TCP User-settable options (used with setsockopt).
N * TCP-specific socket options use the 0x2000 number space.
N */
N
N#define  TCP_ACKDELAYTIME 0x2001    /* Set time for delayed acks */
N#define  TCP_NOACKDELAY   0x2002    /* suppress delayed ACKs */
N#define  TCP_MAXSEG       0x2003    /* set maximum segment size */
N#define  TCP_NODELAY      0x2004    /* Disable Nagle Algorithm */
N
N
N/*
N * Structure used for manipulating linger option.
N */
Nstruct   linger {
N   int   l_onoff;    /* option on/off */
N   int   l_linger;   /* linger time */
N};
N
N
N/*
N * Structure used by kernel to store most
N * addresses.
N */
Nstruct sockaddr {
N   U16     sa_family;     /* address family */
X   unsigned short     sa_family;      
N   char     sa_data[14];      /* up to 14 bytes of direct address */
N};
N
N
N/* Berkeley style "Internet address" */
N
Nstruct in_addr {
N   U32  s_addr;
X   unsigned long  s_addr;
N};
N
N#define  INADDR_ANY     0L
N
N/* Berkeley style "Socket address" */
Nstruct sockaddr_in {
N  U16      sin_family;
X  unsigned short      sin_family;
N  U16      sin_port;
X  unsigned short      sin_port;
N  struct   in_addr  sin_addr;
N  char     sin_zero[8];
N};
N
N
N
N
N/*
N * Structure used by kernel to pass protocol
N * information in raw sockets.
N */
Nstruct sockproto {
N   U16     sp_family;     /* address family */
X   unsigned short     sp_family;      
N   U16     sp_protocol;   /* protocol */
X   unsigned short     sp_protocol;    
N};
N
N/* Support for Large initial congestion window */
N#ifdef TCP_BIGCWND
Sextern   int      use_default_cwnd;    /* Flag to use this on all sockets */
Sextern   U32   default_cwnd;        /* initial cwnd value to use */
N#endif   /* TCP_BIGCWND */
N
N/*
N * Protocol families, same as address families for now.
N */
N#define  PF_UNSPEC   AF_UNSPEC
N#define  PF_UNIX     AF_UNIX
N#define  PF_INET     AF_INET
N#define  PF_IMPLINK  AF_IMPLINK
N#define  PF_PUP      AF_PUP
N#define  PF_CHAOS    AF_CHAOS
N#define  PF_NS       AF_NS
N#define  PF_NBS      AF_NBS
N#define  PF_ECMA     AF_ECMA
N#define  PF_DATAKIT  AF_DATAKIT
N#define  PF_CCITT    AF_CCITT
N#define  PF_SNA      AF_SNA
N#define  PF_DECnet   AF_DECnet
N#define  PF_DLI      AF_DLI
N#define  PF_LAT      AF_LAT
N#define  PF_HYLINK   AF_HYLINK
N#define  PF_APPLETALK   AF_APPLETALK
N
N
N/*
N * Maximum queue length specifiable by listen.
N */
N#define     SOMAXCONN   5
N
N#define     MSG_PEEK       0x2      /* peek at incoming message */
N#define     MSG_DONTROUTE  0x4      /* send without using routing tables */
N#define     MSG_NEWPIPE    0x8      /* New pipe for recvfrom call   */
N#define     MSG_EOR        0x10     /* data completes record */
N#define     MSG_DONTWAIT   0x20     /* this message should be nonblocking */
N
N/* utility functions defined in misclib\parseip.c */
Nint inet46_addr(char *str, struct sockaddr *address);
N
Nlong  t_socket (int, int, int);
Nint   t_bind (long, struct sockaddr *, int);
Nint   t_listen (long, int);
Nlong  t_accept (long, struct sockaddr *, int *);
Nint   t_connect (long, struct sockaddr *, int);
Nint   t_getpeername (long, struct sockaddr *, int * addrlen);
Nint   t_getsockname (long, struct sockaddr *, int * addrlen);
Nint   t_setsockopt (long sock, int level, int op, void * data, int dlen);
Nint   t_getsockopt (long sock, int level, int op, void * data, int dlen);
Nint   t_recv (long, char *, int, int);
Nint   t_send (long, const char *, int, int);
Nint   t_recvfrom (long s, char * buf, int len, int flags, struct sockaddr *, int*);
Nint   t_sendto (long s, const char * buf, int len, int flags, struct sockaddr *, int);
Nint   t_shutdown (long, int);
Nint   t_socketclose (long);
Nint   t_errno(long s);
N
Nchar * so_perror(int);  /* return an error string for a socket error */
N
N//
N// Map plain BSD socket routine names to Interniche t_" names.
N//
N#define  socket(x,y,z)           t_socket(x,y,z)
N#define  bind(s,a,l)             t_bind(s,a,l)
N#define  connect(s,a,l)          t_connect(s,a,l)
N#define  listen(s,c)             t_listen(s,c)
N#define  send(s, b, l, f)        t_send(s, b, l, f)
N#define  recv(s, b, l, f)        t_recv(s, b, l, f)
N#define  accept(s,a,l)           t_accept(s, a, l)
N#define  sendto(s,b,l,f,a,x)     t_sendto(s,b,l,f,a,x)
N#define  recvfrom(s,b,l,f,a,x)   t_recvfrom(s,b,l,f,a,x)
N#define  socketclose(s)          t_socketclose(s)
N#define  closesocket(s)          t_socketclose(s)
N#define  setsockopt(s,l,o,d,x)   t_setsockopt(s,l,o,d,x)
N#define  getsockopt(s,l,o,d,x)   t_getsockopt(s,l,o,d,x)
N#define  shutdown(s,how)         t_shutdown(s,how)
N#define  select(i,o,e,tv)        t_select(i,o,e,tv)
N#define  getpeername(s,a,al)     t_getpeername(s,a,al)
N#define  getsockname(s,a,al)     t_getsockname(s,a,al)
N
Nstruct hostent *  gethostbyname (char * name);
N
N
N
N#define  SOCKTYPE    long     /* preferred generic socket type */
N
N#define  SYS_SOCKETNULL -1    /* error return from sys_socket. */
N#define  INVALID_SOCKET -1    /* WINsock-ish synonym for SYS_SOCKETNULL */
N#define  SOCKET_ERROR   -1    /* error return from send(), sendto(), et.al. */
N#define  SOL_SOCKET     -1    /* compatability parm for set/get sockopt */
N
N#define  SO_SELECT      1  /* support select() call */
N
N
N#ifdef SO_SELECT
N/* define the size of the sockets arrays passed to select(). On UNIX
N * and winsock this is usually 64, but most embedded systems don't
N * need more than 1 or 2, and can't always afford to waste the space.
N * NOTE: These determine the size of set_fd structs, which are often
N */
N#ifndef FD_SETSIZE   /* let h_h files override */
N#define  FD_SETSIZE     12
N#endif   /* FD_SETSIZE */
N#endif   /* SO_SELECT */
N
N
N
N
N/* the definitions to support the select() function. These are about
N * as UNIX-like as we can make 'em on embedded code. They are also
N * fairly compatable with WinSock's select() definitions.
N */
N
Ntypedef struct IP_FD_SET   /* the select socket array manager */
N{
N   unsigned fd_count;               /* how many are SET? */
N   long     fd_array[FD_SETSIZE];   /* an array of SOCKETs */
X   long     fd_array[12];    
N} IP_fd_set;
N
N/* our select call - note the traditional "width" parameter is absent */
Nint t_select(IP_fd_set * in, IP_fd_set * out, IP_fd_set * ev, long tmo_seconds);
N
N//
N// Select-related functions are calls (not macros) to save space
N//
Nvoid  IP_FD_CLR  (long so, IP_fd_set * set);
Nvoid  IP_FD_SET  (long so, IP_fd_set * set);
Nint   IP_FD_ISSET(long so, IP_fd_set * set);
N// and one actual macro:
N#define  IP_FD_ZERO(set)   (((IP_fd_set *)(set))->fd_count=0)
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* SOCKET_H */
N
N/* end of file socket.h */
N
N
L 29 "IP\IP.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#define IP_VERSION   15601   // Format: Mmmrr. Example: 10201 is 1.02a
N
N/*********************************************************************
N*
N*       IP_MTYPE
N*
N*  Ids to distinguish different message types
N*/
N#define IP_MTYPE_INIT         (1UL << 0)
N#define IP_MTYPE_CORE         (1UL << 1)
N#define IP_MTYPE_ALLOC        (1UL << 2)
N#define IP_MTYPE_DRIVER       (1UL << 3)
N#define IP_MTYPE_ARP          (1UL << 4)
N#define IP_MTYPE_IP           (1UL << 5)
N
N#define IP_MTYPE_TCP_CLOSE    (1UL << 6)
N#define IP_MTYPE_TCP_OPEN     (1UL << 7)
N#define IP_MTYPE_TCP_IN       (1UL << 8)
N#define IP_MTYPE_TCP_OUT      (1UL << 9)
N#define IP_MTYPE_TCP_RTT      (1UL << 10)
N#define IP_MTYPE_TCP_RXWIN    (1UL << 11)
N#define IP_MTYPE_TCP          (IP_MTYPE_TCP_OPEN | IP_MTYPE_TCP_CLOSE | IP_MTYPE_TCP_IN | IP_MTYPE_TCP_OUT | IP_MTYPE_TCP_RTT)
N
N#define IP_MTYPE_UDP_IN       (1UL << 12)
N#define IP_MTYPE_UDP_OUT      (1UL << 13)
N#define IP_MTYPE_UDP          (IP_MTYPE_UDP_IN | IP_MTYPE_UDP_OUT)
N
N#define IP_MTYPE_LINK_CHANGE  (1UL << 14)
N#define IP_MTYPE_DHCP         (1UL << 17)
N#define IP_MTYPE_DHCP_EXT     (1UL << 18)
N
N#define IP_MTYPE_APPLICATION  (1UL << 19)
N
N
N#define IP_MTYPE_ICMP         (1UL << 20)
N#define IP_MTYPE_NET_IN       (1UL << 21)
N#define IP_MTYPE_NET_OUT      (1UL << 22)
N
N#define IP_MTYPE_DNS          (1UL << 24)
N
N#define IP_MTYPE_SOCKET_STATE (1UL << 26)
N#define IP_MTYPE_SOCKET_READ  (1UL << 27)
N#define IP_MTYPE_SOCKET_WRITE (1UL << 28)
N#define IP_MTYPE_SOCKET       (IP_MTYPE_SOCKET_STATE | IP_MTYPE_SOCKET_READ | IP_MTYPE_SOCKET_WRITE)
N#define IP_MTYPE_DNSC         (1UL << 29)
N
Nvoid IP_Logf_Application(const char * sFormat, ...);
Nvoid IP_Warnf_Application(const char * sFormat, ...);
N
N/*********************************************************************
N*
N*       IP_ERR_
N*
N*  Ids to distinguish different message types
N*
N* Stack generic error codes: generally full success is 0,
N* definite errors are negative numbers, and indeterminate conditions
N* are positive numbers. These may be changed if they conflict with
N* defines in the target system.
N* If you have to change
N* these values, be sure to recompile ALL NetPort sources.
N*/
N
N/* programming errors */
N#define IP_ERR_PARAM      -10 /* bad parameter */
N#define IP_ERR_LOGIC      -11 /* sequence of events that shouldn't happen */
N#define IP_ERR_NOCIPHER   -12 /* No corresponding cipher found for the cipher id */
N
N/* system errors */
N#define IP_ERR_NOMEM      -20 /* malloc or calloc failed */
N#define IP_ERR_NOBUFFER   -21 /* ran out of free packets */
N#define IP_ERR_RESOURCE   -22 /* ran out of other queue-able resource */
N#define SEND_DROPPED IP_ERR_RESOURCE /* full queue or similar lack of resource */
N#define IP_ERR_BAD_STATE  -23 /* TCP layer error */
N#define IP_ERR_TIMEOUT    -24 /* TCP layer error */
N
N#define IP_ERR_NOFILE     -25 /* expected file was missing */
N#define IP_ERR_FILEIO     -26 /* file IO error */
N
N/* net errors */
N#define IP_ERR_SENDERR    -30 /* send to net failed at low layer */
N#define IP_ERR_NOARPREP   -31 /* no ARP for a given host */
N#define IP_ERR_BAD_HEADER -32 /* bad header at upper layer (for upcalls) */
N#define IP_ERR_NO_ROUTE   -33 /* can't find a reasonable next IP hop */
N#define IP_ERR_NO_IFACE   -34 /* can't find a reasonable interface */
N#define IP_ERR_HARDWARE   -35 /* detected hardware failure */
N
N/* conditions that are not really fatal OR success: */
N#define IP_ERR_SEND_PENDING 1 /* packet queued pending an ARP reply */
N#define IP_ERR_NOT_MINE     2 /* packet was not of interest (upcall reply) */
N
N
N
N/*********************************************************************
N*
N*  Convert little/big endian - these should be efficient,
N*  inline code or MACROs
N*/
N#if IP_IS_BIG_ENDIAN
X#if 0
S  #define htonl(l) (l)
S  #define htons(s) (s)
S  #define IP_HTONL_FAST(l) (l)
N#else
N  #define htonl(l) IP_SwapU32(l)
N  #define htons(s) ((U16)((U16)(s) >> 8) | (U16)((U16)(s) << 8))   /* Amazingly, some compilers really need all these U16 casts: */
N//  #define htons(s) (((s) >> 8) | (U16)((s) << 8))
N  #define IP_HTONL_FAST(v) (                      \
N      (((U32)((v) << 0)  >> 24) << 0) | \
N      (((U32)((v) << 8)  >> 24) << 8) | \
N      (((U32)((v) << 16) >> 24) << 16) | \
N      (((U32)((v) << 24) >> 24) << 24))
X  #define IP_HTONL_FAST(v) (                            (((U32)((v) << 0)  >> 24) << 0) |       (((U32)((v) << 8)  >> 24) << 8) |       (((U32)((v) << 16) >> 24) << 16) |       (((U32)((v) << 24) >> 24) << 24))
N#endif
N
N#define ntohl(l) htonl(l)
N#define ntohs(s) htons(s)
N
N
NU32 IP_SwapU32(U32 v);
Xunsigned long IP_SwapU32(unsigned long v);
N
N
N/*********************************************************************
N*
N*  IP_OS_
N*/
Nvoid IP_OS_Delay(unsigned ms);
Nvoid IP_OS_DisableInterrupt(void);
Nvoid IP_OS_EnableInterrupt(void);
Nvoid IP_OS_Init(void);
Nvoid IP_OS_Unlock(void);
Nvoid IP_OS_AssertLock(void);
Nvoid IP_OS_Lock  (void);
NU32  IP_OS_GetTime32(void);
Xunsigned long  IP_OS_GetTime32(void);
N// Wait and signal for Net task
Nvoid IP_OS_WaitNetEvent  (unsigned ms);
Nvoid IP_OS_SignalNetEvent(void);
N// Wait and signal for the optional Rx task
Nvoid IP_OS_WaitRxEvent  (void);
Nvoid IP_OS_SignalRxEvent(void);
N// Wait and signal for application tasks
Nvoid IP_OS_WaitItem      (void * pWaitItem);
Nvoid IP_OS_WaitItemTimed (void * pWaitItem, unsigned Timeout);
Nvoid IP_OS_SignalItem(void * pWaitItem);
Nvoid IP_OS_AddTickHook(void (* pfHook)(void));
N
N
N/*********************************************************************
N*
N*       IP_PACKET
N*
N* INCOMING: Incoming packets are always front-aligned in the
N* pBuffer field. The pData pointer is set to pBuffer by the
N* receiver and advanced by each layer of the stack before
N* upcalling the next; ie the ethernet driver bumps the prot field
N* by 14 and decrements plen by 14. PACKETs are pk_alloc()ed by
N* the receiving net layer and pk_free()ed by the transport layer
N* or application when it's finished with them. OUTGOING:
N* Protocols install data into pBuffer with a front pad big enough
N* to accomadate the biggest likely protocol headers, ususally
N* about 62 bytes (14 ether + 24 IP + 24 TCP, where IP & TCP each
N* have option fields.) prot plen are set for this data, and the
N* protocol headers are prepended as the packet goes down the
N* stack. pBuffer is not used in this case except for overflow
N* checks. PACKETs are pk_alloc()ed by the sending protocol and
N* freed by the lower layer level that dispatches them, usually
N* net link layer driver. They can be held by ARP for several
N* seconds while awaiting arp replys on initial sends to a new IP
N* host, and the ARP code will free them when a reply comes in or
N* times out.
N*/
Ntypedef   U32 ip_addr;
Xtypedef   unsigned long ip_addr;
N
Ntypedef struct IP_PACKET {
N  struct IP_PACKET * pNext;
N  struct net       * pNet;          // The interface (net) it came in on
N  char             * pBuffer;       // Beginning of raw buffer
N  char             * pData;         // Beginning of protocol/data. This is always >= pBuffer.
N  ip_addr          fhost;           // IP address asociated with packet
N  U16              NumBytes;        // Number of bytes in buffer
X  unsigned short              NumBytes;        
N  U16              BufferSize;      // Length of raw buffer */
X  unsigned short              BufferSize;      
N  U16              UseCnt;          // Use count, for cloning buffer
X  unsigned short              UseCnt;          
N} IP_PACKET;
N
Ntypedef struct IP_PHY_CONTEXT IP_PHY_CONTEXT;
N
Ntypedef struct {
N  unsigned (*pfRead)         (IP_PHY_CONTEXT* pContext, unsigned RegIndex);
N  void     (*pfWrite)        (IP_PHY_CONTEXT* pContext, unsigned RegIndex, unsigned  val);
N} IP_PHY_ACCESS;
N
Nstruct IP_PHY_CONTEXT {
N  const IP_PHY_ACCESS * pAccess;
N  void * pContext;   // Context needed for low level functions
N  U8   Addr;
X  unsigned char   Addr;
N  U8   UseRMII;      // 0: MII, 1: RMII
X  unsigned char   UseRMII;      
N  U16  Anar;         // Value written to ANAR (Auto-negotiation Advertisement register)
X  unsigned short  Anar;         
N  U16  Bmcr;         // Value written to BMCR (basic mode control register)
X  unsigned short  Bmcr;         
N};
N
Ntypedef struct {
N  int   (*pfInit)         (IP_PHY_CONTEXT * pContext);
N  void  (*pfGetLinkState) (IP_PHY_CONTEXT * pContext, U32 * pDuplex, U32 * pSpeed);
X  void  (*pfGetLinkState) (IP_PHY_CONTEXT * pContext, unsigned long * pDuplex, unsigned long * pSpeed);
N} IP_PHY_DRIVER;
N
Nextern const IP_PHY_DRIVER IP_PHY_Generic;
N
Ntypedef struct {
N  int   (*pfInit)         (unsigned Unit);
N  int   (*pfSendPacket)   (unsigned Unit);
N  int   (*pfGetPacketSize)(unsigned Unit);                                   // Return the number of bytes in next packet, <= 0 if there is no more packet.
N  int   (*pfReadPacket)   (unsigned Unit, U8 * pDest, unsigned NumBytes);    // Read (if pDest is valid) and discard packet.
X  int   (*pfReadPacket)   (unsigned Unit, unsigned char * pDest, unsigned NumBytes);    
N  void  (*pfTimer)        (unsigned Unit);                                   // Routine is called periodically
N  int   (*pfControl)      (unsigned Unit, int Cmd, void * p);                // Various control functions
N} IP_HW_DRIVER;
N
N
Ntypedef struct {
N  unsigned NumAddr;
N  const U8 * pHWAddr;                // Hardware addresses
X  const unsigned char * pHWAddr;                
N} IP_NI_CMD_SET_FILTER_DATA;
N
N
N
N/*********************************************************************
N*
N*       Drivers commands
N*/
N#define IP_NI_CMD_SET_FILTER          0   // Set filter. Can handle multiple MAC-addresses.
N#define IP_NI_CMD_CLR_BPRESSURE       1   // Clear back-pressure
N#define IP_NI_CMD_SET_BPRESSURE       2   // Set back-pressure, to avoid receiving more data until the current data is handled
N#define IP_NI_CMD_GET_CAPS            3   // Retrieves the capabilites, which are a logical-or combination of the IP_NI_CAPS below
N#define IP_NI_CMD_SET_PHY_ADDR        4   // Allows settings the PHY address
N#define IP_NI_CMD_SET_PHY_MODE        5   // Allows settings the PHY in a specific mode (duplex, speed)
N#define IP_NI_CMD_POLL                6   // Poll MAC (typically once per ms) in cases where MAC does not trigger an interrupt.
N#define IP_NI_CMD_GET_MAC_ADDR        7   // Retrieve the MAC address from the MAC. This is used for hardware which stores the MAC addr. in an attached EEPROM.
N#define IP_NI_CMD_DISABLE             8   // Disable the network interface (MAC unit + PHY)
N#define IP_NI_CMD_ENABLE              9   // Enable the network interface (MAC unit + PHY)
N#define IP_NI_CMD_SET_TX_BUFFER_SIZE 10   // Allows setting the size of the Tx buffer.
N
N
N/*********************************************************************
N*
N*       Drivers capabilities
N*/
N#define IP_NI_CAPS_WRITE_IP_CHKSUM     (1 << 0)    // Driver capable of inserting the IP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_WRITE_UDP_CHKSUM    (1 << 1)    // Driver capable of inserting the UDP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_WRITE_TCP_CHKSUM    (1 << 2)    // Driver capable of inserting the TCP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_WRITE_ICMP_CHKSUM   (1 << 3)    // Driver capable of inserting the ICMP-checksum into an outgoing packet ?
N#define IP_NI_CAPS_CHECK_IP_CHKSUM     (1 << 4)    // Driver capable of computing and comparing the IP-checksum of an incoming packet ?
N#define IP_NI_CAPS_CHECK_UDP_CHKSUM    (1 << 5)    // Driver capable of computing and comparing the UDP-checksum of an incoming packet ?
N#define IP_NI_CAPS_CHECK_TCP_CHKSUM    (1 << 6)    // Driver capable of computing and comparing the TCP-checksum of an incoming packet ?
N#define IP_NI_CAPS_CHECK_ICMP_CHKSUM   (1 << 7)    // Driver capable of computing and comparing the ICMP-checksum of an incoming packet ?
N
N
Nvoid IP_NI_ClrBPressure  (unsigned Unit);
Nvoid IP_NI_SetBPressure  (unsigned Unit);
N
N/*********************************************************************
N*
N*       Drivers supplied by SEGGER.
N*
N*  Other drivers can always be added or developped by end user.
N*/
Nextern const IP_HW_DRIVER IP_Driver_AT32AP7000;
Nextern const IP_HW_DRIVER IP_Driver_AT91RM9200;
Nextern const IP_HW_DRIVER IP_Driver_CAP9;
Nextern const IP_HW_DRIVER IP_Driver_DM9000;
Nextern const IP_HW_DRIVER IP_Driver_LAN9115;
Nextern const IP_HW_DRIVER IP_Driver_LPC17xx;
Nextern const IP_HW_DRIVER IP_Driver_LPC24xx;
Nextern const IP_HW_DRIVER IP_Driver_LPC32xx;
Nextern const IP_HW_DRIVER IP_Driver_SAM7X;
Nextern const IP_HW_DRIVER IP_Driver_SAM9260;
Nextern const IP_HW_DRIVER IP_Driver_SAM9263;
Nextern const IP_HW_DRIVER IP_Driver_SAM9XE;
Nextern const IP_HW_DRIVER IP_Driver_STR912;
Nextern const IP_HW_DRIVER IP_Driver_NIOSII_MaCo;
Nextern const IP_HW_DRIVER IP_Driver_GMACII;
Nextern const IP_HW_DRIVER IP_Driver_MCF5329;
Nextern const IP_HW_DRIVER IP_Driver_MCF5223x;
Nextern const IP_HW_DRIVER IP_Driver_H8S2472;
Nextern const IP_HW_DRIVER IP_Driver_LAN9118;
Nextern const IP_HW_DRIVER IP_Driver_LAN91C111;
Nextern const IP_HW_DRIVER IP_Driver_LM3S6965;
Nextern const IP_HW_DRIVER IP_Driver_LM3S9B90;
Nextern const IP_HW_DRIVER IP_Driver_SH7670;
N
Nvoid IP_NI_AT32AP7000_ConfigNumRxBuffers(U16 NumRxBuffers);
Xvoid IP_NI_AT32AP7000_ConfigNumRxBuffers(unsigned short NumRxBuffers);
Nvoid IP_NI_AT91RM9200_ConfigNumRxBuffers(U16 NumRxBuffers);
Xvoid IP_NI_AT91RM9200_ConfigNumRxBuffers(unsigned short NumRxBuffers);
Nvoid IP_NI_SAM7X_ConfigNumRxBuffers     (U16 NumRxBuffers);
Xvoid IP_NI_SAM7X_ConfigNumRxBuffers     (unsigned short NumRxBuffers);
Nvoid IP_NI_SAM9260_ConfigNumRxBuffers   (U16 NumRxBuffers);
Xvoid IP_NI_SAM9260_ConfigNumRxBuffers   (unsigned short NumRxBuffers);
Nvoid IP_NI_SAM9263_ConfigNumRxBuffers   (U16 NumRxBuffers);
Xvoid IP_NI_SAM9263_ConfigNumRxBuffers   (unsigned short NumRxBuffers);
Nvoid IP_NI_SAM9XE_ConfigNumRxBuffers    (U16 NumRxBuffers);
Xvoid IP_NI_SAM9XE_ConfigNumRxBuffers    (unsigned short NumRxBuffers);
Nvoid IP_NI_CAP9_ConfigNumRxBuffers      (U16 NumRxBuffers);
Xvoid IP_NI_CAP9_ConfigNumRxBuffers      (unsigned short NumRxBuffers);
N
Ntypedef struct IP_NI_DM9000_ACCESS  IP_NI_DM9000_ACCESS;
Ntypedef struct DM9000_INST DM9000_INST;
N
Nstruct DM9000_INST {
N  U8 *  pHardware;
X  unsigned char *  pHardware;
N  U8 *  pValue;
X  unsigned char *  pValue;
N  U8    BusWidth;    // 8, 16 or 32 bits
X  unsigned char    BusWidth;    
N  IP_NI_DM9000_ACCESS* pAccess;
N};
N
Nstruct IP_NI_DM9000_ACCESS {
N  void (*pf_WriteReg8)    (DM9000_INST * pInst, unsigned RegIndex,  unsigned  val);
N  U16  (*pf_ReadReg8)     (DM9000_INST * pInst, unsigned RegIndex);
X  unsigned short  (*pf_ReadReg8)     (DM9000_INST * pInst, unsigned RegIndex);
N  void (*pf_ReadData)     (DM9000_INST * pInst, U8*   pDest, U32 NumBytes);
X  void (*pf_ReadData)     (DM9000_INST * pInst, unsigned char*   pDest, unsigned long NumBytes);
N  void (*pf_WriteData)    (DM9000_INST * pInst, void* pPacket, U32 NumBytes);
X  void (*pf_WriteData)    (DM9000_INST * pInst, void* pPacket, unsigned long NumBytes);
N};
N
Nvoid IP_NI_DM9000_ISR_Handler (unsigned Unit);
Nvoid IP_NI_DM9000_ConfigAddr  (unsigned Unit, void* pBase, void* pValue);
Nvoid IP_NI_DM9000_ConfigAccess(unsigned Unit, IP_NI_DM9000_ACCESS * pAccess);
N
Nvoid IP_NI_LAN91C111_ISR_Handler(unsigned Unit);
Nvoid IP_NI_LAN91C111_ConfigAddr (unsigned Unit, void* pBase);
N
Nvoid IP_NI_LAN9115_ISR_Handler   (unsigned Unit);
Nvoid IP_NI_LAN9115_ConfigBaseAddr(unsigned Unit, void* pBase);
N
Nvoid IP_NI_NIOSII_MaCo_ConfigNumRxBuffers(unsigned Unit, U16 NumRxBuffers);
Xvoid IP_NI_NIOSII_MaCo_ConfigNumRxBuffers(unsigned Unit, unsigned short NumRxBuffers);
Nvoid IP_NI_NIOSII_MaCo_ConfigBaseAddr    (unsigned Unit, void* pBase, unsigned IrqNumber);
N
Nvoid IP_NI_GMACII_ConfigBaseAddr(unsigned Unit, void* pBase, unsigned IrqNumber);
N
N/*********************************************************************
N*
N*       PHY configuration
N*/
N#define IP_PHY_MODE_MII  0
N#define IP_PHY_MODE_RMII 1
N
N#define IP_PHY_ADDR_ANY       0xFF                          // IP_PHY_ADDR_ANY is used as PHY addr to initiate automatic scan for PHY
N#define IP_PHY_ADDR_INTERNAL  0xFE                          // IP_PHY_ADDR_INTERNAL is used as PHY addr to select internal PHY
N
Nvoid IP_NI_ConfigPHYAddr (unsigned Unit, U8 Addr);          // Configure PHY Addr (5-bit)
Xvoid IP_NI_ConfigPHYAddr (unsigned Unit, unsigned char Addr);          
Nvoid IP_NI_ConfigPHYMode (unsigned Unit, U8 Mode);          // Configure PHY Mode: 0: MII, 1: RMII
Xvoid IP_NI_ConfigPHYMode (unsigned Unit, unsigned char Mode);          
Nvoid IP_NI_ConfigPoll    (unsigned Unit);
Nvoid IP_NI_SetError      (unsigned Unit);
Nint  IP_NI_SetTxBufferSize(unsigned Unit, unsigned NumBytes);
N
N
N/*********************************************************************
N*
N*       IP stack tasks
N*/
Nvoid IP_Task(void);
Nvoid IP_RxTask(void);
Nvoid IP_ShellServer(void);
N
N
Ntypedef int (IP_RX_HOOK)(IP_PACKET * pPacket);
N
N/*********************************************************************
N*
N*       Core functions
N*/
Nvoid IP_AddBuffers                (int NumBuffers, int BytesPerBuffer);
Nvoid IP_AddEtherInterface         (const IP_HW_DRIVER *pDriver);
Nvoid IP_AllowBackPressure         (char v);
Nvoid IP_AssignMemory              (U32 * pMem, U32 NumBytes);
Xvoid IP_AssignMemory              (unsigned long * pMem, unsigned long NumBytes);
Nvoid IP_ConfTCPSpace              (unsigned SendSpace, unsigned RecvSpace);  // Set window sizes
Nvoid IP_Exec                      (void);
Nvoid IP_GetAddrMask               (U8 IFace, U32 * pAddr, U32 * pMask);
Xvoid IP_GetAddrMask               (unsigned char IFace, unsigned long * pAddr, unsigned long * pMask);
Nint  IP_GetCurrentLinkSpeed       (void);
NU32  IP_GetGWAddr                 (U8 IFace);
Xunsigned long  IP_GetGWAddr                 (unsigned char IFace);
Nvoid IP_GetHWAddr                 (U8 IFace, U8 * pDest, unsigned Len);
Xvoid IP_GetHWAddr                 (unsigned char IFace, unsigned char * pDest, unsigned Len);
NU32  IP_GetIPAddr                 (U8 IFace);
Xunsigned long  IP_GetIPAddr                 (unsigned char IFace);
Nconst char * IP_GetIPPacketInfo   (IP_PACKET * pPacket);
Nint  IP_GetVersion                (void);                   // Format: Mmmrr. Sample 10201 is 1.02a
Nvoid IP_ICMP_SetRxHook            (IP_RX_HOOK * pfRxHook);
Nint  IP_IFaceIsReady              (void);
Nvoid IP_Init                      (void);
Nint  IP_NI_GetCaps                (unsigned Unit);
Nint  IP_NI_LoadHWAddr             (unsigned Unit);
Nvoid IP_Panic                     (const char * sError);
Nvoid IP_SetAddrMask               (U32 Addr, U32 Mask);
Xvoid IP_SetAddrMask               (unsigned long Addr, unsigned long Mask);
Nint  IP_SetCurrentLinkState       (U32 Duplex, U32 Speed);  // Called from driver
Xint  IP_SetCurrentLinkState       (unsigned long Duplex, unsigned long Speed);  
Nvoid IP_SetDefaultTTL             (int v);
Nvoid IP_SetGWAddr                 (U8 IFace, U32 GWAddr);
Xvoid IP_SetGWAddr                 (unsigned char IFace, unsigned long GWAddr);
Nvoid IP_SetHWAddr                 (const U8 * pHWAddr);
Xvoid IP_SetHWAddr                 (const unsigned char * pHWAddr);
Nvoid IP_SetMTU                    (U8 IFace, U32 Mtu);
Xvoid IP_SetMTU                    (unsigned char IFace, unsigned long Mtu);
Nint  IP_SendPacket                (unsigned IFace, void * pData, int NumBytes);
Nint  IP_SendPing                  (ip_addr, char* pData, unsigned NumBytes, U16 SeqNo);
Xint  IP_SendPing                  (ip_addr, char* pData, unsigned NumBytes, unsigned short SeqNo);
Nvoid IP_SetRxHook                 (IP_RX_HOOK * pfRxHook);
Nvoid IP_SOCKET_SetDefaultOptions  (U16 v);
Xvoid IP_SOCKET_SetDefaultOptions  (unsigned short v);
Nvoid IP_SOCKET_SetLimit           (unsigned Limit);
Nvoid IP_TCP_Set2MSLDelay          (unsigned v);
Nvoid IP_TCP_SetConnKeepaliveOpt   (U32 Init, U32 Idle, U32 Period, U32 Cnt);
Xvoid IP_TCP_SetConnKeepaliveOpt   (unsigned long Init, unsigned long Idle, unsigned long Period, unsigned long Cnt);
Nvoid IP_TCP_SetRetransDelayRange  (unsigned RetransDelayMin, unsigned RetransDelayMax);
Nvoid IP_X_Config                  (void);
N
N/*********************************************************************
N*
N*       Log/Warn functions
N*/
Nvoid IP_Log           (const char * s);
Nvoid IP_Warn          (const char * s);
Nvoid IP_SetLogFilter  (U32 FilterMask);
Xvoid IP_SetLogFilter  (unsigned long FilterMask);
Nvoid IP_SetWarnFilter (U32 FilterMask);
Xvoid IP_SetWarnFilter (unsigned long FilterMask);
Nvoid IP_AddLogFilter  (U32 FilterMask);
Xvoid IP_AddLogFilter  (unsigned long FilterMask);
Nvoid IP_AddWarnFilter (U32 FilterMask);
Xvoid IP_AddWarnFilter (unsigned long FilterMask);
N
N
N/*********************************************************************
N*
N*       DNS (Domain name system)
N*
N*  Name resolution
N*/
N// Description of data base entry for a single host.
Nstruct hostent {
N  char *  h_name;        // Official name of host.
N  char ** h_aliases;     // Alias list.
N  int     h_addrtype;    // Host address type.
N  int     h_length;      // Length of address.
N  char ** h_addr_list;   // List of addresses from name server.
N#define h_addr h_addr_list[0] /* Address, for backward compatibility.  */
N#ifdef DNS_CLIENT_UPDT
S  // Extra variables passed in to Dynamic DNS updates.
S  char *  h_z_name;      // IN- zone name for UPDATE packet.
S  ip_addr h_add_ipaddr;  // IN- add this ip address for host name in zone.
S  U32     h_ttl;         // IN- time-to-live field for UPDATE packet.
N#endif
N};
N
N
Nstruct hostent * gethostbyname (char * name);
Nint              IP_ResolveHost(char * host, ip_addr *   address,  int   flags);
Nvoid             IP_DNS_SetServer (U32 DNSServerAddr);
Xvoid             IP_DNS_SetServer (unsigned long DNSServerAddr);
NU32              IP_DNS_GetServer (void);
Xunsigned long              IP_DNS_GetServer (void);
Nint              IP_DNS_SetServerEx (U8 IFace, U8 DNSServer, const U8 * pDNSAddr, int AddrLen);
Xint              IP_DNS_SetServerEx (unsigned char IFace, unsigned char DNSServer, const unsigned char * pDNSAddr, int AddrLen);
Nvoid             IP_DNS_GetServerEx (U8 IFace, U8 DNSServer, U8 * pDNSAddr, int * pAddrLen);
Xvoid             IP_DNS_GetServerEx (unsigned char IFace, unsigned char DNSServer, unsigned char * pDNSAddr, int * pAddrLen);
Nchar           * IP_ParseIPAddr(ip_addr * ipout,  unsigned *  sbits, char *   stringin);
Nvoid             IP_DNSC_SetMaxTTL(U32 TTL);
Xvoid             IP_DNSC_SetMaxTTL(unsigned long TTL);
N
N
N/*********************************************************************
N*
N*       Utility functions
N*
N* RS: Maybe we should move them into a UTIL module some time ? (We can keep macros here for compatibility)
N*/
NI32  IP_BringInBounds(I32 v, I32 Min, I32 Max);
Xsigned long  IP_BringInBounds(signed long v, signed long Min, signed long Max);
NU32  IP_LoadU32BE(const U8 * pData);
Xunsigned long  IP_LoadU32BE(const unsigned char * pData);
NU32  IP_LoadU32LE(const U8 * pData);
Xunsigned long  IP_LoadU32LE(const unsigned char * pData);
NU32  IP_LoadU32TE(const U8 * pData);
Xunsigned long  IP_LoadU32TE(const unsigned char * pData);
NU32  IP_LoadU16BE(const U8 * pData);
Xunsigned long  IP_LoadU16BE(const unsigned char * pData);
NU32  IP_LoadU16LE(const U8 * pData);
Xunsigned long  IP_LoadU16LE(const unsigned char * pData);
Nvoid IP_StoreU32BE(U8 * p, U32 v);
Xvoid IP_StoreU32BE(unsigned char * p, unsigned long v);
Nvoid IP_StoreU32LE(U8 * p, U32 v);
Xvoid IP_StoreU32LE(unsigned char * p, unsigned long v);
N
Nchar IP_tolower(char c);
Nchar IP_isalpha(char c);
Nchar IP_isalnum(char c);
Nint  IP_PrintIPAddr(char * pDest, U32 IPAddr, int BufferSize);
Xint  IP_PrintIPAddr(char * pDest, unsigned long IPAddr, int BufferSize);
N
N
N
N/*********************************************************************
N*
N*       UDP
N*/
Ntypedef  struct udp_conn * UDPCONN;
Ntypedef  U32 IP_ADDR;
Xtypedef  unsigned long IP_ADDR;
N
N#define IP_RX_ERROR        -1
N#define IP_OK               0
N#define IP_OK_KEEP_PACKET   1
N
Ntypedef UDPCONN IP_UDP_CONN;
N
NIP_UDP_CONN IP_UDP_Open(IP_ADDR IPAddr, U16 fport, U16 lport, int(*)(IP_PACKET *, void * pContext) , void * pContext);
XIP_UDP_CONN IP_UDP_Open(IP_ADDR IPAddr, unsigned short fport, unsigned short lport, int(*)(IP_PACKET *, void * pContext) , void * pContext);
Nvoid        IP_UDP_Close(IP_UDP_CONN);
NIP_PACKET * IP_UDP_Alloc(int NumBytes);
Nint         IP_UDP_Send       (int IFace, IP_ADDR FHost, U16 fport, U16 lport, IP_PACKET * pPacket);
Xint         IP_UDP_Send       (int IFace, IP_ADDR FHost, unsigned short fport, unsigned short lport, IP_PACKET * pPacket);
Nint         IP_UDP_SendAndFree(int IFace, IP_ADDR FHost, U16 fport, U16 lport, IP_PACKET * pPacket);
Xint         IP_UDP_SendAndFree(int IFace, IP_ADDR FHost, unsigned short fport, unsigned short lport, IP_PACKET * pPacket);
Nvoid        IP_UDP_Free       (IP_PACKET * pPacket);
NU16         IP_UDP_FindFreePort(void);
Xunsigned short         IP_UDP_FindFreePort(void);
NU16         IP_UDP_GetLPort  (const IP_PACKET *pPacket);
Xunsigned short         IP_UDP_GetLPort  (const IP_PACKET *pPacket);
Nvoid *      IP_UDP_GetDataPtr(const IP_PACKET *pPacket);
Nvoid        IP_UDP_GetSrcAddr(const IP_PACKET *pPacket, void * pSrcAddr, int AddrLen);
N
Nvoid        IP_UDP_EnableRxChecksum(void);
Nvoid        IP_UDP_DisableRxChecksum(void);
Nvoid        IP_UDP_EnableTxChecksum(void);
Nvoid        IP_UDP_DisableTxChecksum(void);
N
N
N/*********************************************************************
N*
N*       TCP Zero copy
N*/
NIP_PACKET * IP_TCP_Alloc      (int datasize);
Nvoid        IP_TCP_Free       (        IP_PACKET * pPacket);
Nint         IP_TCP_Send       (long s, IP_PACKET * pPacket);
Nint         IP_TCP_SendAndFree(long s, IP_PACKET * pPacket);
N
N/*********************************************************************
N*
N*       IP_DHCPC_...
N*
N*  DHCP (Dynamic host configuration protocol) functions.
N*/
Nvoid     IP_DHCPC_Activate   (int IFIndex, const char *sHost, const char *sDomain, const char *sVendor);
Nunsigned IP_DHCPC_GetState   (int IFIndex);
Nvoid     IP_DHCPC_Halt       (int IFIndex);
Nvoid     IP_DHCPC_SetCallback(int IFIndex, int (*routine)(int,int) );
Nvoid     IP_DHCPC_SetClientId(int IFIndex, const char *sClientId);
N
N
N/*********************************************************************
N*
N*       IP_Show_...
N*
N*  Text output functions informing about the state of various components of the software
N*/
Nint IP_ShowARP       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowICMP      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowTCP       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowBSDConn   (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowBSDSend   (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowBSDRcv    (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowMBuf      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowMBufList  (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowSocketList(void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowStat      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowUDP       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowUDPSockets(void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowDHCPClient(void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowDNS       (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
Nint IP_ShowDNS1      (void (*pfSendf)(void * pContext, const char * sFormat, ...), void * pContext);
N
N
Ntypedef struct {
N  long Socket;
N  char * pBuffer;
N  int BufferSize;
N} IP_SENDF_CONTEXT;
N
Nvoid IP_Sendf(void * pContext, const char * sFormat, ...);
N
N/*********************************************************************
N*
N*       IP_CONNECTION information
N*
N*/
N
N#define IP_CONNECTION_TYPE_TCP 1
N
Ntypedef void * IP_CONNECTION_HANDLE;
Ntypedef struct {
N  void * pSock;
N  long hSock;
N  U32  ForeignAddr;
X  unsigned long  ForeignAddr;
N  U32  LocalAddr;
X  unsigned long  LocalAddr;
N  U16  ForeignPort;
X  unsigned short  ForeignPort;
N  U16  LocalPort;
X  unsigned short  LocalPort;
N  U8   Type;
X  unsigned char   Type;
N  U8   TcpState;
X  unsigned char   TcpState;
N  U16  TcpMtu;
X  unsigned short  TcpMtu;
N  U16  TcpMss;
X  unsigned short  TcpMss;
N  U32  TcpRetransDelay;
X  unsigned long  TcpRetransDelay;
N  U32  TcpIdleTime;
X  unsigned long  TcpIdleTime;
N  U32  RxWindowCur;
X  unsigned long  RxWindowCur;
N  U32  RxWindowMax;
X  unsigned long  RxWindowMax;
N  U32  TxWindow;
X  unsigned long  TxWindow;
N} IP_CONNECTION;
N
Nint IP_INFO_GetConnectionList(IP_CONNECTION_HANDLE *pDest, int MaxItems);
Nint IP_INFO_GetConnectionInfo(IP_CONNECTION_HANDLE h, IP_CONNECTION * p);
Nconst char * IP_INFO_ConnectionType2String(U8 Type);
Xconst char * IP_INFO_ConnectionType2String(unsigned char Type);
Nconst char * IP_INFO_ConnectionState2String(U8 State);
Xconst char * IP_INFO_ConnectionState2String(unsigned char State);
N
N#if defined(__cplusplus)
X#if 0L
S  }              // Make sure we have C-declarations in C++ programs
N#endif
N
N#endif   // Avoid multiple inclusion
N
N
N
L 24 "GUI\GUI_VNC_X_StartServer.c" 2
N#include "RTOS.H"     // embOS header
L 1 "OS\RTOS.H" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile    : RTOS.h
NPurpose : include file for embOS,
N          to be included in every C-module accessing embOS-routines
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef RTOS_H_INCLUDED        /* Avoid multiple inclusion          */
N#define RTOS_H_INCLUDED
N
N/*********************************************************************
N*
N*       Chip specifics for ARM7TDMI / ARM9TDMI and KEIL ARM MDK
N*
N**********************************************************************
N*/
N
N#include <string.h>                            /* req. for memset.h */
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 30 "OS\RTOS.H" 2
N
N/*********************************************************************
N*
N*     Specifics for ARM cores and KEIL-MDK compiler
N*
N**********************************************************************
N*/
N
N#define OS_PORT_REVISION          (1)                // Port specific revision
N#define OS_PTR_OP_IS_ATOMIC       (1)
N#define OS_GetTime()              (OS_Time)
N#define OS_GetTime32()            (OS_Time)
N#define OS_I32                    int
N#define OS_SIZEOF_INT             (4)                // Size of integer in bytes
N#define OS_BIG_ENDIAN             (0)                
N#define OS_SUPPORT_SYSSTACK_INFO  (1)                // Option to supply more info  to viewer
N#define OS_SUPPORT_OS_ALLOC       (1)                // Define whether OS_Alloc is supported
N#define OS_SP_ADJUST              (0)
N#define OS_EnterIntStack()                           // Int stack is automatically used by ARM
N#define OS_LeaveIntStack()                           // Int stack is automatically used by ARM
N
N/*****  Core specific configuration *********************************/
N
N#define OS_SUPPORT_INTSTACK_INFO            (1)      // Option to supply more info  to viewer
N#define OS_SWITCH_FROM_INT_MODIFIES_STACK   (1)
N#define OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY (0)
N#define OS_SUPPORT_INT_PRIORITY             (0)              // No selectable interrupt priorities with ARM
N
N/*****  End of configuration settings *******************************/
N
N#ifdef __TARGET_ARCH_4T
N  #define OS_CPU "ARM4/KEIL_MDK"
N#else
S  #define OS_CPU "ARM5/KEIL_MDK"
N#endif
N
N#define OS_DI() __disable_irq()    /* We use the default intrinsic function */
N#define OS_EI() __enable_irq()     /* We use the default intrinsic function */
N
N
N/* Option to get Stack pointer information  */
N#define OS_INIT_STACK_INFO()
N
N/*********************************************************************
N*
N*       Port specific (non OS generic) functions
N*/
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N  typedef void    OS_ISR_HANDLER(void);
N  void            OS_irq_handler(void);     /* Declare function to make sure it is arm pcs */
N  void            OS_IRQ_SERVICE(void);     /* embOS int handler in RTOSVect.asm  */
N  void            OS_USER_irq_func(void);   /* User interrupt handler from UserIrq.c */
N  OS_ISR_HANDLER* OS_ARM_InstallISRHandler (int ISRIndex, OS_ISR_HANDLER* pFunc);
N  void            OS_ARM_EnableISR         (int ISRIndex);
N  void            OS_ARM_DisableISR        (int ISRIndex);
N  int             OS_ARM_ISRSetPrio        (int ISRIndex, int Prio);
N  void            OS_ARM_AssignISRSource   (int ISRIndex, int Source);
N  void            OS_ARM_EnableISRSource   (int SourceIndex);
N  void            OS_ARM_DisableISRSource  (int SourceIndex);
N  void            OS_StartTask             (void);
N  void            OS_InitPLL               (void);
N
N/*********************************************************************
N*
N*       Core specific implementation
N*/
N
N/****** Support for ARM VFP *****************************************/
N  
Nextern const struct OS_EXTEND_TASK_CONTEXT OS_VFP_ExtendContext;
N
N/****** Support for ARM MMU and caches ******************************/
N
Nvoid OS_ARM_ICACHE_Enable(void);
Nvoid OS_ARM_DCACHE_Enable(void);
Nvoid OS_ARM_DCACHE_CleanRange     (void* p, unsigned int NumBytes);
Nvoid OS_ARM_DCACHE_InvalidateRange(void* p, unsigned int NumBytes);
Nvoid OS_ARM_CACHE_Sync(void);
N
Nvoid OS_ARM_MMU_Enable(unsigned int* pTranslationTable);
Nvoid OS_ARM_MMU_InitTT(unsigned int* pTranslationTable);
Nvoid OS_ARM_MMU_AddTTEntries(unsigned int* pTranslationTable, unsigned int CacheMode, unsigned int VIndex, unsigned int PIndex, unsigned int NumEntries);
N
Nvoid OS_ARM720_CACHE_Enable(void);
Nvoid OS_ARM720_CACHE_CleanRange(void* p, unsigned int NumBytes);
Nvoid OS_ARM720_CACHE_InvalidateRange(void* p, unsigned int NumBytes);
N
Nvoid OS_ARM720_MMU_Enable(unsigned int* pTranslationTable);
Nvoid OS_ARM720_MMU_InitTT(unsigned int* pTranslationTable);
Nvoid OS_ARM720_MMU_AddTTEntries(unsigned int* pTranslationTable, unsigned int CacheMode, unsigned int VIndex, unsigned int PIndex, unsigned int NumEntries);
N
N#define OS_ARM_CACHEMODE_NC_NB    ((0 << 3) | (0 << 2))
N#define OS_ARM_CACHEMODE_C_NB     ((1 << 3) | (0 << 2))
N#define OS_ARM_CACHEMODE_NC_B     ((0 << 3) | (1 << 2))
N#define OS_ARM_CACHEMODE_C_B      ((1 << 3) | (1 << 2))
N#define OS_ARM_CACHEMODE_ILLEGAL  (0x01)
N
N#ifdef __cplusplus
S  } 
N#endif
N
N/*********************************************************************
N*
N*     Port specific revision
N*/
N
N/*********************************************************************
N*
N*       Check configuration
N*
N**********************************************************************
N
NThis is required in order to automatically create the correct identifiers
Nin order to be able to autoamitcally remap the identifiers.
N
N*/
N
N#ifdef __thumb
N  #define OS_CPUMODE_PREFIX "T"
N#else
S  #define OS_CPUMODE_PREFIX "A"
N#endif
N
N#ifdef __TARGET_ARCH_4T
N  #define OS_CPU_PREFIX "4"
N#else
S  #define OS_CPU_PREFIX "5"
N#endif
N
N#ifdef __BIG_ENDIAN
S  #define OS_ENDIAN_PREFIX "B"
N#else
N  #define OS_ENDIAN_PREFIX "L"
N#endif
N
N#define OS_MODEL OS_CPUMODE_PREFIX OS_CPU_PREFIX OS_ENDIAN_PREFIX
N
N
N/****** End of chip / compiler specific part ************************/
N
N/*********************************************************************
N*
N*       Generic portion of the OS starts here
N*
N**********************************************************************
NThis file (original name OS_RAW.h) is part of RTOS.h, the include
Nfile for the OS.
N*/
N
N#if (!defined(OS_LIBMODE_XR) && !defined(OS_LIBMODE_R)  &&   \
N     !defined(OS_LIBMODE_S)  && !defined(OS_LIBMODE_SP) &&   \
N     !defined(OS_LIBMODE_D)  && !defined(OS_LIBMODE_DP) &&   \
N     !defined(OS_LIBMODE_DT))
X#if (!0L && !0L  &&        !0L  && !0L &&        !0L  && !0L &&        !0L)
N#include "OS_Config.h"
L 1 "Config\OS_Config.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef OS_CONFIG_H                     /* Avoid multiple inclusion */
N#define OS_CONFIG_H
N
N/*********************************************************************
N*
N*       Configuration for RTOS build and UART
N*
N*  One of the following builds needs to be selected for both DEBUG and Release builds:
N*
N*  OS_LIBMODE_XR    Extremly small release build without Round robin
N*  OS_LIBMODE_R     Release build
N*  OS_LIBMODE_S     Release build with stack check
N*  OS_LIBMODE_SP    Release build with stack check and profiling
N*  OS_LIBMODE_D     Debug build
N*  OS_LIBMODE_DP    Debug build with profiling
N*  OS_LIBMODE_DT    Debug build with trace
N*/
N
N#ifndef   DEBUG
S  #define DEBUG 0
N#endif
N
N#if DEBUG
X#if 1
N  #define OS_LIBMODE_DP
N#else
S  #define OS_LIBMODE_R
S  #define OS_VIEW_ENABLE   0
N#endif
N
N#endif                                  /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 187 "OS\RTOS.H" 2
N#endif
N
N#define OS_VERSION_GENERIC (36004)      /*   Generic version 3.60d  */
N
N#ifndef   OS_PORT_REVISION
S  #define OS_PORT_REVISION 0
N#endif
N
N#define OS_VERSION OS_VERSION_GENERIC + (OS_PORT_REVISION * 25)
N
N/*********************************************************************
N*
N*       Defines for library types
N*
N**********************************************************************
N*/
N
N/* If library type is not selected yet (on project level,
N   for example), then select DP by default
N*/
N#if (!defined(OS_LIBMODE_XR) && !defined(OS_LIBMODE_R)  &&   \
N     !defined(OS_LIBMODE_S)  && !defined(OS_LIBMODE_SP) &&   \
N     !defined(OS_LIBMODE_D)  && !defined(OS_LIBMODE_DP) &&   \
N     !defined(OS_LIBMODE_DT))
X#if (!0L && !0L  &&        !0L  && !0L &&        !0L  && !1L &&        !0L)
S#define OS_LIBMODE_DP
N#endif
N
N#if defined(OS_LIBMODE_XR)                                   // Extremely small release - without Round robin support
X#if 0L                                   
S  #define OS_CHECKSTACK       0
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_RR_SUPPORTED     0
S  #define OS_TRACKNAME        0
S  #define OS_SUPPORT_SAVE_RESTORE_HOOK 0
S  #define OS_CreateTask   OS_CreateTask_XR
S  #define OS_CreateTaskEx OS_CreateTaskEx_XR
S  #define OS_LIBMODE "XR"
S#elif defined(OS_LIBMODE_R)                                  // Release build
X#elif 0L                                  
S  #define OS_CHECKSTACK       0
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_R
S  #define OS_CreateTaskEx OS_CreateTaskEx_R
S  #define OS_LIBMODE "R"
S#elif defined(OS_LIBMODE_S)                                  // Release build with stack check
X#elif 0L                                  
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            0
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 0
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_S
S  #define OS_CreateTaskEx OS_CreateTaskEx_S
S  #define OS_LIBMODE "S"
S#elif defined(OS_LIBMODE_SP)                                 // Release build with stack check and profiling
X#elif 0L                                 
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            0
S  #define OS_PROFILE          1
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_SP
S  #define OS_CreateTaskEx OS_CreateTaskEx_SP
S  #define OS_LIBMODE "SP"
S#elif defined(OS_LIBMODE_D)                                  // Debug build
X#elif 0L                                  
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            1
S  #define OS_PROFILE          0
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            0
S  #define OS_CreateTask   OS_CreateTask_D
S  #define OS_CreateTaskEx OS_CreateTaskEx_D
S  #define OS_LIBMODE "D"
N#elif defined(OS_LIBMODE_DP)                                  // Debug build with profiling
X#elif 1L                                  
N  #define OS_CHECKSTACK       1
N  #define OS_PROFILE          1
N  #define OS_DEBUG            1
N  #define OS_SUPPORT_TICKSTEP 1
N  #define OS_TRACE            0
N  #define OS_CreateTask   OS_CreateTask_DP
N  #define OS_CreateTaskEx OS_CreateTaskEx_DP
N  #define OS_LIBMODE "DP"
N#elif defined(OS_LIBMODE_DT)                                  // Debug build with profiling and trace
S  #define OS_CHECKSTACK       1
S  #define OS_DEBUG            1
S  #define OS_PROFILE          1
S  #define OS_SUPPORT_TICKSTEP 1
S  #define OS_TRACE            1
S  #define OS_CreateTask   OS_CreateTask_DT
S  #define OS_CreateTaskEx OS_CreateTaskEx_DT
S  #define OS_LIBMODE "DT"
S#else
S  #error Please define library type used !
N#endif
N
N/*********************************************************************
N*
N*       OS compile time switches
N*
N**********************************************************************
N
NThese compile time switches can be modified when recompiling
Nthe library. Usually, the values are in OSCHIP.H, which is then
Nmerged with OS_RAW.H to form RTOS.H.
NIf the values are not defined in OSCHIP.H, the default values
Nbelow are used.
N*/
N
N/* Make it possible to place const data in RAM via
N   define and therefore via command line. This is required
N   for some smaller CPUs in small memory models
N   It is defined to be "const" by default, but can be defined to nothing
N   by simply adding a -DOS_CONST_DATA on the commandline
N*/
N
N#ifndef   OS_CONST_DATA
N  #define OS_CONST_DATA const  /* Default      */
N#else
S  #undef  OS_CONST_DATA
S  #define OS_CONST_DATA        /* define blank */
N#endif
N
N#ifndef   OS_INTERWORK
N  #define OS_INTERWORK
N#endif
N
N#ifndef   OS_SCHEDULER_ACTIVATED_BY_EXCEPTION
N  #define OS_SCHEDULER_ACTIVATED_BY_EXCEPTION   (0)
N#endif
N
N#ifndef   OS_STACK_ADR
N  #define OS_STACK_ADR OS_U32
N#endif
N
N#ifndef   OS_MODEL
S  #define OS_MODEL ""
N#endif
N
N#ifndef   OS_MEMSET
N  #define OS_MEMSET(a,v,s) memset(a,v,s)
N#endif
N
N#ifndef   OS_MEMCPY
N  #define OS_MEMCPY(dest,src,cnt) memcpy(dest,src,cnt)
N#endif
N
N#ifndef   OS_STRLEN
N  #define OS_STRLEN(s) strlen(s)
N#endif
N
N#ifndef   OS_DUMMY_STATEMENT
N  #define OS_DUMMY_STATEMENT()
N#endif
N
N#ifndef   OS_USEPARA
N  #define OS_USEPARA(para) para=para
N#endif
N
N#ifndef   OS_SUPPORT_TICKSTEP
S  #define OS_SUPPORT_TICKSTEP 0
N#endif
N
N#ifndef   OS_TRACKNAME
N  #define OS_TRACKNAME (1)
N#endif
N
N#ifndef   OS_TRACE
S  #define OS_TRACE (0)
N#endif
N
N#ifndef   OS_SUPPORT_SAVE_RESTORE_HOOK
N  #define OS_SUPPORT_SAVE_RESTORE_HOOK  (1)
N#endif
N
N#ifndef   OS_RR_SUPPORTED
N  #define OS_RR_SUPPORTED (1)
N#endif
N
N#ifndef   OS_STACK_AT_BOTTOM
N  #define OS_STACK_AT_BOTTOM (0)
N#endif
N
N/*  Settings for NON-ANSI compiler syntax
N    The default behaviour complies with IAR.
N*/
N#ifndef   OS_COMPILER_LOCATION_LEFT
N  #define OS_COMPILER_LOCATION_LEFT 1  /* (req. for IAR) */
N#endif
N
N#ifndef   OS_COMPILER_STORAGE_MODIFIER_LEFT
N  #define OS_COMPILER_STORAGE_MODIFIER_LEFT 1  /* default for all except KEIL */
N#endif
N
N#define OS_LINK_MAILBOXES (OS_DEBUG)
N
N#ifndef   OS_CHECK
N  #define OS_CHECK 0
N#endif
N
N#ifndef   OS_ALIGN_PTR
N  #define OS_ALIGN_PTR (1)
N#endif
N
N#ifndef   OS_ALIGN_INT
N  #define OS_ALIGN_INT (1)
N#endif
N
N#ifndef   OS_PTR_TO_VALUE
N  #define OS_PTR_TO_VALUE(p) (p)
N#endif
N
N#ifndef   OS_IDLE
N  #define OS_IDLE() OS_Idle()
N#endif
N
N#ifndef   OS_PTR_OP_IS_ATOMIC
S  #define OS_PTR_OP_IS_ATOMIC   (0)         // Helps to minimize code size and execution time. Some code is not required if setting pointers is an atomic operation (32 bit CPUs or 16 bit CPUs in near model)
N#endif
N
N#ifndef   OS_SUSPEND_TASK_ON_TERMINATE      // Sets the task state of a terminated task to "suspended". Primarily used in the OS simulation, because the windows scheduler might re-activate a suspended task
N  #define OS_SUSPEND_TASK_ON_TERMINATE (0)
N#endif
N
N#ifndef   OS_INIT_EXPLICITLY
N  #define OS_INIT_EXPLICITLY  (0)           // If enabled, OS_InitKern() initializes Non-Zero globals. Required only for faulty compiler (or startup-code) which do not perform proper init of globals during startup.
N#endif
N
N#ifndef   OS_TASK_LIST_HAS_PPREV
N  #define OS_TASK_LIST_HAS_PPREV   OS_RR_SUPPORTED
N#else
S  #if (OS_TASK_LIST_HAS_PPREV == 0) && OS_RR_SUPPORTED
S    #error  "Invalid combination of config switches"
S  #endif
N#endif
N
N#ifndef   OS_SUPPORT_CALL_ISR
N  #define OS_SUPPORT_CALL_ISR (1)
N#endif
N
N#ifndef   OS_PREPARE_STACKPOINTER
N  #define OS_PREPARE_STACKPOINTER()
N#endif
N
N#ifndef   OS_SUPPORT_POWER
N  #define OS_SUPPORT_POWER (1)
N#endif
N
N#ifndef   OS_POWER_NUM_COUNTERS
N  #define OS_POWER_NUM_COUNTERS (5)
N#endif
N
N/*********************************************************************
N*
N*       Check Compile time switches
N*
N**********************************************************************
N*/
N
N#ifndef OS_SIZEOF_INT
S  #error "Please define OS_SIZEOF_INT (OSChip.h)"
N#endif
N#ifndef OS_BIG_ENDIAN
S  #error "Please define OS_BIG_ENDIAN (OSChip.h)"
N#endif
N
N#if (OS_STACK_AT_BOTTOM != 0) && (OS_STACK_AT_BOTTOM != 1)
X#if ((0) != 0) && ((0) != 1)
S  /*
S  *  Only 0 or 1 is allowed, because OS_STACK_AT_BOTTOM is used for calculations!
S  */
S  #error "OS_STACK_AT_BOTTOM has to be defined to 0 or 1"
N#endif
N
N/*********************************************************************
N*
N*       Basic type defines
N*
N**********************************************************************
N*/
N
N#ifndef   OS_I8
N  #define OS_I8 signed char
N#endif
N
N#ifndef   OS_U8
N  #define OS_U8 unsigned char
N#endif
N
N#ifndef   OS_I16
N  #define OS_I16 signed short
N#endif
N
N#ifndef   OS_U16
N  #define OS_U16 unsigned short
N#endif
N
N#ifndef   OS_I32
S  #define OS_I32 long
N#endif
N
N#ifndef   OS_U32
N  #define OS_U32 unsigned OS_I32
N#endif
N
N/* Defines a true integer. This type is guaranteed
N   a) to have at least 8 bits,
N   b) to compile and execute best on the target CPU
N   It will normally be the same as an int, but on most
N   8-bit CPUs it will be replaced by a character because
N   the CPU can deal with 8 bits more efficient than with
N   16 bit integers.
N   Use with care !
N*/
N#ifndef   OS_INT
N  #define OS_INT       int
N#endif
N
N#ifndef   OS_UINT
N  #define OS_UINT      unsigned OS_INT
N#endif
N
N#ifndef   OS_TIME
N  #define OS_TIME      int
N#endif
N
N
N/*********************************************************************
N*
N*       Error codes
N*
N**********************************************************************
N*/
N
N/* User 0..99  ***********************************/
N
N/* Port 100..119 *********************************/
N#define OS_ERR_ISR_INDEX                      (100)
N#define OS_ERR_ISR_VECTOR                     (101)
N#define OS_ERR_ISR_PRIO                       (102)
N
N/* OS generic ************************************/
N/* stack overflow or invalid stack */
N#define OS_ERR_STACK                          (120)
N
N/* Counting semaphore overflow */
N#define OS_ERR_CSEMA_OVERFLOW                 (121)
N
N/* Power management module */
N#define OS_ERR_POWER_OVER                     (122)
N#define OS_ERR_POWER_UNDER                    (123)
N#define OS_ERR_POWER_INDEX                    (124)
N
N
N/* invalid or non-initialized data structures */
N#define OS_ERR_INV_TASK                       (128)
N#define OS_ERR_INV_TIMER                      (129)
N#define OS_ERR_INV_MAILBOX                    (130)
N#define OS_ERR_INV_CSEMA                      (132)
N#define OS_ERR_INV_RSEMA                      (133)
N
N/* Using GetMail1 or PutMail1 or GetMailCond1 or PutMailCond1 on
N   a non-1 byte mailbox  */
N#define OS_ERR_MAILBOX_NOT1                   (135)
N
N/* Waitable objects deleted with waiting tasks or occupied by task */
N#define OS_ERR_MAILBOX_DELETE                 (136)
N#define OS_ERR_CSEMA_DELETE                   (137)
N#define OS_ERR_RSEMA_DELETE                   (138)
N
N/* internal errors, please contact SEGGER Microcontrollersysteme */
N#define OS_ERR_MAILBOX_NOT_IN_LIST            (140)
N#define OS_ERR_TASKLIST_CORRUPT               (142)
N
N/* not matching routine calls or macro usage */
N#define OS_ERR_UNUSE_BEFORE_USE               (150)
N#define OS_ERR_LEAVEREGION_BEFORE_ENTERREGION (151)
N#define OS_ERR_LEAVEINT                       (152)
N#define OS_ERR_DICNT                          (153)
N#define OS_ERR_INTERRUPT_DISABLED             (154)
N#define OS_ERR_TASK_ENDS_WITHOUT_TERMINATE    (155)
N#define OS_ERR_RESOURCE_OWNER                 (156)
N
N#define OS_ERR_ILLEGAL_IN_ISR                 (160)  /* not a legal system call during interrupt */
N#define OS_ERR_ILLEGAL_IN_TIMER               (161)  /* not a legal system call during timer */
N#define OS_ERR_ILLEGAL_OUT_ISR                (162)  /* not a legal system call outside interrupt */
N#define OS_ERR_NOT_IN_ISR                     (163)  /* OS_EnterInterrupt() has been called, but CPU is not in ISR state */
N#define OS_ERR_IN_ISR                         (164)  /* OS_EnterInterrupt() has not been called, but CPU is in ISR state */
N
N#define OS_ERR_INIT_NOT_CALLED                (165)  /* OS_InitKern() was not called */
N
N/* Double used data structures */
N#define OS_ERR_2USE_TASK                      (170)
N#define OS_ERR_2USE_TIMER                     (171)
N#define OS_ERR_2USE_MAILBOX                   (172)
N#define OS_ERR_2USE_BSEMA                     (173)
N#define OS_ERR_2USE_CSEMA                     (174)
N#define OS_ERR_2USE_RSEMA                     (175)
N#define OS_ERR_2USE_MEMF                      (176)
N
N/* Communication errors (OSCOM) */
N#define OS_ERR_NESTED_RX_INT                  (180)
N
N/* Fixed block memory pool  */
N#define OS_ERR_MEMF_INV                       (190)
N#define OS_ERR_MEMF_INV_PTR                   (191)
N#define OS_ERR_MEMF_PTR_FREE                  (192)
N#define OS_ERR_MEMF_RELEASE                   (193)
N#define OS_ERR_POOLADDR                       (194)
N#define OS_ERR_BLOCKSIZE                      (195)
N
N/* Task suspend / resume errors */
N#define OS_ERR_SUSPEND_TOO_OFTEN              (200)
N#define OS_ERR_RESUME_BEFORE_SUSPEND          (201)
N
N/* Other task related errors */
N#define OS_ERR_TASK_PRIORITY                  (202)
N
N/* Event object */
N#define OS_ERR_EVENT_INVALID                  (210)
N#define OS_ERR_2USE_EVENTOBJ                  (211)
N#define OS_ERR_EVENT_DELETE                   (212)
N
N/* Waitlist (checked build) */
N#define OS_ERR_WAITLIST_RING                  (220)
N#define OS_ERR_WAITLIST_PREV                  (221)
N#define OS_ERR_WAITLIST_NEXT                  (222)
N
N/* Other potential problems discovered in checked build */
N#define OS_ERR_NOT_IN_REGION                  (225)
N
N/* Cache related */
N#define OS_ERR_NON_ALIGNED_INVALIDATE         (230)
N
N/* OS special build, or internal */
N#define OS_ERR_TRIAL_LIMIT                    (254)
N
N/*********************************************************************
N*
N*       Trace identifier
N*
N**********************************************************************
N
NIdentifier from 0 to 99 are reserved for the OS
NEven when not all of those are currently used,
Nthey may be defined in the future
N
N*/
N
N#define OS_TRACE_ID_DEACTIVATE      (1)
N#define OS_TRACE_ID_ACTIVATE        (2)
N#define OS_TRACE_ID_TIMERCALLBACK   (3)
N
N/* Task group */
N#define OS_TRACE_ID_DELAY           (10)
N#define OS_TRACE_ID_DELAYUNTIL      (11)
N#define OS_TRACE_ID_SETPRIORITY     (12)
N#define OS_TRACE_ID_WAKETASK        (13)
N#define OS_TRACE_ID_CREATETASK      (14)
N#define OS_TRACE_ID_TERMINATETASK   (15)
N#define OS_TRACE_ID_SUSPENDTASK     (16)
N#define OS_TRACE_ID_RESUMETASK      (17)
N#define OS_TRACE_ID_CREATETASK_EX   (18)
N#define OS_TRACE_ID_YIELD           (19)
N
N/* Event group */
N#define OS_TRACE_ID_WAITEVENT       (20)
N#define OS_TRACE_ID_WAITEVENT_TIMED (21)
N#define OS_TRACE_ID_SIGNALEVENT     (22)
N#define OS_TRACE_ID_CLEAREVENTS     (23)
N
N/* Mailbox group  */
N#define OS_TRACE_ID_CREATEMB        (30)
N#define OS_TRACE_ID_CLEARMB         (31)
N#define OS_TRACE_ID_DELETEMB        (32)
N#define OS_TRACE_ID_PUTMAIL         (33)
N#define OS_TRACE_ID_GETMAIL         (34)
N#define OS_TRACE_ID_PUTMAILCOND     (35)
N#define OS_TRACE_ID_GETMAILCOND     (36)
N#define OS_TRACE_ID_PUTMAIL_TIMED   (37)
N#define OS_TRACE_ID_GETMAIL_TIMED   (38)
N#define OS_TRACE_ID_WAITMAIL        (39)
N
N#define OS_TRACE_ID_PUTMAIL1        (40)
N#define OS_TRACE_ID_GETMAIL1        (41)
N#define OS_TRACE_ID_PUTMAILCOND1    (42)
N#define OS_TRACE_ID_GETMAILCOND1    (43)
N#define OS_TRACE_ID_PUTMAIL_TIMED1  (44)
N#define OS_TRACE_ID_GETMAIL_TIMED1  (45)
N
N#define OS_TRACE_ID_PUTMAIL_F       (46)
N#define OS_TRACE_ID_PUTMAIL_F1      (47)
N#define OS_TRACE_ID_PUTMAIL_FCOND   (48)
N#define OS_TRACE_ID_PUTMAIL_FCOND1  (49)
N
N/* Resource group */
N#define OS_TRACE_ID_CREATERSEMA     (50)
N#define OS_TRACE_ID_USE             (51)
N#define OS_TRACE_ID_UNUSE           (52)
N#define OS_TRACE_ID_REQUEST         (53)
N#define OS_TRACE_ID_GETSEMAVALUE    (54)
N#define OS_TRACE_ID_DELETE_RSEMA    (55)
N
N/* Counting Semaphore group */
N#define OS_TRACE_ID_CREATECSEMA     (60)
N#define OS_TRACE_ID_DELETECSEMA     (61)
N#define OS_TRACE_ID_SIGNALCSEMA     (62)
N#define OS_TRACE_ID_WAITCSEMA       (63)
N#define OS_TRACE_ID_WAITCSEMATIMED  (64)
N#define OS_TRACE_ID_SIGNALCSEMA_MAX (65)
N#define OS_TRACE_ID_SET_CSEMAVALUE  (66)
N#define OS_TRACE_ID_CSEMAREQUEST    (67)
N
N/* Timer group    */
N#define OS_TRACE_ID_CREATETIMER     (70)
N#define OS_TRACE_ID_DELETETIMER     (71)
N#define OS_TRACE_ID_STARTTIMER      (72)
N#define OS_TRACE_ID_STOPTIMER       (73)
N#define OS_TRACE_ID_RETRIGGERTIMER  (74)
N#define OS_TRACE_ID_SETTIMERPERIOD  (75)
N#define OS_TRACE_ID_CREATETIMER_EX  (76)
N
N/* Heap type memory management  */
N#define OS_TRACE_ID_MALLOC          (80)
N#define OS_TRACE_ID_FREE            (81)
N#define OS_TRACE_ID_REALLOC         (82)
N
N/* Fixed block type memory management  */
N#define OS_TRACE_ID_MEMF_CREATE     (90)
N#define OS_TRACE_ID_MEMF_DELETE     (91)
N#define OS_TRACE_ID_MEMF_ALLOC      (92)
N
N
N/*********************************************************************
N*
N*       Assertions
N*
N**********************************************************************
N
N  Assertions are used to generate code in the debug version
N  of the OS in order catch programming faults like
N  bad pointers or uninitialized data structures
N*/
N
N#if OS_DEBUG
X#if 1
N  #define OS_ASSERT(Exp, ErrCode) { if (!(Exp)) OS_Error(ErrCode); }
N#else
S  #define OS_ASSERT(Exp, ErrCode)
N#endif
N
N#define OS_ASSERT_INT()           OS_ASSERT((OS_InInt != 0),          OS_ERR_ILLEGAL_OUT_ISR)
N#define OS_ASSERT_NOINT()         OS_ASSERT((OS_InInt == 0),          OS_ERR_ILLEGAL_IN_ISR)
N#define OS_ASSERT_NOTIMER()       OS_ASSERT((OS_InTimer == 0),        OS_ERR_ILLEGAL_IN_TIMER)
N#define OS_ASSERT_DICnt()         OS_ASSERT(((OS_DICnt & 0xf0) == 0), OS_ERR_DICNT)
N#define OS_ASSERT_INIT_CALLED()   OS_ASSERT((OS_InitCalled != 0),     OS_ERR_INIT_NOT_CALLED)
N
N/*********************************************************************
N*
N*       Memory attributes
N*
N**********************************************************************
N*/
N
N#ifndef OS_STACKPTR
N  #define OS_STACKPTR
N#endif
N
N#ifndef OS_SADDR
N  #ifdef SADDR
S    #define OS_SADDR SADDR
N  #else
N    #define OS_SADDR
N  #endif
N#endif
N
N/* pointer modifier for data items */
N#ifndef OS_DATAPTR
N  #define OS_DATAPTR
N#endif
N
N#ifndef OS_RSEMAPTR
N  #define OS_RSEMAPTR
N#endif
N
N#ifndef   OS_CSEMAPTR
N  #define OS_CSEMAPTR
N#endif
N
N#ifndef   OS_MBPTR
N  #define OS_MBPTR
N#endif
N
N#ifndef   OS_TCBPTR
N  #define OS_TCBPTR
N#endif
N
N#ifndef   OS_TIMERPTR
N  #define OS_TIMERPTR
N#endif
N
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N/*********************************************************************
N*
N*       Data structures
N*
N**********************************************************************
N*/
N
Ntypedef struct OS_TASK         OS_TASK;
Ntypedef struct OS_WAIT_LIST    OS_WAIT_LIST;
Ntypedef struct OS_WAIT_OBJ     OS_WAIT_OBJ;
Ntypedef struct OS_WAIT_OBJ_EX  OS_WAIT_OBJ_EX;
Ntypedef struct OS_REGS         OS_REGS;
N
Ntypedef void voidRoutine(void);
Ntypedef void OS_RX_CALLBACK(OS_U8 Data);
Xtypedef void OS_RX_CALLBACK(unsigned char Data);
Ntypedef void OS_TIMERROUTINE(void);
Ntypedef void OS_TIMER_EX_ROUTINE(void *);
Ntypedef void OS_ON_TERMINATE_FUNC(OS_TASK *);
N
Ntypedef void OS_TICK_HOOK_ROUTINE(void);
N
N/**********************************************************************
N*
N*       OS_WAIT_OBJ
N*       OS_WAIT_LIST
N*       OS_WAIT_OBJ_EX
N*/
Nstruct OS_WAIT_OBJ {
N  OS_WAIT_LIST * pWaitList;
N};
N
Nstruct OS_WAIT_OBJ_EX {
N  OS_WAIT_OBJ WaitObj;
N  int v;
N};
N
Nstruct OS_WAIT_LIST {
N  OS_WAIT_LIST * pNext;    /* Needs to be first element ! */
N  OS_WAIT_LIST * pPrev;
N  OS_WAIT_OBJ  * pWaitObj;
N  OS_TASK      * pTask;
N};
N
N
N/**********************************************************************
N*
N*       OS_EXTEND_TASK_CONTEXT
N*
N*  This structure is used to define a save and restore function for
N*  extension of the task context.
N*  A pointer to this structure is part of the task control block
N*  It is initialized by OS_ExtendTaskContext();
N*/
Ntypedef struct OS_EXTEND_TASK_CONTEXT {
N  void (*pfSave)   (      void * pStack);
N  void (*pfRestore)(const void * pStack);
N} OS_EXTEND_TASK_CONTEXT;
N
N
N/**********************************************************************
N*
N*       OS_TASK
N*
N*  This structure (referred to as "task control block" or TCB) holds all relevant information
N*  about a single task. Note that some elements are optional, depending on the compile time
N*  options, especially the type of build
N*/
Nstruct OS_TASK {
N  //
N  // Elements required for all builds
N  //
N  // Start of assembly relevant section. Do not move these elements
N  OS_TASK * pNext;                        // Points to the TCB of the next task in the list (with equal or lower priority). Needs to be first element !
N  OS_REGS OS_STACKPTR * pStack;           // Typically contains the stack pointer if the task is suspended.                 Needs to be second element !
X  OS_REGS  * pStack;           
N  // End of assembly relevant section
N  OS_WAIT_LIST * pWaitList;               // Points to a waitable object if task is suspended.
N  OS_TIME        Timeout;
X  int        Timeout;
N  OS_U8          Priority;
X  unsigned char          Priority;
N  OS_U8          Stat;
X  unsigned char          Stat;
N  OS_U8          Events;                  // Event storage
X  unsigned char          Events;                  
N  OS_U8          EventMask;               // Event mask
X  unsigned char          EventMask;               
N  //
N  // PPrev is required only in builds with doubly-linked task lists
N  //
N  #if OS_TASK_LIST_HAS_PPREV
X  #if (1)
N    OS_TASK      * pPrev;                   //
N  #endif
N  //
N  // Elements required with "Track-name" functionality only. Typically available in all builds, but can be disabled at compile time
N  //
N  #if OS_TRACKNAME
X  #if (1)
N    const char * Name;
N  #endif
N  //
N  // Elements required with "Stack-check" functionality only. Available in stack-check and debug builds.
N  //
N  #if OS_CHECKSTACK
X  #if 1
N    OS_UINT  StackSize;            // Stack size in bytes. Not required for functionality, just for analysis
X    unsigned int  StackSize;            
N    OS_U8 OS_STACKPTR* pStackBot;  // First byte of stack. Not required for functionality, just for analysis
X    unsigned char * pStackBot;  
N  #endif
N  //
N  // Elements required with profiling or debug builds
N  //
N  #if (OS_PROFILE || OS_DEBUG)
X  #if (1 || 1)
N    OS_U32 NumActivations;         // Counts how many times task has been activated
X    unsigned int NumActivations;         
N    OS_U32 NumPreemptions;         // Counts how many times task has been preempted
X    unsigned int NumPreemptions;         
N  #endif
N  //
N  // Elements required with profiling builds
N  //
N  #if OS_PROFILE
X  #if 1
N    OS_U32 ExecTotal;              // Time spent executing
X    unsigned int ExecTotal;              
N    OS_U32 ExecLast;               // Time spent executing (Reference)
X    unsigned int ExecLast;               
N    OS_U32 Load;                   // Profiling builds only:
X    unsigned int Load;                   
N  #endif
N  //
N  // Elements required with Round-robin functionality only. Typically available in all builds, but can be disabled at compile time
N  //
N  #if OS_RR_SUPPORTED
X  #if (1)
N    OS_U8  TimeSliceRem;
X    unsigned char  TimeSliceRem;
N    OS_U8  TimeSliceReload;
X    unsigned char  TimeSliceReload;
N  #endif
N  //
N  // Optional Save & Restore hook support (usually only for bigger CPUs)
N  //
N  #if OS_SUPPORT_SAVE_RESTORE_HOOK
X  #if (1)
N    const OS_EXTEND_TASK_CONTEXT * pExtendContext;
N  #endif
N  //
N  // Elements required with debug builds
N  //
N  #if OS_DEBUG
X  #if 1
N    char Id;                       // Debug builds only: Id of this control block.
N  #endif
N  //
N  // Allow port specific extension to the task control block. Not used in most ports
N  //
N  #ifdef OS_TCB_CPU_EX
S    OS_TCB_CPU_EX
N  #endif
N};
N
N/**********************************************************************
N*
N*       OS_TIMER
N*/
Ntypedef struct OS_timer OS_TIMER;
Nstruct OS_timer {
N  OS_TIMER * pNext;
N  voidRoutine* Hook;
N  OS_TIME Time;
X  int Time;
N  OS_TIME Period;
X  int Period;
N  char    Active;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_TIMER_EX
N*/
Ntypedef struct {
N  OS_TIMER Timer;
N  OS_TIMER_EX_ROUTINE * pfUser;
N  void * pData;
N} OS_TIMER_EX;
N
N/**********************************************************************
N*
N*       OS_TICK_HOOK
N*/
Ntypedef struct OS_TICK_HOOK OS_TICK_HOOK;
Nstruct OS_TICK_HOOK {
N  OS_TICK_HOOK*          pNext;
N  OS_TICK_HOOK_ROUTINE * pfUser;
N};
N
N/**********************************************************************
N*
N*       OS_RSEMA
N*/
Ntypedef struct OS_RSEMA OS_RSEMA;
Nstruct OS_RSEMA {
N  OS_WAIT_OBJ WaitObj;
N  OS_TASK * pTask;                /* Owner */
N  OS_U8 UseCnt;
X  unsigned char UseCnt;
N  OS_RSEMA * pNext;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_CSEMA
N*/
Ntypedef struct OS_CSEMA OS_CSEMA;
Nstruct OS_CSEMA {
N  OS_WAIT_OBJ WaitObj;
N  OS_UINT Cnt;
X  unsigned int Cnt;
N#if OS_DEBUG
X#if 1
N  OS_CSEMA * pNext;
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_MAILBOX
N*/
Ntypedef struct OS_MAILBOX OS_MAILBOX;
Nstruct OS_MAILBOX {
N  OS_WAIT_OBJ WaitObj;
N#if OS_LINK_MAILBOXES
X#if (1)
N  OS_MAILBOX * pNext;
N#endif
N  char *pData;
N  OS_UINT nofMsg;
X  unsigned int nofMsg;
N  OS_UINT maxMsg;
X  unsigned int maxMsg;
N  OS_UINT iRd;
X  unsigned int iRd;
N  OS_U8  sizeofMsg;
X  unsigned char  sizeofMsg;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_Q
N*/
Ntypedef struct OS_Q OS_Q;
Nstruct OS_Q {
N  OS_WAIT_OBJ WaitObj;
N  OS_Q*    pNext;          /* ptr to next queue (for debugging / monitoring) */
N  OS_U8*   pData;
X  unsigned char*   pData;
N  OS_UINT  Size;
X  unsigned int  Size;
N  OS_UINT  MsgCnt;
X  unsigned int  MsgCnt;
N  OS_UINT  offFirst;
X  unsigned int  offFirst;
N  OS_UINT  offLast;
X  unsigned int  offLast;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_MEMF
N*/
N#ifndef   OS_MEMF_MAX_ITEMS
N  #define OS_MEMF_MAX_ITEMS 20
N#endif
N
N#define OS_MEMF_SIZEOF_BLOCKCONTROL 0  /* sizeof(int) in future version for debugging */
N
Ntypedef struct OS_MEMF OS_MEMF;
Nstruct OS_MEMF {
N  OS_WAIT_OBJ WaitObj;
N  OS_MEMF* pNext;          /* ptr to next memory pool */
N  void*    pPool;
N  OS_U16   NumBlocks;
X  unsigned short   NumBlocks;
N  OS_U16   BlockSize;
X  unsigned short   BlockSize;
N  OS_U16   NumFreeBlocks;
X  unsigned short   NumFreeBlocks;
N  OS_U16   MaxUsed;
X  unsigned short   MaxUsed;
N  void*    pFree;
N  #if OS_DEBUG
X  #if 1
N    int  aiPurpose[OS_MEMF_MAX_ITEMS];
X    int  aiPurpose[20];
N    char Id;
N  #endif
N};
N
N/**********************************************************************
N*
N*       OS_EVENT
N*/
Ntypedef struct  OS_EVENT OS_EVENT;
N
Nstruct OS_EVENT {
N  OS_WAIT_OBJ WaitObj;
N  OS_U8       Signaled;
X  unsigned char       Signaled;
N#if OS_DEBUG
X#if 1
N  char Id;
N#endif
N};
N
N/**********************************************************************
N*
N*       OS_TRACE_ENTRY
N*/
Ntypedef struct {
N  OS_U32  Time;
X  unsigned int  Time;
N  void    *pCurrentTask;
N  void    *p;
N  OS_U32  v;
X  unsigned int  v;
N  OS_U8   iRout;
X  unsigned char   iRout;
N} OS_TRACE_ENTRY;
N
N
N/*********************************************************************
N*
N*       Globals
N*
N**********************************************************************
N*/
N
N/*
N    Handle DEFinition (storage is actually allocted) versus DEClaration
N    (reference) of RTOS variables depending upon who includes this header file.
N*/
N#ifdef __OSGLOBAL_C__
S  #define OS_EXTERN        /* Declare variables if included by RTOSKERN.C */
S  #define OS_EXTERN_INIT(Var, Val) Var=Val
N#else
N  #define OS_EXTERN extern /* Define variables if included by anyone else */
N  #define OS_EXTERN_INIT(Var, Val) Var
N#endif
N
N/*****  Mark start of memory pragma area ****************************/
N
N/* Some compilers can not deal with memory attributes and need pragmas */
N#if defined(__ghs_zda)
X#if 0L
S  #pragma ghs startzda
N#endif
N
N/********************************************************************/
N
Ntypedef union {
N  int Dummy;            // Make sure a full integer (32 bit on 32 bit CPUs) is used.
N  struct {
N    OS_U8 Region;
X    unsigned char Region;
N    OS_U8 DI;
X    unsigned char DI;
N  } Cnt;
N} OS_COUNTERS;
N
N
N#if OS_COMPILER_STORAGE_MODIFIER_LEFT  /* default */
X#if 1   
N  OS_EXTERN OS_SADDR  volatile OS_I32 OS_Time;
X  extern   volatile int OS_Time;
N  OS_EXTERN OS_SADDR  OS_TIME         OS_EXTERN_INIT(OS_TimeDex, 16384);
X  extern   int         OS_TimeDex;
N  OS_EXTERN OS_SADDR  OS_COUNTERS OS_Counters;
X  extern   OS_COUNTERS OS_Counters;
N
N  OS_EXTERN OS_SADDR  OS_U8  OS_EXTERN_INIT(OS_IntMSInc, 1);
X  extern   unsigned char  OS_IntMSInc;
N  OS_EXTERN OS_SADDR  OS_U8  OS_Pending;
X  extern   unsigned char  OS_Pending;
N  OS_EXTERN OS_SADDR  volatile OS_U8  OS_Status;
X  extern   volatile unsigned char  OS_Status;
N
N  #if OS_RR_SUPPORTED
X  #if (1)
N    OS_EXTERN OS_SADDR  OS_U8  OS_TimeSlice;
X    extern   unsigned char  OS_TimeSlice;
N    OS_EXTERN OS_SADDR  OS_U8  OS_TimeSliceAtStart;
X    extern   unsigned char  OS_TimeSliceAtStart;
N  #endif
N  #if OS_SUPPORT_TICKSTEP
X  #if 1
N    OS_EXTERN OS_SADDR  volatile OS_U8   OS_TickStep;
X    extern   volatile unsigned char   OS_TickStep;
N    OS_EXTERN OS_SADDR  volatile int     OS_TickStepTime;
X    extern   volatile int     OS_TickStepTime;
N  #endif
N  OS_EXTERN OS_SADDR        OS_UINT OS_TicksPerMS;
X  extern         unsigned int OS_TicksPerMS;
N  OS_EXTERN OS_SADDR        int     OS_IntTicksInc;
X  extern         int     OS_IntTicksInc;
N  #if OS_PROFILE
X  #if 1
N    OS_EXTERN OS_SADDR OS_U32 OS_TS_ExecStart;
X    extern  unsigned int OS_TS_ExecStart;
N    OS_EXTERN OS_SADDR OS_U8  ProfilingOn;
X    extern  unsigned char  ProfilingOn;
N  #endif
N  #if OS_DEBUG
X  #if 1
N    OS_EXTERN OS_SADDR OS_U8 OS_InInt;
X    extern  unsigned char OS_InInt;
N    OS_EXTERN OS_SADDR OS_U8 OS_InTimer;
X    extern  unsigned char OS_InTimer;
N    OS_EXTERN OS_SADDR OS_U8 OS_InitCalled;
X    extern  unsigned char OS_InitCalled;
N  #endif
N
N  #if OS_SUPPORT_POWER
X  #if (1)
N    OS_EXTERN OS_SADDR OS_U8 OS_POWER_Levels[OS_POWER_NUM_COUNTERS];
X    extern  unsigned char OS_POWER_Levels[(5)];
N  #endif
N
N  /*** Pointers ***
N    Unfortunately there is no real standard on how to define/declare
N    pointers properly with extended memory attributes. There are
N    currently 2 different standards, which we both support.
N  */
N  #if OS_COMPILER_LOCATION_LEFT
X  #if 1
N    OS_EXTERN OS_SADDR  OS_TASK      * OS_pTask;             /* linked list of all Tasks */
X    extern   OS_TASK      * OS_pTask;              
N    OS_EXTERN OS_SADDR  OS_TASK      * OS_pCurrentTask;      /* pointer to current Task */
X    extern   OS_TASK      * OS_pCurrentTask;       
N    OS_EXTERN OS_SADDR  OS_TASK volatile * volatile OS_pActiveTask;
X    extern   OS_TASK volatile * volatile OS_pActiveTask;
N    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pTimer;            /* linked list of all active Timers */
X    extern   OS_TIMER     * OS_pTimer;             
N    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pCurrentTimer;     /* Actual expired timer which called callback */
X    extern   OS_TIMER     * OS_pCurrentTimer;      
N    OS_EXTERN OS_SADDR OS_RSEMA      * OS_pRSema;
X    extern  OS_RSEMA      * OS_pRSema;
N    #if OS_LINK_MAILBOXES
X    #if (1)
N      OS_EXTERN OS_SADDR OS_MAILBOX  * OS_pMailbox;
X      extern  OS_MAILBOX  * OS_pMailbox;
N    #endif
N    #if OS_DEBUG
X    #if 1
N      OS_EXTERN OS_SADDR OS_CSEMA    * OS_pCSema;
X      extern  OS_CSEMA    * OS_pCSema;
N    #endif
N    OS_EXTERN   OS_SADDR OS_MEMF      * OS_pMEMF;            /* linked list of all fixed size memory pools */
X    extern    OS_MEMF      * OS_pMEMF;             
N    OS_EXTERN   OS_SADDR OS_TICK_HOOK * OS_pTickHook;        /* linked list of all tick hook functions */
X    extern    OS_TICK_HOOK * OS_pTickHook;         
N  #else
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pTask;          /* linked list of all Tasks */
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pCurrentTask;   /* pointer to current Task */
S    OS_EXTERN OS_TASK    volatile * OS_SADDR volatile OS_pActiveTask;
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pTimer;         /* linked list of all active Timers */
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pCurrentTimer;  /* Actual expired timer which called callback */
S    OS_EXTERN OS_RSEMA            * OS_SADDR OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_MAILBOX        * OS_SADDR OS_pMailbox;
S    #endif
S
S    #if OS_DEBUG
S      OS_EXTERN  OS_CSEMA         * OS_SADDR OS_pCSema;
S    #endif
S    OS_EXTERN OS_MEMF             * OS_SADDR OS_pMEMF;          /* linked list of all fixed size memory pools */
S    OS_EXTERN OS_TICK_HOOK        * OS_SADDR OS_pTickHook;      /* linked list of all tick hook functions */
N  #endif
N
N#else  /*  OS_COMPILER_STORAGE_MODIFIER_LEFT == 0, needed for Keil 166 */
S  OS_EXTERN volatile OS_I32 OS_SADDR OS_Time;
S  OS_EXTERN OS_TIME         OS_SADDR OS_EXTERN_INIT(OS_TimeDex, 16384);
S  OS_EXTERN OS_COUNTERS OS_SADDR OS_Counters;
S
S  OS_EXTERN OS_U8 OS_SADDR OS_EXTERN_INIT(OS_IntMSInc, 1);
S  OS_EXTERN OS_U8 OS_SADDR OS_Pending;
S  OS_EXTERN volatile OS_U8 OS_SADDR OS_Status;
S  #if OS_RR_SUPPORTED
S    OS_EXTERN OS_U8 OS_SADDR OS_TimeSlice;
S    OS_EXTERN OS_U8 OS_SADDR OS_TimeSliceAtStart;
S  #endif
S  #if OS_SUPPORT_TICKSTEP
S    OS_EXTERN volatile OS_U8 OS_SADDR OS_TickStep;
S    OS_EXTERN volatile int   OS_SADDR OS_TickStepTime;
S  #endif
S  OS_EXTERN OS_UINT OS_SADDR OS_TicksPerMS;
S  OS_EXTERN int     OS_SADDR OS_IntTicksInc;
S  #if OS_PROFILE
S    OS_EXTERN OS_U32 OS_SADDR OS_TS_ExecStart;
S    OS_EXTERN OS_U8  OS_SADDR ProfilingOn;
S  #endif
S  #if OS_DEBUG
S    OS_EXTERN OS_U8 OS_SADDR OS_InInt;
S    OS_EXTERN OS_U8 OS_SADDR OS_InTimer;
S    OS_EXTERN OS_U8 OS_SADDR OS_InitCalled;
S  #endif
S
S  #if OS_SUPPORT_POWER
S    OS_EXTERN OS_U8 OS_SADDR OS_POWER_Levels[OS_POWER_NUM_COUNTERS];
S  #endif
S
S  /*** Pointers ***
S    Unfortunately there is no real standard on how to define/declare
S    pointers properly with extended memory attributes. There are
S    currently 2 different standards, which we both support.
S  */
S  #if OS_COMPILER_LOCATION_LEFT
S    OS_EXTERN OS_SADDR  OS_TASK      * OS_pTask;             /* linked list of all Tasks */
S    OS_EXTERN OS_SADDR  OS_TASK      * OS_pCurrentTask;      /* pointer to current Task */
S    OS_EXTERN OS_SADDR  OS_TASK volatile * volatile OS_pActiveTask;
S    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pTimer;            /* linked list of all active Timers */
S    OS_EXTERN OS_SADDR  OS_TIMER     * OS_pCurrentTimer;     /* Actual expired timer which called callback */
S    OS_EXTERN OS_SADDR OS_RSEMA      * OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_SADDR OS_MAILBOX  * OS_pMailbox;
S    #endif
S    #if OS_DEBUG
S      OS_EXTERN OS_SADDR OS_CSEMA    * OS_pCSema;
S    #endif
S      OS_EXTERN OS_SADDR OS_MEMF      * OS_pMEMF;            /* linked list of all fixed size memory pools */
S      OS_EXTERN OS_SADDR OS_TICK_HOOK * OS_pTickHook;        /* linked list of all tick hook functions */
S
S  #else
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pTask;          /* linked list of all Tasks */
S    OS_EXTERN OS_TASK             * OS_SADDR OS_pCurrentTask;   /* pointer to current Task */
S    OS_EXTERN OS_TASK    volatile * volatile OS_SADDR OS_pActiveTask;
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pTimer;         /* linked list of all active Timers */
S    OS_EXTERN OS_TIMER            * OS_SADDR OS_pCurrentTimer;  /* Actual expired timer which called callback */
S    OS_EXTERN OS_RSEMA            * OS_SADDR OS_pRSema;
S    #if OS_LINK_MAILBOXES
S      OS_EXTERN OS_MAILBOX        * OS_SADDR OS_pMailbox;
S    #endif
S    #if OS_DEBUG
S      OS_EXTERN OS_CSEMA          * OS_SADDR OS_pCSema;
S    #endif
S
S    OS_EXTERN OS_MEMF             * OS_SADDR OS_pMEMF;          /* linked list of all fixed size memory pools */
S    OS_EXTERN OS_TICK_HOOK        * OS_SADDR OS_pTickHook;      /* linked list of all tick hook functions */
S  #endif
S
N#endif  /*  OS_COMPILER_STORAGE_MODIFIER_LEFT  */
N
N/***** Mark end of memory pragma area *******************************/
N#if defined(__ghs_zda)
X#if 0L
S  #pragma ghs endzda
N#endif
N
N/********************************************************************/
N
N#define OS_RegionCnt OS_Counters.Cnt.Region
N#define OS_DICnt     OS_Counters.Cnt.DI
N
N/*********************************************************************
N*
N*       OS_CREATETASK macro
N*       OS_CREATETASK_EX macro
N*/
N#if OS_RR_SUPPORTED
X#if (1)
N  #define CTPARA_TIMESLICE ,2
N#else
S  #define CTPARA_TIMESLICE
N#endif
N
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack) \
N  OS_CreateTask (pTask,                                      \
N                  Name,                                      \
N                  Priority,                                  \
N                  Hook,                                      \
N                  (void OS_STACKPTR*)pStack,                 \
N                  sizeof(pStack)                             \
N                  CTPARA_TIMESLICE                           \
N               )
X  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack)   OS_CreateTask (pTask,                                                        Name,                                                        Priority,                                                    Hook,                                                        (void OS_STACKPTR*)pStack,                                   sizeof(pStack)                                               CTPARA_TIMESLICE                                          )
N#else
S  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack) \
S  OS_CreateTask (pTask,                                      \
S                  Priority,                                  \
S                  Hook,                                      \
S                  (void OS_STACKPTR*)pStack,                 \
S                  sizeof(pStack)                             \
S                  CTPARA_TIMESLICE                           \
S               )
X  #define OS_CREATETASK(pTask, Name, Hook, Priority, pStack)   OS_CreateTask (pTask,                                                        Priority,                                                    Hook,                                                        (void OS_STACKPTR*)pStack,                                   sizeof(pStack)                                               CTPARA_TIMESLICE                                          )
N#endif
N
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext) \
N  OS_CreateTaskEx  (pTask,                                                \
N                    Name,                                                 \
N                    Priority,                                             \
N                    Hook,                                                 \
N                    (void OS_STACKPTR*)pStack,                            \
N                    sizeof(pStack)                                        \
N                    CTPARA_TIMESLICE,                                     \
N                    pContext                                              \
N               )
X  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext)   OS_CreateTaskEx  (pTask,                                                                    Name,                                                                     Priority,                                                                 Hook,                                                                     (void OS_STACKPTR*)pStack,                                                sizeof(pStack)                                                            CTPARA_TIMESLICE,                                                         pContext                                                             )
N#else
S  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext) \
S  OS_CreateTaskEx  (pTask,                                                \
S                    Priority,                                             \
S                    Hook,                                                 \
S                    (void OS_STACKPTR*)pStack,                            \
S                    sizeof(pStack)                                        \
S                    CTPARA_TIMESLICE,                                     \
S                    pContext                                              \
S               )
X  #define OS_CREATETASK_EX(pTask, Name, Hook, Priority, pStack, pContext)   OS_CreateTaskEx  (pTask,                                                                    Priority,                                                                 Hook,                                                                     (void OS_STACKPTR*)pStack,                                                sizeof(pStack)                                                            CTPARA_TIMESLICE,                                                         pContext                                                             )
N#endif
N
N/*********************************************************************
N*
N*       OS_CreateTask
N*       OS_CreateTaskEx
N*/
N#if OS_TRACKNAME
X#if (1)
N  #define OS_CREATE_TASK_PARA_NAME      const char*Name,
N#else
S  #define OS_CREATE_TASK_PARA_NAME
N#endif
N
N#if OS_RR_SUPPORTED
X#if (1)
N  #define OS_CREATE_TASK_PARA_TS   ,OS_UINT TimeSlice
N#else
S  #define OS_CREATE_TASK_PARA_TS
N#endif
N
Nvoid OS_CreateTask  ( OS_TASK * pTask,
Xvoid OS_CreateTask_DP  ( OS_TASK * pTask,
N                      OS_CREATE_TASK_PARA_NAME
X                      const char*Name,
N                      OS_U8 Priority,
X                      unsigned char Priority,
N                      void (*pRoutine)(void),
N                      void OS_STACKPTR *pStack,
X                      void  *pStack,
N                      OS_UINT StackSize
X                      unsigned int StackSize
N                      OS_CREATE_TASK_PARA_TS
X                      ,unsigned int TimeSlice
N        );
Nvoid OS_CreateTaskEx  ( OS_TASK * pTask,
Xvoid OS_CreateTaskEx_DP  ( OS_TASK * pTask,
N                        OS_CREATE_TASK_PARA_NAME
X                        const char*Name,
N                        OS_U8 Priority,
X                        unsigned char Priority,
N                        void (*pRoutine)(void *),
N                        void OS_STACKPTR *pStack,
X                        void  *pStack,
N                        OS_UINT StackSize
X                        unsigned int StackSize
N                        OS_CREATE_TASK_PARA_TS,
X                        ,unsigned int TimeSlice,
N                        void * pContext
N        );
N#if OS_SUPPORT_SAVE_RESTORE_HOOK
X#if (1)
Nvoid OS_ExtendTaskContext(const OS_EXTEND_TASK_CONTEXT * pExtendContext);
N#endif
N/*********************************************************************
N*
N*       Task related routines
N*
N**********************************************************************
N*/
N
Nvoid  OS_Delay(OS_TIME ms);                /* OSKern.c              */
Xvoid  OS_Delay(int ms);                 
Nvoid  OS_DelayUntil(OS_TIME t);            /* OSKern.c              */
Xvoid  OS_DelayUntil(int t);             
NOS_U8 OS_GetSuspendCnt  (OS_TASK* pTask);  /* OS_GetSuspendCnt.c    */
Xunsigned char OS_GetSuspendCnt  (OS_TASK* pTask);   
Nvoid  OS_GetState       (OS_TASK* pTask);
Nchar  OS_IsTask         (OS_TASK* pTask);  /* OSIsTask.c            */
Nvoid  OS_Resume         (OS_TASK* pTask);  /* OS_Suspend.c          */
Nvoid  OS_SetTaskName    (OS_TASK * pTask, const char* s);
Nvoid  OS_SetPriority    (OS_TASK* pTask, OS_U8 Prio); /* OSSetP.c   */
Xvoid  OS_SetPriority    (OS_TASK* pTask, unsigned char Prio);  
Nvoid  OS_Suspend        (OS_TASK* pTask);  /* OS_Suspend.c          */
Nvoid  OS_Terminate      (OS_TASK* pTask);  /* OSTerm.c              */
Nvoid  OS_TerminateError (void);            /* OSTermE.c             */
Nvoid  OS_WakeTask       (OS_TASK* pTask);  /* OSWake.c              */
Nvoid  OS_Yield          (void);            /* OS_Yield              */
N
N#if OS_SUSPEND_TASK_ON_TERMINATE           /* Set task state of a terminated task to "suspended" */
X#if (0)            
S  #define OS_SUSPEND_TERMINATED_TASK(pTask) (pTask->Stat = 0x01)
N#else
N  #define OS_SUSPEND_TERMINATED_TASK(pTask)
N#endif
N
N/*********************************************************************
N*
N*       Info routines (OSInfo.c)
N*
N**********************************************************************
N*/
N
Nconst char* OS_GetCPU(void);
Nconst char* OS_GetLibMode(void);
Nconst char* OS_GetModel(void);
Nconst char* OS_GetLibName(void);
N
NOS_UINT OS_GetVersion(void);
Xunsigned int OS_GetVersion(void);
N#define OS_GetType() OS_GetLibMode()
N
N#define OS_TASKID OS_TASK *
N#define OS_GetTaskID() OS_pCurrentTask
N
N#define OS_GetpCurrentTask()    OS_pCurrentTask
N#define OS_GetpCurrentTimer()   OS_pCurrentTimer
N#define OS_GetpCurrentTimerEx() ((OS_TIMER_EX*)OS_pCurrentTimer)
N
N#if OS_TRACKNAME
X#if (1)
N  const char* OS_GetTaskName(OS_TASK *);
N#else
S  #define OS_GetTaskName(pt)  ("n/a")
N#endif
N
N#if OS_CHECKSTACK
X#if 1
N  void OS_CheckStack(void);              /* internal usage */
N  int  OS_GetStackSpace(OS_TASK * pTask);
N  int  OS_GetStackUsed (OS_TASK * pTask);
N  int  OS_GetStackSize (OS_TASK OS_TCBPTR * pTask);
X  int  OS_GetStackSize (OS_TASK  * pTask);
N  void OS_STACKPTR* OS_GetStackBase(OS_TASK OS_TCBPTR *pTask);
X  void * OS_GetStackBase(OS_TASK  *pTask);
N#else
S  #define OS_CheckStack()
S  #define OS_GetStackSpace(pt) 0
S  #define OS_GetStackUsed(pt)  0
S  #define OS_GetStackSize(pt)  0
S  #define OS_GetStackBase(pt)  0
N#endif
N
NOS_STACK_ADR OS_GetSysStackBase(void);  /* RTOS asm part */
Xunsigned int OS_GetSysStackBase(void);   
Nunsigned int OS_GetSysStackSize(void);  /* RTOS asm part */
NOS_STACK_ADR OS_GetIntStackBase(void);  /* RTOS asm part */
Xunsigned int OS_GetIntStackBase(void);   
Nunsigned int OS_GetIntStackSize(void);  /* RTOS asm part */
N
N#if OS_RR_SUPPORTED
X#if (1)
N  OS_U8 OS_SetTimeSlice(OS_TASK * pTask, OS_U8 TimeSlice);
X  unsigned char OS_SetTimeSlice(OS_TASK * pTask, unsigned char TimeSlice);
N  OS_U8 OS_GetTimeSliceRem(OS_TASK OS_TCBPTR * pTask);
X  unsigned char OS_GetTimeSliceRem(OS_TASK  * pTask);
N  #define OS_GetTimeSliceReload(pTask)  pTask->TimeSliceReload
N#else
S  #define OS_GetTimeSliceRem(pTask)     0
S  #define OS_GetTimeSliceReload(pTask)  0
N#endif
N
NOS_U8    OS_GetPriority(OS_TASK * pTask);  /* OS_GetPrio.c       */
Xunsigned char    OS_GetPriority(OS_TASK * pTask);   
N#define OS_GET_PRIORITY(pt) pt->Priority
N
Nint     OS_GetNumTasks(void);              /* OS_GetNumTasks.c   */
N
NOS_TASK* OS_TaskIndex2Ptr(int TaskIndex);  /* OS_TaskIndex2Ptr.c */
N
N#if OS_PROFILE >=1
X#if 1 >=1
N  OS_U32 OS_STAT_GetExecTime_Cycles (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetExecTime_Cycles (OS_TASK *pTask);   
N  int    OS_STAT_GetLoad            (OS_TASK *pTask);  /* OSStatGL.c */
N  void   OS_STAT_NotifyReadyStart   (OS_TASK *pTask);  /* OSStat.c   */
N  void   OS_STAT_Sample(void);                         /* OSStat.c   */
N#else
S  #define OS_STAT_NotifyExecEnd()
S  #define OS_STAT_GetExecTime_Cycles(pTask)   0
S  #define OS_STAT_GetLoad(pTask)              0
S  #define OS_STAT_Sample()
S  #define OS_STAT_SetClocksPerUnit(ClocksPerUnit)
S  #define OS_STAT_NOTIFYREADYSTART(pTask)
N#endif
N
N
N#if ((OS_PROFILE >= 1) || (OS_DEBUG > 0))  /* Also available in Debug build since V3.32b */
X#if ((1 >= 1) || (1 > 0))   
N  OS_U32 OS_STAT_GetNumActivations  (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetNumActivations  (OS_TASK *pTask);   
N  OS_U32 OS_STAT_GetNumPreemptions  (OS_TASK *pTask);  /* OSStat.c   */
X  unsigned int OS_STAT_GetNumPreemptions  (OS_TASK *pTask);   
N#else
S  #define OS_STAT_GetNumActivations(pTask)    0
S  #define OS_STAT_GetNumPreemptions(pTask)    0
N#endif
N
N/*********************************************************************
N*
N*       Size info routines (OS_GetSize.c)
N*
N**********************************************************************
N*/
N
Nint OS_WAIT_OBJ_GetSize(void);
Nint OS_WAIT_OBJ_EX_GetSize(void);
Nint OS_WAIT_LIST_GetSize(void);
Nint OS_EXTEND_TASK_CONTEXT_GetSize(void);
Nint OS_TASK_GetSize(void);
Nint OS_REGS_GetSize(void);
Nint OS_TIMER_GetSize(void);
Nint OS_TIMER_EX_GetSize(void);
Nint OS_TICK_HOOK_GetSize(void);
Nint OS_RSEMA_GetSize(void);
Nint OS_CSEMA_GetSize(void);
Nint OS_MAILBOX_GetSize(void);
Nint OS_Q_GetSize(void);
Nint OS_MEMF_GetSize(void);
Nint OS_EVENT_GetSize(void);
Nint OS_TRACE_ENTRY_GetSize(void);
N
N/*********************************************************************
N*
N*       Critical regions (OsKern.c)
N*
N**********************************************************************
N*/
N
N#define OS_EnterRegion() {OS_RegionCnt++; }
Nvoid OS_LeaveRegion(void);
N
N/* Macro for OS_Leaveregion.
N   Main purposes:
N   - Used in OS-Kernel
N   - Offers the high speed variant (macro) instead of the function call
N*/
N
N#define OS_LEAVEREGION_STD()        \
N  if (--OS_RegionCnt == 0) {        \
N    OS_DI();                        \
N    if (OS_Pending) {               \
N      OS_RegionCnt = 1;             \
N      OS_Switch();                  \
N      OS_RegionCnt = 0;             \
N    }                               \
N    OS_RESTORE_I();                 \
N  }
X#define OS_LEAVEREGION_STD()          if (--OS_RegionCnt == 0) {            OS_DI();                            if (OS_Pending) {                     OS_RegionCnt = 1;                   OS_Switch();                        OS_RegionCnt = 0;                 }                                   OS_RESTORE_I();                   }
N
N#if OS_DEBUG
X#if 1
N #define OS_LEAVEREGION() \
N   if (!OS_RegionCnt) OS_Error(OS_ERR_LEAVEREGION_BEFORE_ENTERREGION); \
N   OS_LEAVEREGION_STD()
X #define OS_LEAVEREGION()    if (!OS_RegionCnt) OS_Error(OS_ERR_LEAVEREGION_BEFORE_ENTERREGION);    OS_LEAVEREGION_STD()
N#else
S  #define OS_LEAVEREGION()  OS_LEAVEREGION_STD()
N#endif
N
N/*********************************************************************
N*
N*       Interrupt save/disable/restore macros
N*
N**********************************************************************
N*/
N#define OS_IncDI()       { OS_ASSERT_DICnt(); OS_DI(); OS_DICnt++; }
N#define OS_DecRI()       { OS_ASSERT_DICnt(); if (--OS_DICnt==0) OS_EI(); }
N#define OS_RESTORE_I()   { OS_ASSERT_DICnt(); if (OS_DICnt==0)   OS_EI(); }
N
Nvoid OS_RestoreI(void);  /* OS_Kern.c */
N
N/*********************************************************************
N*
N*       ISR (Interrupt service routine) support
N*
N**********************************************************************
N*/
N
N#define RTOS_PPENDING           (1)     /*      Preemption  pending */
N#define RTOS_TSPENDING          (2)     /*      Task switch pending */
N#define RTOS_RRPENDING          (4)     /*      Round robin pending */
N
N
N#ifndef   OS_SUPPORT_INT_PRIORITY
S  #define OS_SUPPORT_INT_PRIORITY (1)
N#endif
N
N#if OS_SUPPORT_INT_PRIORITY
X#if (0)
S  #ifndef   OS_IPL_EI_DEFAULT
S    #error "Please define OS_IPL_EI_DEFAULT (OSChip.h)"
S  #endif
S
S  #ifndef   OS_IPL_DI_DEFAULT
S    #error "Please define OS_IPL_DI_DEFAULT (OSChip.h)"
S  #endif
S
S  #if OS_COMPILER_STORAGE_MODIFIER_LEFT
S    OS_EXTERN OS_SADDR unsigned int  OS_EXTERN_INIT(OS_Ipl_EI, OS_IPL_EI_DEFAULT);
S    OS_EXTERN OS_SADDR unsigned int  OS_EXTERN_INIT(OS_Ipl_DI, OS_IPL_DI_DEFAULT);
S  #else
S    OS_EXTERN unsigned int OS_SADDR  OS_EXTERN_INIT(OS_Ipl_EI, OS_IPL_EI_DEFAULT);
S    OS_EXTERN unsigned int OS_SADDR  OS_EXTERN_INIT(OS_Ipl_DI, OS_IPL_DI_DEFAULT);
S  #endif
N#endif
N
N#if OS_DEBUG
X#if 1
N  #define OS_MARK_IN_ISR()         {OS_InInt++;}
N  #define OS_MARK_OUTOF_ISR()      {if (!OS_InInt--) OS_Error(OS_ERR_LEAVEINT);}
N#else
S  #define OS_MARK_IN_ISR()
S  #define OS_MARK_OUTOF_ISR()
N#endif
N
N#if OS_SUPPORT_CALL_ISR            // Not allowed for some CPUs
X#if (1)            
Nvoid OS_CallISR        (void (*pRoutine)(void));
Nvoid OS_CallNestableISR(void (*pRoutine)(void));
N#endif
N
N#if (OS_SWITCH_FROM_INT_MODIFIES_STACK == 0) && (OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY != 0) && (OS_SCHEDULER_ACTIVATED_BY_EXCEPTION == 0)
X#if ((1) == 0) && ((0) != 0) && ((0) == 0)
S  //
S  // FOR CPUs without separate interrupt stack which do not disable interrupts on entry,
S  // OS_Enter- / Leave- Interrupt() is not defined.
S  // OS_CallISR() has to be used
S  //
N#else
N
N  #ifndef   OS_ENABLE_INTS_SAVE_IPL
N    #define OS_ENABLE_INTS_SAVE_IPL() OS_EI()
N  #endif
N
N  #ifndef   OS_RESTORE_IPL
N    #define OS_RESTORE_IPL()
N  #endif
N
N  #ifndef   OS_EI_ON_LEAVE
N    #define OS_EI_ON_LEAVE()        // Required for CPUs with do not restore DI-flag by RETI. Currently only CM3.
N  #endif
N
N  #if OS_INTERRUPTS_ARE_NESTABLE_ON_ENTRY
X  #if (0)
S    #define OS_DI_ON_ENTRY() OS_DI()
N  #else
N    #define OS_DI_ON_ENTRY()
N  #endif
N
N  #if OS_SWITCH_FROM_INT_MODIFIES_STACK
X  #if (1)
N    #define OS_HANDLE_REGION_CNT_ON_LI()                                          \
N      else {                                                                      \
N        OS_RegionCnt--;                                                           \
N      }
X    #define OS_HANDLE_REGION_CNT_ON_LI()                                                else {                                                                              OS_RegionCnt--;                                                                 }
N  #else
S    #define OS_HANDLE_REGION_CNT_ON_LI()                                          \
S      OS_RegionCnt--;
X    #define OS_HANDLE_REGION_CNT_ON_LI()                                                OS_RegionCnt--;
N  #endif
N
N
N  #define OS_SWITCH_FROM_INT_IF_REQUIRED()                                      \
N    if ((OS_RegionCnt == 1) && OS_Pending) {                                    \
N      OS_SwitchFromInt();                                                       \
N    }
X  #define OS_SWITCH_FROM_INT_IF_REQUIRED()                                          if ((OS_RegionCnt == 1) && OS_Pending) {                                          OS_SwitchFromInt();                                                           }
N
N  #define OS_EnterInterrupt() { \
N    OS_DI_ON_ENTRY();           \
N    OS_MARK_IN_ISR();           \
N    OS_RegionCnt++;             \
N    OS_DICnt++;                 \
N  }
X  #define OS_EnterInterrupt() {     OS_DI_ON_ENTRY();               OS_MARK_IN_ISR();               OS_RegionCnt++;                 OS_DICnt++;                   }
N
N  #define OS_LeaveInterrupt() {                                                 \
N    OS_MARK_OUTOF_ISR();                                                        \
N    OS_DICnt--; /* Must have been zero initially ! (We could put =0 instead) */ \
N    OS_SWITCH_FROM_INT_IF_REQUIRED()                                            \
N    OS_HANDLE_REGION_CNT_ON_LI();                                               \
N    OS_EI_ON_LEAVE();                                                           \
N  }
X  #define OS_LeaveInterrupt() {                                                     OS_MARK_OUTOF_ISR();                                                            OS_DICnt--;       OS_SWITCH_FROM_INT_IF_REQUIRED()                                                OS_HANDLE_REGION_CNT_ON_LI();                                                   OS_EI_ON_LEAVE();                                                             }
N
N  #define OS_LeaveInterruptNoSwitch() { \
N    OS_MARK_OUTOF_ISR();                \
N    OS_DICnt--;                         \
N    OS_RegionCnt--;                     \
N    OS_EI_ON_LEAVE();                   \
N  }
X  #define OS_LeaveInterruptNoSwitch() {     OS_MARK_OUTOF_ISR();                    OS_DICnt--;                             OS_RegionCnt--;                         OS_EI_ON_LEAVE();                     }
N
N  #define OS_EnterNestableInterrupt() { \
N    OS_MARK_IN_ISR();                   \
N    OS_RegionCnt++;                     \
N    OS_ENABLE_INTS_SAVE_IPL();          \
N  }
X  #define OS_EnterNestableInterrupt() {     OS_MARK_IN_ISR();                       OS_RegionCnt++;                         OS_ENABLE_INTS_SAVE_IPL();            }
N
N  #define OS_LeaveNestableInterrupt() {                                         \
N    OS_DI();                                                                    \
N    OS_MARK_OUTOF_ISR();                                                        \
N    OS_SWITCH_FROM_INT_IF_REQUIRED()                                            \
N    OS_HANDLE_REGION_CNT_ON_LI();                                               \
N    OS_RESTORE_IPL();                                                           \
N    OS_EI_ON_LEAVE();                                                           \
N  }
X  #define OS_LeaveNestableInterrupt() {                                             OS_DI();                                                                        OS_MARK_OUTOF_ISR();                                                            OS_SWITCH_FROM_INT_IF_REQUIRED()                                                OS_HANDLE_REGION_CNT_ON_LI();                                                   OS_RESTORE_IPL();                                                               OS_EI_ON_LEAVE();                                                             }
N
N  #define OS_LeaveNestableInterruptNoSwitch() { \
N    OS_DI();                                    \
N    OS_MARK_OUTOF_ISR();                        \
N    OS_RegionCnt--;                             \
N    OS_RESTORE_IPL();                           \
N    OS_EI_ON_LEAVE();                           \
N  }
X  #define OS_LeaveNestableInterruptNoSwitch() {     OS_DI();                                        OS_MARK_OUTOF_ISR();                            OS_RegionCnt--;                                 OS_RESTORE_IPL();                               OS_EI_ON_LEAVE();                             }
N#endif
N
N#ifndef OS_EnterIntStack
S  void OS__EnterIntStack(void);
S  #define OS_EnterIntStack() {OS_DI(); OS__EnterIntStack(); OS_RESTORE_I(); }
N#endif
N
N#ifndef OS_LeaveIntStack
S  void OS__LeaveIntStack(void);
S  #define OS_LeaveIntStack() {OS_DI(); OS__LeaveIntStack(); }
N#endif
N
Nvoid OS_SetFastIntPriorityLimit(OS_UINT Priority);
Xvoid OS_SetFastIntPriorityLimit(unsigned int Priority);
N
N/*********************************************************************
N*
N*       Resource semaphores
N*
N**********************************************************************
N*/
N
Nint      OS_Use             (OS_RSEMA * pRSema); /* OSRsem.c   */
Nvoid     OS_Unuse           (OS_RSEMA * pRSema); /* OSRsem.c   */
Nchar     OS_Request         (OS_RSEMA * pRSema); /* OSRsemRQ.c */
Nint      OS_GetSemaValue    (OS_RSEMA * pRSema); /* OSRSemGV.c */
NOS_TASK* OS_GetResourceOwner(OS_RSEMA * pRSema); /* OSRsemGO.c */
N
Nvoid     OS_CreateRSema     (OS_RSEMA * pRSema); /* OSRsem.c   */
Nvoid     OS_DeleteRSema     (OS_RSEMA * pRSema); /* OSDelRS.c  */
N
N#define  OS_CREATERSEMA(ps) OS_CreateRSema(ps)
N
N/*********************************************************************
N*
N*       Counting semaphores
N*
N**********************************************************************
N*/
N
Nvoid  OS_CreateCSema    (OS_CSEMA * pCSema, OS_UINT InitValue);  /* OSCSEM.c             */
Xvoid  OS_CreateCSema    (OS_CSEMA * pCSema, unsigned int InitValue);   
Nvoid  OS_DeleteCSema    (OS_CSEMA * pCSema);                     /* OSDELCS.c            */
Nint   OS_GetCSemaValue  (OS_CSEMA * pCSema);                     /* OSCSEMGV.c           */
NOS_U8 OS_SetCSemaValue  (OS_CSEMA * pCSema, OS_UINT value);      /* OS_SetCSemaValue.c   */
Xunsigned char OS_SetCSemaValue  (OS_CSEMA * pCSema, unsigned int value);       
Nvoid  OS_SignalCSema    (OS_CSEMA * pCSema);                     /* OSCSEM.c             */
Nvoid  OS_SignalCSemaMax (OS_CSEMA * pCSema, OS_UINT MaxValue);   /* OS_CSEMA_SignalMax.c */
Xvoid  OS_SignalCSemaMax (OS_CSEMA * pCSema, unsigned int MaxValue);    
Nvoid  OS_WaitCSema      (OS_CSEMA * pCSema);                     /* OSCSEM.c             */
Nint   OS_WaitCSemaTimed (OS_CSEMA * pCSema, OS_TIME TimeOut);    /* OSCSEMT.c            */
Xint   OS_WaitCSemaTimed (OS_CSEMA * pCSema, int TimeOut);     
Nchar  OS_CSemaRequest   (OS_CSEMA * pCSema);                     /* OSCSEMRQ.c           */
N
N#define OS_CREATECSEMA(ps) OS_CreateCSema(ps,0)
N
N/*********************************************************************
N*
N*       Mailboxes
N*
N**********************************************************************
N*/
N#define CREATEMB(MAILBOX, size, max, Buffer) OS_CreateMB(MAILBOX,size, max, Buffer);
Nvoid OS_CreateMB          (OS_MAILBOX * pMB, OS_U8 sizeofMsg, OS_UINT maxnofMsg, void* Buffer);    /* initialize mailbox */
Xvoid OS_CreateMB          (OS_MAILBOX * pMB, unsigned char sizeofMsg, unsigned int maxnofMsg, void* Buffer);     
Nvoid OS_ClearMB           (OS_MAILBOX * pMB);
Nvoid OS_PutMail           (OS_MAILBOX * pMB, void* pMail);
Nchar OS_PutMailCond       (OS_MAILBOX * pMB, void* pMail);
Nvoid OS_PutMailFront      (OS_MAILBOX * pMB, void* pMail);
Nchar OS_PutMailFrontCond  (OS_MAILBOX * pMB, void* pMail);
Nvoid OS_GetMail           (OS_MAILBOX * pMB, void* pDest);
Nchar OS_GetMailCond       (OS_MAILBOX * pMB, void* pDest);
Nvoid OS_PutMail1          (OS_MAILBOX * pMB, const char* pMail);
Nchar OS_PutMailCond1      (OS_MAILBOX * pMB, const char* pMail);
Nvoid OS_PutMailFront1     (OS_MAILBOX * pMB, const char* pMail);
Nchar OS_PutMailFrontCond1 (OS_MAILBOX * pMB, const char* pMail);
Nvoid OS_GetMail1          (OS_MAILBOX * pMB, char* pDest);
Nchar OS_GetMailCond1      (OS_MAILBOX * pMB, char* pDest);
Nchar OS_GetMailTimed      (OS_MAILBOX * pMB, void* pDest, OS_TIME Timeout);
Xchar OS_GetMailTimed      (OS_MAILBOX * pMB, void* pDest, int Timeout);
Nvoid OS_DeleteMB          (OS_MAILBOX * pMB);
Nvoid OS_WaitMail          (OS_MAILBOX * pMB);
N
N#if OS_DEBUG == 0
X#if 1 == 0
S  #define OS_GetMessageCnt(pMB) (*pMB).nofMsg
N#else
N  OS_UINT OS_GetMessageCnt(OS_MAILBOX * pMB);   /* get no. of available Messages */
X  unsigned int OS_GetMessageCnt(OS_MAILBOX * pMB);    
N#endif
N
N/*********************************************************************
N*
N*       Message Queues (OSQ.c)
N*
N**********************************************************************
N*/
N
Nvoid    OS_Q_Create       (OS_Q* pQ, void*pData, OS_UINT Size);
Xvoid    OS_Q_Create       (OS_Q* pQ, void*pData, unsigned int Size);
Nvoid    OS_Q_Clear        (OS_Q* pQ);                                /* OSQCL.c  */
Nint     OS_Q_GetMessageCnt(OS_Q* pQ);                                /* OSQGMC.c */
Nint     OS_Q_Put          (OS_Q* pQ, const void* pSrc, OS_UINT Size);
Xint     OS_Q_Put          (OS_Q* pQ, const void* pSrc, unsigned int Size);
Nint     OS_Q_GetPtr       (OS_Q* pQ, void**ppData);
Nint     OS_Q_GetPtrCond   (OS_Q* pQ, void**ppData);                  /* OSQGPC.c */
Nint     OS_Q_GetPtrTimed  (OS_Q* pQ, void**ppData, OS_TIME Timeout); /* OSQGPT.c */
Xint     OS_Q_GetPtrTimed  (OS_Q* pQ, void**ppData, int Timeout);  
Nvoid    OS_Q_Purge        (OS_Q* pQ);
N
N/*********************************************************************
N*
N*       Events
N*
N**********************************************************************
N*/
N
Nchar OS_ClearEvents          (OS_TASK * pTask);                 /* OSEVENCL.c  */
Nchar OS_GetEventsOccured     (OS_TASK * pTask);                 /* OSEVENGE.c  */
Nvoid OS_SignalEvent          (char Event, OS_TASK * pTask);     /* OSENENS.c   */
Nchar OS_WaitEvent            (char EventMask);                  /* OSEVENW.c   */
Nchar OS_WaitEventTimed       (char EventMask, OS_TIME TimeOut); /* OSEVENT.c   */
Xchar OS_WaitEventTimed       (char EventMask, int TimeOut);  
Nchar OS_WaitSingleEvent      (char EventMask);                  /* OSEVENWS.c  */
Nchar OS_WaitSingleEventTimed (char EventMask, OS_TIME TimeOut); /* OSEVENWST.c */
Xchar OS_WaitSingleEventTimed (char EventMask, int TimeOut);  
N
N/*********************************************************************
N*
N*       Timers(OSTIME.c)
N*
N**********************************************************************
N*/
N
N#ifdef OS_SIZEOF_INT
N  #if OS_SIZEOF_INT == 2
X  #if (4) == 2
S    #define OS_TIMER_MAX_TIME 0x7F00
N  #elif OS_SIZEOF_INT == 4
X  #elif (4) == 4
N    #define OS_TIMER_MAX_TIME 0x7FFFFF00
N  #else
S    #error "OS_SIZEOF_INT not correctly defined"
N  #endif
N#endif
N
Nvoid    OS_CreateTimer    (OS_TIMER * pTimer, OS_TIMERROUTINE* Callback, OS_TIME Timeout);
Xvoid    OS_CreateTimer    (OS_TIMER * pTimer, OS_TIMERROUTINE* Callback, int Timeout);
Nvoid    OS_RetriggerTimer (OS_TIMER * pTimer);
Nvoid    OS_StartTimer     (OS_TIMER * pTimer);
Nvoid    OS_StopTimer      (OS_TIMER * pTimer);
Nvoid    OS_DeleteTimer    (OS_TIMER * pTimer);                  /* OSTIMED.c  */
NOS_TIME OS_GetTimerPeriod (OS_TIMER * pTimer);                  /* OSTIMEGP.c */
Xint OS_GetTimerPeriod (OS_TIMER * pTimer);                   
NOS_U8   OS_GetTimerStatus (OS_TIMER * pTimer);                  /* OSTIMEGS.c */
Xunsigned char   OS_GetTimerStatus (OS_TIMER * pTimer);                   
NOS_TIME OS_GetTimerValue  (OS_TIMER * pTimer);                  /* OSTIMEGV.c */
Xint OS_GetTimerValue  (OS_TIMER * pTimer);                   
Nvoid    OS_SetTimerPeriod (OS_TIMER * pTimer, OS_TIME Period);  /* OSTIMES.c  */
Xvoid    OS_SetTimerPeriod (OS_TIMER * pTimer, int Period);   
N
N#define OS_CREATETIMER(pTimer,c,d)  \
N        OS_CreateTimer(pTimer,c,d); \
N        OS_StartTimer(pTimer);
X#define OS_CREATETIMER(pTimer,c,d)          OS_CreateTimer(pTimer,c,d);         OS_StartTimer(pTimer);
N
N/*********************************************************************
N*
N*       Extended timers (OSTIMERX.c)
N*
N**********************************************************************
N*/
Nvoid    OS_CreateTimerEx (OS_TIMER_EX * pTimerEx, OS_TIMER_EX_ROUTINE* Callback, OS_TIME Timeout, void * pData);
Xvoid    OS_CreateTimerEx (OS_TIMER_EX * pTimerEx, OS_TIMER_EX_ROUTINE* Callback, int Timeout, void * pData);
N
N#define OS_RetriggerTimerEx(pTimerEx)         OS_RetriggerTimer(&(pTimerEx)->Timer)
N#define OS_StartTimerEx(pTimerEx)             OS_StartTimer(&(pTimerEx)->Timer)
N#define OS_StopTimerEx(pTimerEx)              OS_StopTimer(&(pTimerEx)->Timer)
N#define OS_DeleteTimerEx(pTimerEx)            OS_DeleteTimer(&(pTimerEx)->Timer)
N#define OS_GetTimerPeriodEx(pTimerEx)         OS_GetTimerPeriod(&(pTimerEx)->Timer)
N#define OS_GetTimerStatusEx(pTimerEx)         OS_GetTimerStatus(&(pTimerEx)->Timer)
N#define OS_GetTimerValueEx(pTimerEx)          OS_GetTimerValue(&(pTimerEx)->Timer)
N#define OS_SetTimerPeriodEx(pTimerEx,Period)  OS_SetTimerPeriod(&(pTimerEx)->Timer, Period)
N
N#define OS_CREATETIMER_EX(pTimerEx,cb,Timeout,pData) \
N        OS_CreateTimerEx(pTimerEx,cb,Timeout,pData); \
N        OS_StartTimerEx(pTimerEx)
X#define OS_CREATETIMER_EX(pTimerEx,cb,Timeout,pData)         OS_CreateTimerEx(pTimerEx,cb,Timeout,pData);         OS_StartTimerEx(pTimerEx)
N
N/*********************************************************************
N*
N*       Heap type memory management (OS_Alloc.c)
N*
N**********************************************************************
N
N  This functions might not be implemented in all OS ports.
N  Therefore declaration depends on condition OS_SUPPORT_OS_ALLOC
N  which has to be defined in CPU specific part
N
N*/
N
N#if OS_SUPPORT_OS_ALLOC
X#if (1)
N  void* OS_malloc(unsigned int);
N  void  OS_free  (void* pMemBlock);
N  void* OS_realloc  (void* pMemBlock, unsigned NewSize);
N#endif
N
N/*********************************************************************
N*
N*       Fixed Block memory management
N*
N**********************************************************************
N*/
N
Nvoid  OS_MEMF_Create(OS_MEMF* pMEMF, void* pPool, OS_U16 NumBlocks, OS_U16 BlockSize);
Xvoid  OS_MEMF_Create(OS_MEMF* pMEMF, void* pPool, unsigned short NumBlocks, unsigned short BlockSize);
Nvoid  OS_MEMF_Delete(OS_MEMF* pMEMF);
Nvoid* OS_MEMF_Alloc(OS_MEMF* pMEMF, int Purpose);
Nvoid* OS_MEMF_AllocTimed(OS_MEMF* pMEMF, OS_TIME Timeout, int Purpose);
Xvoid* OS_MEMF_AllocTimed(OS_MEMF* pMEMF, int Timeout, int Purpose);
Nvoid* OS_MEMF_Request(OS_MEMF* pMEMF, int Purpose);
Nvoid  OS_MEMF_Release(OS_MEMF* pMEMF, void* pMemBlock);
Nvoid  OS_MEMF_FreeBlock(void* pMemBlock);
Nint   OS_MEMF_GetNumFreeBlocks(OS_MEMF* pMEMF);
Nchar  OS_MEMF_IsInPool(OS_MEMF* pMEMF, void* pMemBlock);
Nint   OS_MEMF_GetMaxUsed(OS_MEMF* pMEMF);
Nint   OS_MEMF_GetNumBlocks(OS_MEMF* pMEMF);
Nint   OS_MEMF_GetBlockSize(OS_MEMF* pMEMF);
N
N/*********************************************************************
N*
N*       Event object module
N*
N**********************************************************************
N*/
N
N/****** Simple OS_EVENT functions ************************************/
N
Nvoid  OS_EVENT_Create    (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Delete    (OS_EVENT* pEvent);
N
NOS_U8 OS_EVENT_Get       (OS_EVENT* pEvent);
Xunsigned char OS_EVENT_Get       (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Pulse     (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Reset     (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Set       (OS_EVENT* pEvent);
Nvoid  OS_EVENT_Wait      (OS_EVENT* pEvent);
Nchar  OS_EVENT_WaitTimed (OS_EVENT* pEvent, OS_TIME Timeout);
Xchar  OS_EVENT_WaitTimed (OS_EVENT* pEvent, int Timeout);
N
N/*********************************************************************
N*
N*       Timing support (OSTiming.c)
N*
N**********************************************************************
N
N New in V3.04, but not yet documented to the end user. Great for
N run-time measurement.
N*/
N
N#define OS_TIMING OS_U32
Nvoid    OS_Timing_Start(OS_TIMING* pCycle);
Xvoid    OS_Timing_Start(unsigned int* pCycle);
Nvoid    OS_Timing_End(OS_TIMING* pCycle);
Xvoid    OS_Timing_End(unsigned int* pCycle);
NOS_U32  OS_Timing_Getus(OS_TIMING* pCycle);
Xunsigned int  OS_Timing_Getus(unsigned int* pCycle);
N#define OS_Timing_GetCycles(pPara) (*pPara)
N
N
N/*********************************************************************
N*
N*       OS Power control module OS_Power.c
N*
N**********************************************************************
N*/
N#if OS_SUPPORT_POWER
X#if (1)
N#define OS_POWER_LEVEL0  (0x0001)
N#define OS_POWER_LEVEL1  (0x0002)
N#define OS_POWER_LEVEL2  (0x0004)
N#define OS_POWER_LEVEL3  (0x0008)
N#define OS_POWER_LEVEL4  (0x0010)
N#define OS_POWER_LEVEL5  (0x0020)
N#define OS_POWER_LEVEL6  (0x0040)
N#define OS_POWER_LEVEL8  (0x0080)
N
Nvoid    OS_POWER_UsageInc(OS_UINT Level);
Xvoid    OS_POWER_UsageInc(unsigned int Level);
Nvoid    OS_POWER_UsageDec(OS_UINT Level);
Xvoid    OS_POWER_UsageDec(unsigned int Level);
NOS_UINT OS_POWER_GetMask(void);
Xunsigned int OS_POWER_GetMask(void);
N#endif
N
N/*********************************************************************
N*
N*       Advanced profiling support (Module OsKern.c)
N*
N**********************************************************************
N*/
N#if OS_PROFILE >= 1
X#if 1 >= 1
N  void OS_EnableProfiling(int Period);
N  #define OS_DisableProfiling() { OS_ProfilingOn=0; }
N#else
S  #define OS_EnableProfiling(Period);
S  #define OS_DisableProfiling()
N#endif
N
N/*********************************************************************
N*
N*       Configuration
N*
N**********************************************************************
N*/
N
N#define OS_CONFIG_FRACT(f, div)                    \
N  OS_TicksPerMS  = f/1000;                         \
N  OS_IntMSInc    = div*1000L/f;                    \
N  OS_IntTicksInc = div-(f/1000)*(div*1000L/f);
X#define OS_CONFIG_FRACT(f, div)                      OS_TicksPerMS  = f/1000;                           OS_IntMSInc    = div*1000L/f;                      OS_IntTicksInc = div-(f/1000)*(div*1000L/f);
N
N#define OS_CONFIG(f, div)     \
N  OS_IntMSInc    = div*1000L/f;
X#define OS_CONFIG(f, div)       OS_IntMSInc    = div*1000L/f;
N
N
N/*********************************************************************
N*
N*       Trace support (OSTrace.c)
N*
N**********************************************************************
N
NTrace support is enabled by defining OS_TRACE 1.
NThis is automatically done, when OS_LIBMODE_T is defined.
N
N*/
N
N#if OS_TRACE
X#if 0
S  /* Declare trace function prototypes */
S  void OS_TraceVoid (OS_U8 id);
S  void OS_TracePtr  (OS_U8 id, void* p);
S  void OS_TraceData (OS_U8 id, int v);
S  void OS_TraceDataPtr (OS_U8 id, int v, void*p);
S  void OS_TraceU32Ptr  (OS_U8 id, OS_U32 p0, void*p1);
S  void OS_TraceEnable(void);
S  void OS_TraceDisable(void);
S  void OS_TraceEnableAll(void);                              /* OSTrace1.c */
S  void OS_TraceDisableAll(void);                             /* OSTrace1.c */
S  void OS_TraceEnableId(OS_U8 id);                           /* OSTrace1.c */
S  void OS_TraceDisableId(OS_U8 id);                          /* OSTrace1.c */
S  void OS_TraceEnableFilterId(OS_U8 FilterIndex, OS_U8 id);  /* OSTrace1.c */
S  void OS_TraceDisableFilterId(OS_U8 FilterIndex, OS_U8 id); /* OSTrace1.c */
S
S  /* Trace function macros, used in API functions */
S  #define OS_TRACE_VOID(id)            OS_TraceVoid(id)
S  #define OS_TRACE_PTR(id, p)          OS_TracePtr(id, p)
S  #define OS_TRACE_DATA(id, v)         OS_TraceData(id, v)
S  #define OS_TRACE_DATA_PTR(id, v, p)  OS_TraceDataPtr(id, v, p)
S  #define OS_TRACE_U32_PTR(id, p0, p1) OS_TraceU32Ptr(id, p0, p1)
S
S  #define OS_TRACE_START()                    { OS_EnterRegion();                                }
S  #define OS_TRACE_START_VOID(id)             { OS_EnterRegion(); OS_TraceVoid(id);              }
S  #define OS_TRACE_START_PTR(id, p)           { OS_EnterRegion(); OS_TracePtr(id, p);            }
S  #define OS_TRACE_START_DATA(id, v)          { OS_EnterRegion(); OS_TraceData(id, v);           }
S  #define OS_TRACE_START_DATA_PTR(id, v, p)   { OS_EnterRegion(); OS_TraceDataPtr(id, v, p);     }
S  #define OS_TRACE_START_U32_PTR(id, p0, p1)  { OS_EnterRegion(); OS_TraceU32Ptr(id, u, p);      }
S  #define OS_TRACE_END()                      { OS_LeaveRegion();                                }
S
N#else
N  /* Replace trace functions by empty macros if trace is not enabled */
N  #define OS_TraceVoid(id)
N  #define OS_TracePtr(id, p)
N  #define OS_TraceData(id, v)
N  #define OS_TraceDataPtr(id, v, p)
N  #define OS_TraceU32Ptr(id, p0, p1)
N  #define OS_TraceEnable()
N  #define OS_TraceDisable()
N  #define OS_TraceEnableAll()
N  #define OS_TraceDisableAll()
N  #define OS_TraceEnableId(id)
N  #define OS_TraceDisableId(id)
N  #define OS_TraceEnableFilterId(FilterIndex, id)
N  #define OS_TraceDisableFilterId(FilterIndex, id)
N  /* Trace function macros, used in API functions. */
N  /* Expand to nothing if trace is disabled       */
N  #define OS_TRACE_VOID(id)
N  #define OS_TRACE_PTR(id, p)
N  #define OS_TRACE_DATA(id, v)
N  #define OS_TRACE_DATA_PTR(id, v, p)
N  #define OS_TRACE_U32_PTR(id, p0, p1)
N
N  #define OS_TRACE_START()
N  #define OS_TRACE_START_VOID(id)
N  #define OS_TRACE_START_PTR(id, p)
N  #define OS_TRACE_START_DATA(id, v)
N  #define OS_TRACE_START_DATA_PTR(id, v, p)
N  #define OS_TRACE_START_U32_PTR(id, p0, p1)
N  #define OS_TRACE_END()
N#endif
N
N/*********************************************************************
N*
N*        RTOSInit and misc.
N*
N**********************************************************************
N
NThe routines declared below are available on all targets.
N
N*/
N
N/* Routines in RTOSInit.c */
Nvoid   OS_InitHW(void);
Nvoid   OS_Idle(void);
NOS_U32 OS_ConvertCycles2us(OS_U32 Cycles);
Xunsigned int OS_ConvertCycles2us(unsigned int Cycles);
NOS_U32 OS_GetTime_Cycles(void);
Xunsigned int OS_GetTime_Cycles(void);
Nvoid   OS_COM_Init(void);
Nvoid   OS_COM_Send1(unsigned char c);
N
N/* Routines in OS_Error.c, delivered as source file */
Nvoid   OS_Error(int code);
N
NOS_INTERWORK void  OS_Start(void);                  /* RTOS ASM part   */
X void  OS_Start(void);                   
NOS_INTERWORK void  OS_Switch(void);                 /* RTOS ASM part   */
X void  OS_Switch(void);                  
NOS_INTERWORK int   OS_SwitchFromInt(void);          /* RTOS ASM part   */
X int   OS_SwitchFromInt(void);           
N
Nvoid  OS_InitKern(void);             /* OSKern.c        */
NOS_U8 OS_OnTx(void);                 /* OSComRxTx1.c, Returns 1 on last byte */
Xunsigned char OS_OnTx(void);                  
Nvoid  OS_OnRx(unsigned char c);      /* OSComRxTx1.c    */
Nvoid  OS_Send1(OS_U8 c);             /* not implemented */
Xvoid  OS_Send1(unsigned char c);              
Nvoid  OS_SendString(const char* s);  /* OSSend.c        */
NOS_RX_CALLBACK* OS_SetRxCallback(OS_RX_CALLBACK* cb);
NOS_U8 OS_EvaPacketEx(const OS_U8 * pSrc, OS_U16 SrcLen, OS_U8** pReturn);  /* OS_EvaPacketEx.c */
Xunsigned char OS_EvaPacketEx(const unsigned char * pSrc, unsigned short SrcLen, unsigned char** pReturn);   
N
Nvoid  OS_COM_ClearTxActive(void);    /* OSCom2.c */
N
N/*********************************************************************
N*
N*        RTOS misc. optional
N*
N**********************************************************************
N
NThe routines declared below are available on some targets
Nonly. (Because they do not make much sense on others)
N*/
N
N/* Timing routines. Their existance depends on the CPU. In general,
N  8-bit CPUs require both routines, where 16-bit CPUs require one
N  and 32-bit CPUs require none of these.
N*/
N#ifndef OS_GetTime
S  OS_TIME OS_GetTime(void);
N#endif
N#ifndef OS_GetTime32
S  #if (OS_SIZEOF_INT == 4)
S    #define OS_GetTime32() (OS_Time)
S  #else
S    OS_I32 OS_GetTime32(void);
S  #endif
N#endif
N
Nvoid OS__di(void);
Nvoid OS__ei(void);
Nvoid OS__SaveIPL(void);
Nvoid OS__RestIPL(void);
Nvoid OS_SIM_Init(void);
N
N/* Standard tick handler which increment OS time variable by one on each interrupt */
Nvoid OS_HandleTick(void);       /* New version of OS_TickHandler() without Enter- Leave-Interrupt    */
Nvoid OS_HandleTickDI(void);     /* OSTickDI.c */
N
N/* Non standard tick handler which increment the OS time variable by OS_IntMsInc once on each interrupt */
N/* One of these handler has to be used when OS_CONFIG() is used to set a tick increment unequal to 0    */
Nvoid OS_HandleTick_Ex(void);    /* OS_HandleTick_Ex.c */
Nvoid OS_HandleTickDI_Ex(void);  /* OSTickDI_Ex.c      */
N
Nvoid OS_AddTickHook(OS_TICK_HOOK* pHook, OS_TICK_HOOK_ROUTINE * pfUser);
Nvoid OS_RemoveTickHook(OS_TICK_HOOK* pHook);
N
N/* Routines for the PC-version running in native mode (non-windows) */
Nvoid OS_SetIntFreq(OS_UINT f);
Xvoid OS_SetIntFreq(unsigned int f);
Nvoid OS_Exit(int code);
Nvoid OS_UseDos(void);
Nvoid OS_UnuseDos(void);
Nint  OS_GetKey(void);
Nint  OS_WaitKey(void);
N
N/* Compatibility with manual */
N#define OS_CREATEMB          OS_CreateMB
N#define OS_GetUseCnt         OS_GetSemaValue
N#define OS_WaitCSema_Timed   OS_WaitCSemaTimed
N#define OS_WaitEvent_Timed   OS_WaitEventTimed
N
N/********************************************************************/
N
N#ifdef __cplusplus
S  }
N#endif
N
N#endif /* RTOS_H_INCLUDED */
N
N/*****  EOF  ********************************************************/
N
L 25 "GUI\GUI_VNC_X_StartServer.c" 2
N#include "GUI.h"
L 1 "GUI\GUI.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI.h
NPurpose     : GUI API include file
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_H
N#define  GUI_H
N
N#include "GUI_ConfDefaults.h"
L 1 "GUI\GUI_ConfDefaults.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI_ConfDefaults.h
NPurpose     : Defaults for GUI config switches.
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_CONFDEFAULTS_H
N#define  GUI_CONFDEFAULTS_H
N
N#include "GUIConf.h"
L 1 "Config\GUIConf.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUIConf.h
NPurpose     : Configuration of available features and default values
N----------------------------------------------------------------------
N*/
N
N#ifndef GUICONF_H
N#define GUICONF_H
N
N/*********************************************************************
N*
N*       Multi layer/display support
N*/
N#define GUI_NUM_LAYERS            (16) // Maximum number of available layers
N
N/*********************************************************************
N*
N*       Multi tasking support
N*/
N#define GUI_OS                    (1)  // Compile with multitasking support
N
N/*********************************************************************
N*
N*       Configuration of available packages
N*/
N#ifndef   GUI_SUPPORT_TOUCH
N  #define GUI_SUPPORT_TOUCH       (1)  // Support touchscreen
N#endif
N#define GUI_SUPPORT_MOUSE         (1)  // Support a mouse
N#define GUI_SUPPORT_UNICODE       (1)  // Support mixed ASCII/UNICODE strings
N#define GUI_WINSUPPORT            (1)  // Window manager package available
N#define GUI_SUPPORT_MEMDEV        (1)  // Memory devices available
N#define GUI_SUPPORT_AA            (1)  // Anti aliasing available
N#define WM_SUPPORT_STATIC_MEMDEV  (1)  // Static memory devices available
N
N/*********************************************************************
N*
N*       Default font
N*/
N#define GUI_DEFAULT_FONT          &GUI_Font6x8
N
N#endif  /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 26 "GUI\GUI_ConfDefaults.h" 2
N
N#ifndef   LCD_MAX_LOG_COLORS
N  #define LCD_MAX_LOG_COLORS 256
N#else
S  #if (LCD_MAX_LOG_COLORS > 256)
S    #error The value of LCD_MAX_LOG_COLORS must be <= 256!
S  #endif
N#endif
N
N#ifndef GUI_BYTESPERPIXEL
N  #define GUI_BYTESPERPIXEL 4
N#endif
N
N#if   (GUI_BYTESPERPIXEL != 4)
X#if   (4 != 4)
S  #error This emWin version only supports an internal length of 4 bytes per pixel!
N#endif
N
N#if   (GUI_BYTESPERPIXEL == 1)
X#if   (4 == 1)
S  #define LCD_PIXELINDEX U8
S#elif (GUI_BYTESPERPIXEL == 2)
X#elif (4 == 2)
S  #define LCD_PIXELINDEX U16
N#elif (GUI_BYTESPERPIXEL == 4)
X#elif (4 == 4)
N  #define LCD_PIXELINDEX U32
N#else
S  #error The value of GUI_BYTESPERPIXEL needs to be 1, 2 or 4!
N#endif
N
N#ifndef LCD_YMAG
N  #define LCD_YMAG 1
N#endif
N#ifndef LCD_XMAG
N  #define LCD_XMAG 1
N#endif
N
N/**********************************************************************
N*
N*       Defaults for config switches
N*
N***********************************************************************
N*/
N
N/* Define "universal pointer". Normally, this is not needed (define will expand to nothing)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __generic),
N   since a default pointer can access RAM only, not the built-in Flash
N*/
N#ifndef GUI_UNI_PTR
N  #define GUI_UNI_PTR
N  #define GUI_UNI_PTR_USED 0
N#else
S  #define GUI_UNI_PTR_USED 1
N#endif
N
N/* Define const storage. Normally, this is not needed (define will expand to const)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __flash const),
N   since otherwise constants are copied into RAM
N*/
N#ifndef GUI_CONST_STORAGE
N  #define GUI_CONST_STORAGE const
N#endif
N
N#ifndef GUI_USE_MEMDEV_1BPP_FOR_SCREEN
N  #define GUI_USE_MEMDEV_1BPP_FOR_SCREEN 1
N#endif
N
N#ifndef GUI_BIDI_MAX_CHARS_PER_LINE
N  #define GUI_BIDI_MAX_CHARS_PER_LINE 80
N#endif
N
N#ifndef GUI_SUPPORT_BIDI
N  #define GUI_SUPPORT_BIDI 0
N#endif
N
N#ifndef GUI_ALLOC_SIZE
N  #define GUI_ALLOC_SIZE      0
N#endif
N
N#ifndef GUI_MAXBLOCKS
N  #define GUI_MAXBLOCKS (2 + GUI_ALLOC_SIZE / 32)
N#endif
N
N#ifndef GUI_SUPPORT_TOUCH
S  #define GUI_SUPPORT_TOUCH   0
N#endif
N
N#ifndef GUI_SUPPORT_MOUSE
S  #define GUI_SUPPORT_MOUSE   0
N#endif
N
N#ifndef GUI_SUPPORT_MEMDEV
S  #define GUI_SUPPORT_MEMDEV  0
N#endif
N
N#ifndef GUI_OS
S  #define GUI_OS              0
N#endif
N
N#ifndef GUI_SUPPORT_LARGE_BITMAPS
N  #if GUI_ALLOC_SIZE > 65535
X  #if 0 > 65535
S    #define GUI_SUPPORT_LARGE_BITMAPS 1
N  #else
N    #define GUI_SUPPORT_LARGE_BITMAPS 0
N  #endif
N#endif
N
N#ifndef GUI_COMPATIBLE_MODE
N  #define GUI_COMPATIBLE_MODE 1
N#endif
N
N#ifndef GUI_NUM_LAYERS
S  #define GUI_NUM_LAYERS      1
N#endif
N
N#ifndef GUI_SUPPORT_CURSOR
N  #define GUI_SUPPORT_CURSOR  (GUI_SUPPORT_MOUSE | GUI_SUPPORT_TOUCH)
N#endif
N
N#ifndef   GUI_SUPPORT_SPRITE
N  #define GUI_SUPPORT_SPRITE 1
N#endif
N
N#ifndef   GUI_CURSOR_LAYER
N  #define GUI_CURSOR_LAYER 0
N#endif
N
N#ifndef GUI_SELECT_JPEG
N  #define GUI_SELECT_JPEG 0
N#endif
N
N#ifndef GUI_MEMCPY
N  #define GUI_MEMCPY(pDest, pSrc, NumBytes) memcpy(pDest, pSrc, NumBytes)
N#endif
N
N#ifndef GUI_SUPPORT_ROTATION
N  #define GUI_SUPPORT_ROTATION 1
N#endif
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef GUI_USE_PARA
N  #if defined (__BORLANDC__) || defined(NC30) || defined(NC308)
X  #if 0L || 0L || 0L
S    #define GUI_USE_PARA(para)
N  #else
N    #define GUI_USE_PARA(para) para=para;
N  #endif
N#endif
N
N/* Default for types */
N#ifndef GUI_TIMER_TIME
N  #define GUI_TIMER_TIME int  /* default is to use 16 bits for 16 bit CPUs,
N	                           32 bits on 32 bit CPUs for timing */
N#endif
N
N/* Types used for memory allocation */
N#if (GUI_ALLOC_SIZE >= 32767) || (GUI_ALLOC_SIZE == 0)
X#if (0 >= 32767) || (0 == 0)
N  #define GUI_ALLOC_DATATYPE   I32
N  #define GUI_ALLOC_DATATYPE_U U32
N#else
S  #define GUI_ALLOC_DATATYPE   I16
S  #define GUI_ALLOC_DATATYPE_U U16
N#endif
N
N#ifndef   GUI_MAX_XBF_BYTES
N  #define GUI_MAX_XBF_BYTES 200
N#endif
N
N#ifndef   GUI_MEMSET
N  #define GUI_MEMSET GUI__memset
N#endif
N
N
N#endif   /* ifdef GUI_CONFDEFAULTS_H */
N
N/*************************** End of file ****************************/
L 22 "GUI\GUI.h" 2
N#include "GUI_Type.h"
L 1 "GUI\GUI_Type.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI_Type.h
NPurpose     : Include file define the types used for GUI
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUITYPE_H_INCLUDED
N#define  GUITYPE_H_INCLUDED
N
N#include "LCD.h"
L 1 "GUI\LCD.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : LCD.h
NPurpose     : Declares LCD interface functions
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_H
N#define LCD_H
N
N#include "GUI_ConfDefaults.h" /* Used for GUI_UNI_PTR */
N#include "Global.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Basic type defines
N*
N* The follwing are defines for types used in the LCD-driver and the
N* GUI layers on top of that. Since "C" does not provide data types of
N* fixed length which are identical on all platforms, this is done here.
N* For most 16/32 controllers, the settings will work fine. However, if
N* you have similar defines in other sections of your program, you might
N* want to change or relocate these defines, e.g. in a TYPE.h file.
N*/
N#define I16P I16              /*   signed 16 bits OR MORE ! */
N#define U16P U16              /* unsigned 16 bits OR MORE ! */
N
N/*********************************************************************
N*
N*       Settings for windows simulation
N*
N* Some settings in the configuration may conflict with the values required
N* in the Simulation. This is why we ignore the target settings for data
N* types and use the correct settings for the simulation.
N* (U32 could be defined as long, which would yield a 64 bit type on
N* the PC)
N*/
N#ifdef WIN32
S  #pragma warning( disable : 4244 )  // Disable warning messages in simulation
S  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
N#endif                                      
N
N/*********************************************************************
N*
N*       Constants
N*/
N#define LCD_ERR0 (0x10)
N#define LCD_ERR_CONTROLLER_NOT_FOUND (LCD_ERR0+1)
N#define LCD_ERR_MEMORY               (LCD_ERR0+2)
N
N/*********************************************************************
N*
N*       Drawing modes
N*/
N#define LCD_DRAWMODE_NORMAL (0)
N#define LCD_DRAWMODE_XOR    (1<<0)
N#define LCD_DRAWMODE_TRANS  (1<<1)
N#define LCD_DRAWMODE_REV    (1<<2)
N
N/*********************************************************************
N*
N*       Typedefs
N*/
Ntypedef int LCD_DRAWMODE;
Ntypedef U32 LCD_COLOR;
Xtypedef unsigned long LCD_COLOR;
N 
N/*********************************************************************
N*
N*       Data structures
N*/
Ntypedef struct { I16P x,y; } GUI_POINT;
Xtypedef struct { signed short x,y; } GUI_POINT;
Ntypedef struct { I16 x0,y0,x1,y1; } LCD_RECT;
Xtypedef struct { signed short x0,y0,x1,y1; } LCD_RECT;
N
Ntypedef struct {
N  int              NumEntries; 
N  char             HasTrans;         
N  const LCD_COLOR GUI_UNI_PTR * pPalEntries; 
X  const LCD_COLOR  * pPalEntries; 
N} LCD_LOGPALETTE; 
N
N/* This is used for the simulation only ! */
Ntypedef struct {
N  int x,y;
N  unsigned char KeyStat;
N} LCD_tMouseState;
N
Ntypedef struct {
N  int               NumEntries; 
N  const LCD_COLOR * pPalEntries; 
N} LCD_PHYSPALETTE; 
N
N/*********************************************************************
N*
N*       LCD_L0_... color conversion
N*/
Ntypedef LCD_COLOR      tLCDDEV_Index2Color  (unsigned Index);
Ntypedef unsigned int   tLCDDEV_Color2Index  (LCD_COLOR Color);
Ntypedef unsigned int   tLCDDEV_GetIndexMask (void);
N
N/*********************************************************************
N*
N*       Color conversion API tables
N*/
Ntypedef struct {
N  tLCDDEV_Color2Index  * pfColor2Index;
N  tLCDDEV_Index2Color  * pfIndex2Color;
N  tLCDDEV_GetIndexMask * pfGetIndexMask;
N} LCD_API_COLOR_CONV;
N
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_0;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_5;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_822216;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_84444;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8888;
N
N#define GUICC_0        &LCD_API_ColorConv_0
N#define GUICC_1        &LCD_API_ColorConv_1
N#define GUICC_M1       &LCD_API_ColorConv_M1
N#define GUICC_2        &LCD_API_ColorConv_2
N#define GUICC_M2       &LCD_API_ColorConv_M2
N#define GUICC_4        &LCD_API_ColorConv_4
N#define GUICC_M4       &LCD_API_ColorConv_M4
N#define GUICC_5        &LCD_API_ColorConv_5
N#define GUICC_111      &LCD_API_ColorConv_111
N#define GUICC_222      &LCD_API_ColorConv_222
N#define GUICC_233      &LCD_API_ColorConv_233
N#define GUICC_323      &LCD_API_ColorConv_323
N#define GUICC_332      &LCD_API_ColorConv_332
N#define GUICC_444_12   &LCD_API_ColorConv_444_12
N#define GUICC_444_12_1 &LCD_API_ColorConv_444_12_1
N#define GUICC_444_16   &LCD_API_ColorConv_444_16
N#define GUICC_555      &LCD_API_ColorConv_555
N#define GUICC_565      &LCD_API_ColorConv_565
N#define GUICC_556      &LCD_API_ColorConv_556
N#define GUICC_655      &LCD_API_ColorConv_655
N#define GUICC_666      &LCD_API_ColorConv_666
N#define GUICC_822216   &LCD_API_ColorConv_822216
N#define GUICC_84444    &LCD_API_ColorConv_84444
N#define GUICC_8666     &LCD_API_ColorConv_8666
N#define GUICC_8666_1   &LCD_API_ColorConv_8666_1
N#define GUICC_888      &LCD_API_ColorConv_888
N#define GUICC_8888     &LCD_API_ColorConv_8888
N#define GUICC_M111     &LCD_API_ColorConv_M111
N#define GUICC_M222     &LCD_API_ColorConv_M222
N#define GUICC_M233     &LCD_API_ColorConv_M233
N#define GUICC_M323     &LCD_API_ColorConv_M323
N#define GUICC_M332     &LCD_API_ColorConv_M332
N#define GUICC_M444_12  &LCD_API_ColorConv_M444_12
N#define GUICC_M444_16  &LCD_API_ColorConv_M444_16
N#define GUICC_M555     &LCD_API_ColorConv_M555
N#define GUICC_M565     &LCD_API_ColorConv_M565
N#define GUICC_M556     &LCD_API_ColorConv_M556
N#define GUICC_M655     &LCD_API_ColorConv_M655
N#define GUICC_M666     &LCD_API_ColorConv_M666
N#define GUICC_M8565    &LCD_API_ColorConv_M8565
N#define GUICC_M888     &LCD_API_ColorConv_M888
N#define GUICC_M8888    &LCD_API_ColorConv_M8888
N
N/*********************************************************************
N*
N*       Compatibility defines for older versions
N*/
N#define GUI_COLOR_CONV_1    GUICC_1   
N#define GUI_COLOR_CONV_2    GUICC_2   
N#define GUI_COLOR_CONV_4    GUICC_4   
N#define GUI_COLOR_CONV_8666 GUICC_8666
N#define GUI_COLOR_CONV_888  GUICC_888 
N#define GUI_COLOR_CONV_8888 GUICC_8888
N#define GUI_COLOR_CONV_565  GUICC_565 
N#define GUI_COLOR_CONV_M565 GUICC_M565
N
N/*********************************************************************
N*
N*       LCDDEV function table
N*
N*  Below the routines which need to in an LCDDEV routine table are
N*  defined. All of these routines have to be in the low-level driver
N*  (LCD_L0) or in the memory device which can be used to replace the
N*  driver.
N*  The one exception to this is the SetClipRect routine, which would
N*  be identical for all drivers and is therefor contained in the
N*  level above (LCD).
N*/
Ntypedef void         tLCDDEV_DrawPixel    (int x, int y);
Ntypedef void         tLCDDEV_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCDDEV_DrawVLine    (int x , int y0,  int y1);
Ntypedef void         tLCDDEV_FillRect     (int x0, int y0, int x1, int y1);
Ntypedef unsigned int tLCDDEV_GetPixelIndex(int x, int y);
Ntypedef void         tLCDDEV_SetPixelIndex(int x, int y, int ColorIndex);
Ntypedef void         tLCDDEV_XorPixel     (int x, int y);
Ntypedef void         tLCDDEV_FillPolygon  (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_FillPolygonAA(const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_GetRect      (LCD_RECT*pRect);
Ntypedef int          tLCDDEV_Init         (void);
Ntypedef void         tLCDDEV_On           (void);
Ntypedef void         tLCDDEV_Off          (void);
Ntypedef void         tLCDDEV_SetLUTEntry  (U8 Pos, LCD_COLOR color);
Xtypedef void         tLCDDEV_SetLUTEntry  (unsigned char Pos, LCD_COLOR color);
Ntypedef void *       tLCDDEV_GetDevFunc   (int Index);
Ntypedef I32          tLCDDEV_GetDevProp   (int Index);
Xtypedef signed long          tLCDDEV_GetDevProp   (int Index);
Ntypedef void         tLCDDEV_SetOrg       (int x, int y);
N
N/*********************************************************************
N*
N*       Memory device API tables
N*/
Ntypedef struct GUI_DEVICE     GUI_DEVICE;
Ntypedef struct GUI_DEVICE_API GUI_DEVICE_API;
N
Ntypedef void tLCDDEV_DrawBitmap   (int x0, int y0, int xsize, int ysize,
N                       int BitsPerPixel, int BytesPerLine,
N                       const U8 GUI_UNI_PTR * pData, int Diff,
X                       const unsigned char  * pData, int Diff,
N                       const void* pTrans);   /* Really LCD_PIXELINDEX, but is void to avoid compiler warnings*/
N#define GUI_MEMDEV_APILIST_1  &GUI_MEMDEV_DEVICE_1
N#define GUI_MEMDEV_APILIST_8  &GUI_MEMDEV_DEVICE_8
N#define GUI_MEMDEV_APILIST_16 &GUI_MEMDEV_DEVICE_16
N#define GUI_MEMDEV_APILIST_32 &GUI_MEMDEV_DEVICE_32
N
N/*********************************************************************
N*
N*       Defines for device capabilities
N*
N* The following is the list of device capabilities which can, but do
N* not have to be implemented in the driver. This way the driver can be
N* enhanced in the future without affecting the driver interface,
N* keeping older drivers compatible.
N* More DevCaps can always be added in the future, as older drivers
N* are guaranteed to return 0 for all unimplemented features or queries.
N*
N* The values below define the legal parameters to the LCD_GetDeviceCaps
N* and the LCD_GetpCapFunc routines.
N*/
N
N#define LCD_DEVCAP_XSIZE             0x01    /* Quest horiz. res. of display */
N#define LCD_DEVCAP_YSIZE             0x02    /* Quest vert. res. of display */
N#define LCD_DEVCAP_VXSIZE            0x03    /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_VYSIZE            0x04    /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_XORG              0x05    /* X-origin ... usually 0 */
N#define LCD_DEVCAP_YORG              0x06    /* Y-origin ... usually 0 */
N#define LCD_DEVCAP_CONTROLLER        0x07    /* LCD Controller (Numerical) */
N#define LCD_DEVCAP_BITSPERPIXEL      0x08    /* Bits per pixel ... 1/2/4/8 */
N#define LCD_DEVCAP_NUMCOLORS         0x09    /* Quest number of colors */
N#define LCD_DEVCAP_XMAG              0x0A
N#define LCD_DEVCAP_YMAG              0x0B
N#define LCD_DEVCAP_MIRROR_X          0x0C
N#define LCD_DEVCAP_MIRROR_Y          0x0D
N#define LCD_DEVCAP_SWAP_XY           0x0E
N#define LCD_DEVCAP_SWAP_RB           0x0F
N
Nint LCD_GetXSizeMax(void);
Nint LCD_GetYSizeMax(void);
Nint LCD_GetVXSizeMax(void);
Nint LCD_GetVYSizeMax(void);
Nint LCD_GetBitsPerPixelMax(void);
N
Nint LCD_GetXSizeEx          (int LayerIndex);
Nint LCD_GetYSizeEx          (int LayerIndex);
Nint LCD_GetVXSizeEx         (int LayerIndex);
Nint LCD_GetVYSizeEx         (int LayerIndex);
Nint LCD_GetBitsPerPixelEx   (int LayerIndex);
NU32 LCD_GetNumColorsEx      (int LayerIndex);
Xunsigned long LCD_GetNumColorsEx      (int LayerIndex);
Nint LCD_GetXMagEx           (int LayerIndex);
Nint LCD_GetYMagEx           (int LayerIndex);
Nint LCD_GetMirrorXEx        (int LayerIndex);
Nint LCD_GetMirrorYEx        (int LayerIndex);
Nint LCD_GetSwapXYEx         (int LayerIndex);
Nint LCD_GetReversLUTEx      (int LayerIndex);
Nint LCD_GetPhysColorsInRAMEx(int LayerIndex);
N
Nint LCD_GetXSize            (void);
Nint LCD_GetYSize            (void);
Nint LCD_GetVXSize           (void);
Nint LCD_GetVYSize           (void);
Nint LCD_GetBitsPerPixel     (void);
NU32 LCD_GetNumColors        (void);
Xunsigned long LCD_GetNumColors        (void);
Nint LCD_GetXMag             (void);
Nint LCD_GetYMag             (void);
Nint LCD_GetMirrorX          (void);
Nint LCD_GetMirrorY          (void);
Nint LCD_GetSwapXY           (void);
Nint LCD_GetReversLUT        (void);
Nint LCD_GetPhysColorsInRAM  (void);
N
NI32 LCD__GetBPP      (U32 IndexMask);
Xsigned long LCD__GetBPP      (unsigned long IndexMask);
NI32 LCD__GetBPPDevice(U32 IndexMask);
Xsigned long LCD__GetBPPDevice(unsigned long IndexMask);
N
NtLCDDEV_Index2Color * LCD_GetpfIndex2ColorEx(int LayerIndex);
NtLCDDEV_Color2Index * LCD_GetpfColor2IndexEx(int LayerIndex);
N
NtLCDDEV_Color2Index * LCD_GetpfColor2Index(void);
N
Nint LCD_GetNumLayers(void);
N
NLCD_COLOR * LCD_GetPalette  (void);
NLCD_COLOR * LCD_GetPaletteEx(int LayerIndex);
N
N/*********************************************************************
N*
N*       Values for requesting function pointers (display driver)
N*/
N                                       /* Request of a function pointer for... */
N#define LCD_DEVFUNC_READRECT      0x01 /* ...reading a rectangular display area */
N#define LCD_DEVFUNC_SETALPHA      0x02 /* ...setting the alpha blending factor */
N#define LCD_DEVFUNC_SETPOS        0x03 /* ...setting the layer position */
N#define LCD_DEVFUNC_GETPOS        0x04 /* ...getting the layer position */
N#define LCD_DEVFUNC_SETSIZE       0x05 /* ...setting the layer size */
N#define LCD_DEVFUNC_SETVIS        0x06 /* ...setting the visibility of a layer */
N#define LCD_DEVFUNC_24BPP         0x07 /* ...drawing 24bpp bitmaps */
N#define LCD_DEVFUNC_NEXT_PIXEL    0x08 /* ...drawing a bitmap pixel by pixel */
N#define LCD_DEVFUNC_SET_VRAM_ADDR 0x09 /* ...setting the VRAM address */
N#define LCD_DEVFUNC_SET_VSIZE     0x0A /* ...setting the VRAM size */
N#define LCD_DEVFUNC_SET_SIZE      0x0B /* ...setting the display size */
N#define LCD_DEVFUNC_INIT          0x0C /* ...initializing the display controller */
N#define LCD_DEVFUNC_CONTROLCACHE  0x0D /* ...controlling the cache */
N#define LCD_DEVFUNC_ON            0x0E /* ...switching the display on */
N#define LCD_DEVFUNC_OFF           0x0F /* ...switching the display off */
N#define LCD_DEVFUNC_SETLUTENTRY   0x10 /* ...setting a LUT entry */
N#define LCD_DEVFUNC_FILLPOLY      0x11 /* ...filling a polygon */
N#define LCD_DEVFUNC_FILLPOLYAA    0x12 /* ...filling an antialiased polygon */
N#define LCD_DEVFUNC_ALPHAMODE     0x13 /* ...setting the alpha blending mode */
N#define LCD_DEVFUNC_CHROMAMODE    0x14 /* ...setting the chroma blending mode */
N#define LCD_DEVFUNC_CHROMA        0x15 /* ...setting the chroma values */
N
N/*********************************************************************
N*
N*       Values for requesting function pointers (memory devices)
N*/
N                                          /* Request of a function pointer for... */
N#define MEMDEV_DEVFUNC_WRITETOACTIVE 0x16 /* ...writing the memory device */
N
N/*********************************************************************
N*
N*       Values for requesting data
N*/
N                                       /* Request pointer to... */
N#define LCD_DEVDATA_MEMDEV        0x01 /* ...default memory device API */
N#define LCD_DEVDATA_PHYSPAL       0x02 /* ...physical palette */
N
N/*********************************************************************
N*
N*       Structures for passing data to LCD_X_DisplayDriver()
N*/
Ntypedef struct {
N  void * pVRAM;
N} LCD_X_SETVRAMADDR_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N} LCD_X_SETORG_INFO;
N
Ntypedef struct {
N  LCD_COLOR Color;
N  U8 Pos;
X  unsigned char Pos;
N} LCD_X_SETLUTENTRY_INFO;
N
Ntypedef struct {
N  int xSize, ySize;
N} LCD_X_SETSIZE_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N} LCD_X_SETPOS_INFO;
N
Ntypedef struct {
N  int Alpha;
N} LCD_X_SETALPHA_INFO;
N
Ntypedef struct {
N  int OnOff;
N} LCD_X_SETVIS_INFO;
N
Ntypedef struct {
N  int AlphaMode;
N} LCD_X_SETALPHAMODE_INFO;
N
Ntypedef struct {
N  int ChromaMode;
N} LCD_X_SETCHROMAMODE_INFO;
N
Ntypedef struct {
N  LCD_COLOR ChromaMin;
N  LCD_COLOR ChromaMax;
N} LCD_X_SETCHROMA_INFO;
N
N/*********************************************************************
N*
N*       Commands for LCD_X_DisplayDriver()
N*/
N#define LCD_X_INITCONTROLLER 0x01 /* Initializing the display controller */
N#define LCD_X_SETVRAMADDR    0x02 /* Setting the video RAM address */
N#define LCD_X_SETORG         0x03 /* Setting the origin within a layer */
N#define LCD_X_SETLUTENTRY    0x04 /* Setting an entry of the LUT */
N#define LCD_X_ON             0x05 /* Switching the display on */
N#define LCD_X_OFF            0x06 /* Switching the display off */
N#define LCD_X_SETSIZE        0x07 /* Setting the layer size */
N#define LCD_X_SETPOS         0x08 /* Setting the layer position */
N#define LCD_X_SETVIS         0x09 /* Setting the visibility of a layer */
N#define LCD_X_SETALPHA       0x0A /* Setting the alpha value of the layer */
N#define LCD_X_SETALPHAMODE   0x0B /* Setting the alpha blending mode */
N#define LCD_X_SETCHROMAMODE  0x0C /* Setting the chroma blending mode */
N#define LCD_X_SETCHROMA      0x0D /* Setting the chroma values */
N
Nint  LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData);
Nvoid LCD_X_Config(void);
N
N/*********************************************************************
N*
N*       Set layer properties
N*/
Nint LCD_SetAlphaEx     (int LayerIndex, int Alpha);
Nint LCD_SetPosEx       (int LayerIndex, int xPos, int yPos);
Nint LCD_SetSizeEx      (int LayerIndex, int xSize, int ySize);
Nint LCD_SetVisEx       (int LayerIndex, int OnOff);
Nint LCD_SetVRAMAddrEx  (int LayerIndex, void * pVRAM);
Nint LCD_SetVSizeEx     (int LayerIndex, int xSize, int ySize);
Nint LCD_SetAlphaModeEx (int LayerIndex, int AlphaMode);
Nint LCD_SetChromaModeEx(int LayerIndex, int ChromaMode);
Nint LCD_SetChromaEx    (int LayerIndex, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
N
Nint LCD_SetAlpha     (int Alpha);
Nint LCD_SetVRAMAddr  (void * pVRAM);
Nint LCD_SetVSize     (int xSize, int ySize);
Nint LCD_SetSize      (int xSize, int ySize);
Nint LCD_SetVis       (int OnOff);
Nint LCD_SetPos       (int xPos, int yPos);
Nint LCD_SetAlphaMode (int AlphaMode);
Nint LCD_SetChromaMode(int ChromaMode);
Nint LCD_SetChroma    (LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
Nint LCD_SetLUTEntry  (U8 Pos, LCD_COLOR Color);
Xint LCD_SetLUTEntry  (unsigned char Pos, LCD_COLOR Color);
N
N/*********************************************************************
N*
N*       Get layer properties
N*/
Nint LCD_GetPosEx(int LayerIndex, int * pxPos, int * pyPos);
N
Nint LCD_GetPos  (int * pxPos, int * pyPos);
N
N
N/*********************************************************************
N*
N*       NEXT_PIXEL API support
N*/
Ntypedef struct {
N  void (* pfStart)   (int x0, int y0, int x1, int y1);
N  void (* pfSetPixel)(int PixelIndex);
N  void (* pfNextLine)(void);
N  void (* pfEnd)     (void);
N} LCD_API_NEXT_PIXEL;
N
NLCD_API_NEXT_PIXEL * LCD_GetNextPixelAPI(void);
N
N/*********************************************************************
N*
N*      LCD_CLIP function table
N*/
Ntypedef void         tLCD_HL_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCD_HL_DrawPixel    (int x0, int y0);
N
Ntypedef struct {
N  tLCD_HL_DrawHLine*          pfDrawHLine;
N  tLCD_HL_DrawPixel*          pfDrawPixel;
N} tLCD_HL_APIList;
N
Nvoid LCD_DrawHLine(int x0, int y0,  int x1);
Nvoid LCD_DrawPixel(int x0, int y0);
Nvoid LCD_DrawVLine  (int x, int y0,  int y1);
N
N
N/*********************************************************************
N*
N*       Declarations for LCD_
N*/
Nvoid LCD_SetClipRectEx(const LCD_RECT* pRect);
Nvoid LCD_SetClipRectMax(void);
N
N/* Get device capabilities (0 if not supported) */
NI32  LCD_GetDevCap  (int Index);
Xsigned long  LCD_GetDevCap  (int Index);
NI32  LCD_GetDevCapEx(int LayerIndex, int Index);
Xsigned long  LCD_GetDevCapEx(int LayerIndex, int Index);
N
N/* Initialize LCD using config-paramters */
Nint LCD_Init(void);
N
Nvoid LCD_SetBkColor   (LCD_COLOR Color); /* Set background color */
Nvoid LCD_SetColor     (LCD_COLOR Color); /* Set foreground color */
Nvoid LCD_SetPixelIndex(int x, int y, int ColorIndex);
N
N/* Palette routines (Not available on all drivers) */
Nvoid LCD_InitLUT(void);
Nint  LCD_SetLUTEntryEx(int LayerIndex, U8 Pos, LCD_COLOR Color);
Xint  LCD_SetLUTEntryEx(int LayerIndex, unsigned char Pos, LCD_COLOR Color);
Nvoid LCD_SetLUTEx(int LayerIndex, const LCD_PHYSPALETTE * pPalette);
Nvoid LCD_SetLUT  (const LCD_PHYSPALETTE * pPalette);
N
N/* Decompressors */
Nvoid LCD_DrawBitmap_RLE8(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid LCD_DrawBitmap_RLE8(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid LCD_DrawBitmap_RLE4(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid LCD_DrawBitmap_RLE4(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid LCD_DrawBitmap_565 (int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid LCD_DrawBitmap_565 (int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid LCD_DrawBitmap_M565(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid LCD_DrawBitmap_M565(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
N
NLCD_DRAWMODE LCD_SetDrawMode  (LCD_DRAWMODE dm);
Nvoid LCD_SetColorIndex(unsigned PixelIndex);
Nvoid LCD_SetBkColorIndex(unsigned PixelIndex);
Nvoid LCD_FillRect(int x0, int y0, int x1, int y1);
Ntypedef void tLCD_SetPixelAA(int x, int y, U8 Intens);
Xtypedef void tLCD_SetPixelAA(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA        (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA        (int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA_NoTrans(int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA_Xor    (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA_Xor    (int x, int y, unsigned char Intens);
N
NLCD_COLOR    LCD_AA_MixColors(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, unsigned Intens);
NLCD_COLOR    LCD_GetPixelColor(int x, int y);     /* Get RGB color of pixel */
Nunsigned int LCD_GetPixelIndex(int x, int y);
Nint          LCD_GetBkColorIndex (void);
Nint          LCD_GetColorIndex (void);
N
N/*********************************************************************
N*
N*       Optional support for rotatation
N*/
N#if GUI_SUPPORT_ROTATION
X#if 1
N
Ntypedef void tLCD_DrawBitmap(int x0, int y0, int xsize, int ysize,
N                             int xMul, int yMul, int BitsPerPixel, int BytesPerLine,
N                             const U8 GUI_UNI_PTR * pPixel, const void * pTrans);
X                             const unsigned char  * pPixel, const void * pTrans);
Ntypedef void tRect2TextRect (LCD_RECT * pRect);
N
Nstruct tLCD_APIList_struct {
N  tLCD_DrawBitmap   * pfDrawBitmap;
N  tRect2TextRect    * pfRect2TextRect;
N};
N
Ntypedef struct tLCD_APIList_struct tLCD_APIList;
N
Nextern tLCD_APIList LCD_APIListCCW;
Nextern tLCD_APIList LCD_APIListCW;
Nextern tLCD_APIList LCD_APIList180;
N
N#define GUI_ROTATION   tLCD_APIList
N#define GUI_ROTATE_CCW &LCD_APIListCCW
N#define GUI_ROTATE_CW  &LCD_APIListCW
N#define GUI_ROTATE_180 &LCD_APIList180
N#define GUI_ROTATE_0   0
N#endif
N
N/*********************************************************************
N*
N*       Physical color access, internally used only
N*/
Nvoid LCD__SetPhysColor(U8 Pos, LCD_COLOR Color);
Xvoid LCD__SetPhysColor(unsigned char Pos, LCD_COLOR Color);
N
N/*********************************************************************
N*
N*       Cache control
N*/
N#define LCD_CC_UNLOCK (0)    /* Default mode: Cache is transparent */
N#define LCD_CC_LOCK   (1)    /* Cache is locked, no write operations */
N#define LCD_CC_FLUSH  (2)    /* Flush cache, do not change mode */
N
Nint LCD_ControlCache  (int Cmd);
Nint LCD_ControlCacheEx(int LayerIndex, int Cmd);
N
N/*********************************************************************
N*
N*       Color conversion
N*/
Nunsigned         LCD_Color2Index     (LCD_COLOR Color);
NLCD_COLOR        LCD_Index2Color     (int Index);
NLCD_COLOR        LCD_Index2ColorEx   (int i, unsigned LayerIndex);
N
N/*********************************************************************
N*
N*       LCD_X_...
N*/
Nunsigned char LCD_X_Read00(void);
Nunsigned char LCD_X_Read01(void);
Nvoid LCD_X_Write00 (unsigned char c);
Nvoid LCD_X_Write01 (unsigned char c);
Nvoid LCD_X_WriteM01(unsigned char * pData, int NumBytes);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* LCD_H */
N
N/*************************** End of file ****************************/
L 26 "GUI\GUI_Type.h" 2
N#include "GUIConf.h"
N
N/*********************************************************************
N*
N*       Common types
N*/
Ntypedef const char *  GUI_ConstString;
N
Ntypedef LCD_COLOR       GUI_COLOR;
Ntypedef LCD_LOGPALETTE  GUI_LOGPALETTE;
Ntypedef LCD_DRAWMODE    GUI_DRAWMODE;
Ntypedef LCD_RECT        GUI_RECT;
N
Ntypedef struct {
N  void      (* pfDraw)  (int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 GUI_UNI_PTR * pPixel, 
X                         const unsigned char  * pPixel, 
N                         const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, 
X                         const LCD_LOGPALETTE  * pLogPal, 
N                         int xMag, 
N                         int yMag);
N  GUI_COLOR (* pfIndex2Color)(unsigned Index);
N  void      (* pfDrawHW)(int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 GUI_UNI_PTR * pPixel, 
X                         const unsigned char  * pPixel, 
N                         const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, 
X                         const LCD_LOGPALETTE  * pLogPal, 
N                         int xMag, 
N                         int yMag);
N} GUI_BITMAP_METHODS;
N
Ntypedef struct {
N  U16P XSize;
X  unsigned short XSize;
N  U16P YSize;
X  unsigned short YSize;
N  U16P BytesPerLine;
X  unsigned short BytesPerLine;
N  U16P BitsPerPixel;
X  unsigned short BitsPerPixel;
N  const U8 GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N  const GUI_LOGPALETTE GUI_UNI_PTR * pPal;
X  const GUI_LOGPALETTE  * pPal;
N  const GUI_BITMAP_METHODS * pMethods;
N} GUI_BITMAP;
N
N/* This structure may not be changed because the data that it
N   expects is read in binary form (via any kind of interface,
N   at runtime).
N   This structure should therefor not be changed.
N*/
Ntypedef struct {
N  U16 ID;
X  unsigned short ID;
N  U16 Format;
X  unsigned short Format;
N  U16 XSize;
X  unsigned short XSize;
N  U16 YSize;
X  unsigned short YSize;
N  U16 BytesPerLine;
X  unsigned short BytesPerLine;
N  U16 BitsPerPixel;
X  unsigned short BitsPerPixel;
N  U16 NumColors;
X  unsigned short NumColors;
N  U16 HasTrans;
X  unsigned short HasTrans;
N} GUI_BITMAP_STREAM;
N
Ntypedef struct {
N  int    Cmd;
N  U32    v;
X  unsigned long    v;
N  void * p;
N} GUI_BITMAPSTREAM_PARAM;
N
Ntypedef struct {
N  int XSize;
N  int YSize;
N  int BitsPerPixel;
N  int NumColors;
N  int HasTrans;
N} GUI_BITMAPSTREAM_INFO;
N
Ntypedef void * (* GUI_BITMAPSTREAM_CALLBACK)(GUI_BITMAPSTREAM_PARAM * pParam);
N
Ntypedef struct {
N  int x,y;
N  U8  Pressed;
X  unsigned char  Pressed;
N  U8  Layer;
X  unsigned char  Layer;
N} GUI_PID_STATE;
N
Ntypedef struct {
N  int xPos;
N  int yPos;
N  int xSize;
N  int ySize;
N  int Delay;
N} GUI_GIF_IMAGE_INFO;
N
Ntypedef struct {
N  int xSize;
N  int ySize;
N  int NumImages;
N} GUI_GIF_INFO;
N
N/*********************************************************************
N*
N*       FONT structures
N*/
N
N/* Translation list. Translates a character code into up to 2
N   indices of images to display on top of each other;
N   '' -> index('a'), index('') */
Ntypedef struct {
N  I16P c0;
X  signed short c0;
N  I16P c1;
X  signed short c1;
N} GUI_FONT_TRANSLIST;
N
Ntypedef struct {
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  const GUI_FONT_TRANSLIST GUI_UNI_PTR * pList;
X  const GUI_FONT_TRANSLIST  * pList;
N} GUI_FONT_TRANSINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N} GUI_CHARINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 YSize;
X  unsigned char YSize;
N  I8 XPos;
X  signed char XPos;
N  I8 YPos;
X  signed char YPos;
N  U8 XDist;
X  unsigned char XDist;
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N} GUI_CHARINFO_EXT;
N
Ntypedef struct GUI_FONT_PROP {
N  U16P First;                                              /* First character               */
X  unsigned short First;                                               
N  U16P Last;                                               /* Last character                */
X  unsigned short Last;                                                
N  const GUI_CHARINFO         GUI_UNI_PTR * paCharInfo;     /* Address of first character    */
X  const GUI_CHARINFO          * paCharInfo;      
N  const struct GUI_FONT_PROP GUI_UNI_PTR * pNext;          /* Pointer to next               */
X  const struct GUI_FONT_PROP  * pNext;           
N} GUI_FONT_PROP;
N
Ntypedef struct GUI_FONT_PROP_EXT {
N  U16P First;                                              /* First character               */
X  unsigned short First;                                               
N  U16P Last;                                               /* Last character                */
X  unsigned short Last;                                                
N  const GUI_CHARINFO_EXT         GUI_UNI_PTR * paCharInfo; /* Address of first character    */
X  const GUI_CHARINFO_EXT          * paCharInfo;  
N  const struct GUI_FONT_PROP_EXT GUI_UNI_PTR * pNext;      /* Pointer to next               */
X  const struct GUI_FONT_PROP_EXT  * pNext;       
N} GUI_FONT_PROP_EXT;
N
Ntypedef struct {
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N  const U8 GUI_UNI_PTR * pTransData;
X  const unsigned char  * pTransData;
N  const GUI_FONT_TRANSINFO GUI_UNI_PTR * pTrans;
X  const GUI_FONT_TRANSINFO  * pTrans;
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N} GUI_FONT_MONO;
N
N/*********************************************************************
N*
N*       FONT structures
N*
N* This structure is used when retrieving information about a font.
N* It is designed for future expansion without incompatibilities.
N*/
Ntypedef struct {
N  U16 Flags;
X  unsigned short Flags;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N} GUI_FONTINFO;
N
N#define GUI_FONTINFO_FLAG_PROP    (1 << 0)    /* Is proportional */
N#define GUI_FONTINFO_FLAG_MONO    (1 << 1)    /* Is monospaced */
N#define GUI_FONTINFO_FLAG_AA      (1 << 2)    /* Is an antialiased font */
N#define GUI_FONTINFO_FLAG_AA2     (1 << 3)    /* Is an antialiased font, 2bpp */
N#define GUI_FONTINFO_FLAG_AA4     (1 << 4)    /* Is an antialiased font, 4bpp */
N#define GUI_FONTINFO_FLAG_PROPFRM (1 << 5)    /* Is proportional, framed */
N
N/*********************************************************************
N*
N*       UNICODE Encoding
N*/
Ntypedef U16  tGUI_GetCharCode(const char GUI_UNI_PTR *s);
Xtypedef unsigned short  tGUI_GetCharCode(const char  *s);
Ntypedef int  tGUI_GetCharSize(const char GUI_UNI_PTR *s);
Xtypedef int  tGUI_GetCharSize(const char  *s);
Ntypedef int  tGUI_CalcSizeOfChar(U16 Char);
Xtypedef int  tGUI_CalcSizeOfChar(unsigned short Char);
Ntypedef int  tGUI_Encode(char *s, U16 Char);
Xtypedef int  tGUI_Encode(char *s, unsigned short Char);
N
Ntypedef struct {
N  tGUI_GetCharCode*            pfGetCharCode;
N  tGUI_GetCharSize*            pfGetCharSize;
N  tGUI_CalcSizeOfChar*         pfCalcSizeOfChar;
N  tGUI_Encode*                 pfEncode;
N} GUI_UC_ENC_APILIST;
N
N/*********************************************************************
N*
N*       FONT Encoding
N*/
Ntypedef int  tGUI_GetLineDistX(const char GUI_UNI_PTR *s, int Len);
Xtypedef int  tGUI_GetLineDistX(const char  *s, int Len);
Ntypedef int  tGUI_GetLineLen(const char GUI_UNI_PTR *s, int MaxLen);
Xtypedef int  tGUI_GetLineLen(const char  *s, int MaxLen);
Ntypedef void tGL_DispLine(const char GUI_UNI_PTR *s, int Len);
Xtypedef void tGL_DispLine(const char  *s, int Len);
N
Ntypedef struct {
N  tGUI_GetLineDistX*          pfGetLineDistX;
N  tGUI_GetLineLen*            pfGetLineLen;
N  tGL_DispLine*               pfDispLine;
N} tGUI_ENC_APIList;
N
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_SJIS;
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_EXT;
N
N/*********************************************************************
N*
N*       FONT methods
N*/
Ntypedef struct GUI_FONT GUI_FONT;
N
Ntypedef void GUI_DISPCHAR    (U16 c);
Xtypedef void GUI_DISPCHAR    (unsigned short c);
Ntypedef int  GUI_GETCHARDISTX(U16P c);
Xtypedef int  GUI_GETCHARDISTX(unsigned short c);
Ntypedef void GUI_GETFONTINFO (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi);
Xtypedef void GUI_GETFONTINFO (const GUI_FONT  * pFont, GUI_FONTINFO * pfi);
Ntypedef char GUI_ISINFONT    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xtypedef char GUI_ISINFONT    (const GUI_FONT  * pFont, unsigned short c);
Ntypedef int  GUI_GETCHARINFO (U16P c, GUI_CHARINFO_EXT * pInfo);
Xtypedef int  GUI_GETCHARINFO (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N
N#define DECLARE_FONT(Type)                                     \
Nvoid GUI##Type##_DispChar    (U16P c);                         \
Nint  GUI##Type##_GetCharDistX(U16P c);                         \
Nvoid GUI##Type##_GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi); \
Nchar GUI##Type##_IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c); \
Nint  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
X#define DECLARE_FONT(Type)                                     void GUI##Type##_DispChar    (U16P c);                         int  GUI##Type##_GetCharDistX(U16P c);                         void GUI##Type##_GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi); char GUI##Type##_IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c); int  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/* MONO: Monospaced fonts */
NDECLARE_FONT(MONO);
Xvoid GUIMONO_DispChar (unsigned short c); int GUIMONO_GetCharDistX(unsigned short c); void GUIMONO_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIMONO_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIMONO_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_MONO       \
N  GUIMONO_DispChar,             \
N  GUIMONO_GetCharDistX,         \
N  GUIMONO_GetFontInfo,          \
N  GUIMONO_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_MONO         GUIMONO_DispChar,               GUIMONO_GetCharDistX,           GUIMONO_GetFontInfo,            GUIMONO_IsInFont,               (GUI_GETCHARINFO *)0,           (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts */
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c); void GUIPROP_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP       \
N  GUIPROP_DispChar,             \
N  GUIPROP_GetCharDistX,         \
N  GUIPROP_GetFontInfo,          \
N  GUIPROP_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP         GUIPROP_DispChar,               GUIPROP_GetCharDistX,           GUIPROP_GetFontInfo,            GUIPROP_IsInFont,               (GUI_GETCHARINFO *)0,           (tGUI_ENC_APIList*)0
N
N/* PROP_EXT: Extended proportional fonts */
NDECLARE_FONT(PROP_EXT);
Xvoid GUIPROP_EXT_DispChar (unsigned short c); int GUIPROP_EXT_GetCharDistX(unsigned short c); void GUIPROP_EXT_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_EXT_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_EXT       \
N  GUIPROP_EXT_DispChar,             \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_EXT         GUIPROP_EXT_DispChar,               GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_FRM: Extended proportional fonts, framed */
NDECLARE_FONT(PROP_FRM);
Xvoid GUIPROP_FRM_DispChar (unsigned short c); int GUIPROP_FRM_GetCharDistX(unsigned short c); void GUIPROP_FRM_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_FRM_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_FRM_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_FRM       \
N  GUIPROP_FRM_DispChar,             \
N  GUIPROP_FRM_GetCharDistX,         \
N  GUIPROP_FRM_GetFontInfo,          \
N  GUIPROP_FRM_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_FRM         GUIPROP_FRM_DispChar,               GUIPROP_FRM_GetCharDistX,           GUIPROP_FRM_GetFontInfo,            GUIPROP_FRM_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts SJIS */
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c); void GUIPROP_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_SJIS  \
N  GUIPROP_DispChar,             \
N  GUIPROP_GetCharDistX,         \
N  GUIPROP_GetFontInfo,          \
N  GUIPROP_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_SJIS    GUIPROP_DispChar,               GUIPROP_GetCharDistX,           GUIPROP_GetFontInfo,            GUIPROP_IsInFont,               (GUI_GETCHARINFO *)0,           &GUI_ENC_APIList_SJIS
N
N/* PROPAA: Proportional, antialiased fonts */
NDECLARE_FONT(PROPAA);
Xvoid GUIPROPAA_DispChar (unsigned short c); int GUIPROPAA_GetCharDistX(unsigned short c); void GUIPROPAA_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROPAA_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROPAA_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROPAA       \
N  GUIPROPAA_DispChar,             \
N  GUIPROPAA_GetCharDistX,         \
N  GUIPROPAA_GetFontInfo,          \
N  GUIPROPAA_IsInFont,             \
N  (GUI_GETCHARINFO *)0,           \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROPAA         GUIPROPAA_DispChar,               GUIPROPAA_GetCharDistX,           GUIPROPAA_GetFontInfo,            GUIPROPAA_IsInFont,               (GUI_GETCHARINFO *)0,             (tGUI_ENC_APIList*)0
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp */
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c); void GUIPROP_AA2_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA2_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA2       \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA2         GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA2_EXT: Proportional, antialiased fonts, 2bpp, extended font information */
NDECLARE_FONT(PROP_AA2_EXT);
Xvoid GUIPROP_AA2_EXT_DispChar (unsigned short c); int GUIPROP_AA2_EXT_GetCharDistX(unsigned short c); void GUIPROP_AA2_EXT_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_EXT_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA2_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA2_EXT   \
N  GUIPROP_AA2_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA2_EXT     GUIPROP_AA2_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp, SJIS encoding */
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c); void GUIPROP_AA2_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA2_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA2_SJIS  \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  GUI_ENCODE_SJIS
X#define GUI_FONTTYPE_PROP_AA2_SJIS    GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               GUI_ENCODE_SJIS
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp */
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c); void GUIPROP_AA4_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA4_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA4       \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA4         GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA4_EXT: Proportional, antialiased fonts, 4bpp, extended font information */
NDECLARE_FONT(PROP_AA4_EXT);
Xvoid GUIPROP_AA4_EXT_DispChar (unsigned short c); int GUIPROP_AA4_EXT_GetCharDistX(unsigned short c); void GUIPROP_AA4_EXT_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_EXT_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA4_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA4_EXT   \
N  GUIPROP_AA4_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA4_EXT     GUIPROP_AA4_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp, SJIS encoding */
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c); void GUIPROP_AA4_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT  * pFont, unsigned short c); int GUIPROP_AA4_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N#define GUI_FONTTYPE_PROP_AA4_SJIS  \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  GUI_ENCODE_SJIS
X#define GUI_FONTTYPE_PROP_AA4_SJIS    GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               GUI_ENCODE_SJIS
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
Nstruct GUI_FONT {
N  GUI_DISPCHAR     * pfDispChar; 
N  GUI_GETCHARDISTX * pfGetCharDistX; 
N  GUI_GETFONTINFO  * pfGetFontInfo; 
N  GUI_ISINFONT     * pfIsInFont;
N  GUI_GETCHARINFO  * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N  U8 YSize;
X  unsigned char YSize;
N  U8 YDist;
X  unsigned char YDist;
N  U8 XMag;
X  unsigned char XMag;
N  U8 YMag;
X  unsigned char YMag;
N  union {
N    const void              GUI_UNI_PTR * pFontData;
X    const void               * pFontData;
N    const GUI_FONT_MONO     GUI_UNI_PTR * pMono;
X    const GUI_FONT_MONO      * pMono;
N    const GUI_FONT_PROP     GUI_UNI_PTR * pProp;
X    const GUI_FONT_PROP      * pProp;
N    const GUI_FONT_PROP_EXT GUI_UNI_PTR * pPropExt;
X    const GUI_FONT_PROP_EXT  * pPropExt;
N  } p;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* Height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* Height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N};
N
N/*********************************************************************
N*
N*       System independent font structures (SIF)
N*/
Ntypedef struct {
N  U32 ID;           /* Font file ID */
X  unsigned long ID;            
N  U16 YSize;        /* Height of font */
X  unsigned short YSize;         
N  U16 YDist;        /* Space of font Y */
X  unsigned short YDist;         
N  U16 Baseline;     /* Index of baseline */
X  unsigned short Baseline;      
N  U16 LHeight;      /* Height of a small lower case character (a) */
X  unsigned short LHeight;       
N  U16 CHeight;      /* Height of a upper case character (A) */
X  unsigned short CHeight;       
N  U16 NumAreas;     /* Number of character areas */
X  unsigned short NumAreas;      
N} GUI_SI_FONT;
N
Ntypedef struct {
N  U16 First;        /* Index of first character */
X  unsigned short First;         
N  U16 Last;         /* Index of last character */
X  unsigned short Last;          
N} GUI_SIF_CHAR_AREA;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 BytesPerLine; /* Number of bytes per line */
X  unsigned short BytesPerLine;  
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 YSize;        /* Size of bitmap data in X */
X  unsigned short YSize;         
N  I16 XOff;         /* Display offset of bitmap data in X */
X  signed short XOff;          
N  I16 YOff;         /* Display offset of bitmap data in Y */
X  signed short YOff;          
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO_EXT;
N
Ntypedef struct tGUI_SIF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_SIF_APIList;
N
N#define GUI_SIF_TYPE              tGUI_SIF_APIList
N#define GUI_SIF_TYPE_PROP         &GUI_SIF_APIList_Prop
N#define GUI_SIF_TYPE_PROP_EXT     &GUI_SIF_APIList_Prop_Ext
N#define GUI_SIF_TYPE_PROP_FRM     &GUI_SIF_APIList_Prop_Frm
N#define GUI_SIF_TYPE_PROP_AA2     &GUI_SIF_APIList_Prop_AA2
N#define GUI_SIF_TYPE_PROP_AA4     &GUI_SIF_APIList_Prop_AA4
N#define GUI_SIF_TYPE_PROP_AA2_EXT &GUI_SIF_APIList_Prop_AA2_EXT
N#define GUI_SIF_TYPE_PROP_AA4_EXT &GUI_SIF_APIList_Prop_AA4_EXT
N
N/*********************************************************************
N*
N*       External binary font structures (XBF)
N*/
Ntypedef int GUI_XBF_GET_DATA_FUNC(U32 Off, U16 NumBytes, void * pVoid, void * pBuffer);
Xtypedef int GUI_XBF_GET_DATA_FUNC(unsigned long Off, unsigned short NumBytes, void * pVoid, void * pBuffer);
N
Ntypedef struct {
N  U16 First;                         /* First character of font */
X  unsigned short First;                          
N  U16 Last;                          /* Last character of font */
X  unsigned short Last;                           
N  void * pVoid;                      /* Void pointer passed to GetData-function */
N  GUI_XBF_GET_DATA_FUNC * pfGetData; /* Pointer to callback function */
N} GUI_XBF_DATA;
N
Ntypedef struct tGUI_XBF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_XBF_APIList;
N
N#define GUI_XBF_TYPE              tGUI_XBF_APIList
N#define GUI_XBF_TYPE_PROP         &GUI_XBF_APIList_Prop
N#define GUI_XBF_TYPE_PROP_EXT     &GUI_XBF_APIList_Prop_Ext
N#define GUI_XBF_TYPE_PROP_FRM     &GUI_XBF_APIList_Prop_Frm
N#define GUI_XBF_TYPE_PROP_AA2_EXT &GUI_XBF_APIList_Prop_AA2_Ext
N#define GUI_XBF_TYPE_PROP_AA4_EXT &GUI_XBF_APIList_Prop_AA4_Ext
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
Ntypedef struct {
N  const void * pData;      /* Pointer to TTF font file in addressable memory area */
N  U32 NumBytes;            /* Size of file in bytes */
X  unsigned long NumBytes;             
N} GUI_TTF_DATA;
N
Ntypedef struct {
N  GUI_TTF_DATA * pTTF;     /* Pointer to GUI_TTF_DATA structure which contains location and size of font file */
N  U32 aImageTypeBuffer[4]; /* Buffer for image type structure */
X  unsigned long aImageTypeBuffer[4];  
N  int PixelHeight;         /* Pixel height of new font. It means the height of the surrounding rectangle
N                            * between the glyphs 'g' anf 'f'. Please notice that it is not the distance
N                            * between two lines of text. With other words the value returned byGUI_GetFontSizeY()
N                            * is not identically with this value. */
N  int FaceIndex;           /* Some font files can contain more than one font face. In case of more than one face
N                            * this index specifies the zero based face index to be used to create the font. 
N                            * Usually 0. */
N} GUI_TTF_CS;
N
N/*********************************************************************
N*
N*       Memory management
N*/
N#ifndef     GUI_HMEM
N  #define     GUI_HMEM        I32
N#endif
N#define     GUI_HMEM_NULL     (0)
Ntypedef     GUI_HMEM      GUI_HWIN;
Xtypedef     signed long      GUI_HWIN;
Ntypedef     GUI_HMEM      GUI_HSPRITE;
Xtypedef     signed long      GUI_HSPRITE;
N
N/*********************************************************************
N*
N*       Hardware routines
N*/
Ntypedef struct {
N  //
N  // 8 Bit access
N  //
N  void (* pfWrite8_A0)  (U8 Data);
X  void (* pfWrite8_A0)  (unsigned char Data);
N  void (* pfWrite8_A1)  (U8 Data);
X  void (* pfWrite8_A1)  (unsigned char Data);
N  void (* pfWriteM8_A0) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A0) (unsigned char * pData, int NumItems);
N  void (* pfWriteM8_A1) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A1) (unsigned char * pData, int NumItems);
N  U8   (* pfRead8_A0)   (void);
X  unsigned char   (* pfRead8_A0)   (void);
N  U8   (* pfRead8_A1)   (void);
X  unsigned char   (* pfRead8_A1)   (void);
N  void (* pfReadM8_A0)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A0)  (unsigned char * pData, int NumItems);
N  void (* pfReadM8_A1)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A1)  (unsigned char * pData, int NumItems);
N  //
N  // 16 Bit access
N  //
N  void (* pfWrite16_A0) (U16 Data);
X  void (* pfWrite16_A0) (unsigned short Data);
N  void (* pfWrite16_A1) (U16 Data);
X  void (* pfWrite16_A1) (unsigned short Data);
N  void (* pfWriteM16_A0)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A0)(unsigned short * pData, int NumItems);
N  void (* pfWriteM16_A1)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A1)(unsigned short * pData, int NumItems);
N  U16  (* pfRead16_A0)  (void);
X  unsigned short  (* pfRead16_A0)  (void);
N  U16  (* pfRead16_A1)  (void);
X  unsigned short  (* pfRead16_A1)  (void);
N  void (* pfReadM16_A0) (U16 * pData, int NumItems);
X  void (* pfReadM16_A0) (unsigned short * pData, int NumItems);
N  void (* pfReadM16_A1) (U16 * pData, int NumItems);
X  void (* pfReadM16_A1) (unsigned short * pData, int NumItems);
N  //
N  // Optional 'flush'
N  //
N  void (* pfFlushBuffer)(void);
N} GUI_PORT_API;
N
N#endif  /* GUITYPE_H_INCLUDED */
N
N/*************************** End of file ****************************/
L 23 "GUI\GUI.h" 2
N#include "GUI_Version.h"
L 1 "GUI\GUI_Version.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI_Version.h
NPurpose     : Include file defining current GUI version
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_VERSION_H
N#define  GUI_VERSION_H
N
N#define GUI_VERSION 50500
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 24 "GUI\GUI.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Disable string function warning with newer MSVC versions
N*/
N#if defined (_MSC_VER)
X#if 0L
S  #if (_MSC_VER > 1200)
S    #pragma warning( disable : 4996)
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       Macros, function replacement
N*/
N#define GUI_COUNTOF(a)          (sizeof(a) / sizeof(a[0]))
N#define GUI_MIN(a,b)            (((a) < (b)) ? (a) : (b))
N#define GUI_MAX(a,b)            (((a) > (b)) ? (a) : (b))
N#define GUI_ZEROFILL(p, Size)   (memset(p, 0, Size))
N
N/*********************************************************************
N*
N*       Support for multitasking systems (locking)
N*/
Ntypedef struct GUI_CONTEXT GUI_CONTEXT;
N
N#if !GUI_OS
X#if !(1)
S  #define GUI_LOCK()
S  #define GUI_UNLOCK()
S  #define GUITASK_INIT()
S  #define GUITASK_COPY_CONTEXT()
N#else
N  void GUI_Lock(void);
N  void GUI_Unlock(void);
N  void GUITASK_Init(void);
N  void GUITASK_CopyContext(void);
N  GUI_CONTEXT * GUITASK_GetpContext(int Index);
N  #define GUI_LOCK()             GUI_Lock()
N  #define GUI_UNLOCK()           GUI_Unlock()
N  #define GUITASK_INIT()         GUITASK_Init()
N  #define GUITASK_COPY_CONTEXT() GUITASK_CopyContext()
N#endif
N
N/*********************************************************************
N*
N*       API table of a display driver
N*/
Nstruct GUI_DEVICE_API {
N  //
N  // Data
N  //
N  int DeviceClassIndex;
N  //
N  // Drawing functions
N  //
N  void     (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void     (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char  * pData, int Diff, const unsigned long * pTrans);
N  void     (* pfDrawHLine    )(GUI_DEVICE * pDevice, int x0, int y0,  int x1);
N  void     (* pfDrawVLine    )(GUI_DEVICE * pDevice, int x , int y0,  int y1);
N  void     (* pfFillRect     )(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1);
N  unsigned (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
N  void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
N  void     (* pfXorPixel     )(GUI_DEVICE * pDevice, int x, int y);
N  //
N  // Set origin
N  //
N  void     (* pfSetOrg       )(GUI_DEVICE * pDevice, int x, int y);
N  //
N  // Request information
N  //
N  void   (*(* pfGetDevFunc)   (GUI_DEVICE * pDevice, int Index))(void);
N  I32      (* pfGetDevProp   )(GUI_DEVICE * pDevice, int Index);
X  signed long      (* pfGetDevProp   )(GUI_DEVICE * pDevice, int Index);
N  void    *(* pfGetDevData   )(GUI_DEVICE * pDevice, int Index);
N  void     (* pfGetRect      )(GUI_DEVICE * pDevice, LCD_RECT * pRect);
N};
N
N/*********************************************************************
N*
N*       Device classes
N*/
Ntypedef enum { 
N  DEVICE_CLASS_DRIVER,
N  DEVICE_CLASS_DRIVER_MODIFIER,   // Zoom or delta-pixel modifier
N  DEVICE_CLASS_VNC,
N  DEVICE_CLASS_SPRITE,
N  DEVICE_CLASS_MEMDEV,
N  DEVICE_CLASS_ALPHA,
N  DEVICE_CLASS_AUTOALPHA,
N  DEVICE_CLASS_MEASDEV
N} DEVICE_CLASS;
N
N#define GUI_DEVICE_STAYONTOP 1
N
N/*********************************************************************
N*
N*       Display drivers
N*/
N//
N// Addresses
N//
Nextern const GUI_DEVICE_API GUIDRV_Win_API;
N
Nextern const GUI_DEVICE_API GUIDRV_Template_API;
N
N//
N// Macros to be used in configuration files
N//
N#define GUIDRV_WIN32       &GUIDRV_Win_API
N
N#if defined(WIN32) && !defined(LCD_SIMCONTROLLER)
X#if 0L && !0L
S
S  #define GUIDRV_TEMPLATE         &GUIDRV_Win_API
S
N#else
N
N  #define GUIDRV_TEMPLATE         &GUIDRV_Template_API
N
N#endif
N
N/*********************************************************************
N*
N*       Definition of GUI_DEVICE structure
N*/
Nstruct GUI_DEVICE {
N  //
N  // Linking
N  //
N  GUI_DEVICE * pNext;
N  GUI_DEVICE * pPrev;
N  //
N  // Data
N  //
N  union {
N    GUI_HMEM hContext; // Handle of payload data like sprite- or memory device context
X    signed long hContext; 
N    void   * pContext; // Pointer for context data in a fixed block
N  } u;
N  //
N  // API pointers
N  //
N  const GUI_DEVICE_API     * pDeviceAPI;
N  const LCD_API_COLOR_CONV * pColorConvAPI;
N  U16 Flags;
X  unsigned short Flags;
N  int LayerIndex;
N};
N
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_1;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_8;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_16;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_32;
N
N/*********************************************************************
N*
N*       GUI_CONTEXT
N*
N*  This structure is public for one reason only:
N*  To allow the application to save and restore the context.
N*/
Ntypedef union {
N  U8  aColorIndex8[2];
X  unsigned char  aColorIndex8[2];
N  U16 aColorIndex16[2];
X  unsigned short aColorIndex16[2];
N  U32 aColorIndex32[2];
X  unsigned long aColorIndex32[2];
N} LCD_COLORINDEX_UNION;
N
Nstruct GUI_CONTEXT {
N  //
N  // Variables in LCD module
N  //
N  LCD_COLORINDEX_UNION LCD;
N  LCD_RECT       ClipRect;
N  U8             DrawMode;
X  unsigned char             DrawMode;
N  U8             SelLayer;
X  unsigned char             SelLayer;
N  U8             TextStyle;
X  unsigned char             TextStyle;
N  //
N  // Variables in GL module
N  //
N  GUI_RECT * pClipRect_HL;                 // High level clip rectangle ... Speed optimization so drawing routines can optimize
N  U8         PenSize;
X  unsigned char         PenSize;
N  U8         PenShape;
X  unsigned char         PenShape;
N  U8         LineStyle;
X  unsigned char         LineStyle;
N  //
N  // Variables in GUICHAR module
N  //
N  const GUI_FONT           GUI_UNI_PTR * pAFont;
X  const GUI_FONT            * pAFont;
N  const GUI_UC_ENC_APILIST * pUC_API;    // Unicode encoding API
N  I16P LBorder;
X  signed short LBorder;
N  I16P DispPosX, DispPosY;
X  signed short DispPosX, DispPosY;
N  I16P DrawPosX, DrawPosY;
X  signed short DrawPosX, DrawPosY;
N  I16P TextMode, TextAlign;
X  signed short TextMode, TextAlign;
N  GUI_COLOR Color, BkColor;                // Required only when changing devices and for speed opt (caching)
N  //
N  // Variables in WM module
N  //
N  #if GUI_WINSUPPORT
X  #if (1)
N    const GUI_RECT* WM__pUserClipRect;
N    GUI_HWIN hAWin;
N    int xOff, yOff;
N  #endif
N  //
N  // Array of pointers to device chains
N  //
N  GUI_DEVICE * apDevice[GUI_NUM_LAYERS];
X  GUI_DEVICE * apDevice[(16)];
N  //
N  // Variables in MEMDEV module (with memory devices only)
N  //
N  GUI_HMEM    hDevData;
X  signed long    hDevData;
N  GUI_RECT    ClipRectPrev;
N  //
N  // Variables in Anitaliasing module
N  //
N  const tLCD_HL_APIList * pLCD_HL;       // Required to reroute drawing (HLine & Pixel) to the AA module
N  U8 AA_Factor;
X  unsigned char AA_Factor;
N  U8 AA_HiResEnable;
X  unsigned char AA_HiResEnable;
N};
N
N/* Rename GUI_SaveContext in order to avoid crashes if wrong GUIConf is used */
N#if (GUI_WINSUPPORT == 1)
X#if ((1) == 1)
N  #define GUI_SaveContext GUI_SaveContext_W
N#else
S  #define GUI_SaveContext GUI_SaveContext_
N#endif
N
N/*********************************************************************
N*
N*       Device management
N*/
NGUI_DEVICE * GUI_DEVICE_Create       (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_Create       (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
NGUI_DEVICE * GUI_DEVICE_CreateAndLink(const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_CreateAndLink(const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
Nvoid         GUI_DEVICE_Delete       (GUI_DEVICE * pDevice);
Nint          GUI_DEVICE_Link         (GUI_DEVICE * pDevice);
Nvoid         GUI_DEVICE_Unlink       (GUI_DEVICE * pDevice);
NGUI_DEVICE * GUI_DEVICE__GetpDriver  (int LayerIndex);
NGUI_DEVICE * GUI_DEVICE__GetpDevice  (int LayerIndex, int DeviceClass);
N
N/*********************************************************************
N*
N*       General routines
N*/
Nint          GUI_Init             (void);
Nvoid         GUI_SetDefault       (void);
NGUI_DRAWMODE GUI_SetDrawMode      (GUI_DRAWMODE dm);
Nconst char * GUI_GetVersionString (void);
Nvoid         GUI_SaveContext      (      GUI_CONTEXT* pContext);
Xvoid         GUI_SaveContext_W      (      GUI_CONTEXT* pContext);
Nvoid         GUI_RestoreContext   (const GUI_CONTEXT* pContext);
Nvoid         GUI_SetScreenSizeX   (int xSize);
Nvoid         GUI_SetScreenSizeY   (int ySize);
Nint          GUI_GetScreenSizeX   (void);
Nint          GUI_GetScreenSizeY   (void);
Nconst GUI_RECT * GUI_SetClipRect  (const GUI_RECT * pRect);
N
N/*********************************************************************
N*
N*       Rectangle helper functions
N*/
Nint  GUI_RectsIntersect(const GUI_RECT* pr0, const GUI_RECT* pr1);
Nvoid GUI_MoveRect       (GUI_RECT *pRect, int x, int y);
Nvoid GUI_MergeRect      (GUI_RECT* pDest, const GUI_RECT* pr0, const GUI_RECT* pr1);
Nint  GUI__IntersectRects(GUI_RECT* pDest, const GUI_RECT* pr0, const GUI_RECT* pr1);
Nvoid GUI__IntersectRect (GUI_RECT* pDest, const GUI_RECT* pr0);
Nvoid GUI__ReduceRect    (GUI_RECT* pDest, const GUI_RECT *pRect, int Dist);
N
N/*********************************************************************
N*
N*       Misc helper functions
N*/
Nvoid GUI__CompactPixelIndices  (LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel);
Xvoid GUI__CompactPixelIndices  (unsigned long * pBuffer, int NumPixels, int BitsPerPixel);
Nvoid GUI__CompactPixelIndicesEx(LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel, tLCDDEV_Color2Index * pfColor2Index);
Xvoid GUI__CompactPixelIndicesEx(unsigned long * pBuffer, int NumPixels, int BitsPerPixel, tLCDDEV_Color2Index * pfColor2Index);
Nvoid GUI__Config(void);
NI32  GUI__CosHQ(I32 Ang1000);
Xsigned long  GUI__CosHQ(signed long Ang1000);
Nint  GUI__DivideRound     (int a, int b);
NI32  GUI__DivideRound32   (I32 a, I32 b);
Xsigned long  GUI__DivideRound32   (signed long a, signed long b);
Nvoid GUI__ExpandPixelIndices   (void * pBuffer, int NumPixels, int BitsPerPixel);
Nvoid GUI__ExpandPixelIndicesEx (void * pBuffer, int NumPixels, int BitsPerPixel, tLCDDEV_Index2Color * pfIndex2Color);
Nvoid GUI__memcpy(void * pDest, const void * pSrc, int NumBytes);
Nint  GUI__SetText(GUI_HMEM * phText, const char * s);
Xint  GUI__SetText(signed long * phText, const char * s);
NI32  GUI__SinHQ(I32 Ang1000);
Xsigned long  GUI__SinHQ(signed long Ang1000);
N
N/*********************************************************************
N*
N*       Get / Set Attributes
N*/
NGUI_COLOR GUI_GetBkColor     (void);
NGUI_COLOR GUI_GetColor       (void);
Nint       GUI_GetBkColorIndex(void);
Nint       GUI_GetColorIndex  (void);
NU8        GUI_GetPenSize     (void);
Xunsigned char        GUI_GetPenSize     (void);
NU8        GUI_GetPenShape    (void);
Xunsigned char        GUI_GetPenShape    (void);
NU8        GUI_GetLineStyle   (void);
Xunsigned char        GUI_GetLineStyle   (void);
N
Nvoid      GUI_SetBkColor   (GUI_COLOR);
Nvoid      GUI_SetColor     (GUI_COLOR);
Nvoid      GUI_SetBkColorIndex(int Index);
Nvoid      GUI_SetColorIndex(int Index);
N
NU8        GUI_SetPenSize   (U8 Size);
Xunsigned char        GUI_SetPenSize   (unsigned char Size);
NU8        GUI_SetPenShape  (U8 Shape);
Xunsigned char        GUI_SetPenShape  (unsigned char Shape);
NU8        GUI_SetLineStyle (U8 Style);
Xunsigned char        GUI_SetLineStyle (unsigned char Style);
N
N/* Get/Set Character used as decimal point (usually '.' or ',') */
Nchar      GUI_GetDecChar(void);
Nchar      GUI_SetDecChar(char c);
N
N/*********************************************************************
N*
N*       Color / Index related functions
N*/
Nint       GUI_Color2Index(GUI_COLOR color);
NGUI_COLOR GUI_Color2VisColor(GUI_COLOR color);
Nchar      GUI_ColorIsAvailable(GUI_COLOR color);
NGUI_COLOR GUI_Index2Color(int Index);
NU32       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
Xunsigned long       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
NU32       GUI_CalcVisColorError(GUI_COLOR color);
Xunsigned long       GUI_CalcVisColorError(GUI_COLOR color);
N
N/*********************************************************************
N*
N*       Logging (for debugging primarily)
N*/
Nvoid GUI_Log      (const char *s);
Nvoid GUI_Log1     (const char *s, int p0);
Nvoid GUI_Log2     (const char *s, int p0, int p1);
Nvoid GUI_Log3     (const char *s, int p0, int p1, int p2);
Nvoid GUI_Log4     (const char *s, int p0, int p1, int p2,int p3);
Nvoid GUI_Warn     (const char *s);
Nvoid GUI_Warn1    (const char *s, int p0);
Nvoid GUI_Warn2    (const char *s, int p0, int p1);
Nvoid GUI_Warn3    (const char *s, int p0, int p1, int p2);
Nvoid GUI_Warn4    (const char *s, int p0, int p1, int p2, int p3);
Nvoid GUI_ErrorOut (const char *s);
Nvoid GUI_ErrorOut1(const char *s, int p0);
Nvoid GUI_ErrorOut2(const char *s, int p0, int p1);
Nvoid GUI_ErrorOut3(const char *s, int p0, int p1, int p2);
Nvoid GUI_ErrorOut4(const char *s, int p0, int p1, int p2, int p3);
N
N/*********************************************************************
N*
N*       2d - GL
N*/
Nvoid GUI_Clear            (void);
Nvoid GUI_ClearRect        (int x0, int y0, int x1, int y1);
Nvoid GUI_ClearRectEx      (const GUI_RECT* pRect);
Nvoid GUI_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_DrawBitmap       (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0);
Xvoid GUI_DrawBitmap       (const GUI_BITMAP  * pBM, int x0, int y0);
Nvoid GUI_DrawBitmapMag    (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0, int XMul, int YMul);
Xvoid GUI_DrawBitmapMag    (const GUI_BITMAP  * pBM, int x0, int y0, int XMul, int YMul);
Nvoid GUI_DrawBitmapEx     (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Xvoid GUI_DrawBitmapEx     (const GUI_BITMAP  * pBM, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Nvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const U8 GUI_UNI_PTR * pData, const GUI_LOGPALETTE GUI_UNI_PTR * pPal);
Xvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const unsigned char  * pData, const GUI_LOGPALETTE  * pPal);
Nvoid GUI_DrawBitmapHWAlpha(const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0);
Xvoid GUI_DrawBitmapHWAlpha(const GUI_BITMAP  * pBM, int x0, int y0);
Nvoid GUI_DrawCircle       (int x0, int y0, int r);
Nvoid GUI_DrawEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_DrawGradientV    (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientH    (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGraph        (I16 *pay, int NumPoints, int x0, int y0);
Xvoid GUI_DrawGraph        (signed short *pay, int NumPoints, int x0, int y0);
Nvoid GUI_DrawGraphEx      (I16 *pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Xvoid GUI_DrawGraphEx      (signed short *pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Nvoid GUI_DrawHLine        (int y0, int x0, int x1);
Nvoid GUI_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawLineRel      (int dx, int dy);
Nvoid GUI_DrawLineTo       (int x, int y);
Nvoid GUI_DrawPie          (int x0, int y0, int r, int a0, int a1, int Type);
Nvoid GUI_DrawPixel        (int x, int y);
Nvoid GUI_DrawPoint        (int x, int y);
Nvoid GUI_DrawPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawPolyLine     (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawFocusRect    (const GUI_RECT *pRect, int Dist);
Nvoid GUI_DrawRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawRectEx       (const GUI_RECT *pRect);
Nvoid GUI_DrawRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_DrawVLine        (int x0, int y0, int y1);
Nvoid GUI_FillCircle       (int x0, int y0, int r);
Nvoid GUI_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_FillPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_FillRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_FillRectEx       (const GUI_RECT* pRect);
Nvoid GUI_FillRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_GetClientRect    (GUI_RECT* pRect);
Nvoid GUI_InvertRect       (int x0, int y0, int x1, int y1);
Nvoid GUI_MoveRel          (int dx, int dy);
Nvoid GUI_MoveTo           (int x, int y);
N
N/*********************************************************************
N*
N*       Graphic file support
N*/
Ntypedef int GUI_GET_DATA_FUNC(void * p, const U8 ** ppData, unsigned NumBytes, U32 Off);
Xtypedef int GUI_GET_DATA_FUNC(void * p, const unsigned char ** ppData, unsigned NumBytes, unsigned long Off);
N
N/*********************************************************************
N*
N*       GIF file support
N*/
Nint GUI_GIF_Draw           (const void * pGIF, U32 NumBytes,         int x0, int y0);
Xint GUI_GIF_Draw           (const void * pGIF, unsigned long NumBytes,         int x0, int y0);
Nint GUI_GIF_DrawEx         (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_GIF_DrawSub        (const void * pGIF, U32 NumBytes,         int x0, int y0, int Index);
Xint GUI_GIF_DrawSub        (const void * pGIF, unsigned long NumBytes,         int x0, int y0, int Index);
Nint GUI_GIF_DrawSubEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index);
Nint GUI_GIF_DrawSubScaled  (const void * pGIF, U32 NumBytes,         int x0, int y0, int Index, int Num, int Denom);
Xint GUI_GIF_DrawSubScaled  (const void * pGIF, unsigned long NumBytes,         int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_DrawSubScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_GetComment     (const void * pGIF, U32 NumBytes,         U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetComment     (const void * pGIF, unsigned long NumBytes,         unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetCommentEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetCommentEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetImageInfo   (const void * pGIF, U32 NumBytes,         GUI_GIF_IMAGE_INFO * pInfo, int Index);
Xint GUI_GIF_GetImageInfo   (const void * pGIF, unsigned long NumBytes,         GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetImageInfoEx (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetInfo        (const void * pGIF, U32 NumBytes,         GUI_GIF_INFO * pInfo);
Xint GUI_GIF_GetInfo        (const void * pGIF, unsigned long NumBytes,         GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetInfoEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetXSize       (const void * pGIF);
Nint GUI_GIF_GetXSizeEx     (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_GIF_GetYSize       (const void * pGIF);
Nint GUI_GIF_GetYSizeEx     (GUI_GET_DATA_FUNC * pfGetData, void * p);
N
N/*********************************************************************
N*
N*       BMP file support
N*/
Nint GUI_BMP_Draw        (const void * pFileData,                  int x0, int y0);
Nint GUI_BMP_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_BMP_DrawScaled  (const void * pFileData,                  int x0, int y0, int Num, int Denom);
Nint GUI_BMP_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint GUI_BMP_GetXSize    (const void * pFileData);
Nint GUI_BMP_GetXSizeEx  (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_BMP_GetYSize    (const void * pFileData);
Nint GUI_BMP_GetYSizeEx  (GUI_GET_DATA_FUNC * pfGetData, void * p);
N
N/*********************************************************************
N*
N*       PNG file support
N*/
Nint GUI_PNG_Draw      (const void * pFileData, int DataSize, int x0, int y0);
Nint GUI_PNG_DrawEx    (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_PNG_GetXSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetXSizeEx(GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_PNG_GetYSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetYSizeEx(GUI_GET_DATA_FUNC * pfGetData, void * p);
N
N/*********************************************************************
N*
N*       JPEG file support
N*/
Ntypedef struct {
N  int XSize;
N  int YSize;
N} GUI_JPEG_INFO;
N
N#if (GUI_SELECT_JPEG == 1)
X#if (0 == 1)
S
S#define GUI_JPEG_Draw(        pFileData, DataSize, x0, y0)             GUI_JPEG1_Draw        (pFileData, DataSize, x0, y0)            
S#define GUI_JPEG_DrawScaled(  pFileData, DataSize, x0, y0, Num, Denom) GUI_JPEG1_DrawScaled  (pFileData, DataSize, x0, y0, Num, Denom)
S#define GUI_JPEG_GetInfo(     pFileData, DataSize, pInfo)              GUI_JPEG1_GetInfo     (pFileData, DataSize, pInfo)             
S#define GUI_JPEG_DrawEx(      pfGetData, p, x0, y0)                    GUI_JPEG1_DrawEx      (pfGetData, p, x0, y0)                   
S#define GUI_JPEG_DrawScaledEx(pfGetData, p, x0, y0, Num, Denom)        GUI_JPEG1_DrawScaledEx(pfGetData, p, x0, y0, Num, Denom)       
S#define GUI_JPEG_GetInfoEx(   pfGetData, p, pInfo)                     GUI_JPEG1_GetInfoEx   (pfGetData, p, pInfo)                    
S
N#else
N
Nint GUI_JPEG_Draw        (const void * pFileData, int DataSize,    int x0, int y0);
Nint GUI_JPEG_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_JPEG_DrawScaled  (const void * pFileData, int DataSize,    int x0, int y0, int Num, int Denom);
Nint GUI_JPEG_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint GUI_JPEG_GetInfo     (const void * pFileData, int DataSize,    GUI_JPEG_INFO* pInfo);
Nint GUI_JPEG_GetInfoEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_JPEG_INFO * pInfo);
N
N#endif
N
Nint GUI_JPEG1_Draw        (const void * pFileData, int DataSize,    int x0, int y0);
Nint GUI_JPEG1_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_JPEG1_DrawScaled  (const void * pFileData, int DataSize,    int x0, int y0, int Num, int Denom);
Nint GUI_JPEG1_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint GUI_JPEG1_GetInfo     (const void * pFileData, int DataSize,    GUI_JPEG_INFO * pContext);
Nint GUI_JPEG1_GetInfoEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_JPEG_INFO * pContext);
N
N/*********************************************************************
N*
N*       Cursor routines
N*/
Ntypedef struct {
N  const GUI_UNI_PTR GUI_BITMAP * pBitmap;
X  const  GUI_BITMAP * pBitmap;
N  int xHot, yHot;
N} GUI_CURSOR;
N
N#if GUI_SUPPORT_CURSOR
X#if ((1) | (1))
N  int                            GUI_CURSOR_GetState     (void);
N  void                           GUI_CURSOR_Hide         (void);
N  void                           GUI_CURSOR_SetXor       (const GUI_BITMAP * pBM, int x, int y);
N  void                           GUI_CURSOR_SetPosition  (int x, int y);
N  const GUI_CURSOR GUI_UNI_PTR * GUI_CURSOR_Select       (const GUI_CURSOR GUI_UNI_PTR * pCursor);
X  const GUI_CURSOR  * GUI_CURSOR_Select       (const GUI_CURSOR  * pCursor);
N  void                           GUI_CURSOR_Show         (void);
N  const GUI_CURSOR GUI_UNI_PTR * GUI_CURSOR_SelectEx     (const GUI_CURSOR GUI_UNI_PTR * pCursor, int Layer);
X  const GUI_CURSOR  * GUI_CURSOR_SelectEx     (const GUI_CURSOR  * pCursor, int Layer);
N  void                           GUI_CURSOR_HideEx       (int Layer);
N  void                           GUI_CURSOR_ShowEx       (int Layer);
N  int                            GUI_CURSOR_GetStateEx   (int Layer);
N  void                           GUI_CURSOR_SetPositionEx(int xNewPos, int yNewPos, int Layer);
N  void                           GUI_CURSOR_GetCursorRect(GUI_RECT * pRect);
N  void                           GUI_CURSOR_GetCursorRectEx(GUI_RECT * pRect, int Layer);
N  void                           GUI_CURSOR_SetPixelIndexEx(int x, int y, int Index, int Layer);
N  void                           GUI_CURSOR_XorPixelIndexEx(int x, int y, int Layer);
N#else
S  #define GUI_CURSOR_Show()
S  #define GUI_CURSOR_Clear();
N#endif
N
N/*********************************************************************
N*
N*       Sprite support
N*/
N#define GUI_SPRITE_CF_STAYONTOP (1 << 0)
N#define GUI_SPRITE_CF_SHOW      (1 << 1)
N
NGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y, int Layer, U16 Flags); /* Not to be documented, only used by cursor modul */
XGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP  * pBM, int x, int y, int Layer, unsigned short Flags);  
NGUI_HSPRITE GUI_SPRITE_Create              (const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y);
XGUI_HSPRITE GUI_SPRITE_Create              (const GUI_BITMAP  * pBM, int x, int y);
NGUI_HSPRITE GUI_SPRITE_CreateEx            (const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y, int Layer);
XGUI_HSPRITE GUI_SPRITE_CreateEx            (const GUI_BITMAP  * pBM, int x, int y, int Layer);
Nvoid        GUI_SPRITE_Delete              (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_GetState            (GUI_HSPRITE hSprite);
Nvoid        GUI_SPRITE_Hide                (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_SetBitmap           (GUI_HSPRITE hSprite, const GUI_BITMAP GUI_UNI_PTR * pBM);
Xint         GUI_SPRITE_SetBitmap           (GUI_HSPRITE hSprite, const GUI_BITMAP  * pBM);
Nint         GUI_SPRITE_SetBitmapAndPosition(GUI_HSPRITE hSprite, const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y);
Xint         GUI_SPRITE_SetBitmapAndPosition(GUI_HSPRITE hSprite, const GUI_BITMAP  * pBM, int x, int y);
Nvoid        GUI_SPRITE_SetPosition         (GUI_HSPRITE hSprite, int x, int y);
Nvoid        GUI_SPRITE_Show                (GUI_HSPRITE hSprite);
N
N/*********************************************************************
N*
N*       Cursors and their bitmaps
N*/
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Xextern const GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Xextern const GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Xextern const GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Xextern const GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Xextern const GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Xextern const GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
Xextern const GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
N
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowS, GUI_BitmapArrowSI;
Xextern const GUI_BITMAP GUI_BitmapArrowS, GUI_BitmapArrowSI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowM, GUI_BitmapArrowMI;
Xextern const GUI_BITMAP GUI_BitmapArrowM, GUI_BitmapArrowMI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowL, GUI_BitmapArrowLI;
Xextern const GUI_BITMAP GUI_BitmapArrowL, GUI_BitmapArrowLI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossS, GUI_BitmapCrossSI;
Xextern const GUI_BITMAP GUI_BitmapCrossS, GUI_BitmapCrossSI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossM, GUI_BitmapCrossMI;
Xextern const GUI_BITMAP GUI_BitmapCrossM, GUI_BitmapCrossMI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossL, GUI_BitmapCrossLI;
Xextern const GUI_BITMAP GUI_BitmapCrossL, GUI_BitmapCrossLI;
N
N/*********************************************************************
N*
N*       Wrap modes
N*/
Ntypedef enum { GUI_WRAPMODE_NONE, GUI_WRAPMODE_WORD, GUI_WRAPMODE_CHAR } GUI_WRAPMODE;
N
N/*********************************************************************
N*
N*       Text related routines
N*/
Nvoid  GUI_DispCEOL             (void);
Nvoid  GUI_DispChar             (U16 c);
Xvoid  GUI_DispChar             (unsigned short c);
Nvoid  GUI_DispCharAt           (U16 c, I16P x, I16P y);
Xvoid  GUI_DispCharAt           (unsigned short c, signed short x, signed short y);
Nvoid  GUI_DispChars            (U16 c, int Cnt);
Xvoid  GUI_DispChars            (unsigned short c, int Cnt);
Nvoid  GUI_DispNextLine         (void);
Nvoid  GUI_DispString           (const char GUI_UNI_PTR * s);
Xvoid  GUI_DispString           (const char  * s);
Nvoid  GUI_DispStringAt         (const char GUI_UNI_PTR * s, int x, int y);
Xvoid  GUI_DispStringAt         (const char  * s, int x, int y);
Nvoid  GUI_DispStringAtCEOL     (const char GUI_UNI_PTR * s, int x, int y);
Xvoid  GUI_DispStringAtCEOL     (const char  * s, int x, int y);
Nvoid  GUI_DispStringHCenterAt  (const char GUI_UNI_PTR * s, int x, int y);
Xvoid  GUI_DispStringHCenterAt  (const char  * s, int x, int y);
Nvoid  GUI__DispStringInRect    (const char GUI_UNI_PTR * s, GUI_RECT * pRect, int TextAlign, int MaxNumChars);
Xvoid  GUI__DispStringInRect    (const char  * s, GUI_RECT * pRect, int TextAlign, int MaxNumChars);
Nvoid  GUI_DispStringInRect     (const char GUI_UNI_PTR * s, GUI_RECT * pRect, int TextAlign);
Xvoid  GUI_DispStringInRect     (const char  * s, GUI_RECT * pRect, int TextAlign);
N#if GUI_SUPPORT_ROTATION
X#if 1
N  void  GUI_DispStringInRectEx (const char GUI_UNI_PTR * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const GUI_ROTATION * pLCD_Api);
X  void  GUI_DispStringInRectEx (const char  * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const tLCD_APIList * pLCD_Api);
N#endif
Nvoid  GUI_DispStringInRectMax  (const char GUI_UNI_PTR * s, GUI_RECT * pRect, int TextAlign, int MaxLen); /* Not to be doc. */
Xvoid  GUI_DispStringInRectMax  (const char  * s, GUI_RECT * pRect, int TextAlign, int MaxLen);  
Nvoid  GUI_DispStringInRectWrap (const char GUI_UNI_PTR * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode); /* Not to be doc. */
Xvoid  GUI_DispStringInRectWrap (const char  * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode);  
Nvoid  GUI_DispStringLen        (const char GUI_UNI_PTR * s, int Len);
Xvoid  GUI_DispStringLen        (const char  * s, int Len);
Nvoid  GUI_GetTextExtend        (GUI_RECT* pRect, const char GUI_UNI_PTR * s, int Len);
Xvoid  GUI_GetTextExtend        (GUI_RECT* pRect, const char  * s, int Len);
Nint   GUI_GetYAdjust           (void);
Nint   GUI_GetDispPosX          (void);
Nint   GUI_GetDispPosY          (void);
Nconst GUI_FONT GUI_UNI_PTR * GUI_GetFont(void);
Xconst GUI_FONT  * GUI_GetFont(void);
Nint   GUI_GetCharDistX(U16 c);
Xint   GUI_GetCharDistX(unsigned short c);
Nint   GUI_GetStringDistX       (const char GUI_UNI_PTR * s);
Xint   GUI_GetStringDistX       (const char  * s);
NGUI_DRAWMODE GUI_GetDrawMode   (void);
Nint   GUI_GetFontDistY         (void);
Nint   GUI_GetFontSizeY         (void);
Nvoid  GUI_GetFontInfo          (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi);
Xvoid  GUI_GetFontInfo          (const GUI_FONT  * pFont, GUI_FONTINFO * pfi);
Nvoid  GUI_GetOrg               (int * px, int * py);
Nint   GUI_GetYSizeOfFont       (const GUI_FONT GUI_UNI_PTR * pFont);
Xint   GUI_GetYSizeOfFont       (const GUI_FONT  * pFont);
Nint   GUI_GetYDistOfFont       (const GUI_FONT GUI_UNI_PTR * pFont);
Xint   GUI_GetYDistOfFont       (const GUI_FONT  * pFont);
Nint   GUI_GetTextAlign         (void);
Nint   GUI_GetTextMode          (void);
Nchar  GUI_IsInFont             (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xchar  GUI_IsInFont             (const GUI_FONT  * pFont, unsigned short c);
Nint   GUI_SetTextAlign         (int Align);
Nint   GUI_SetTextMode          (int Mode);
Nchar  GUI_SetTextStyle         (char Style);
Nint   GUI_SetLBorder           (int x);
Nvoid  GUI_SetOrg               (int x, int y);
Nconst GUI_FONT GUI_UNI_PTR * GUI_SetFont(const GUI_FONT GUI_UNI_PTR * pNewFont);
Xconst GUI_FONT  * GUI_SetFont(const GUI_FONT  * pNewFont);
Nchar  GUI_GotoXY               (int x, int y);
Nchar  GUI_GotoX                (int x);
Nchar  GUI_GotoY                (int y);
Nint   GUI_WrapGetNumLines      (const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode);
Xint   GUI_WrapGetNumLines      (const char  * pText, int xSize, GUI_WRAPMODE WrapMode);
N
Nint   GUI_GetLeadingBlankCols (U16 c); /* Currently not implemented in V5! */
Xint   GUI_GetLeadingBlankCols (unsigned short c);  
Nint   GUI_GetTrailingBlankCols(U16 c); /* Currently not implemented in V5! */
Xint   GUI_GetTrailingBlankCols(unsigned short c);  
N
N/*********************************************************************
N*
N*       System independent fonts (SIF)
N*/
Nvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const GUI_SIF_TYPE * pFontType);
Xvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const tGUI_SIF_APIList * pFontType);
Nvoid GUI_SIF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       External binary fonts (XBF)
N*/
Nint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const GUI_XBF_TYPE * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Xint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const tGUI_XBF_APIList * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid GUI_XBF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
Nint  GUI_TTF_CreateFont   (GUI_FONT * pFont, GUI_TTF_CS * pCS);
Nvoid GUI_TTF_DestroyCache (void);
Nvoid GUI_TTF_Done         (void);
Nint  GUI_TTF_GetFamilyName(GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nint  GUI_TTF_GetStyleName (GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nvoid GUI_TTF_SetCacheSize (unsigned MaxFaces, unsigned MaxSizes, U32 MaxBytes);
Xvoid GUI_TTF_SetCacheSize (unsigned MaxFaces, unsigned MaxSizes, unsigned long MaxBytes);
N
N/*********************************************************************
N*
N*       Unicode support
N*/
Nint   GUI_UC_ConvertUC2UTF8   (const U16 GUI_UNI_PTR * s, int Len, char * pBuffer, int BufferSize);
Xint   GUI_UC_ConvertUC2UTF8   (const unsigned short  * s, int Len, char * pBuffer, int BufferSize);
Nint   GUI_UC_ConvertUTF82UC   (const char GUI_UNI_PTR * s, int Len, U16 * pBuffer, int BufferSize);
Xint   GUI_UC_ConvertUTF82UC   (const char  * s, int Len, unsigned short * pBuffer, int BufferSize);
Nint   GUI_UC_Encode           (char* s, U16 Char);
Xint   GUI_UC_Encode           (char* s, unsigned short Char);
Nint   GUI_UC_GetCharSize      (const char GUI_UNI_PTR * s);
Xint   GUI_UC_GetCharSize      (const char  * s);
NU16   GUI_UC_GetCharCode      (const char GUI_UNI_PTR * s);
Xunsigned short   GUI_UC_GetCharCode      (const char  * s);
Nvoid  GUI_UC_SetEncodeNone    (void);
Nvoid  GUI_UC_SetEncodeUTF8    (void);
N
Nvoid GUI_UC_DispString(const U16 GUI_UNI_PTR *s);
Xvoid GUI_UC_DispString(const unsigned short  *s);
Nvoid GUI_UC2DB (U16 Code, U8* pOut);
Xvoid GUI_UC2DB (unsigned short Code, unsigned char* pOut);
NU16  GUI_DB2UC (U8 Byte0, U8 Byte1);
Xunsigned short  GUI_DB2UC (unsigned char Byte0, unsigned char Byte1);
N
N/*********************************************************************
N*
N*       Drawing of binary, decimal and hexadecimal values
N*/
Nvoid GUI_DispBin  (U32  v, U8 Len);
Xvoid GUI_DispBin  (unsigned long  v, unsigned char Len);
Nvoid GUI_DispBinAt(U32  v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispBinAt(unsigned long  v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDec  (I32 v, U8 Len);
Xvoid GUI_DispDec  (signed long v, unsigned char Len);
Nvoid GUI_DispDecAt (I32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispDecAt (signed long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDecMin(I32 v);
Xvoid GUI_DispDecMin(signed long v);
Nvoid GUI_DispDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispDecShift(signed long v, unsigned char Len, unsigned char Shift);
Nvoid GUI_DispDecSpace(I32 v, U8 MaxDigits);
Xvoid GUI_DispDecSpace(signed long v, unsigned char MaxDigits);
Nvoid GUI_DispHex  (U32 v, U8 Len);
Xvoid GUI_DispHex  (unsigned long v, unsigned char Len);
Nvoid GUI_DispHexAt(U32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispHexAt(unsigned long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispSDec(I32 v, U8 Len);
Xvoid GUI_DispSDec(signed long v, unsigned char Len);
Nvoid GUI_DispSDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispSDecShift(signed long v, unsigned char Len, unsigned char Shift);
N
N/*********************************************************************
N*
N*       Drawing of floating point values
N*/
Nvoid GUI_DispFloat    (float v, char Len);
Nvoid GUI_DispFloatFix (float v, char Len, char Fract);
Nvoid GUI_DispFloatMin (float v, char Fract);
Nvoid GUI_DispSFloatFix(float v, char Len, char Fract);
Nvoid GUI_DispSFloatMin(float v, char Fract);
N
N/*********************************************************************
N*
N*       Dynamic memory management
N*/
N#if !defined(GUI_ALLOC_ALLOC)
X#if !0L
N  /* diagnostics */
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void);
X  signed long GUI_ALLOC_GetNumFreeBlocks(void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes (void);
X  signed long GUI_ALLOC_GetNumFreeBytes (void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void);
X  signed long GUI_ALLOC_GetNumUsedBlocks(void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes (void);
X  signed long GUI_ALLOC_GetNumUsedBytes (void);
N#else
S  #define GUI_ALLOC_GetNumFreeBlocks() 0
S  #define GUI_ALLOC_GetNumFreeBytes()  0
S  #define GUI_ALLOC_GetNumUsedBlocks() 0
S  #define GUI_ALLOC_GetNumUsedBytes()  0
N#endif
N
NGUI_HMEM           GUI_ALLOC_AllocInit     (const void * pInitData, GUI_ALLOC_DATATYPE Size);
Xsigned long           GUI_ALLOC_AllocInit     (const void * pInitData, signed long Size);
NGUI_HMEM           GUI_ALLOC_AllocNoInit   (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocNoInit   (signed long size);
NGUI_HMEM           GUI_ALLOC_AllocZero     (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocZero     (signed long size);
Nvoid               GUI_ALLOC_AssignMemory  (void * p, U32 NumBytes);
Xvoid               GUI_ALLOC_AssignMemory  (void * p, unsigned long NumBytes);
Nvoid               GUI_ALLOC_Free          (GUI_HMEM  hMem);
Xvoid               GUI_ALLOC_Free          (signed long  hMem);
Nvoid               GUI_ALLOC_FreeFixedBlock(void * p);
Nvoid               GUI_ALLOC_FreePtrArray  (GUI_HMEM * pArray, int NumElems);
Xvoid               GUI_ALLOC_FreePtrArray  (signed long * pArray, int NumElems);
Nvoid               GUI_ALLOC_FreePtr       (GUI_HMEM * phMem);
Xvoid               GUI_ALLOC_FreePtr       (signed long * phMem);
Nvoid *             GUI_ALLOC_GetFixedBlock (GUI_ALLOC_DATATYPE Size);
Xvoid *             GUI_ALLOC_GetFixedBlock (signed long Size);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize    (void);
Xsigned long GUI_ALLOC_GetMaxSize    (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetSize       (GUI_HMEM  hMem);
Xsigned long GUI_ALLOC_GetSize       (signed long  hMem);
Nvoid *             GUI_ALLOC_h2p           (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_h2p           (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_p2h           (void * p);
Xsigned long           GUI_ALLOC_p2h           (void * p);
Nvoid               GUI_ALLOC_Init          (void);
Nvoid               GUI_ALLOC_Lock          (void);
Nvoid *             GUI_ALLOC_LockH         (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_LockH         (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_Realloc       (GUI_HMEM hOld, int NewSize);
Xsigned long           GUI_ALLOC_Realloc       (signed long hOld, int NewSize);
NGUI_ALLOC_DATATYPE GUI_ALLOC_RequestSize   (void);
Xsigned long GUI_ALLOC_RequestSize   (void);
Nvoid               GUI_ALLOC_SetAvBlockSize(U32 BlockSize);
Xvoid               GUI_ALLOC_SetAvBlockSize(unsigned long BlockSize);
Nvoid               GUI_ALLOC_Unlock        (void);
Nvoid *             GUI_ALLOC_UnlockH       (void);
N
N/*********************************************************************
N*
N*       Memory devices: GUI_MEMDEV
N*/
N#define GUI_MEMDEV_HASTRANS       0
N#define GUI_MEMDEV_NOTRANS    (1<<0)
N
Ntypedef GUI_HMEM GUI_MEMDEV_Handle;
Xtypedef signed long GUI_MEMDEV_Handle;
Ntypedef void GUI_CALLBACK_VOID_P(void* p);
N
Ntypedef struct {
N  GUI_RECT rView, rPrev;
N  char FirstCall;
N} GUI_AUTODEV;
N
Ntypedef struct {
N  char DrawFixed;
N  char IsMeasurement;
N} GUI_AUTODEV_INFO;
N
Nint  GUI_MEMDEV_CreateAuto(GUI_AUTODEV * pAutoDev);
Nvoid GUI_MEMDEV_DeleteAuto(GUI_AUTODEV * pAutoDev);
Nint  GUI_MEMDEV_DrawAuto  (GUI_AUTODEV * pAutoDev, GUI_AUTODEV_INFO * pAutoDevInfo, GUI_CALLBACK_VOID_P * pfDraw, void * pData);
N
N/* Create a memory device which is compatible to the selected LCD */
NGUI_MEMDEV_Handle GUI_MEMDEV_Create     (int x0, int y0, int XSize, int YSize);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateEx   (int x0, int y0, int XSize, int YSize, int Flags);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed(int x0, int y0, 
N                                         int xsize, int ysize, int Flags,
N                                         const GUI_DEVICE_API     * pDeviceAPI,
N                                         const LCD_API_COLOR_CONV * pColorConvAPI);
Nvoid GUI_MEMDEV_Clear         (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyFromLCD   (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyFromLCDAA (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCD     (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCDAA   (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCDAt   (GUI_MEMDEV_Handle hMem, int x, int y);
Nint  GUI_MEMDEV_CompareWithLCD(GUI_MEMDEV_Handle hMem, int*px, int*py, int *pExp, int*pAct);
Nvoid GUI_MEMDEV_Delete        (GUI_MEMDEV_Handle MemDev);
Nvoid GUI_MEMDEV_DrawPerspectiveX(GUI_MEMDEV_Handle hMem, int x, int y, int h0, int h1, int dx, int dy);
Nint  GUI_MEMDEV_GetXPos       (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetXSize      (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetYPos       (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetYSize      (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_MarkDirty     (GUI_MEMDEV_Handle hMem, int x0, int y0, int x1, int y1);
Nvoid GUI_MEMDEV_ReduceYSize   (GUI_MEMDEV_Handle hMem, int YSize);
Nvoid GUI_MEMDEV_Rotate        (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateHQ      (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
NGUI_MEMDEV_Handle GUI_MEMDEV_Select (GUI_MEMDEV_Handle hMem);  /* Select (activate) a particular memory device. */
Nvoid  GUI_MEMDEV_SetOrg        (GUI_MEMDEV_Handle hMem, int x0, int y0);
Nvoid  GUI_MEMDEV_WriteAt       (GUI_MEMDEV_Handle hMem, int x, int y);
Nvoid  GUI_MEMDEV_Write         (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_WriteAlphaAt  (GUI_MEMDEV_Handle hMem, int Alpha, int x, int y);
Nvoid  GUI_MEMDEV_WriteAlpha    (GUI_MEMDEV_Handle hMem, int Alpha);
Nvoid  GUI_MEMDEV_WriteExAt     (GUI_MEMDEV_Handle hMem, int x, int y, int xMag, int yMag, int Alpha);
Nvoid  GUI_MEMDEV_WriteEx       (GUI_MEMDEV_Handle hMem, int xMag, int yMag, int Alpha);
Nint   GUI_MEMDEV_Draw          (GUI_RECT * pRect, GUI_CALLBACK_VOID_P * pfDraw, void * pData, int MemSize, int Flags);
Nint   GUI_MEMDEV_DrawStatic    (GUI_RECT * pRect, GUI_CALLBACK_VOID_P * pfDraw, void * pData, GUI_MEMDEV_Handle * phDst, int Flags);
Nvoid* GUI_MEMDEV_GetDataPtr    (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_SetColorConv  (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
Nint   GUI_MEMDEV_GetBitsPerPixel(GUI_MEMDEV_Handle hMemDev);
N
Nvoid     GUI_SelectLCD(void);
N
N/*********************************************************************
N*
N*       Alpha blending
N*/
Ntypedef struct {
N  U32 UserAlpha;
X  unsigned long UserAlpha;
N} GUI_ALPHA_STATE;
N
N#define GUI_MAKE_ALPHA(Alpha, Color) ((U32)(((U32)Alpha << 24) | Color))
N
Nunsigned GUI_EnableAlpha     (unsigned OnOff);
NU32      GUI_RestoreUserAlpha(GUI_ALPHA_STATE * pAlphaState);
Xunsigned long      GUI_RestoreUserAlpha(GUI_ALPHA_STATE * pAlphaState);
Nunsigned GUI_SetAlpha        (U8 Alpha);
Xunsigned GUI_SetAlpha        (unsigned char Alpha);
NU32      GUI_SetUserAlpha    (GUI_ALPHA_STATE * pAlphaState, U32 UserAlpha);
Xunsigned long      GUI_SetUserAlpha    (GUI_ALPHA_STATE * pAlphaState, unsigned long UserAlpha);
N
N/*********************************************************************
N*
N*       Multi layer support
N*/
Nunsigned GUI_SelectLayer(unsigned Index);
N
Nint  GUI_SetLayerPosEx  (unsigned Index, int xPos, int yPos);
Nint  GUI_SetLayerSizeEx (unsigned Index, int xSize, int ySize);
Nint  GUI_SetLayerVisEx  (unsigned Index, int OnOff);
Nint  GUI_SetLayerAlphaEx(unsigned Index, int Alpha);
Nvoid GUI_GetLayerPosEx  (unsigned Index, int * pxPos, int * pyPos);
N
Nvoid     GUI_AssignCursorLayer(unsigned Index, unsigned CursorLayer);
Nunsigned GUI_GetCursorLayer   (unsigned Index);
N
N/*********************************************************************
N*
N*       Display orientation
N*/
N/*********************************************************************
N*
N*       GUI_ORIENTATION_API
N*/
Ntypedef struct {
N  void     (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void     (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char  * pData, int Diff, const unsigned long * pTrans);
N  void     (* pfDrawHLine    )(GUI_DEVICE * pDevice, int x0, int y0,  int x1);
N  void     (* pfDrawVLine    )(GUI_DEVICE * pDevice, int x , int y0,  int y1);
N  void     (* pfFillRect     )(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1);
N  unsigned (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
N  void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
N  void     (* pfXorPixel     )(GUI_DEVICE * pDevice, int x, int y);
N  int      BytesPerPixel;
N} GUI_ORIENTATION_API;
N
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C0;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C8;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C16;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C32;
N
N#define GUI_ORIENTATION_C0  &GUI_OrientationAPI_C0
N#define GUI_ORIENTATION_C8  &GUI_OrientationAPI_C8
N#define GUI_ORIENTATION_C16 &GUI_OrientationAPI_C16
N#define GUI_ORIENTATION_C32 &GUI_OrientationAPI_C32
N
Nint GUI_SetOrientation        (int Orientation);
Nint GUI_SetOrientationEx      (int Orientation, int LayerIndex);
Nint GUI_SetOrientationExCached(int Orientation, int LayerIndex, const GUI_ORIENTATION_API * pAPI);
N
N/*********************************************************************
N*
N*       Measure device: GUI_MEASDEV
N*/
Ntypedef GUI_HMEM GUI_MEASDEV_Handle;
Xtypedef signed long GUI_MEASDEV_Handle;
N
NGUI_MEASDEV_Handle GUI_MEASDEV_Create (void);
Nvoid               GUI_MEASDEV_Delete (GUI_MEASDEV_Handle hMemDev);
Nvoid               GUI_MEASDEV_Select (GUI_MEASDEV_Handle hMem);
Nvoid               GUI_MEASDEV_GetRect(GUI_MEASDEV_Handle hMem, GUI_RECT *pRect);
Nvoid               GUI_MEASDEV_ClearRect(GUI_MEASDEV_Handle hMem);
N
N/*********************************************************************
N*
N*       Polygon helpers
N*/
Nvoid GUI_RotatePolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, float Angle);
Nvoid GUI_MagnifyPolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, int Mag);
Nvoid GUI_EnlargePolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, int Len);
N
N/*********************************************************************
N*
N*       Streamed bitmaps
N*/
N#define GUI_BITMAPSTREAM_GET_BUFFER     1
N#define GUI_BITMAPSTREAM_RELEASE_BUFFER 2
N#define GUI_BITMAPSTREAM_MODIFY_PALETTE 3
N
N#define DECLARE_CREATE_FROM_STREAM(ID) int GUI_CreateBitmapFromStream##ID(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
NDECLARE_CREATE_FROM_STREAM(IDX)
Xint GUI_CreateBitmapFromStreamIDX(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE4)
Xint GUI_CreateBitmapFromStreamRLE4(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE8)
Xint GUI_CreateBitmapFromStreamRLE8(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(565)
Xint GUI_CreateBitmapFromStream565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M565)
Xint GUI_CreateBitmapFromStreamM565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(555)
Xint GUI_CreateBitmapFromStream555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M555)
Xint GUI_CreateBitmapFromStreamM555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE16)
Xint GUI_CreateBitmapFromStreamRLE16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLEM16)
Xint GUI_CreateBitmapFromStreamRLEM16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(24)
Xint GUI_CreateBitmapFromStream24(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(Alpha)
Xint GUI_CreateBitmapFromStreamAlpha(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
Nint  GUI_CreateBitmapFromStream  (GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
Nvoid GUI_DrawStreamedBitmap      (const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapEx    (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nvoid GUI_GetStreamedBitmapInfo   (const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nint  GUI_GetStreamedBitmapInfoEx (GUI_GET_DATA_FUNC * pfGetData, const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nvoid GUI_SetStreamedBitmapHook   (GUI_BITMAPSTREAM_CALLBACK pfStreamedBitmapHook);
N
N/*********************************************************************
N*
N*       BMP-export
N*/
Ntypedef void GUI_CALLBACK_VOID_U8_P(U8 Data, void * p);
Xtypedef void GUI_CALLBACK_VOID_U8_P(unsigned char Data, void * p);
N
Nvoid GUI_BMP_SerializeEx(GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p);
Nvoid GUI_BMP_Serialize  (GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
N
N/*********************************************************************
N*
N*       Time / execution related routines
N*/
Nvoid GUI_Delay  (int Period);
Nint  GUI_GetTime(void);
Nint  GUI_Exec(void);         /* Execute all jobs ... Return 0 if nothing was done. */
Nint  GUI_Exec1(void);        /* Execute one job  ... Return 0 if nothing was done. */
N
N/*********************************************************************
N*
N*       MessageBox
N*/
Nint     GUI_MessageBox   (const char * sMessage, const char * sCaption, int Flags);
N#define GUI_MESSAGEBOX_CF_MOVEABLE (1 << 0)
N#define GUI_MESSAGEBOX_CF_MODAL    (1 << 1)
N
N#define GUI_MB_OK                20
N#define GUI_MB_WARNING           21
N
N/*********************************************************************
N*
N*       GUI_TIMER module
N*/
Ntypedef struct {
N  GUI_TIMER_TIME Time;
X  int Time;
N  U32            Context;
X  unsigned long            Context;
N} GUI_TIMER_MESSAGE;
N
Ntypedef GUI_HMEM GUI_TIMER_HANDLE;
Xtypedef signed long GUI_TIMER_HANDLE;
Ntypedef void GUI_TIMER_CALLBACK(/*const*/ GUI_TIMER_MESSAGE* pTM);
N
NGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK* cb, int Time,  U32 Context, int Flags);
XGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK* cb, int Time,  unsigned long Context, int Flags);
Nvoid             GUI_TIMER_Delete   (GUI_TIMER_HANDLE hObj);
N
N/* Methods changing properties */
Nvoid GUI_TIMER_SetPeriod (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid GUI_TIMER_SetPeriod (GUI_TIMER_HANDLE hObj, int Period);
Nvoid GUI_TIMER_SetTime   (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid GUI_TIMER_SetTime   (GUI_TIMER_HANDLE hObj, int Period);
Nvoid GUI_TIMER_SetDelay  (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Delay);
Xvoid GUI_TIMER_SetDelay  (GUI_TIMER_HANDLE hObj, int Delay);
Nvoid GUI_TIMER_Restart   (GUI_TIMER_HANDLE hObj);
Nint  GUI_TIMER_Exec(void);
N
N/*********************************************************************
N*
N*       Anti Aliasing
N*/
Nvoid GUI_AA_DisableHiRes     (void);
Nvoid GUI_AA_EnableHiRes      (void);
Nint  GUI_AA_GetFactor        (void);
Nvoid GUI_AA_SetFactor        (int Factor);
Nvoid GUI_AA_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_AA_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_AA_DrawPolyOutline  (const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y);
Nvoid GUI_AA_DrawPolyOutlineEx(const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y, GUI_POINT * pBuffer);
Nvoid GUI_AA_DrawRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_AA_FillCircle       (int x0, int y0, int r);
Nvoid GUI_AA_FillPolygon      (GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_AA_FillRoundedRect  (int x0, int y0, int x1, int y1, int r);
N
N/*********************************************************************
N*
N*       Keyboard
N*/
N/* Message layer */
Nvoid GUI_StoreKeyMsg(int Key, int Pressed);
Nvoid GUI_SendKeyMsg (int Key, int Pressed);
Nint  GUI_PollKeyMsg(void);
N
N/* Application layer */
Nint  GUI_GetKey(void);
Nint  GUI_WaitKey(void);
Nvoid GUI_StoreKey(int c);
Nvoid GUI_ClearKeyBuffer(void);
N
N/*********************************************************************
N*
N*       Task syncronisation (depends on configuration)
N*/
Nvoid GUI_WaitEvent(void);
N
N/*********************************************************************
N*
N*       Joystick, generic
N*/
Nvoid GUI_JOYSTICK_StoreState(const GUI_PID_STATE * pState);
N
N/*********************************************************************
N*
N*       PID  (Pointer input device ... mouse/touch) 
N*/
Nvoid GUI_PID_StoreState(const GUI_PID_STATE *pState);
Nint  GUI_PID_GetState  (      GUI_PID_STATE *pState);
N
N/*********************************************************************
N*
N*       Mouse, generic
N*/
Nint  GUI_MOUSE_GetState  (      GUI_PID_STATE *pState);
Nvoid GUI_MOUSE_StoreState(const GUI_PID_STATE *pState);
N
N/*********************************************************************
N*
N*       TOUCH screen, generic
N*/
Nint  GUI_TOUCH_GetState     (GUI_PID_STATE *pState);
Nvoid GUI_TOUCH_GetUnstable  (int* px, int* py);  /* for diagnostics only */
Nvoid GUI_TOUCH_SetLayer     (int Layer);
Nvoid GUI_TOUCH_StoreState   (int x, int y);
Nvoid GUI_TOUCH_StoreStateEx (const GUI_PID_STATE *pState);
Nvoid GUI_TOUCH_StoreUnstable(int x, int y);
N
N/*********************************************************************
N*
N*       Mouse, PS2 driver
N*/
Nvoid GUI_MOUSE_DRIVER_PS2_Init(void);               /* optional */
Nvoid GUI_MOUSE_DRIVER_PS2_OnRx(unsigned char Data);
N
N/*********************************************************************
N*
N*       TOUCH screen, analog driver
N*/
Nvoid GUI_TOUCH_Exec                 (void);
Nint  GUI_TOUCH_Calibrate            (int Coord, int Log0, int Log1, int Phys0, int Phys1);
Nvoid GUI_TOUCH_SetDefaultCalibration(void);
Nint  GUI_TOUCH_GetxPhys             (void);    /* for diagnostics only */
Nint  GUI_TOUCH_GetyPhys             (void);    /* for diagnostics only */
Nvoid GUI_TOUCH_GetCalData           (int Coord, int* pMin,int* pMax);
Nvoid GUI_TOUCH_SetOrientation       (unsigned Orientation);
Nvoid GUI_TOUCH_SetOrientationPhys   (unsigned Orientation);
N
N/*********************************************************************
N*
N*       TOUCH: imports
N*
N* Please note: The following functions are required by the module.
N* They need to be part of your application software (or rather, part
N* of the hardware-layer of your software).
N*/
Nvoid GUI_TOUCH_X_ActivateX(void);
Nvoid GUI_TOUCH_X_ActivateY(void);
Nvoid GUI_TOUCH_X_Disable  (void);
Nint  GUI_TOUCH_X_MeasureX (void);
Nint  GUI_TOUCH_X_MeasureY (void);
N
N/*********************************************************************
N*
N*       GUI_X_
N*
N* Externals, to be defined by application
N*
N* The externals defined below should be defined by the
N* application. They are per default contained in the module
N* GUI_X.c.
N* Note that a lot if not all of these are not required in most target
N* systems.
N* For this module, samples are available for configurations
N* with or without operating system.
N*/
N
N//
N// Configuration
N//
Nvoid GUI_X_Config(void);
Nvoid GUI_X_Init(void);
N
N//
N// ExecIdle - called if nothing else is left to do
N//
Nvoid GUI_X_ExecIdle(void);
N
N//
N// Timing routines
N//
Nint  GUI_X_GetTime(void);
Nvoid GUI_X_Delay(int Period);
N
N//
N// Multitask routines - required only if multitasking is used (#define GUI_OS 1)
N//
Nvoid GUI_X_Unlock(void);
Nvoid GUI_X_Lock(void);
NU32  GUI_X_GetTaskId(void);
Xunsigned long  GUI_X_GetTaskId(void);
Nvoid GUI_X_InitOS(void);
N
N//
N// Event driving (optional with multitasking)
N//
Nvoid GUI_X_WaitEvent(void);
Nvoid GUI_X_WaitEventTimed(int Period);
Nvoid GUI_X_SignalEvent(void);
N
N//
N// Recording (logs/warnings and errors) - required only for higher levels
N//
Nvoid GUI_X_Log(const char *s);
Nvoid GUI_X_Warn(const char *s);
Nvoid GUI_X_ErrorOut(const char *s); 
N
N/*********************************************************************
N*
N*       Constants for fonts and bitmaps
N*/
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods8888;
N
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods24;
N
N#define GUI_COMPRESS_RLE4 0
N#define GUI_COMPRESS_RLE8 0
N
N#define GUI_DRAW_RLE4    &GUI_BitmapMethodsRLE4   /* Method table ! */
N#define GUI_DRAW_RLE8    &GUI_BitmapMethodsRLE8   /* Method table ! */
N#define GUI_DRAW_RLE16   &GUI_BitmapMethodsRLE16  /* Method table ! */
N#define GUI_DRAW_RLEM16  &GUI_BitmapMethodsRLEM16 /* Method table ! */
N#define GUI_DRAW_BMP555  &GUI_BitmapMethods555    /* Method table ! */
N#define GUI_DRAW_BMPM555 &GUI_BitmapMethodsM555   /* Method table ! */
N#define GUI_DRAW_BMP565  &GUI_BitmapMethods565    /* Method table ! */
N#define GUI_DRAW_BMPM565 &GUI_BitmapMethodsM565   /* Method table ! */
N#define GUI_DRAW_BMP888  &GUI_BitmapMethods888    /* Method table ! */
N#define GUI_DRAW_BMPM888 &GUI_BitmapMethodsM888   /* Method table ! */
N#define GUI_DRAW_BMP8888 &GUI_BitmapMethods8888   /* Method table ! */
N#define GUI_DRAW_BMP24   &GUI_BitmapMethods24     /* Method table ! */
N
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Ext;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Frm;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2_EXT;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4_EXT;
N
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Frm;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA2_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA4_Ext;
N
N/*********************************************************************
N*
N*       GUI_KEY_...
N*
N* These ID values are basically meant to be used with widgets
N* Note that we have chosen the values to be close to existing
N* "standards", so do not change them unless forced to.
N*
N*/
N#define GUI_KEY_BACKSPACE         8         /* ASCII: BACKSPACE Crtl-H */
N#define GUI_KEY_TAB               9         /* ASCII: TAB       Crtl-I */
N#define GUI_KEY_BACKTAB           10
N#define GUI_KEY_ENTER             13        /* ASCII: ENTER     Crtl-M */
N#define GUI_KEY_LEFT              16
N#define GUI_KEY_UP                17
N#define GUI_KEY_RIGHT             18
N#define GUI_KEY_DOWN              19
N#define GUI_KEY_HOME              23
N#define GUI_KEY_END               24
N#define GUI_KEY_SHIFT             25
N#define GUI_KEY_CONTROL           26
N#define GUI_KEY_ESCAPE            27        /* ASCII: ESCAPE    0x1b   */
N#define GUI_KEY_INSERT            29
N#define GUI_KEY_DELETE            30
N#define GUI_KEY_SPACE             32
N#define GUI_KEY_PGUP              33
N#define GUI_KEY_PGDOWN            34
N
N#define GUI_KEY_F1                40
N#define GUI_KEY_F2                41
N
N/*********************************************************************
N*
N*       Dialog item IDs
N*
N*  The IDs below are arbitrary values. They just have to be unique
N*  within the dialog.
N*
N*  If you use your own Ids, we recommend to use values above GUI_ID_USER.
N*/
N#define GUI_ID_OK                1
N#define GUI_ID_CANCEL            2
N#define GUI_ID_YES               3
N#define GUI_ID_NO                4
N#define GUI_ID_CLOSE             5
N#define GUI_ID_HELP              6
N#define GUI_ID_MAXIMIZE          7
N#define GUI_ID_MINIMIZE          8
N
N#define GUI_ID_VSCROLL  0xFE
N#define GUI_ID_HSCROLL  0xFF
N
N#define GUI_ID_EDIT0    0x100
N#define GUI_ID_EDIT1    0x101
N#define GUI_ID_EDIT2    0x102
N#define GUI_ID_EDIT3    0x103
N#define GUI_ID_EDIT4    0x104
N#define GUI_ID_EDIT5    0x105
N#define GUI_ID_EDIT6    0x106
N#define GUI_ID_EDIT7    0x107
N#define GUI_ID_EDIT8    0x108
N#define GUI_ID_EDIT9    0x109
N
N#define GUI_ID_LISTBOX0 0x110
N#define GUI_ID_LISTBOX1 0x111
N#define GUI_ID_LISTBOX2 0x112
N#define GUI_ID_LISTBOX3 0x113
N#define GUI_ID_LISTBOX4 0x114
N#define GUI_ID_LISTBOX5 0x115
N#define GUI_ID_LISTBOX6 0x116
N#define GUI_ID_LISTBOX7 0x117
N#define GUI_ID_LISTBOX8 0x118
N#define GUI_ID_LISTBOX9 0x119
N
N#define GUI_ID_CHECK0   0x120
N#define GUI_ID_CHECK1   0x121
N#define GUI_ID_CHECK2   0x122
N#define GUI_ID_CHECK3   0x123
N#define GUI_ID_CHECK4   0x124
N#define GUI_ID_CHECK5   0x125
N#define GUI_ID_CHECK6   0x126
N#define GUI_ID_CHECK7   0x127
N#define GUI_ID_CHECK8   0x128
N#define GUI_ID_CHECK9   0x129
N
N#define GUI_ID_SLIDER0  0x130
N#define GUI_ID_SLIDER1  0x131
N#define GUI_ID_SLIDER2  0x132
N#define GUI_ID_SLIDER3  0x133
N#define GUI_ID_SLIDER4  0x134
N#define GUI_ID_SLIDER5  0x135
N#define GUI_ID_SLIDER6  0x136
N#define GUI_ID_SLIDER7  0x137
N#define GUI_ID_SLIDER8  0x138
N#define GUI_ID_SLIDER9  0x139
N
N#define GUI_ID_SCROLLBAR0 0x140
N#define GUI_ID_SCROLLBAR1 0x141
N#define GUI_ID_SCROLLBAR2 0x142
N#define GUI_ID_SCROLLBAR3 0x142
N
N#define GUI_ID_RADIO0 0x150
N#define GUI_ID_RADIO1 0x151
N#define GUI_ID_RADIO2 0x152
N#define GUI_ID_RADIO3 0x153
N#define GUI_ID_RADIO4 0x154
N#define GUI_ID_RADIO5 0x155
N#define GUI_ID_RADIO6 0x156
N#define GUI_ID_RADIO7 0x157
N
N#define GUI_ID_TEXT0  0x160
N#define GUI_ID_TEXT1  0x161
N#define GUI_ID_TEXT2  0x162
N#define GUI_ID_TEXT3  0x163
N#define GUI_ID_TEXT4  0x164
N#define GUI_ID_TEXT5  0x165
N#define GUI_ID_TEXT6  0x166
N#define GUI_ID_TEXT7  0x167
N#define GUI_ID_TEXT8  0x168
N#define GUI_ID_TEXT9  0x169
N
N#define GUI_ID_BUTTON0 0x170
N#define GUI_ID_BUTTON1 0x171
N#define GUI_ID_BUTTON2 0x172
N#define GUI_ID_BUTTON3 0x173
N#define GUI_ID_BUTTON4 0x174
N#define GUI_ID_BUTTON5 0x175
N#define GUI_ID_BUTTON6 0x176
N#define GUI_ID_BUTTON7 0x177
N#define GUI_ID_BUTTON8 0x178
N#define GUI_ID_BUTTON9 0x179
N
N#define GUI_ID_DROPDOWN0  0x180
N#define GUI_ID_DROPDOWN1  0x181
N#define GUI_ID_DROPDOWN2  0x182
N#define GUI_ID_DROPDOWN3  0x183
N
N#define GUI_ID_MULTIEDIT0 0x190
N#define GUI_ID_MULTIEDIT1 0x191
N#define GUI_ID_MULTIEDIT2 0x192
N#define GUI_ID_MULTIEDIT3 0x193
N
N#define GUI_ID_LISTVIEW0  0x200
N#define GUI_ID_LISTVIEW1  0x201
N#define GUI_ID_LISTVIEW2  0x202
N#define GUI_ID_LISTVIEW3  0x203
N
N#define GUI_ID_PROGBAR0   0x210
N#define GUI_ID_PROGBAR1   0x211
N#define GUI_ID_PROGBAR2   0x212
N#define GUI_ID_PROGBAR3   0x213
N
N#define GUI_ID_GRAPH0 0x220
N#define GUI_ID_GRAPH1 0x221
N#define GUI_ID_GRAPH2 0x222
N#define GUI_ID_GRAPH3 0x223
N
N#define GUI_ID_MULTIPAGE0 0x230
N#define GUI_ID_MULTIPAGE1 0x231
N#define GUI_ID_MULTIPAGE2 0x232
N#define GUI_ID_MULTIPAGE3 0x233
N
N#define GUI_ID_TREEVIEW0 0x240
N#define GUI_ID_TREEVIEW1 0x241
N#define GUI_ID_TREEVIEW2 0x242
N#define GUI_ID_TREEVIEW3 0x243
N
N#define GUI_ID_ICONVIEW0 0x250
N#define GUI_ID_ICONVIEW1 0x251
N#define GUI_ID_ICONVIEW2 0x252
N#define GUI_ID_ICONVIEW3 0x253
N
N#define GUI_ID_LISTWHEEL0 0x260
N#define GUI_ID_LISTWHEEL1 0x261
N#define GUI_ID_LISTWHEEL2 0x262
N#define GUI_ID_LISTWHEEL3 0x263
N
N#define GUI_ID_USER     0x800
N
N/*********************************************************************
N*
N*       Mouse buttons
N*/
N#define GUI_LBUTTON (1 << 0) /* Left button */
N#define GUI_RBUTTON (1 << 1) /* Right button */
N#define GUI_MBUTTON (1 << 2) /* Middle button */
N#define GUI_DBUTTON (1 << 7) /* Double-click button */
N
N/*********************************************************************
N*
N*       Text styles
N*/
N#define GUI_TS_NORMAL           (0)
N#define GUI_TS_UNDERLINE        (1 << 0)
N#define GUI_TS_STRIKETHRU       (1 << 1)
N#define GUI_TS_OVERLINE         (1 << 2)
N
N/*********************************************************************
N*
N*       Line styles
N*/
N#define GUI_LS_SOLID        (0)
N#define GUI_LS_DASH         (1)
N#define GUI_LS_DOT          (2)
N#define GUI_LS_DASHDOT      (3)
N#define GUI_LS_DASHDOTDOT   (4)
N
N/*********************************************************************
N*
N*       Pen shapes
N*/
N#define GUI_PS_ROUND        (0)
N#define GUI_PS_FLAT         (1)
N#define GUI_PS_SQUARE       (2)
N
N/*********************************************************************
N*
N*       Standard colors
N*/
N#define GUI_BLUE          0x00FF0000
N#define GUI_GREEN         0x0000FF00
N#define GUI_RED           0x000000FF
N#define GUI_CYAN          0x00FFFF00
N#define GUI_MAGENTA       0x00FF00FF
N#define GUI_YELLOW        0x0000FFFF
N#define GUI_LIGHTBLUE     0x00FF8080
N#define GUI_LIGHTGREEN    0x0080FF80
N#define GUI_LIGHTRED      0x008080FF
N#define GUI_LIGHTCYAN     0x00FFFF80
N#define GUI_LIGHTMAGENTA  0x00FF80FF
N#define GUI_LIGHTYELLOW   0x0080FFFF
N#define GUI_DARKBLUE      0x00800000
N#define GUI_DARKGREEN     0x00008000
N#define GUI_DARKRED       0x00000080
N#define GUI_DARKCYAN      0x00808000
N#define GUI_DARKMAGENTA   0x00800080
N#define GUI_DARKYELLOW    0x00008080
N#define GUI_WHITE         0x00FFFFFF
N#define GUI_LIGHTGRAY     0x00D3D3D3
N#define GUI_GRAY          0x00808080
N#define GUI_DARKGRAY      0x00404040
N#define GUI_BLACK         0x00000000
N#define GUI_BROWN         0x002A2AA5
N#define GUI_TRANSPARENT   0xFF000000
N
N#define GUI_INVALID_COLOR 0xFFFFFFF      /* Invalid color - more than 24 bits */
N
N/*********************************************************************
N*
N*       Coordinates used in touch driver
N*/
N#define GUI_COORD_X 0
N#define GUI_COORD_Y 1
N
N/*********************************************************************
N*
N*       Addresses of standard fonts
N*/
N//
N// Proportional fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Xextern const GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Xextern const GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Xextern const GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Xextern const GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Xextern const GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Xextern const GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Xextern const GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Xextern const GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Xextern const GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Xextern const GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Xextern const GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Xextern const GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Xextern const GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Xextern const GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
Xextern const GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
N
N//
N// Proportional fonts, framed
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20F_ASCII;
Xextern const GUI_FONT GUI_Font20F_ASCII;
N
N//
N// Monospaced
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font4x6;
Xextern const GUI_FONT GUI_Font4x6;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Xextern const GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Xextern const GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Xextern const GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Xextern const GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x10_ASCII;
Xextern const GUI_FONT GUI_Font8x10_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x12_ASCII;
Xextern const GUI_FONT GUI_Font8x12_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Xextern const GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Xextern const GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Xextern const GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Xextern const GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
Xextern const GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
N
N//
N// Digits
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD24x32;
Xextern const GUI_FONT GUI_FontD24x32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD32;
Xextern const GUI_FONT GUI_FontD32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD36x48;
Xextern const GUI_FONT GUI_FontD36x48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48;
Xextern const GUI_FONT GUI_FontD48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48x64;
Xextern const GUI_FONT GUI_FontD48x64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD64;
Xextern const GUI_FONT GUI_FontD64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD60x80;
Xextern const GUI_FONT GUI_FontD60x80;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD80;
Xextern const GUI_FONT GUI_FontD80;
N
N//
N// Comic fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Xextern const GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
Xextern const GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
N
N/*********************************************************************
N*
N*       Macros to be used
N*/
N//
N// Proportional fonts
N//
N#define GUI_FONT_8_ASCII        &GUI_Font8_ASCII
N#define GUI_FONT_8_1            &GUI_Font8_1
N#define GUI_FONT_10S_ASCII      &GUI_Font10S_ASCII
N#define GUI_FONT_10S_1          &GUI_Font10S_1
N#define GUI_FONT_10_ASCII       &GUI_Font10_ASCII
N#define GUI_FONT_10_1           &GUI_Font10_1
N#define GUI_FONT_13_ASCII       &GUI_Font13_ASCII
N#define GUI_FONT_13_1           &GUI_Font13_1
N#define GUI_FONT_13B_ASCII      &GUI_Font13B_ASCII
N#define GUI_FONT_13B_1          &GUI_Font13B_1
N#define GUI_FONT_13H_ASCII      &GUI_Font13H_ASCII
N#define GUI_FONT_13H_1          &GUI_Font13H_1
N#define GUI_FONT_13HB_ASCII     &GUI_Font13HB_ASCII
N#define GUI_FONT_13HB_1         &GUI_Font13HB_1
N#define GUI_FONT_16_ASCII       &GUI_Font16_ASCII
N#define GUI_FONT_16_1           &GUI_Font16_1
N#define GUI_FONT_16_HK          &GUI_Font16_HK
N#define GUI_FONT_16_1HK         &GUI_Font16_1HK
N#define GUI_FONT_16_ASCII       &GUI_Font16_ASCII
N#define GUI_FONT_16_1           &GUI_Font16_1
N#define GUI_FONT_16_HK          &GUI_Font16_HK
N#define GUI_FONT_16_1HK         &GUI_Font16_1HK
N#define GUI_FONT_16B_ASCII      &GUI_Font16B_ASCII
N#define GUI_FONT_16B_1          &GUI_Font16B_1
N#define GUI_FONT_20_ASCII       &GUI_Font20_ASCII
N#define GUI_FONT_20_1           &GUI_Font20_1
N#define GUI_FONT_20B_ASCII      &GUI_Font20B_ASCII
N#define GUI_FONT_20B_1          &GUI_Font20B_1
N#define GUI_FONT_24_ASCII       &GUI_Font24_ASCII
N#define GUI_FONT_24_1           &GUI_Font24_1
N#define GUI_FONT_24B_ASCII      &GUI_Font24B_ASCII
N#define GUI_FONT_24B_1          &GUI_Font24B_1
N#define GUI_FONT_32_ASCII       &GUI_Font32_ASCII
N#define GUI_FONT_32_1           &GUI_Font32_1
N#define GUI_FONT_32B_ASCII      &GUI_Font32B_ASCII
N#define GUI_FONT_32B_1          &GUI_Font32B_1
N
N//
N// Proportional fonts, framed
N//
N#define GUI_FONT_20F_ASCII      &GUI_Font20F_ASCII
N
N//
N// Monospaced
N//
N#define GUI_FONT_4X6            &GUI_Font4x6
N#define GUI_FONT_6X8            &GUI_Font6x8
N#define GUI_FONT_6X8_ASCII      &GUI_Font6x8_ASCII
N#define GUI_FONT_6X8_1          &GUI_Font6x8_1
N#define GUI_FONT_6X9            &GUI_Font6x9
N#define GUI_FONT_8X8            &GUI_Font8x8
N#define GUI_FONT_8X8_ASCII      &GUI_Font8x8_ASCII
N#define GUI_FONT_8X8_1          &GUI_Font8x8_1
N#define GUI_FONT_8X9            &GUI_Font8x9
N#define GUI_FONT_8X10_ASCII     &GUI_Font8x10_ASCII
N#define GUI_FONT_8X12_ASCII     &GUI_Font8x12_ASCII
N#define GUI_FONT_8X13_ASCII     &GUI_Font8x13_ASCII
N#define GUI_FONT_8X13_1         &GUI_Font8x13_1
N#define GUI_FONT_8X15B_ASCII    &GUI_Font8x15B_ASCII
N#define GUI_FONT_8X15B_1        &GUI_Font8x15B_1
N#define GUI_FONT_8X16           &GUI_Font8x16
N#define GUI_FONT_8X17           &GUI_Font8x17
N#define GUI_FONT_8X18           &GUI_Font8x18
N#define GUI_FONT_8X16X1X2       &GUI_Font8x16x1x2
N#define GUI_FONT_8X16X2X2       &GUI_Font8x16x2x2
N#define GUI_FONT_8X16X3X3       &GUI_Font8x16x3x3
N#define GUI_FONT_8X16_ASCII     &GUI_Font8x16_ASCII
N#define GUI_FONT_8X16_1         &GUI_Font8x16_1
N
N//
N// Digits
N//
N#define GUI_FONT_D24X32         &GUI_FontD24x32
N#define GUI_FONT_D32            &GUI_FontD32
N#define GUI_FONT_D36X48         &GUI_FontD36x48
N#define GUI_FONT_D48            &GUI_FontD48
N#define GUI_FONT_D48X64         &GUI_FontD48x64
N#define GUI_FONT_D64            &GUI_FontD64
N#define GUI_FONT_D60X80         &GUI_FontD60x80
N#define GUI_FONT_D80            &GUI_FontD80
N
N//
N// Comic fonts
N//
N#define GUI_FONT_COMIC18B_ASCII &GUI_FontComic18B_ASCII
N#define GUI_FONT_COMIC18B_1     &GUI_FontComic18B_1
N#define GUI_FONT_COMIC24B_ASCII &GUI_FontComic24B_ASCII
N#define GUI_FONT_COMIC24B_1     &GUI_FontComic24B_1
N
N/*********************************************************************
N*
N*       Text and drawing modes
N*
N* These defines come in two flavors: the long version (.._DRAWMODE_..)
N* and the short ones (.._DM_..). They are identical, feel free to use
N* which ever one you like best.
N*/
N#define GUI_DRAWMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_DRAWMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_DRAWMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_DRAWMODE_REV     LCD_DRAWMODE_REV
N#define GUI_DM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_DM_XOR           LCD_DRAWMODE_XOR
N#define GUI_DM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_DM_REV           LCD_DRAWMODE_REV
N
N#define GUI_TEXTMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_TEXTMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_TEXTMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_TEXTMODE_REV     LCD_DRAWMODE_REV
N#define GUI_TM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_TM_XOR           LCD_DRAWMODE_XOR
N#define GUI_TM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_TM_REV           LCD_DRAWMODE_REV
N
N/* Text alignment flags, horizontal */
N#define GUI_TA_HORIZONTAL  (3<<0)
N#define GUI_TA_LEFT        (0<<0)
N#define GUI_TA_RIGHT	     (1<<0)
N#define GUI_TA_CENTER	     (2<<0)
N#define GUI_TA_HCENTER	   GUI_TA_CENTER  /* easier to remember :-)  */
N
N/* Text alignment flags, vertical */
N#define GUI_TA_VERTICAL   (3<<2)
N#define GUI_TA_TOP	      (0<<2)
N#define GUI_TA_BOTTOM	    (1<<2)
N#define GUI_TA_BASELINE   (2<<2)
N#define GUI_TA_VCENTER    (3<<2)
N
N/* General orientation flags */
N#define GUI_MIRROR_X (1 << 0)
N#define GUI_MIRROR_Y (1 << 1)
N#define GUI_SWAP_XY  (1 << 2)
N
N/*********************************************************************
N*
N*       Min/Max coordinates
N*
N* Define minimum and maximum coordinates in x and y
N*/
N#define GUI_XMIN -4095
N#define GUI_XMAX  4095
N#define GUI_YMIN -4095
N#define GUI_YMAX  4095
N
N/*********************************************************************
N*
N*       Defines for constants
N*/
N#define	________	0x0
N#define	_______X	0x1
N#define	______X_	0x2
N#define	______XX	0x3
N#define	_____X__	0x4
N#define	_____X_X	0x5
N#define	_____XX_	0x6
N#define	_____XXX	0x7
N#define	____X___	0x8
N#define	____X__X	0x9
N#define	____X_X_	0xa
N#define	____X_XX	0xb
N#define	____XX__	0xc
N#define	____XX_X	0xd
N#define	____XXX_	0xe
N#define	____XXXX	0xf
N#define	___X____	0x10
N#define	___X___X	0x11
N#define	___X__X_	0x12
N#define	___X__XX	0x13
N#define	___X_X__	0x14
N#define	___X_X_X	0x15
N#define	___X_XX_	0x16
N#define	___X_XXX	0x17
N#define	___XX___	0x18
N#define	___XX__X	0x19
N#define	___XX_X_	0x1a
N#define	___XX_XX	0x1b
N#define	___XXX__	0x1c
N#define	___XXX_X	0x1d
N#define	___XXXX_	0x1e
N#define	___XXXXX	0x1f
N#define	__X_____	0x20
N#define	__X____X	0x21
N#define	__X___X_	0x22
N#define	__X___XX	0x23
N#define	__X__X__	0x24
N#define	__X__X_X	0x25
N#define	__X__XX_	0x26
N#define	__X__XXX	0x27
N#define	__X_X___	0x28
N#define	__X_X__X	0x29
N#define	__X_X_X_	0x2a
N#define	__X_X_XX	0x2b
N#define	__X_XX__	0x2c
N#define	__X_XX_X	0x2d
N#define	__X_XXX_	0x2e
N#define	__X_XXXX	0x2f
N#define	__XX____	0x30
N#define	__XX___X	0x31
N#define	__XX__X_	0x32
N#define	__XX__XX	0x33
N#define	__XX_X__	0x34
N#define	__XX_X_X	0x35
N#define	__XX_XX_	0x36
N#define	__XX_XXX	0x37
N#define	__XXX___	0x38
N#define	__XXX__X	0x39
N#define	__XXX_X_	0x3a
N#define	__XXX_XX	0x3b
N#define	__XXXX__	0x3c
N#define	__XXXX_X	0x3d
N#define	__XXXXX_	0x3e
N#define	__XXXXXX	0x3f
N#define	_X______	0x40
N#define	_X_____X	0x41
N#define	_X____X_	0x42
N#define	_X____XX	0x43
N#define	_X___X__	0x44
N#define	_X___X_X	0x45
N#define	_X___XX_	0x46
N#define	_X___XXX	0x47
N#define	_X__X___	0x48
N#define	_X__X__X	0x49
N#define	_X__X_X_	0x4a
N#define	_X__X_XX	0x4b
N#define	_X__XX__	0x4c
N#define	_X__XX_X	0x4d
N#define	_X__XXX_	0x4e
N#define	_X__XXXX	0x4f
N#define	_X_X____	0x50
N#define	_X_X___X	0x51
N#define	_X_X__X_	0x52
N#define	_X_X__XX	0x53
N#define	_X_X_X__	0x54
N#define	_X_X_X_X	0x55
N#define	_X_X_XX_	0x56
N#define	_X_X_XXX	0x57
N#define	_X_XX___	0x58
N#define	_X_XX__X	0x59
N#define	_X_XX_X_	0x5a
N#define	_X_XX_XX	0x5b
N#define	_X_XXX__	0x5c
N#define	_X_XXX_X	0x5d
N#define	_X_XXXX_	0x5e
N#define	_X_XXXXX	0x5f
N#define	_XX_____	0x60
N#define	_XX____X	0x61
N#define	_XX___X_	0x62
N#define	_XX___XX	0x63
N#define	_XX__X__	0x64
N#define	_XX__X_X	0x65
N#define	_XX__XX_	0x66
N#define	_XX__XXX	0x67
N#define	_XX_X___	0x68
N#define	_XX_X__X	0x69
N#define	_XX_X_X_	0x6a
N#define	_XX_X_XX	0x6b
N#define	_XX_XX__	0x6c
N#define	_XX_XX_X	0x6d
N#define	_XX_XXX_	0x6e
N#define	_XX_XXXX	0x6f
N#define	_XXX____	0x70
N#define	_XXX___X	0x71
N#define	_XXX__X_	0x72
N#define	_XXX__XX	0x73
N#define	_XXX_X__	0x74
N#define	_XXX_X_X	0x75
N#define	_XXX_XX_	0x76
N#define	_XXX_XXX	0x77
N#define	_XXXX___	0x78
N#define	_XXXX__X	0x79
N#define	_XXXX_X_	0x7a
N#define	_XXXX_XX	0x7b
N#define	_XXXXX__	0x7c
N#define	_XXXXX_X	0x7d
N#define	_XXXXXX_	0x7e
N#define	_XXXXXXX	0x7f
N#define	X_______	0x80
N#define	X______X	0x81
N#define	X_____X_	0x82
N#define	X_____XX	0x83
N#define	X____X__	0x84
N#define	X____X_X	0x85
N#define	X____XX_	0x86
N#define	X____XXX	0x87
N#define	X___X___	0x88
N#define	X___X__X	0x89
N#define	X___X_X_	0x8a
N#define	X___X_XX	0x8b
N#define	X___XX__	0x8c
N#define	X___XX_X	0x8d
N#define	X___XXX_	0x8e
N#define	X___XXXX	0x8f
N#define	X__X____	0x90
N#define	X__X___X	0x91
N#define	X__X__X_	0x92
N#define	X__X__XX	0x93
N#define	X__X_X__	0x94
N#define	X__X_X_X	0x95
N#define	X__X_XX_	0x96
N#define	X__X_XXX	0x97
N#define	X__XX___	0x98
N#define	X__XX__X	0x99
N#define	X__XX_X_	0x9a
N#define X__XX_XX	0x9b
N#define X__XXX__	0x9c
N#define X__XXX_X	0x9d
N#define	X__XXXX_	0x9e
N#define	X__XXXXX	0x9f
N#define	X_X_____	0xa0
N#define	X_X____X	0xa1
N#define	X_X___X_	0xa2
N#define	X_X___XX	0xa3
N#define	X_X__X__	0xa4
N#define	X_X__X_X	0xa5
N#define	X_X__XX_	0xa6
N#define	X_X__XXX	0xa7
N#define	X_X_X___	0xa8
N#define	X_X_X__X	0xa9
N#define	X_X_X_X_	0xaa
N#define	X_X_X_XX	0xab
N#define	X_X_XX__	0xac
N#define	X_X_XX_X	0xad
N#define	X_X_XXX_	0xae
N#define	X_X_XXXX	0xaf
N#define	X_XX____	0xb0
N#define X_XX___X	0xb1
N#define	X_XX__X_	0xb2
N#define	X_XX__XX	0xb3
N#define	X_XX_X__	0xb4
N#define	X_XX_X_X	0xb5
N#define	X_XX_XX_	0xb6
N#define	X_XX_XXX	0xb7
N#define	X_XXX___	0xb8
N#define	X_XXX__X	0xb9
N#define	X_XXX_X_	0xba
N#define	X_XXX_XX	0xbb
N#define	X_XXXX__	0xbc
N#define	X_XXXX_X	0xbd
N#define	X_XXXXX_	0xbe
N#define	X_XXXXXX	0xbf
N#define	XX______	0xc0
N#define	XX_____X	0xc1
N#define	XX____X_	0xc2
N#define	XX____XX	0xc3
N#define	XX___X__	0xc4
N#define	XX___X_X	0xc5
N#define	XX___XX_	0xc6
N#define	XX___XXX	0xc7
N#define	XX__X___	0xc8
N#define	XX__X__X	0xc9
N#define	XX__X_X_	0xca
N#define	XX__X_XX	0xcb
N#define	XX__XX__	0xcc
N#define	XX__XX_X	0xcd
N#define	XX__XXX_	0xce
N#define XX__XXXX	0xcf
N#define	XX_X____	0xd0
N#define	XX_X___X	0xd1
N#define	XX_X__X_	0xd2
N#define	XX_X__XX	0xd3
N#define	XX_X_X__	0xd4
N#define	XX_X_X_X	0xd5
N#define	XX_X_XX_	0xd6
N#define	XX_X_XXX	0xd7
N#define	XX_XX___	0xd8
N#define	XX_XX__X	0xd9
N#define	XX_XX_X_	0xda
N#define	XX_XX_XX	0xdb
N#define	XX_XXX__	0xdc
N#define	XX_XXX_X	0xdd
N#define	XX_XXXX_	0xde
N#define	XX_XXXXX	0xdf
N#define	XXX_____	0xe0
N#define	XXX____X	0xe1
N#define	XXX___X_	0xe2
N#define	XXX___XX	0xe3
N#define	XXX__X__	0xe4
N#define	XXX__X_X	0xe5
N#define	XXX__XX_	0xe6
N#define	XXX__XXX	0xe7
N#define	XXX_X___	0xe8
N#define	XXX_X__X	0xe9
N#define	XXX_X_X_	0xea
N#define	XXX_X_XX	0xeb
N#define	XXX_XX__	0xec
N#define	XXX_XX_X	0xed
N#define	XXX_XXX_	0xee
N#define	XXX_XXXX	0xef
N#define	XXXX____	0xf0
N#define	XXXX___X	0xf1
N#define	XXXX__X_	0xf2
N#define	XXXX__XX	0xf3
N#define	XXXX_X__	0xf4
N#define	XXXX_X_X	0xf5
N#define	XXXX_XX_	0xf6
N#define	XXXX_XXX	0xf7
N#define	XXXXX___	0xf8
N#define	XXXXX__X	0xf9
N#define	XXXXX_X_	0xfa
N#define	XXXXX_XX	0xfb
N#define	XXXXXX__	0xfc
N#define	XXXXXX_X	0xfd
N#define	XXXXXXX_	0xfe
N#define	XXXXXXXX	0xff
N
N/*********************************************************************
N*
N*       Compatibility with older versions
N*/
N#define GUI_DispString_UC  GUI_UC_DispString
N#define TOUCH_X_ActivateX  GUI_TOUCH_X_ActivateX
N#define TOUCH_X_ActivateY  GUI_TOUCH_X_ActivateY
N#define TOUCH_X_Disable    GUI_TOUCH_X_Disable
N#define TOUCH_X_MeasureX   GUI_TOUCH_X_MeasureX
N#define TOUCH_X_MeasureY   GUI_TOUCH_X_MeasureY
N#define GUI_SelLayer       GUI_SelectLayer
N#if defined(__cplusplus)
X#if 0L
S}
N#endif 
N
N#endif   /* ifdef GUI_H */
N
N/*************************** End of file ****************************/
L 26 "GUI\GUI_VNC_X_StartServer.c" 2
N#include "GUI_VNC.h"
L 1 "GUI\GUI_VNC.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI_VNC.h
NPurpose     : Publics for the VNC server
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_VNC_H
N#define  GUI_VNC_H
N
N#include "GUI_Private.h"
L 1 "GUI\GUI_Private.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI_Private.h
NPurpose     : GUI internal declarations
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GUI_PRIVATE_H
N#define GUI_PRIVATE_H
N
N#include "GUI.h"
N#include "LCD_Protected.h"
L 1 "GUI\LCD_Protected.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : LCD_Protected.h
NPurpose     : LCD level - To be used only internally by the GUI
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_PROTECTED_H
N#define LCD_PROTECTED_H
N
N#include "LCD.h"
N
N/*********************************************************************
N*
N*       Data types
N*/
Ntypedef struct {
N  LCD_COLOR * paColor;
N  I16         NumEntries;
X  signed short         NumEntries;
N} LCD_LUT_INFO;
N
Ntypedef struct {
N  tLCDDEV_DrawPixel  * pfDrawPixel;
N  tLCDDEV_DrawHLine  * pfDrawHLine;
N  tLCDDEV_DrawVLine  * pfDrawVLine;
N  tLCDDEV_FillRect   * pfFillRect;
N  tLCDDEV_DrawBitmap * pfDrawBitmap;
N} LCD_API_LIST;
N
N/*********************************************************************
N*
N*       External data
N*/
Nextern GUI_CONST_STORAGE U8 LCD_aMirror[256];
Xextern const unsigned char LCD_aMirror[256];
Nextern LCD_PIXELINDEX LCD__aConvTable[LCD_MAX_LOG_COLORS];
Xextern unsigned long LCD__aConvTable[256];
N
N/*********************************************************************
N*
N*       Misc functions
N*/
Nvoid LCD_UpdateColorIndices   (void);
Nint  LCD_PassingBitmapsAllowed(void);
Nvoid LCD_EnableCursor         (int OnOff);
Nvoid LCD_SelectLCD            (void);
N
Nvoid LCD_DrawBitmap(int x0, int y0,
N                    int xsize, int ysize,
N                    int xMul, int yMul,
N                    int BitsPerPixel,
N                    int BytesPerLine,
N                    const U8 GUI_UNI_PTR * pPixel,
X                    const unsigned char  * pPixel,
N                    const LCD_PIXELINDEX * pTrans);
X                    const unsigned long * pTrans);
N
N/*********************************************************************
N*
N*       Internal used color conversion routines
N*/
NtLCDDEV_Index2Color LCD_Index2Color_555;
NtLCDDEV_Index2Color LCD_Index2Color_565;
NtLCDDEV_Index2Color LCD_Index2Color_8666;
NtLCDDEV_Index2Color LCD_Index2Color_888;
NtLCDDEV_Index2Color LCD_Index2Color_8888;
NtLCDDEV_Index2Color LCD_Index2Color_M555;
NtLCDDEV_Index2Color LCD_Index2Color_M565;
NtLCDDEV_Index2Color LCD_Index2Color_M888;
N
NtLCDDEV_Color2Index LCD_Color2Index_8666;
N
N#endif /* LCD_PROTECTED_H */
N
N/*************************** End of file ****************************/
N
L 23 "GUI\GUI_Private.h" 2
N#include "GUI_Debug.h"
L 1 "GUI\GUI_Debug.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : GUI_Debug.h
NPurpose     : Debug macros
N----------------------------------------------------------------------
N   Debug macros for logging
N
N In the GUI Simulation, all output is transferred into the log window.
N*/
N
N#ifndef GUI_DEBUG_H
N#define GUI_DEBUG_H
N
N#include <stddef.h>
L 1 "C:\Program Files (x86)\Keil\V473\ARM\ARMCC\bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
Ntypedef signed int ptrdiff_t;
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* others (e.g. <stdio.h>) also define */
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32)
X    #if 0L
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 25 "GUI\GUI_Debug.h" 2
N
N#include "GUI.h"
N
N#define GUI_DEBUG_LEVEL_NOCHECK       0  /* No run time checks are performed */
N#define GUI_DEBUG_LEVEL_CHECK_PARA    1  /* Parameter checks are performed to avoid crashes */
N#define GUI_DEBUG_LEVEL_CHECK_ALL     2  /* Parameter checks and consistency checks are performed */
N#define GUI_DEBUG_LEVEL_LOG_ERRORS    3  /* Errors are recorded */
N#define GUI_DEBUG_LEVEL_LOG_WARNINGS  4  /* Errors & Warnings are recorded */
N#define GUI_DEBUG_LEVEL_LOG_ALL       5  /* Errors, Warnings and Messages are recorded. */
N
N#ifndef GUI_DEBUG_LEVEL
N  #ifdef WIN32
S    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_LOG_WARNINGS  /* Simulation should log all warnings */
N  #else
N    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_CHECK_PARA  /* For most targets, min. size is important */
N  #endif
N#endif
N
N#if (GUI_DEBUG_LEVEL > 0)
X#if (1 > 0)
N  #define GUI_LOCK_H(hMem)   GUI_ALLOC_LockH(hMem)
N  #define GUI_UNLOCK_H(pMem) GUI_ALLOC_UnlockH(); pMem = NULL
N#else
S  #define GUI_LOCK_H(hMem)   GUI_ALLOC_h2p(hMem)
S  #define GUI_UNLOCK_H(pMem)
N#endif
N
N/*******************************************************************
N*
N*               Commandline
N*
N********************************************************************
N*/
N
N#ifdef WIN32
S  #define GUI_DEBUG_GETCMDLINE() SIM_GetCmdLine()
N#else
N  #define GUI_DEBUG_GETCMDLINE() 0
N#endif
N
N/*******************************************************************
N*
N*               Error macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 1 >= 3
S  #define GUI_DEBUG_ERROROUT(s)              GUI_ErrorOut(s)
S  #define GUI_DEBUG_ERROROUT1(s,p0)          GUI_ErrorOut1(s,p0)
S  #define GUI_DEBUG_ERROROUT2(s,p0,p1)       GUI_ErrorOut2(s,p0,p1)
S  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)    GUI_ErrorOut3(s,p0,p1,p2)
S  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3) GUI_ErrorOut4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_ERROROUT_IF(exp,s)              { if (exp) GUI_DEBUG_ERROROUT(s); }
S  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)          { if (exp) GUI_DEBUG_ERROROUT1(s,p0); }
S  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)       { if (exp) GUI_DEBUG_ERROROUT2(s,p0,p1); }
S  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)    { if (exp) GUI_DEBUG_ERROROUT3(s,p0,p1,p2); }
S  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3) { if (exp) GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_ERROROUT(s)
N  #define GUI_DEBUG_ERROROUT1(s,p0)
N  #define GUI_DEBUG_ERROROUT2(s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_ERROROUT_IF(exp,s)
N  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)
N  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Warning macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 1 >= 4
S  #define GUI_DEBUG_WARN(s)              GUI_Warn(s)
S  #define GUI_DEBUG_WARN1(s,p0)          GUI_Warn1(s,p0)
S  #define GUI_DEBUG_WARN2(s,p0,p1)       GUI_Warn2(s,p0,p1)
S  #define GUI_DEBUG_WARN3(s,p0,p1,p2)    GUI_Warn3(s,p0,p1,p2)
S  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3) GUI_Warn4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_WARN_IF(exp,s)                  { if (exp) GUI_DEBUG_WARN(s); }
S  #define GUI_DEBUG_WARN1_IF(exp,s,p0)              { if (exp) GUI_DEBUG_WARN1(s,p0); }
S  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)           { if (exp) GUI_DEBUG_WARN2(s,p0,p1); }
S  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)        { if (exp) GUI_DEBUG_WARN3(s,p0,p1,p2); }
S  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)     { if (exp) GUI_DEBUG_WARN4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_WARN(s)
N  #define GUI_DEBUG_WARN1(s,p0)
N  #define GUI_DEBUG_WARN2(s,p0,p1)
N  #define GUI_DEBUG_WARN3(s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_WARN_IF(exp,s)
N  #define GUI_DEBUG_WARN1_IF(exp,s,p0)
N  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Logging macros
N*
N********************************************************************
N*/
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ALL
X#if 1 >= 5
S  #define GUI_DEBUG_LOG(s)              GUI_Log(s)
S  #define GUI_DEBUG_LOG1(s,p0)          GUI_Warn1(s,p0)
S  #define GUI_DEBUG_LOG2(s,p0,p1)       GUI_Warn2(s,p0,p1)
S  #define GUI_DEBUG_LOG3(s,p0,p1,p2)    GUI_Warn3(s,p0,p1,p2)
S  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3) GUI_Warn4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_LOG_IF(exp,s)                   { if (exp) GUI_DEBUG_LOG(s); }
S  #define GUI_DEBUG_LOG1_IF(exp,s,p0)               { if (exp) GUI_DEBUG_LOG1(s,p0); }
S  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)            { if (exp) GUI_DEBUG_LOG2(s,p0,p1); }
S  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)         { if (exp) GUI_DEBUG_LOG3(s,p0,p1,p2); }
S  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)      { if (exp) GUI_DEBUG_LOG4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_LOG(s)
N  #define GUI_DEBUG_LOG1(s,p0)
N  #define GUI_DEBUG_LOG2(s,p0,p1)
N  #define GUI_DEBUG_LOG3(s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_LOG_IF(exp,s)
N  #define GUI_DEBUG_LOG1_IF(exp,s,p0)
N  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Asserts
N*
N********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 1 >= 3
S  #define GUI_DEBUG_ASSERT(exp)                     { if (!exp) GUI_DEBUG_ERROROUT(#exp); }
N#else
N  #define GUI_DEBUG_ASSERT(exp)
N#endif
N
N#endif /* LCD_H */
N
N
N
N
N/*************************** End of file ****************************/
L 24 "GUI\GUI_Private.h" 2
N#if GUI_WINSUPPORT
X#if (1)
N  #include "WM_GUI.h"
L 1 "GUI\WM_GUI.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N----------------------------------------------------------------------
NFile        : WM_GUI.h
NPurpose     : Windows manager include for low level GUI routines
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_GUI_H            /* Make sure we only include it once */
N#define WM_GUI_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
Nint       WM__InitIVRSearch(const GUI_RECT* pMaxRect);
Nint       WM__GetNextIVR   (void);
Nint       WM__GetOrgX_AA(void);
Nint       WM__GetOrgY_AA(void);
N
N#define WM_ITERATE_START(pRect)                   \
N  {                                               \
N    if (WM__InitIVRSearch(pRect))                 \
N      do {
X#define WM_ITERATE_START(pRect)                     {                                                   if (WM__InitIVRSearch(pRect))                       do {
N
N#define WM_ITERATE_END()                          \
N    } while (WM__GetNextIVR());                   \
N  }
X#define WM_ITERATE_END()                              } while (WM__GetNextIVR());                     }
N
N#define WM_ADDORGX(x)    x += GUI_Context.xOff
N#define WM_ADDORGY(y)    y += GUI_Context.yOff
N#define WM_ADDORG(x0,y0) WM_ADDORGX(x0); WM_ADDORGY(y0)
N#define WM_ADDORGX_AA(x)    x += WM__GetOrgX_AA()
N#define WM_ADDORGY_AA(y)    y += WM__GetOrgY_AA()
N#define WM_ADDORG_AA(x0,y0) WM_ADDORGX_AA(x0); WM_ADDORGY_AA(y0)
N#define WM_SUBORGX(x)    x -= GUI_Context.xOff
N#define WM_SUBORGY(y)    y -= GUI_Context.yOff
N#define WM_SUBORG(x0,y0) WM_SUBORGX(x0); WM_SUBORGY(y0)
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 26 "GUI\GUI_Private.h" 2
N#endif
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defaults for config switches
N*
N**********************************************************************
N
N  The config switches below do not affect the interface in GUI.h and
N  are therefor not required to be in GUI.h.
N*/
N
N/* Short address area.
N   For  most compilers, this is "near" or "__near"
N   We do not use this except for some CPUs which we know to always have some
N   near memory, because the GUI_Context ans some other data will be declared
N   to be in this short address (near) memory area as it has a major effect
N   on performance.
N   Please define in GUIConf.h (if you want to use it)
N*/
N#ifndef GUI_SADDR
N  #define GUI_SADDR
N#endif
N
N#ifndef GUI_DEFAULT_FONT
S  #define GUI_DEFAULT_FONT    &GUI_Font6x8
N#endif
N
N#ifndef GUI_DEFAULT_CURSOR
N  #define GUI_DEFAULT_CURSOR  &GUI_CursorArrowM
N#endif
N
N#ifndef GUI_DEFAULT_BKCOLOR
N  #define GUI_DEFAULT_BKCOLOR GUI_BLACK
N#endif
N
N#ifndef GUI_DEFAULT_COLOR
N  #define GUI_DEFAULT_COLOR   GUI_WHITE
N#endif
N
N#ifndef GUI_X_SIGNAL_EVENT
N  #define GUI_X_SIGNAL_EVENT()
N#endif
N
N#ifndef GUI_X_WAIT_EVENT
N  #define GUI_X_WAIT_EVENT() GUI_X_ExecIdle()
N#endif
N
N
N/*********************************************************************
N*
N*       Angles
N*
N**********************************************************************
N*/
N#define GUI_45DEG  512
N#define GUI_90DEG  (2*GUI_45DEG)
N#define GUI_180DEG (4*GUI_45DEG)
N#define GUI_360DEG (8*GUI_45DEG)
N
N
N/*********************************************************************
N*
N*       Locking checks
N*
N**********************************************************************
N*/
N#if defined (WIN32) && defined (_DEBUG) && GUI_OS
X#if 0L && 0L && (1)
S  #define GUI_ASSERT_LOCK()    GUITASK_AssertLock()
S  #define GUI_ASSERT_NO_LOCK() GUITASK_AssertNoLock()
S  void GUITASK_AssertLock(void);
S  void GUITASK_AssertNoLock(void);
N#else
N  #define GUI_ASSERT_LOCK()
N  #define GUI_ASSERT_NO_LOCK()
N#endif
N
N
N/*********************************************************************
N*
N*       Usage internals
N*
N**********************************************************************
N*/
Ntypedef GUI_HMEM GUI_USAGE_Handle;
Xtypedef signed long GUI_USAGE_Handle;
Ntypedef struct tsUSAGE_APIList tUSAGE_APIList;
Ntypedef struct GUI_Usage GUI_USAGE;
N#define GUI_USAGE_h GUI_USAGE_Handle
N
N
N
Ntypedef GUI_USAGE_h tUSAGE_CreateCompatible(GUI_USAGE* p);
Xtypedef GUI_USAGE_Handle tUSAGE_CreateCompatible(GUI_USAGE* p);
Ntypedef void        tUSAGE_AddPixel        (GUI_USAGE* p, int x, int y);
Ntypedef void        tUSAGE_AddHLine        (GUI_USAGE* p, int x0, int y0, int len);
Ntypedef void        tUSAGE_Clear           (GUI_USAGE* p);
Ntypedef void        tUSAGE_Delete          (GUI_USAGE_h h);
Xtypedef void        tUSAGE_Delete          (GUI_USAGE_Handle h);
Ntypedef int         tUSAGE_GetNextDirty    (GUI_USAGE* p, int *pxOff, int yOff);
N#define GUI_USAGE_H2P(h) ((GUI_USAGE*)GUI_ALLOC_h2p(h))
N
N
Nvoid GUI_USAGE_DecUseCnt(GUI_USAGE_Handle  hUsage);
N
NGUI_USAGE_Handle GUI_USAGE_BM_Create(int x0, int y0, int xsize, int ysize, int Flags);
Nvoid    GUI_USAGE_Select(GUI_USAGE_Handle hUsage);
Nvoid    GUI_USAGE_AddRect(GUI_USAGE*  pUsage, int x0, int y0, int xSize, int ySize);
N#define GUI_USAGE_AddPixel(p, x,y)            p->pAPI->pfAddPixel(p,x,y)
N#define GUI_USAGE_AddHLine(p,x,y,len)         p->pAPI->pfAddHLine(p,x,y,len)
N#define GUI_USAGE_Clear(p)                    p->pAPI->pfClear(p)
N#define GUI_USAGE_Delete(p)                   p->pAPI->pfDelete(p)
N#define GUI_USAGE_GetNextDirty(p,pxOff, yOff) p->pAPI->pfGetNextDirty(p,pxOff, yOff)
N
Nstruct tsUSAGE_APIList {
N  tUSAGE_AddPixel*                pfAddPixel;
N  tUSAGE_AddHLine*                pfAddHLine;
N  tUSAGE_Clear*                   pfClear;
N  tUSAGE_CreateCompatible*        pfCreateCompatible;
N  tUSAGE_Delete*                  pfDelete;
N  tUSAGE_GetNextDirty*            pfGetNextDirty;
N} ;
N
Nstruct GUI_Usage {
N  I16P x0, y0, XSize, YSize;
X  signed short x0, y0, XSize, YSize;
N  const tUSAGE_APIList *pAPI;
N  I16 UseCnt;
X  signed short UseCnt;
N};
N
N
N/*********************************************************************
N*
N*       GUI_MEMDEV
N*
N**********************************************************************
N*/
N#if GUI_SUPPORT_MEMDEV
X#if (1)
N
Ntypedef struct {
N  GUI_DEVICE * pDevice;
N  I16P                   x0, y0, XSize, YSize;
X  signed short                   x0, y0, XSize, YSize;
N  unsigned               BytesPerLine;
N  unsigned               BitsPerPixel;
N  GUI_HMEM               hUsage;
X  signed long               hUsage;
N} GUI_MEMDEV;
N
N#define      GUI_MEMDEV_H2P(h) ((GUI_MEMDEV*)GUI_ALLOC_h2p(h))
N
Nvoid         GUI_MEMDEV__CopyFromLCD (GUI_MEMDEV_Handle hMem);
Nvoid         GUI_MEMDEV__GetRect     (GUI_RECT* pRect);
Nunsigned     GUI_MEMDEV__Color2Index (LCD_COLOR Color);
NLCD_COLOR    GUI_MEMDEV__Index2Color (int Index);
Nunsigned int GUI_MEMDEV__GetIndexMask(void);
N
NGUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xSize, int ySize, int Flags,
N                                          const GUI_DEVICE_API     * pDeviceAPI,
N                                          const LCD_API_COLOR_CONV * pColorConvAPI);
N
Nvoid * GUI_MEMDEV__XY2PTR             (int x,int y);
Nvoid * GUI_MEMDEV__XY2PTREx           (GUI_MEMDEV * pDev, int x,int y);
Nvoid   GUI_MEMDEV__WriteToActiveAt    (GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid   GUI_MEMDEV__WriteToActiveOpaque(GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid   GUI_MEMDEV__WriteToActiveAlpha (GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid   GUI_MEMDEV__ReadLine           (int x0, int y, int x1, LCD_PIXELINDEX * pBuffer);
Xvoid   GUI_MEMDEV__ReadLine           (int x0, int y, int x1, unsigned long * pBuffer);
N
Nunsigned GUI__AlphaSuppressMixing(int OnOff);
N
Nvoid     GUI_MEMDEV__SuppressMixing   (unsigned OnOff);
Nunsigned GUI_MEMDEV__GetSuppressMixing(void);
N
N#define GUI_POS_AUTO -4095   /* Position value for auto-pos */
N
N#endif
N
N
N/*********************************************************************
N*
N*       LCD_HL_ level defines
N*
N**********************************************************************
N*/
N#define LCD_HL_DrawHLine             GUI_Context.pLCD_HL->pfDrawHLine
N#define LCD_HL_DrawPixel             GUI_Context.pLCD_HL->pfDrawPixel
N
N
N/*********************************************************************
N*
N*       Helper functions
N*
N**********************************************************************
N*/
N#define GUI_ZEROINIT(Obj) GUI_MEMSET(Obj, 0, sizeof(Obj))
Nint  GUI_cos(int angle);
Nint  GUI_sin(int angle);
Nextern const U32 GUI_Pow10[10];
Xextern const unsigned long GUI_Pow10[10];
N
N/* Anti-aliased drawing */
Nint  GUI_AA_Init       (int x0, int x1);
Nint  GUI_AA_Init_HiRes (int x0, int x1);
Nvoid GUI_AA_Exit       (void);
NI16  GUI_AA_HiRes2Pixel(int HiRes);
Xsigned short  GUI_AA_HiRes2Pixel(int HiRes);
N
Nvoid GL_FillCircleAA_HiRes(int x0, int y0, int r);
N
Nvoid GUI_AA__DrawCharAA2(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA2(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
Nvoid GUI_AA__DrawCharAA4(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA4(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
N
N/* System independent font routines */
Nint        GUI_SIF__GetCharDistX(U16P c);
Xint        GUI_SIF__GetCharDistX(unsigned short c);
Nvoid       GUI_SIF__GetFontInfo        (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi);
Xvoid       GUI_SIF__GetFontInfo        (const GUI_FONT  * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont           (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xchar       GUI_SIF__IsInFont           (const GUI_FONT  * pFont, unsigned short c);
Nconst U8 * GUI_SIF__GetpCharInfo       (const GUI_FONT GUI_UNI_PTR * pFont, U16P c, unsigned SizeOfCharInfo);
Xconst unsigned char * GUI_SIF__GetpCharInfo       (const GUI_FONT  * pFont, unsigned short c, unsigned SizeOfCharInfo);
Nint        GUI_SIF__GetNumCharAreas    (const GUI_FONT GUI_UNI_PTR * pFont);
Xint        GUI_SIF__GetNumCharAreas    (const GUI_FONT  * pFont);
Nint        GUI_SIF__GetCharDistX_ExtFrm(U16P c);
Xint        GUI_SIF__GetCharDistX_ExtFrm(unsigned short c);
Nvoid       GUI_SIF__GetFontInfo_ExtFrm (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi);
Xvoid       GUI_SIF__GetFontInfo_ExtFrm (const GUI_FONT  * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont_ExtFrm    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xchar       GUI_SIF__IsInFont_ExtFrm    (const GUI_FONT  * pFont, unsigned short c);
Nint        GUI_SIF__GetCharInfo_ExtFrm (U16P c, GUI_CHARINFO_EXT * pInfo);
Xint        GUI_SIF__GetCharInfo_ExtFrm (unsigned short c, GUI_CHARINFO_EXT * pInfo);
Nvoid       GUI_SIF__ClearLine_ExtFrm   (const char GUI_UNI_PTR * s, int Len);
Xvoid       GUI_SIF__ClearLine_ExtFrm   (const char  * s, int Len);
N
N/* External binary font routines */
Nint        GUI_XBF__GetOff       (const GUI_XBF_DATA * pXBF_Data, unsigned c, U32 * pOff);
Xint        GUI_XBF__GetOff       (const GUI_XBF_DATA * pXBF_Data, unsigned c, unsigned long * pOff);
Nint        GUI_XBF__GetOffAndSize(const GUI_XBF_DATA * pXBF_Data, unsigned c, U32 * pOff, U16 * pSize);
Xint        GUI_XBF__GetOffAndSize(const GUI_XBF_DATA * pXBF_Data, unsigned c, unsigned long * pOff, unsigned short * pSize);
Nint        GUI_XBF__GetCharDistX (U16P c);
Xint        GUI_XBF__GetCharDistX (unsigned short c);
Nvoid       GUI_XBF__GetFontInfo  (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pInfo);
Xvoid       GUI_XBF__GetFontInfo  (const GUI_FONT  * pFont, GUI_FONTINFO * pInfo);
Nchar       GUI_XBF__IsInFont     (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xchar       GUI_XBF__IsInFont     (const GUI_FONT  * pFont, unsigned short c);
Nint        GUI_XBF__GetCharInfo  (U16P c, GUI_CHARINFO_EXT * pInfo);
Xint        GUI_XBF__GetCharInfo  (unsigned short c, GUI_CHARINFO_EXT * pInfo);
Nvoid       GUI_XBF__ClearLine    (const char GUI_UNI_PTR * s, int Len);
Xvoid       GUI_XBF__ClearLine    (const char  * s, int Len);
N
N/* Conversion routines */
Nvoid GUI_AddHex     (U32 v, U8 Len, char ** ps);
Xvoid GUI_AddHex     (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI_AddBin     (U32 v, U8 Len, char ** ps);
Xvoid GUI_AddBin     (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI_AddDecMin  (I32 v, char ** ps);
Xvoid GUI_AddDecMin  (signed long v, char ** ps);
Nvoid GUI_AddDec     (I32 v, U8 Len, char ** ps);
Xvoid GUI_AddDec     (signed long v, unsigned char Len, char ** ps);
Nvoid GUI_AddDecShift(I32 v, U8 Len, U8 Shift, char ** ps);
Xvoid GUI_AddDecShift(signed long v, unsigned char Len, unsigned char Shift, char ** ps);
Nlong GUI_AddSign    (long v, char ** ps);
Nint  GUI_Long2Len   (I32 v);
Xint  GUI_Long2Len   (signed long v);
N
N#define GUI_UC__GetCharSize(sText)  GUI_Context.pUC_API->pfGetCharSize(sText)
N#define GUI_UC__GetCharCode(sText)  GUI_Context.pUC_API->pfGetCharCode(sText)
N
Nint   GUI_UC__CalcSizeOfChar   (U16 Char);
Xint   GUI_UC__CalcSizeOfChar   (unsigned short Char);
NU16   GUI_UC__GetCharCodeInc   (const char GUI_UNI_PTR ** ps);
Xunsigned short   GUI_UC__GetCharCodeInc   (const char  ** ps);
Nint   GUI_UC__NumChars2NumBytes(const char GUI_UNI_PTR * s, int NumChars);
Xint   GUI_UC__NumChars2NumBytes(const char  * s, int NumChars);
Nint   GUI_UC__NumBytes2NumChars(const char GUI_UNI_PTR * s, int NumBytes);
Xint   GUI_UC__NumBytes2NumChars(const char  * s, int NumBytes);
N
Nint  GUI__GetLineNumChars  (const char GUI_UNI_PTR * s, int MaxNumChars);
Xint  GUI__GetLineNumChars  (const char  * s, int MaxNumChars);
Nint  GUI__GetNumChars      (const char GUI_UNI_PTR * s);
Xint  GUI__GetNumChars      (const char  * s);
Nint  GUI__GetOverlap       (U16 Char);
Xint  GUI__GetOverlap       (unsigned short Char);
Nint  GUI__GetLineDistX     (const char GUI_UNI_PTR * s, int Len);
Xint  GUI__GetLineDistX     (const char  * s, int Len);
Nint  GUI__GetFontSizeY     (void);
Nint  GUI__HandleEOLine     (const char GUI_UNI_PTR ** ps);
Xint  GUI__HandleEOLine     (const char  ** ps);
Nvoid GUI__DispLine         (const char GUI_UNI_PTR * s, int Len, const GUI_RECT* pr);
Xvoid GUI__DispLine         (const char  * s, int Len, const GUI_RECT* pr);
Nvoid GUI__AddSpaceHex      (U32 v, U8 Len, char ** ps);
Xvoid GUI__AddSpaceHex      (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI__CalcTextRect     (const char GUI_UNI_PTR * pText, const GUI_RECT* pTextRectIn, GUI_RECT* pTextRectOut, int TextAlign);
Xvoid GUI__CalcTextRect     (const char  * pText, const GUI_RECT* pTextRectIn, GUI_RECT* pTextRectOut, int TextAlign);
N
Nint  GUI__WrapGetNumCharsDisp       (const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode);
Xint  GUI__WrapGetNumCharsDisp       (const char  * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumCharsToNextLine (const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode);
Xint  GUI__WrapGetNumCharsToNextLine (const char  * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumBytesToNextLine (const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode);
Xint  GUI__WrapGetNumBytesToNextLine (const char  * pText, int xSize, GUI_WRAPMODE WrapMode);
Nvoid GUI__memset    (U8 * p, U8 Fill, int NumBytes);
Xvoid GUI__memset    (unsigned char * p, unsigned char Fill, int NumBytes);
Nvoid GUI__memset16  (U16* p, U16 Fill, int NumWords);
Xvoid GUI__memset16  (unsigned short* p, unsigned short Fill, int NumWords);
Nint  GUI__strlen    (const char GUI_UNI_PTR * s);
Xint  GUI__strlen    (const char  * s);
Nint  GUI__strcmp    (const char GUI_UNI_PTR * s0, const char GUI_UNI_PTR * s1);
Xint  GUI__strcmp    (const char  * s0, const char  * s1);
Nint  GUI__strcmp_hp (GUI_HMEM hs0, const char GUI_UNI_PTR * s1);
Xint  GUI__strcmp_hp (signed long hs0, const char  * s1);
N
N/* Get cursor position */
Nint  GUI__GetCursorPosX     (const char GUI_UNI_PTR * s, int Index, int MaxNumChars);
Xint  GUI__GetCursorPosX     (const char  * s, int Index, int MaxNumChars);
Nint  GUI__GetCursorPosChar  (const char GUI_UNI_PTR * s, int x, int NumCharsToNextLine);
Xint  GUI__GetCursorPosChar  (const char  * s, int x, int NumCharsToNextLine);
NU16  GUI__GetCursorCharacter(const char GUI_UNI_PTR * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__GetCursorCharacter(const char  * s, int Index, int MaxNumChars, int * pIsRTL);
N
N/* Arabic support (tbd) */
NU16  GUI__GetPresentationForm     (U16 Char, U16 Next, U16 Prev, int * pIgnoreNext, const char GUI_UNI_PTR * s);
Xunsigned short  GUI__GetPresentationForm     (unsigned short Char, unsigned short Next, unsigned short Prev, int * pIgnoreNext, const char  * s);
Nint  GUI__IsArabicCharacter       (U16 c);
Xint  GUI__IsArabicCharacter       (unsigned short c);
N
N/* BiDi support */
Nint  GUI__BIDI_Log2Vis         (const char GUI_UNI_PTR * s, int NumChars, char * pBuffer, int BufferSize);
Xint  GUI__BIDI_Log2Vis         (const char  * s, int NumChars, char * pBuffer, int BufferSize);
Nint  GUI__BIDI_GetCursorPosX   (const char GUI_UNI_PTR * s, int NumChars, int Index);
Xint  GUI__BIDI_GetCursorPosX   (const char  * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCursorPosChar(const char GUI_UNI_PTR * s, int NumChars, int x);
Xint  GUI__BIDI_GetCursorPosChar(const char  * s, int NumChars, int x);
NU16  GUI__BIDI_GetLogChar      (const char GUI_UNI_PTR * s, int NumChars, int Index);
Xunsigned short  GUI__BIDI_GetLogChar      (const char  * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCharDir      (const char GUI_UNI_PTR * s, int NumChars, int Index);
Xint  GUI__BIDI_GetCharDir      (const char  * s, int NumChars, int Index);
Nint  GUI__BIDI_IsNSM           (U16 Char);
Xint  GUI__BIDI_IsNSM           (unsigned short Char);
N
N/* Proportional  font support */
Nconst GUI_FONT_PROP * GUIPROP__FindChar(const GUI_FONT_PROP * pProp, U16P c);
Xconst GUI_FONT_PROP * GUIPROP__FindChar(const GUI_FONT_PROP * pProp, unsigned short c);
N
N/* Extended proportional font support */
Nconst GUI_FONT_PROP_EXT GUI_UNI_PTR * GUIPROP_EXT__FindChar(const GUI_FONT_PROP_EXT GUI_UNI_PTR* pPropExt, U16P c);
Xconst GUI_FONT_PROP_EXT  * GUIPROP_EXT__FindChar(const GUI_FONT_PROP_EXT * pPropExt, unsigned short c);
Nvoid  GUIPROP_EXT__DispLine      (const char GUI_UNI_PTR * s, int Len);
Xvoid  GUIPROP_EXT__DispLine      (const char  * s, int Len);
Nvoid  GUIPROP_EXT__ClearLine     (const char GUI_UNI_PTR * s, int Len);
Xvoid  GUIPROP_EXT__ClearLine     (const char  * s, int Len);
Nvoid  GUIPROP_EXT__SetfpClearLine(void (* fpClearLine)(const char GUI_UNI_PTR * s, int Len));
Xvoid  GUIPROP_EXT__SetfpClearLine(void (* fpClearLine)(const char  * s, int Len));
N
N/* Reading data routines */
NU16 GUI__Read16(const U8 ** ppData);
Xunsigned short GUI__Read16(const unsigned char ** ppData);
NU32 GUI__Read32(const U8 ** ppData);
Xunsigned long GUI__Read32(const unsigned char ** ppData);
N
N/* Virtual screen support */
Nvoid GUI__GetOrg(int * px, int * py);
Nvoid GUI__SetOrgHook(void(* pfHook)(int x, int y));
N
N/* Timer support */
Nint              GUI_TIMER__IsActive    (void);
NGUI_TIMER_TIME   GUI_TIMER__GetPeriod   (void);
Xint   GUI_TIMER__GetPeriod   (void);
NGUI_TIMER_HANDLE GUI_TIMER__GetNextTimer(GUI_TIMER_HANDLE hTimer, U32 * pContext);
XGUI_TIMER_HANDLE GUI_TIMER__GetNextTimer(GUI_TIMER_HANDLE hTimer, unsigned long * pContext);
N
N/* Get function pointers for color conversion */
NtLCDDEV_Index2Color * GUI_GetpfIndex2ColorEx(int LayerIndex);
NtLCDDEV_Color2Index * GUI_GetpfColor2IndexEx(int LayerIndex);
N
NLCD_PIXELINDEX*  LCD_GetpPalConvTable        (const LCD_LOGPALETTE GUI_UNI_PTR *  pLogPal);
Xunsigned long*  LCD_GetpPalConvTable        (const LCD_LOGPALETTE  *  pLogPal);
NLCD_PIXELINDEX*  LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE GUI_UNI_PTR *  pLogPal);
Xunsigned long*  LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE  *  pLogPal);
N
N/* Streamed bitmaps */
N#define GUI_STREAM_FORMAT_INDEXED 100
N#define GUI_STREAM_FORMAT_RLE4      6
N#define GUI_STREAM_FORMAT_RLE8      7
N#define GUI_STREAM_FORMAT_565       8
N#define GUI_STREAM_FORMAT_M565      9
N#define GUI_STREAM_FORMAT_555      10
N#define GUI_STREAM_FORMAT_M555     11
N#define GUI_STREAM_FORMAT_RLE16    12
N#define GUI_STREAM_FORMAT_RLEM16   13
N#define GUI_STREAM_FORMAT_8888     16
N#define GUI_STREAM_FORMAT_24       17
N
Nvoid GUI__ReadHeaderFromStream  (GUI_BITMAP_STREAM * pBitmapHeader, const U8 * pData);
Xvoid GUI__ReadHeaderFromStream  (GUI_BITMAP_STREAM * pBitmapHeader, const unsigned char * pData);
Nvoid GUI__CreateBitmapFromStream(GUI_BITMAP_STREAM * pBitmapHeader, const U8 * pData, GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const GUI_BITMAP_METHODS * pMethods);
Xvoid GUI__CreateBitmapFromStream(GUI_BITMAP_STREAM * pBitmapHeader, const unsigned char * pData, GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const GUI_BITMAP_METHODS * pMethods);
N
N/*********************************************************************
N*
N*       2d - GL
N*
N**********************************************************************
N*/
Nvoid GL_DispChar         (U16 c);
Xvoid GL_DispChar         (unsigned short c);
Nvoid GL_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GL_DrawBitmap       (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0);
Xvoid GL_DrawBitmap       (const GUI_BITMAP  * pBM, int x0, int y0);
Nvoid GL_DrawCircle       (int x0, int y0, int r);
Nvoid GL_DrawEllipse      (int x0, int y0, int rx, int ry);
Nvoid GL_DrawHLine        (int y0, int x0, int x1);
Nvoid GL_DrawPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GL_DrawPoint        (int x, int y);
Nvoid GL_DrawLine1        (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLine1Ex      (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_DrawLineRel      (int dx, int dy);
Nvoid GL_DrawLineTo       (int x, int y);
Nvoid GL_DrawLineToEx     (int x, int y, unsigned * pPixelCnt);
Nvoid GL_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLineEx       (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_MoveTo           (int x, int y);
Nvoid GL_FillCircle       (int x0, int y0, int r);
Nvoid GL_FillCircleAA     (int x0, int y0, int r);
Nvoid GL_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GL_FillPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GL_SetDefault       (void);
N
N
N/*********************************************************************
N*
N*       Callback pointers for dynamic linkage
N*
N**********************************************************************
NDynamic linkage pointers reduces configuration hassles.
N*/
Ntypedef int  GUI_tfTimer(void);
Ntypedef int  WM_tfHandlePID(void);
N
N
N/*********************************************************************
N*
N*       Cursors
N*
N**********************************************************************
N*/
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowS[45];
Xextern const unsigned char  GUI_Pixels_ArrowS[45];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowM[60];
Xextern const unsigned char  GUI_Pixels_ArrowM[60];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowL[150];
Xextern const unsigned char  GUI_Pixels_ArrowL[150];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossS[33];
Xextern const unsigned char  GUI_Pixels_CrossS[33];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossM[126];
Xextern const unsigned char  GUI_Pixels_CrossM[126];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossL[248];
Xextern const unsigned char  GUI_Pixels_CrossL[248];
Nextern GUI_CONST_STORAGE unsigned char  GUI_PixelsHeaderM[5 * 17];
Xextern const unsigned char  GUI_PixelsHeaderM[5 * 17];
N
Nextern GUI_CONST_STORAGE GUI_LOGPALETTE GUI_CursorPal;
Xextern const GUI_LOGPALETTE GUI_CursorPal;
Nextern GUI_CONST_STORAGE GUI_LOGPALETTE GUI_CursorPalI;
Xextern const GUI_LOGPALETTE GUI_CursorPalI;
N
N
N/*********************************************************************
N*
N*       Text rotation
N*
N**********************************************************************
N*/
Nextern GUI_RECT  GUI_RectDispString; /* Used by LCD_Rotate...() and GUI_DispStringInRect() */
N
N/*********************************************************************
N*
N*       Flag for setting transparency for 'EXT' fonts
N*
N**********************************************************************
N*/
Nextern U8 GUI__CharHasTrans;
Xextern unsigned char GUI__CharHasTrans;
N
N/*********************************************************************
N*
N*       Multitasking support
N*
N**********************************************************************
N*/
Nextern int GUITASK__EntranceCnt;
N
N/*********************************************************************
N*
N*       Bitmap related functions
N*
N**********************************************************************
N*/
N
Nint       GUI_GetBitmapPixelIndex(const GUI_BITMAP GUI_UNI_PTR * pBMP, unsigned x, unsigned y);
Xint       GUI_GetBitmapPixelIndex(const GUI_BITMAP  * pBMP, unsigned x, unsigned y);
NGUI_COLOR GUI_GetBitmapPixelColor(const GUI_BITMAP GUI_UNI_PTR * pBMP, unsigned x, unsigned y);
XGUI_COLOR GUI_GetBitmapPixelColor(const GUI_BITMAP  * pBMP, unsigned x, unsigned y);
Nint       GUI_GetBitmapPixelIndexEx(int BitsPerPixel, int BytesPerLine, const U8 GUI_UNI_PTR * pData, unsigned x, unsigned y);
Xint       GUI_GetBitmapPixelIndexEx(int BitsPerPixel, int BytesPerLine, const unsigned char  * pData, unsigned x, unsigned y);
N
Nvoid      GUI__DrawBitmap16bpp(int x0, int y0, int xsize, int ysize, const U8 GUI_UNI_PTR * pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Xvoid      GUI__DrawBitmap16bpp(int x0, int y0, int xsize, int ysize, const unsigned char  * pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Nvoid      GUI__SetPixelAlpha  (int x, int y, U8 Alpha, LCD_COLOR Color);
Xvoid      GUI__SetPixelAlpha  (int x, int y, unsigned char Alpha, LCD_COLOR Color);
NLCD_COLOR GUI__MixColors      (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR GUI__MixColors      (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
N
Nextern const GUI_UC_ENC_APILIST GUI_UC_None;
N
N/*********************************************************************
N*
N*       LCDDEV_L0_xxx
N*
N**********************************************************************
N*/
N#define LCDDEV_L0_Color2Index         GUI_Context.apDevice[GUI_Context.SelLayer]->pColorConvAPI->pfColor2Index
N#define LCDDEV_L0_Index2Color         GUI_Context.apDevice[GUI_Context.SelLayer]->pColorConvAPI->pfIndex2Color
N
N#define LCDDEV_L0_DrawBitmap          GUI_Context.apDevice[GUI_Context.SelLayer]->pDeviceAPI->pfDrawBitmap
N#define LCDDEV_L0_DrawHLine           GUI_Context.apDevice[GUI_Context.SelLayer]->pDeviceAPI->pfDrawHLine
N#define LCDDEV_L0_DrawVLine           GUI_Context.apDevice[GUI_Context.SelLayer]->pDeviceAPI->pfDrawVLine
N#define LCDDEV_L0_DrawPixel           GUI_Context.apDevice[GUI_Context.SelLayer]->pDeviceAPI->pfDrawPixel
N#define LCDDEV_L0_FillRect            GUI_Context.apDevice[GUI_Context.SelLayer]->pDeviceAPI->pfFillRect
N#define LCDDEV_L0_GetPixel            GUI_Context.apDevice[GUI_Context.SelLayer]->pDeviceAPI->pfGetPixel
N#define LCDDEV_L0_GetRect             GUI_Context.apDevice[GUI_Context.SelLayer]->pDeviceAPI->pfGetRect
N#define LCDDEV_L0_GetPixelIndex       GUI_Context.apDevice[GUI_Context.SelLayer]->pDeviceAPI->pfGetPixelIndex
N#define LCDDEV_L0_SetPixelIndex       GUI_Context.apDevice[GUI_Context.SelLayer]->pDeviceAPI->pfSetPixelIndex
N#define LCDDEV_L0_XorPixel            GUI_Context.apDevice[GUI_Context.SelLayer]->pDeviceAPI->pfXorPixel
N#define LCDDEV_L0_GetDevFunc          GUI_Context.apDevice[GUI_Context.SelLayer]->pDeviceAPI->pfGetDevFunc
N
Nvoid LCD_ReadRect  (int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid LCD_ReadRect  (int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
Nvoid GUI_ReadRect  (int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid GUI_ReadRect  (int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
Nvoid GUI_ReadRectEx(int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid GUI_ReadRectEx(int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
N
N/*********************************************************************
N*
N*       Internal color management
N*
N**********************************************************************
N*/
Ntypedef struct {
N  void         (* pfSetColor)   (LCD_COLOR Index);
N  void         (* pfSetBkColor) (LCD_COLOR Index);
N  LCD_DRAWMODE (* pfSetDrawMode)(LCD_DRAWMODE dm);
N} LCD_SET_COLOR_API;
N
Nextern const LCD_SET_COLOR_API * LCD__pSetColorAPI;
N
Nextern LCD_PIXELINDEX * LCD_pBkColorIndex;
Xextern unsigned long * LCD_pBkColorIndex;
Nextern LCD_PIXELINDEX * LCD_pColorIndex;
Xextern unsigned long * LCD_pColorIndex;
N
N#define LCD__SetBkColorIndex(Index) (*LCD_pBkColorIndex = Index)
N#define LCD__SetColorIndex(Index)   (*LCD_pColorIndex   = Index)
N#define LCD__GetBkColorIndex()      (*LCD_pBkColorIndex)
N#define LCD__GetColorIndex()        (*LCD_pColorIndex)
N
N/* The following 2 defines are only required for compatibility to older versions of the TTF library */
N#define LCD_BKCOLORINDEX (*LCD_pBkColorIndex)
N#define LCD_COLORINDEX   (*LCD_pColorIndex)
N
N/*********************************************************************
N*
N*       EXTERNs for GL_CORE
N*
N**********************************************************************
N*/
N#ifdef  GL_CORE_C
S  #define GUI_EXTERN
N#else
N  #define GUI_EXTERN extern
N#endif
N
NGUI_EXTERN GUI_SADDR GUI_CONTEXT        GUI_Context;        /* Thread wide globals */
Xextern  GUI_CONTEXT        GUI_Context;         
NGUI_EXTERN GUI_SADDR char               GUI_DecChar;
Xextern  char               GUI_DecChar;
NGUI_EXTERN           GUI_tfTimer*       GUI_pfTimerExec;
Xextern           GUI_tfTimer*       GUI_pfTimerExec;
NGUI_EXTERN           WM_tfHandlePID*    WM_pfHandlePID;
Xextern           WM_tfHandlePID*    WM_pfHandlePID;
NGUI_EXTERN      void (*GUI_pfDispCharStyle)(U16 Char);
Xextern      void (*GUI_pfDispCharStyle)(unsigned short Char);
N
N#if GUI_SUPPORT_ROTATION
X#if 1
N  GUI_EXTERN const     tLCD_APIList *     GUI_pLCD_APIList;   /* Used for rotating text */
X  extern const     tLCD_APIList *     GUI_pLCD_APIList;    
N#endif
N
NGUI_EXTERN I16 GUI_OrgX, GUI_OrgY;
Xextern signed short GUI_OrgX, GUI_OrgY;
N
N#undef GUI_EXTERN
N
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif 
N
N#endif /* GUI_PRIVATE_H */
N
N/*************************** End of file ****************************/
L 26 "GUI\GUI_VNC.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define GUI_VNC_NO_ERROR            0
N#define GUI_VNC_ERROR_MISC          1
N#define GUI_VNC_ERROR_WRONGFORMAT   2
N
N#define GUI_DES_ENCRYPT 0
N#define GUI_DES_DECRYPT 1
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef int (*GUI_tSend)   (const U8 * pData, int len, void* pConnectInfo);
Xtypedef int (*GUI_tSend)   (const unsigned char * pData, int len, void* pConnectInfo);
Ntypedef int (*GUI_tReceive)(      U8 * pData, int len, void* pConnectInfo);
Xtypedef int (*GUI_tReceive)(      unsigned char * pData, int len, void* pConnectInfo);
N
Ntypedef struct GUI_VNC_CONTEXT {
N  GUI_DEVICE * pDevice;
N  struct GUI_VNC_CONTEXT * pNext;
N  int LayerIndex;
N  int BytesPerPixel;
N  int BitsPerPixel;  // Note, that from within the VNC server the function LCD_GetBitsBerPixel() can not be used because the VNC server runs in a separate thread and the device chain can change during the function call
N  //
N  // Connection related data
N  //
N  GUI_tSend    pfSend;
N  GUI_tReceive pfReceive;
N  void       * pConnectInfo;
N  U16          ServerIndex;
X  unsigned short          ServerIndex;
N  //
N  // Display related info
N  //
N  int x0Dirty, y0Dirty, x1Dirty, y1Dirty;
N  int XSize, YSize;
N  int xOrg, yOrg, xOrgNew, yOrgNew;
N  int OrgLock;
N  //
N  // Status
N  //
N  char ClientSupportsHextile;
N  char IsBigEndian;
N} GUI_VNC_CONTEXT;
N
Ntypedef struct {
N  void (* pfGetChallenge)(U8 * pChallenge);
X  void (* pfGetChallenge)(unsigned char * pChallenge);
N  void (* pfGetResponse )(U8 * pResponse );
X  void (* pfGetResponse )(unsigned char * pResponse );
N} GUI_VNC_AUTHENTICATION;
N
N/*********************************************************************
N*
N*       Private Functions
N*
N**********************************************************************
N*/
Nvoid GUI_VNC_SetDESKey(U8 * pKey, int Mode);
Xvoid GUI_VNC_SetDESKey(unsigned char * pKey, int Mode);
Nvoid GUI_VNC_DoDES    (U8 * pInblock, U8 * pOutblock);
Xvoid GUI_VNC_DoDES    (unsigned char * pInblock, unsigned char * pOutblock);
N
N/*********************************************************************
N*
N*       Public Functions
N*
N**********************************************************************
N*/
Nvoid GUI_VNC_AttachToLayer      (GUI_VNC_CONTEXT * pContext, int LayerIndex);
Nvoid GUI_VNC_EnableKeyboardInput(int OnOff);
Nint  GUI_VNC_GetNumConnections  (void);
Nint  GUI_VNC_Process            (GUI_VNC_CONTEXT * pContext, GUI_tSend pfSend, GUI_tReceive pfReceive, void * pConnectInfo);
Nvoid GUI_VNC_RingBell           (void);
Nvoid GUI_VNC_SetAuthentication  (GUI_VNC_AUTHENTICATION * pAuthentication);
Nvoid GUI_VNC_SetPassword        (U8 * sPassword);
Xvoid GUI_VNC_SetPassword        (unsigned char * sPassword);
Nvoid GUI_VNC_SetProgName        (const char * sProgName);
Nvoid GUI_VNC_SetSize            (unsigned xSize, unsigned ySize);
N
N/****  External routine to link the server to the system ... USER defined ! ****/
Nint  GUI_VNC_X_StartServer(int LayerIndex, int ServerIndex);
Nvoid GUI_VNC_X_getpeername(U32 * Addr);
Xvoid GUI_VNC_X_getpeername(unsigned long * Addr);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 27 "GUI\GUI_VNC_X_StartServer.c" 2
N#include "TaskPrio.h"
L 1 "Inc\TaskPrio.h" 1
N/*********************************************************************
N*                SEGGER MICROCONTROLLER GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N--------  END-OF-HEADER  ---------------------------------------------
N*/
N
N#ifndef TASKPRIO_H                     /* Avoid multiple inclusion */
N#define TASKPRIO_H
N
N/*********************************************************************
N*
N*       Task priorities
N*/
Nenum {
N  TASKPRIO_TOUCH = 100,   // 100
N  TASKPRIO_WINDOW,        // 101
N  TASKPRIO_FTPSCHILD,     // 102
N  TASKPRIO_FTPSPARENT,    // 103
N  TASKPRIO_FTPS,          // 104
N  TASKPRIO_WEBS,          // 105
N  TASKPRIO_WEBSCHILD,     // 106
N  TASKPRIO_WEBSPARENT,    // 107
N  TASKPRIO_USB,           // 108
N  TASKPRIO_MAINTASK,      // 109
N  TASKPRIO_VNC,           // 110
N  TASKPRIO_USBH_MAIN,     // 111
N  TASKPRIO_USBH_ISR,      // 112
N  TASKPRIO_IPMAIN,        // 113, should be higher than prio of server applications
N  TASKPRIO_IPRX,          // 114, needs to have highest prio except for windows that need to be shown immediately
N  TASKPRIO_TRIALWINDOW    // 115, highest prio, needs to be shown immediately
N};
N
N
N#endif                                  /* Avoid multiple inclusion */
N
N/*****  EOF  ********************************************************/
L 28 "GUI\GUI_VNC_X_StartServer.c" 2
N
N/*********************************************************************
N*
N*       Static data
N*
N**********************************************************************
N*/
Nstatic GUI_VNC_CONTEXT    _Context;
Nstatic struct sockaddr_in _Addr;
N
N//
N// embOS Stack area of the server
N//
Nstatic OS_STACKPTR int _StackVNCServer[1000];
Xstatic  int _StackVNCServer[1000];
N
N//
N// embOS Task-control-block of the server
N//
Nstatic OS_TASK         _VNCServer_TCB;
N
N/*********************************************************************
N*
N*       Static functions
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       _Send
N*
N* Function description
N*   This function is called indirectly by the server; it's address is passed to the actual
N*   server code as function pointer. It is needed because the server is independent
N*   of the TCP/IP stack implementation, so details for the TCP/IP stack can be placed here.
N*/
Nstatic int _Send(const U8 * buf, int len, void * pConnectionInfo) {
Xstatic int _Send(const unsigned char * buf, int len, void * pConnectionInfo) {
N  int r;
N
N  r = send((long)pConnectionInfo, (const char *)buf, len, 0);
X  r = t_send((long)pConnectionInfo, (const char *)buf, len, 0);
N  return r;
N}
N
N/*********************************************************************
N*
N*       _Recv
N*
N* Function description
N*   This function is called indirectly by the server; it's address is passed to the actual
N*   server code as function pointer. It is needed because the server is independent
N*   of the TCP/IP stack implementation, so details for the TCP/IP stack can be placed here.
N*/
Nstatic int _Recv(U8 * buf, int len, void * pConnectionInfo) {
Xstatic int _Recv(unsigned char * buf, int len, void * pConnectionInfo) {
N  return recv((long)pConnectionInfo, (char *)buf, len, 0);
X  return t_recv((long)pConnectionInfo, (char *)buf, len, 0);
N}
N
N/*********************************************************************
N*
N*       _ListenAtTcpAddr
N*
N* Starts listening at the given TCP port.
N*/
Nstatic int _ListenAtTcpAddr(U16 Port) {
Xstatic int _ListenAtTcpAddr(unsigned short Port) {
N  int sock;
N  struct sockaddr_in addr;
N
N  sock = socket(AF_INET, SOCK_STREAM, 0);
X  sock = t_socket(2,1,0);
N  memset(&addr, 0, sizeof(addr));
N  addr.sin_family      = AF_INET;
X  addr.sin_family      = 2;
N  addr.sin_port        = htons(Port);
X  addr.sin_port        = ((unsigned short)((unsigned short)(Port) >> 8) | (unsigned short)((unsigned short)(Port) << 8));
N  addr.sin_addr.s_addr = INADDR_ANY;
X  addr.sin_addr.s_addr = 0L;
N  bind(sock, (struct sockaddr *)&addr, sizeof(addr));
X  t_bind(sock,(struct sockaddr *)&addr,sizeof(addr));
N  listen(sock, 1);
X  t_listen(sock,1);
N  return sock;
N}
N
N/*********************************************************************
N*
N*       _ServerTask
N*
N* Function description
N*   This routine is the actual server task.
N*   It executes some one-time init code, then runs in an ednless loop.
N*   It therefor does not terminate.
N*   In the endless loop it
N*     - Waits for a conection from a client
N*     - Runs the server code
N*     - Closes the connection
N*/
Nstatic void _ServerTask(void) {
N  int s, Sock, AddrLen;
N  U16 Port;
X  unsigned short Port;
N
N  //
N  // Prepare socket (one time setup)
N  //
N  Port = 5900 + _Context.ServerIndex; // Default port for VNC is is 590x, where x is the 0-based layer index
N  //
N  // Loop until we get a socket into listening state
N  //
N  do {
N    s = _ListenAtTcpAddr(Port);
N    if (s != -1) {
N      break;
N    }
N    OS_Delay(100); // Try again
N  } while (1);
N  //
N  // Loop once per client and create a thread for the actual server
N  //
N  while (1) {
N    //
N    // Wait for an incoming connection
N    //
N    AddrLen = sizeof(_Addr);
N    if ((Sock = accept(s, (struct sockaddr*)&_Addr, &AddrLen)) == SOCKET_ERROR) {
X    if ((Sock = t_accept(s, (struct sockaddr*)&_Addr, &AddrLen)) == -1) {
N      continue; // Error
N    }
N    //
N    // Run the actual server
N    //
N    GUI_VNC_Process(&_Context, _Send, _Recv, (void *)Sock);
N    //
N    // Close the connection
N    //
N    closesocket(Sock);
X    t_socketclose(Sock);
N    memset(&_Addr, 0, sizeof(struct sockaddr_in));
N  }
N}
N
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       GUI_VNC_X_StartServer
N*
N* Function description
N*   To start the server, the following steps are executed
N*   - Make sure the TCP-IP stack is up and running
N*   - Init the server context and attach it to the layer
N*   - Start the thread (task) which runs the VNC server
N* Notes:
N*   (1) The first part of the code initializes the TCP/IP stack. In a typical
N*       application, this is not required, since the stack should have already been
N*       initialized some other place.
N*       This could be done in a different module. (TCPIP_AssertInit() ?)
N*/
Nint GUI_VNC_X_StartServer(int LayerIndex, int ServerIndex) {
N  //
N  // Init VNC context and attach to layer (so context is updated if the display-layer-contents change
N  //
N  GUI_VNC_AttachToLayer(&_Context, LayerIndex);
N  _Context.ServerIndex = ServerIndex;
N  //
N  // Create task for VNC Server
N  //
N  OS_CREATETASK(&_VNCServer_TCB, "VNC Server", _ServerTask, TASKPRIO_VNC, _StackVNCServer);
X  OS_CreateTask_DP (&_VNCServer_TCB, "VNC Server", TASKPRIO_VNC, _ServerTask, (void *)_StackVNCServer, sizeof(_StackVNCServer) ,2 );
N  //
N  // O.k., server has been started
N  //
N  return 0;
N}
N
N/*********************************************************************
N*
N*       GUI_VNC_X_getpeername
N*
N* Function description
N*   Retrieves the IP addr. of the currently connected VNC client.
N*
N*   Return values
N*     IP addr. if VNC client connected
N*     0 if no client connected
N*/
Nvoid GUI_VNC_X_getpeername(U32 * Addr) {
Xvoid GUI_VNC_X_getpeername(unsigned long * Addr) {
N  *Addr = _Addr.sin_addr.s_addr;
N}
N
N/*************************** End of file ****************************/
N
