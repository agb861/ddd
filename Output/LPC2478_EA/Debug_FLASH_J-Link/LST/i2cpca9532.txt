; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--thumb --list --debug -c --asm --interleave -o.\output\lpc2478_ea\debug_flash_j-link\obj\i2cpca9532.o --asm_dir=.\Output\LPC2478_EA\Debug_FLASH_J-Link\LST\ --list_dir=.\Output\LPC2478_EA\Debug_FLASH_J-Link\LST\ --depend=.\output\lpc2478_ea\debug_flash_j-link\obj\i2cpca9532.d --apcs=interwork -O0 -IApplication\SEGGERDEMO -IApplication\SEGGERDEMO\Src -ISetup -IInc -IConfig -IFS -IIP -IIP\IP_FS\FS_RO\Generated -IGUI -IOS -IUSB -IUSBH -I"C:\Program Files (x86)\Keil\V473\ARM\RV31\INC" -I"C:\Program Files (x86)\Keil\V473\ARM\CMSIS\Include" -I"C:\Program Files (x86)\Keil\V473\ARM\Inc\Philips" -DDEBUG=1 --omf_browse=.\output\lpc2478_ea\debug_flash_j-link\obj\i2cpca9532.crf Setup\I2CPCA9532.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _I2C_CheckStatus PROC
;;;158    */
;;;159    static unsigned char _I2C_CheckStatus(void) {
000000  2000              MOVS     r0,#0
;;;160      unsigned char r = 0;
;;;161    
;;;162      //
;;;163      // Wait for I2C status to change
;;;164      //
;;;165      while ((I20CONSET & (1 << 3)) == 0) {  // SI == 0
000002  46c0              MOV      r8,r8
                  |L1.4|
000004  49bc              LDR      r1,|L1.760|
000006  6809              LDR      r1,[r1,#0]
000008  2208              MOVS     r2,#8
00000a  4211              TST      r1,r2
00000c  d0fa              BEQ      |L1.4|
;;;166      }
;;;167      //
;;;168      // Read I2C state
;;;169      //
;;;170      r = I20STAT;
00000e  49ba              LDR      r1,|L1.760|
000010  6849              LDR      r1,[r1,#4]
000012  0608              LSLS     r0,r1,#24
000014  0e00              LSRS     r0,r0,#24
;;;171    
;;;172      return r;
;;;173    }
000016  4770              BX       lr
;;;174    
                          ENDP

                  _I2C_Start PROC
;;;178    */
;;;179    static char _I2C_Start(void) {
000018  b570              PUSH     {r4-r6,lr}
;;;180      unsigned char Status = 0;
00001a  2400              MOVS     r4,#0
;;;181      unsigned char r      = 0;
00001c  2500              MOVS     r5,#0
;;;182    
;;;183      //
;;;184      // Issue start condition
;;;185      //
;;;186      I20CONSET |= (1 << 5);  // STA = 1, set start flag
00001e  48b6              LDR      r0,|L1.760|
000020  6800              LDR      r0,[r0,#0]
000022  2120              MOVS     r1,#0x20
000024  4308              ORRS     r0,r0,r1
000026  49b4              LDR      r1,|L1.760|
000028  6008              STR      r0,[r1,#0]
;;;187      //
;;;188      // Wait until START transmitted
;;;189      //
;;;190      while(1) {
00002a  e00f              B        |L1.76|
                  |L1.44|
;;;191        Status = _I2C_CheckStatus();
00002c  f7fffffe          BL       _I2C_CheckStatus
000030  0004              MOVS     r4,r0
;;;192        //
;;;193        // Check if start transmitted
;;;194        //
;;;195        if ((Status == 0x08) || (Status == 0x10)) {
000032  2c08              CMP      r4,#8
000034  d001              BEQ      |L1.58|
000036  2c10              CMP      r4,#0x10
000038  d101              BNE      |L1.62|
                  |L1.58|
;;;196          r = I2C_CODE_OK;
00003a  2500              MOVS     r5,#0
;;;197          break;
00003c  e007              B        |L1.78|
                  |L1.62|
;;;198        } else if (Status != 0xF8) {  // Error
00003e  2cf8              CMP      r4,#0xf8
000040  d001              BEQ      |L1.70|
;;;199          r = Status;
000042  0025              MOVS     r5,r4
;;;200          break;
000044  e003              B        |L1.78|
                  |L1.70|
;;;201        } else {
;;;202          I20CONCLR = (1 << 3);      // Clear SI flag
000046  2008              MOVS     r0,#8
000048  49ab              LDR      r1,|L1.760|
00004a  6188              STR      r0,[r1,#0x18]
                  |L1.76|
00004c  e7ee              B        |L1.44|
                  |L1.78|
00004e  46c0              MOV      r8,r8                 ;197
;;;203        }
;;;204      }
;;;205      I20CONCLR = (1 << 5);          // Clear start flag
000050  2020              MOVS     r0,#0x20
000052  49a9              LDR      r1,|L1.760|
000054  6188              STR      r0,[r1,#0x18]
;;;206    
;;;207      return r;
000056  0028              MOVS     r0,r5
;;;208    }
000058  bc70              POP      {r4-r6}
00005a  bc08              POP      {r3}
00005c  4718              BX       r3
;;;209    
                          ENDP

                  _I2C_PutChar PROC
;;;220    */
;;;221    static unsigned  char _I2C_PutChar(unsigned char Data) {
00005e  0001              MOVS     r1,r0
;;;222      unsigned char r = 0;
000060  2000              MOVS     r0,#0
;;;223    
;;;224      /* check if I2C Data register can be accessed */
;;;225      if ((I20CONSET & (1 << 3)) != 0) {  // SI = 1
000062  4aa5              LDR      r2,|L1.760|
000064  6812              LDR      r2,[r2,#0]
000066  2308              MOVS     r3,#8
000068  421a              TST      r2,r3
00006a  d005              BEQ      |L1.120|
;;;226        //
;;;227        // Send data
;;;228        //
;;;229        I20DAT    = Data;
00006c  4aa2              LDR      r2,|L1.760|
00006e  6091              STR      r1,[r2,#8]
;;;230        I20CONCLR = (1 << 3);  // Clear SI flag
000070  2208              MOVS     r2,#8
000072  4ba1              LDR      r3,|L1.760|
000074  619a              STR      r2,[r3,#0x18]
;;;231        r         = I2C_CODE_OK;
000076  e000              B        |L1.122|
                  |L1.120|
;;;232      } else {
;;;233        r = I2C_CODE_BUSY;  // Data register not ready
000078  2006              MOVS     r0,#6
                  |L1.122|
;;;234      }
;;;235    
;;;236      return r;
;;;237    }
00007a  4770              BX       lr
;;;238    
                          ENDP

                  _I2C_WaitTransmit PROC
;;;242    */
;;;243    static unsigned char _I2C_WaitTransmit(void) {
00007c  b510              PUSH     {r4,lr}
;;;244      unsigned char Status = 0;
00007e  2400              MOVS     r4,#0
;;;245    
;;;246      //
;;;247      // Wait till data transmitted
;;;248      //
;;;249      while(1) {
000080  e00e              B        |L1.160|
                  |L1.130|
;;;250        Status = _I2C_CheckStatus();
000082  f7fffffe          BL       _I2C_CheckStatus
000086  0004              MOVS     r4,r0
;;;251        //
;;;252        // SLA+W transmitted, ACK received or
;;;253        // data byte transmitted, ACK received
;;;254        //
;;;255        if ((Status == 0x18) || (Status == 0x28)) {
000088  2c18              CMP      r4,#0x18
00008a  d001              BEQ      |L1.144|
00008c  2c28              CMP      r4,#0x28
00008e  d103              BNE      |L1.152|
                  |L1.144|
;;;256          return I2C_CODE_OK;  // Data transmitted and ACK received
000090  2000              MOVS     r0,#0
                  |L1.146|
;;;257        } else if (Status != 0xF8) {
;;;258          return I2C_CODE_ERROR;  // Error, no relevant status information
;;;259        }
;;;260      }
;;;261    }
000092  bc10              POP      {r4}
000094  bc08              POP      {r3}
000096  4718              BX       r3
                  |L1.152|
000098  2cf8              CMP      r4,#0xf8              ;257
00009a  d001              BEQ      |L1.160|
00009c  2003              MOVS     r0,#3                 ;258
00009e  e7f8              B        |L1.146|
                  |L1.160|
0000a0  e7ef              B        |L1.130|
;;;262    
                          ENDP

                  _I2C_WriteWithWait PROC
;;;266    */
;;;267    static unsigned char _I2C_WriteWithWait(unsigned char Data) {
0000a2  b570              PUSH     {r4-r6,lr}
0000a4  0005              MOVS     r5,r0
;;;268      unsigned char r = 0;
0000a6  2400              MOVS     r4,#0
;;;269    
;;;270      r = _I2C_PutChar(Data);
0000a8  0028              MOVS     r0,r5
0000aa  f7fffffe          BL       _I2C_PutChar
0000ae  0004              MOVS     r4,r0
;;;271      while(r == I2C_CODE_BUSY) {
0000b0  e003              B        |L1.186|
                  |L1.178|
;;;272        r = _I2C_PutChar(Data);
0000b2  0028              MOVS     r0,r5
0000b4  f7fffffe          BL       _I2C_PutChar
0000b8  0004              MOVS     r4,r0
                  |L1.186|
0000ba  2c06              CMP      r4,#6                 ;271
0000bc  d0f9              BEQ      |L1.178|
;;;273      }
;;;274      if(r == I2C_CODE_OK)
0000be  2c00              CMP      r4,#0
0000c0  d102              BNE      |L1.200|
;;;275        r = _I2C_WaitTransmit();
0000c2  f7fffffe          BL       _I2C_WaitTransmit
0000c6  0004              MOVS     r4,r0
                  |L1.200|
;;;276    
;;;277      return r;
0000c8  0020              MOVS     r0,r4
;;;278    }
0000ca  bc70              POP      {r4-r6}
0000cc  bc08              POP      {r3}
0000ce  4718              BX       r3
;;;279    
                          ENDP

                  _I2C_Stop PROC
;;;291    */
;;;292    static void _I2C_Stop(void) {
0000d0  4889              LDR      r0,|L1.760|
;;;293      I20CONSET |= (1 << 4);  // STO = 1, set stop flag
0000d2  6800              LDR      r0,[r0,#0]
0000d4  2110              MOVS     r1,#0x10
0000d6  4308              ORRS     r0,r0,r1
0000d8  4987              LDR      r1,|L1.760|
0000da  6008              STR      r0,[r1,#0]
;;;294      I20CONCLR  = (1 << 3);  // Clear SI flag
0000dc  2008              MOVS     r0,#8
0000de  6188              STR      r0,[r1,#0x18]
;;;295      while (I20CONSET & (1 << 4)) {  // Wait till STOP detected (while STO = 1)
0000e0  46c0              MOV      r8,r8
                  |L1.226|
0000e2  4885              LDR      r0,|L1.760|
0000e4  6800              LDR      r0,[r0,#0]
0000e6  2110              MOVS     r1,#0x10
0000e8  4208              TST      r0,r1
0000ea  d1fa              BNE      |L1.226|
;;;296      }
;;;297    }
0000ec  4770              BX       lr
;;;298    
                          ENDP

                  _I2C_RepeatStart PROC
;;;309    */
;;;310    static unsigned char _I2C_RepeatStart(void) {
0000ee  b570              PUSH     {r4-r6,lr}
;;;311      unsigned char Status = 0;
0000f0  2400              MOVS     r4,#0
;;;312      unsigned char r      = 0;
0000f2  2500              MOVS     r5,#0
;;;313    
;;;314      //
;;;315      // Issue a start condition
;;;316      //
;;;317      I20CONSET |= (1 << 5);  // STA = 1, set start flag
0000f4  4880              LDR      r0,|L1.760|
0000f6  6800              LDR      r0,[r0,#0]
0000f8  2120              MOVS     r1,#0x20
0000fa  4308              ORRS     r0,r0,r1
0000fc  497e              LDR      r1,|L1.760|
0000fe  6008              STR      r0,[r1,#0]
;;;318      I20CONCLR  = (1 << 3);  // Clear SI flag
000100  2008              MOVS     r0,#8
000102  6188              STR      r0,[r1,#0x18]
;;;319      //
;;;320      // Wait until START transmitted
;;;321      //
;;;322      while (1) {
000104  e00f              B        |L1.294|
                  |L1.262|
;;;323        Status = _I2C_CheckStatus();
000106  f7fffffe          BL       _I2C_CheckStatus
00010a  0004              MOVS     r4,r0
;;;324        if ((Status == 0x08) || (Status == 0x10)) {
00010c  2c08              CMP      r4,#8
00010e  d001              BEQ      |L1.276|
000110  2c10              CMP      r4,#0x10
000112  d101              BNE      |L1.280|
                  |L1.276|
;;;325          r = I2C_CODE_OK;  // Start transmitted
000114  2500              MOVS     r5,#0
;;;326          break;
000116  e007              B        |L1.296|
                  |L1.280|
;;;327        } else if (Status != 0xF8) {
000118  2cf8              CMP      r4,#0xf8
00011a  d001              BEQ      |L1.288|
;;;328          r = Status;  // Error
00011c  0025              MOVS     r5,r4
;;;329          break;
00011e  e003              B        |L1.296|
                  |L1.288|
;;;330        } else {
;;;331          I20CONCLR = (1 << 3);  // Clear SI flag
000120  2008              MOVS     r0,#8
000122  4975              LDR      r1,|L1.760|
000124  6188              STR      r0,[r1,#0x18]
                  |L1.294|
000126  e7ee              B        |L1.262|
                  |L1.296|
000128  46c0              MOV      r8,r8                 ;326
;;;332        }
;;;333      }
;;;334      I20CONCLR = (1 << 5);  // Clear start flag
00012a  2020              MOVS     r0,#0x20
00012c  4972              LDR      r1,|L1.760|
00012e  6188              STR      r0,[r1,#0x18]
;;;335    
;;;336      return r;
000130  0028              MOVS     r0,r5
;;;337    }
000132  bc70              POP      {r4-r6}
000134  bc08              POP      {r3}
000136  4718              BX       r3
;;;338    
                          ENDP

                  _I2C_GetChar PROC
;;;352    */
;;;353    static unsigned char _I2C_GetChar(unsigned char Mode, unsigned char * pBuf) {
000138  b410              PUSH     {r4}
00013a  0002              MOVS     r2,r0
;;;354      unsigned char r = I2C_CODE_OK;
00013c  2000              MOVS     r0,#0
;;;355    
;;;356      if(Mode == I2C_MODE_ACK0) {
00013e  2a00              CMP      r2,#0
000140  d108              BNE      |L1.340|
;;;357        //
;;;358        // Operation mode is changed from master transmit to master receive
;;;359        // Set ACK = 0 (informs slave to send next byte)
;;;360        //
;;;361        I20CONSET |= (1 << 2);  // AA = 1
000142  4b6d              LDR      r3,|L1.760|
000144  681b              LDR      r3,[r3,#0]
000146  2404              MOVS     r4,#4
000148  4323              ORRS     r3,r3,r4
00014a  4c6b              LDR      r4,|L1.760|
00014c  6023              STR      r3,[r4,#0]
;;;362        I20CONCLR  = (1 << 3);  // Clear SI flag
00014e  2308              MOVS     r3,#8
000150  61a3              STR      r3,[r4,#0x18]
000152  e013              B        |L1.380|
                  |L1.340|
;;;363      } else if (Mode == I2C_MODE_ACK1) {
000154  2a01              CMP      r2,#1
000156  d105              BNE      |L1.356|
;;;364        I20CONCLR = (1 << 2);   // Set ACK = 1 (informs slave to send last byte)
000158  2304              MOVS     r3,#4
00015a  4c67              LDR      r4,|L1.760|
00015c  61a3              STR      r3,[r4,#0x18]
;;;365        I20CONCLR = (1 << 3);   // Clear SI flag
00015e  2308              MOVS     r3,#8
000160  61a3              STR      r3,[r4,#0x18]
000162  e00b              B        |L1.380|
                  |L1.356|
;;;366      } else if (Mode == I2C_MODE_READ) {
000164  2a02              CMP      r2,#2
000166  d109              BNE      |L1.380|
;;;367        //
;;;368        // Check if I2C Data register can be accessed
;;;369        //
;;;370        if (I20CONSET & (1 << 3)) {       // SI = 1
000168  4b63              LDR      r3,|L1.760|
00016a  681b              LDR      r3,[r3,#0]
00016c  2408              MOVS     r4,#8
00016e  4223              TST      r3,r4
000170  d003              BEQ      |L1.378|
;;;371          *pBuf = (unsigned char)I20DAT;  // Read data
000172  4b61              LDR      r3,|L1.760|
000174  689b              LDR      r3,[r3,#8]
000176  700b              STRB     r3,[r1,#0]
000178  e000              B        |L1.380|
                  |L1.378|
;;;372        } else {
;;;373          r = I2C_CODE_EMPTY;  // No data available
00017a  2005              MOVS     r0,#5
                  |L1.380|
;;;374        }
;;;375      }
;;;376    
;;;377      return r;
;;;378    }
00017c  bc10              POP      {r4}
00017e  4770              BX       lr
;;;379    
                          ENDP

                  I2CPCA9532_WriteRead PROC
;;;390    */
;;;391    unsigned char I2CPCA9532_WriteRead(unsigned char * pData, unsigned short NumBytesToWrite, unsigned char * pBuf, unsigned short NumBytesToRead) {
000180  b5ff              PUSH     {r0-r7,lr}
000182  b081              SUB      sp,sp,#4
000184  001e              MOVS     r6,r3
;;;392      unsigned char  r       = 0;
000186  2400              MOVS     r4,#0
;;;393      unsigned char  Status  = 0;
000188  2500              MOVS     r5,#0
;;;394      unsigned short i       = 0;
00018a  2700              MOVS     r7,#0
;;;395    
;;;396      r = _I2C_Start();  // Generate Start condition
00018c  f7fffffe          BL       _I2C_Start
000190  0004              MOVS     r4,r0
;;;397      if(r != I2C_CODE_OK) {
000192  2c00              CMP      r4,#0
000194  d000              BEQ      |L1.408|
;;;398        goto STOPWRITE;
000196  e01a              B        |L1.462|
                  |L1.408|
;;;399      }
;;;400      r = _I2C_WriteWithWait(0xC0);  // Write PCA9532 address
000198  20c0              MOVS     r0,#0xc0
00019a  f7fffffe          BL       _I2C_WriteWithWait
00019e  0004              MOVS     r4,r0
;;;401      if (r != I2C_CODE_OK) {
0001a0  2c00              CMP      r4,#0
0001a2  d000              BEQ      |L1.422|
;;;402        goto STOPWRITE;
0001a4  e013              B        |L1.462|
                  |L1.422|
;;;403      }
;;;404      //
;;;405      // Write data
;;;406      //
;;;407      for (i = 0; i < NumBytesToWrite; i++) {
0001a6  2700              MOVS     r7,#0
0001a8  e00d              B        |L1.454|
                  |L1.426|
;;;408        r = _I2C_WriteWithWait(*pData);
0001aa  9901              LDR      r1,[sp,#4]
0001ac  7808              LDRB     r0,[r1,#0]
0001ae  f7fffffe          BL       _I2C_WriteWithWait
0001b2  0004              MOVS     r4,r0
;;;409        if (r != I2C_CODE_OK) {
0001b4  2c00              CMP      r4,#0
0001b6  d000              BEQ      |L1.442|
;;;410          goto STOPWRITE;
0001b8  e009              B        |L1.462|
                  |L1.442|
;;;411        }
;;;412        pData++;
0001ba  9801              LDR      r0,[sp,#4]
0001bc  1c40              ADDS     r0,r0,#1
0001be  9001              STR      r0,[sp,#4]
0001c0  1c78              ADDS     r0,r7,#1              ;407
0001c2  0407              LSLS     r7,r0,#16             ;407
0001c4  0c3f              LSRS     r7,r7,#16             ;407
                  |L1.454|
0001c6  9802              LDR      r0,[sp,#8]            ;407
0001c8  4287              CMP      r7,r0                 ;407
0001ca  dbee              BLT      |L1.426|
;;;413      }
;;;414    STOPWRITE:
0001cc  46c0              MOV      r8,r8
                  |L1.462|
;;;415      if (NumBytesToRead > 0) {
0001ce  2e00              CMP      r6,#0
0001d0  dd54              BLE      |L1.636|
;;;416        r = _I2C_RepeatStart();  // Generate Start condition
0001d2  f7fffffe          BL       _I2C_RepeatStart
0001d6  0004              MOVS     r4,r0
;;;417        //
;;;418        // Transmit device address
;;;419        //
;;;420        if (r == I2C_CODE_OK) {
0001d8  2c00              CMP      r4,#0
0001da  d10a              BNE      |L1.498|
;;;421          r = _I2C_PutChar(0xc0 + 0x01);  // Write SLA+R
0001dc  20c1              MOVS     r0,#0xc1
0001de  f7fffffe          BL       _I2C_PutChar
0001e2  0004              MOVS     r4,r0
;;;422          while(r == I2C_CODE_BUSY) {
0001e4  e003              B        |L1.494|
                  |L1.486|
;;;423            r = _I2C_PutChar(0xc0 + 0x01);
0001e6  20c1              MOVS     r0,#0xc1
0001e8  f7fffffe          BL       _I2C_PutChar
0001ec  0004              MOVS     r4,r0
                  |L1.494|
0001ee  2c06              CMP      r4,#6                 ;422
0001f0  d0f9              BEQ      |L1.486|
                  |L1.498|
;;;424          }
;;;425        }
;;;426        //
;;;427        // Wait until SLA+R transmitted
;;;428        //
;;;429        while (1) {
0001f2  e009              B        |L1.520|
                  |L1.500|
;;;430          Status = _I2C_CheckStatus();
0001f4  f7fffffe          BL       _I2C_CheckStatus
0001f8  0005              MOVS     r5,r0
;;;431          if (Status == 0x40) {         // Data transmitted and ACK received
0001fa  2d40              CMP      r5,#0x40
0001fc  d100              BNE      |L1.512|
;;;432            break;
0001fe  e004              B        |L1.522|
                  |L1.512|
;;;433          } else if (Status != 0xF8) {  // Error
000200  2df8              CMP      r5,#0xf8
000202  d001              BEQ      |L1.520|
;;;434            r = I2C_CODE_ERROR;
000204  2403              MOVS     r4,#3
;;;435            break;
000206  e000              B        |L1.522|
                  |L1.520|
000208  e7f4              B        |L1.500|
                  |L1.522|
00020a  46c0              MOV      r8,r8                 ;432
;;;436          }
;;;437        }
;;;438        if (r == I2C_CODE_OK) {
00020c  2c00              CMP      r4,#0
00020e  d135              BNE      |L1.636|
;;;439          //
;;;440          // Wait until address transmitted and receive data
;;;441          //
;;;442          for (i = 1; i <= NumBytesToRead; i++) {
000210  2701              MOVS     r7,#1
000212  e031              B        |L1.632|
                  |L1.532|
;;;443            //
;;;444            // Wait until data transmitted
;;;445            //
;;;446            while (1) {
000214  e02b              B        |L1.622|
                  |L1.534|
;;;447              Status = _I2C_CheckStatus();
000216  f7fffffe          BL       _I2C_CheckStatus
00021a  0005              MOVS     r5,r0
;;;448              if ((Status == 0x40) || (Status == 0x48) || (Status == 0x50 )) {  // Data received
00021c  2d40              CMP      r5,#0x40
00021e  d003              BEQ      |L1.552|
000220  2d48              CMP      r5,#0x48
000222  d001              BEQ      |L1.552|
000224  2d50              CMP      r5,#0x50
000226  d11d              BNE      |L1.612|
                  |L1.552|
;;;449                //
;;;450                // Set generate NACK
;;;451                //
;;;452                if (i == NumBytesToRead) {
000228  42b7              CMP      r7,r6
00022a  d105              BNE      |L1.568|
;;;453                  r = _I2C_GetChar(I2C_MODE_ACK1, pBuf);
00022c  2001              MOVS     r0,#1
00022e  9903              LDR      r1,[sp,#0xc]
000230  f7fffffe          BL       _I2C_GetChar
000234  0004              MOVS     r4,r0
000236  e004              B        |L1.578|
                  |L1.568|
;;;454                } else {
;;;455                  r = _I2C_GetChar(I2C_MODE_ACK0, pBuf);
000238  2000              MOVS     r0,#0
00023a  9903              LDR      r1,[sp,#0xc]
00023c  f7fffffe          BL       _I2C_GetChar
000240  0004              MOVS     r4,r0
                  |L1.578|
;;;456                }
;;;457                r = _I2C_GetChar(I2C_MODE_READ, pBuf);  // Read data
000242  2002              MOVS     r0,#2
000244  9903              LDR      r1,[sp,#0xc]
000246  f7fffffe          BL       _I2C_GetChar
00024a  0004              MOVS     r4,r0
;;;458                while (r == I2C_CODE_EMPTY) {
00024c  e004              B        |L1.600|
                  |L1.590|
;;;459                  r = _I2C_GetChar(I2C_MODE_READ, pBuf);
00024e  2002              MOVS     r0,#2
000250  9903              LDR      r1,[sp,#0xc]
000252  f7fffffe          BL       _I2C_GetChar
000256  0004              MOVS     r4,r0
                  |L1.600|
000258  2c05              CMP      r4,#5                 ;458
00025a  d0f8              BEQ      |L1.590|
;;;460                }
;;;461                pBuf++;
00025c  9803              LDR      r0,[sp,#0xc]
00025e  1c40              ADDS     r0,r0,#1
000260  9003              STR      r0,[sp,#0xc]
;;;462                break;
000262  e005              B        |L1.624|
                  |L1.612|
;;;463              } else if (Status != 0xF8) {  // Error
000264  2df8              CMP      r5,#0xf8
000266  d002              BEQ      |L1.622|
;;;464                i = NumBytesToRead;
000268  0037              MOVS     r7,r6
;;;465                r = I2C_CODE_ERROR;
00026a  2403              MOVS     r4,#3
;;;466                break;
00026c  e000              B        |L1.624|
                  |L1.622|
00026e  e7d2              B        |L1.534|
                  |L1.624|
000270  46c0              MOV      r8,r8                 ;462
000272  1c78              ADDS     r0,r7,#1              ;442
000274  0407              LSLS     r7,r0,#16             ;442
000276  0c3f              LSRS     r7,r7,#16             ;442
                  |L1.632|
000278  42b7              CMP      r7,r6                 ;442
00027a  ddcb              BLE      |L1.532|
                  |L1.636|
;;;467              }
;;;468            }
;;;469          }
;;;470        }
;;;471      }
;;;472      _I2C_Stop();  // Generate Stop condition
00027c  f7fffffe          BL       _I2C_Stop
;;;473    
;;;474      return r;
000280  0020              MOVS     r0,r4
;;;475    }
000282  b005              ADD      sp,sp,#0x14
000284  bcf0              POP      {r4-r7}
000286  bc08              POP      {r3}
000288  4718              BX       r3
;;;476    
                          ENDP

                  I2CPCA9532_Init PROC
;;;480    */
;;;481    void I2CPCA9532_Init(void) {
00028a  b50e              PUSH     {r1-r3,lr}
;;;482      unsigned char InitCommand[] = {0x12, 0x97, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00};
00028c  a21b              ADR      r2,|L1.764|
00028e  ca07              LDM      r2,{r0-r2}
000290  466b              MOV      r3,sp
000292  c307              STM      r3!,{r0-r2}
;;;483    
;;;484      if ((I20CONSET & (1 << 6)) == 0) {  // I2C was not intialized before
000294  4818              LDR      r0,|L1.760|
000296  6800              LDR      r0,[r0,#0]
000298  2140              MOVS     r1,#0x40
00029a  4208              TST      r0,r1
00029c  d129              BNE      |L1.754|
;;;485        PINSEL1 &= 0
00029e  481a              LDR      r0,|L1.776|
0002a0  6840              LDR      r0,[r0,#4]
0002a2  210f              MOVS     r1,#0xf
0002a4  0589              LSLS     r1,r1,#22
0002a6  4388              BICS     r0,r0,r1
0002a8  4917              LDR      r1,|L1.776|
0002aa  6048              STR      r0,[r1,#4]
;;;486                   | (0x3   << 0)  // SSEL
;;;487                   | (0x3   << 2)  // MISO
;;;488                   | (0x3   << 4)  // MOSI
;;;489                   | (0x3   << 6)  // SDA1
;;;490                   | (0x3   << 8)  // SCL1
;;;491                   | (0x3   << 10) // RD1
;;;492                   | (0x3   << 12) // TD1
;;;493                   | (0x3   << 14) // CAP3[0]
;;;494                   | (0x3   << 16) // CAP3[1]
;;;495                   | (0x3   << 18) // TXD3
;;;496                   | (0x3   << 20) // RXD3
;;;497                   | (0x3   << 26) // Reserved
;;;498                   | (0x3   << 28) // Reserved
;;;499                   | (0x3uL << 30) // Reserved
;;;500                   ;
;;;501        PINSEL1 |= 0
0002ac  0008              MOVS     r0,r1
0002ae  6840              LDR      r0,[r0,#4]
0002b0  2105              MOVS     r1,#5
0002b2  0589              LSLS     r1,r1,#22
0002b4  4308              ORRS     r0,r0,r1
0002b6  4914              LDR      r1,|L1.776|
0002b8  6048              STR      r0,[r1,#4]
;;;502                   | (0x1 << 22) // GPIO port 0.27 SDA0
;;;503                   | (0x1 << 24) // GPIO port 0.28 SCL0
;;;504                   ;
;;;505        //
;;;506        // Clear flags
;;;507        //
;;;508        I20CONCLR = 0
0002ba  206c              MOVS     r0,#0x6c
0002bc  490e              LDR      r1,|L1.760|
0002be  6188              STR      r0,[r1,#0x18]
;;;509                    | (1 << 2)   // AAC,   Assert acknowledge clear bit
;;;510                    | (1 << 3)   // SIC,   I2C interrupt clear bit
;;;511                    | (1 << 5)   // STAC,  START flag clear bit
;;;512                    | (1 << 6)   // I2ENC, I2C interface disable bit
;;;513                    ;
;;;514        //
;;;515        // Reset registers
;;;516        //
;;;517        I20SCLL    = (I20SCLL   & 0xFFFF0000) | 0x00000160;  // SCL Duty Cycle low register
0002c0  0008              MOVS     r0,r1
0002c2  6940              LDR      r0,[r0,#0x14]
0002c4  0c00              LSRS     r0,r0,#16
0002c6  0400              LSLS     r0,r0,#16
0002c8  30ff              ADDS     r0,r0,#0xff
0002ca  3061              ADDS     r0,r0,#0x61
0002cc  6148              STR      r0,[r1,#0x14]
;;;518        I20SCLH    = (I20SCLH   & 0xFFFF0000) | 0x000000F0;  // SCL Duty Cycle high register
0002ce  0008              MOVS     r0,r1
0002d0  6900              LDR      r0,[r0,#0x10]
0002d2  0c00              LSRS     r0,r0,#16
0002d4  0400              LSLS     r0,r0,#16
0002d6  30f0              ADDS     r0,r0,#0xf0
0002d8  6108              STR      r0,[r1,#0x10]
;;;519        I20CONSET |= (1 << 6);                                // I2EN, I2C interface enable bit
0002da  0008              MOVS     r0,r1
0002dc  6800              LDR      r0,[r0,#0]
0002de  2140              MOVS     r1,#0x40
0002e0  4308              ORRS     r0,r0,r1
0002e2  4905              LDR      r1,|L1.760|
0002e4  6008              STR      r0,[r1,#0]
;;;520        I2CPCA9532_WriteRead(InitCommand, sizeof(InitCommand), 0, 0);
0002e6  2300              MOVS     r3,#0
0002e8  001a              MOVS     r2,r3
0002ea  2109              MOVS     r1,#9
0002ec  4668              MOV      r0,sp
0002ee  f7fffffe          BL       I2CPCA9532_WriteRead
                  |L1.754|
;;;521      }
;;;522    }
0002f2  b003              ADD      sp,sp,#0xc
0002f4  bc08              POP      {r3}
0002f6  4718              BX       r3
                          ENDP

                  |L1.760|
                          DCD      0xe001c000
                  |L1.764|
0002fc  12978000          DCB      18,151,128,0
000300  4000              DCB      "@",0
000302  00                DCB      0
000303  00                DCB      0
000304  00                DCB      0
000305  00                DCB      0
000306  00                DCB      0
000307  00                DCB      0
                  |L1.776|
                          DCD      0xe002c000
